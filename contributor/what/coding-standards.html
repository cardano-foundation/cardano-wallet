<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Coding Standards - Cardano Wallet</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../.././mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../user.html"><strong aria-hidden="true">2.</strong> User Manual</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../user/when.html"><strong aria-hidden="true">2.1.</strong> When to use</a></li><li class="chapter-item expanded "><a href="../../user/common-use-cases.html"><strong aria-hidden="true">2.2.</strong> How to</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../user/common-use-cases/start-wallet-server.html"><strong aria-hidden="true">2.2.1.</strong> Start a server</a></li><li class="chapter-item expanded "><a href="../../user/common-use-cases/create-a-wallet.html"><strong aria-hidden="true">2.2.2.</strong> Create a wallet</a></li><li class="chapter-item expanded "><a href="../../user/common-use-cases/how-to-manage-wallets.html"><strong aria-hidden="true">2.2.3.</strong> Manage wallets</a></li><li class="chapter-item expanded "><a href="../../user/common-use-cases/how-to-create-addresses.html"><strong aria-hidden="true">2.2.4.</strong> Create addresses</a></li><li class="chapter-item expanded "><a href="../../user/common-use-cases/how-to-make-a-transaction.html"><strong aria-hidden="true">2.2.5.</strong> Create a transaction</a></li><li class="chapter-item expanded "><a href="../../user/common-use-cases/assets.html"><strong aria-hidden="true">2.2.6.</strong> Handle assets</a></li><li class="chapter-item expanded "><a href="../../user/common-use-cases/delegation.html"><strong aria-hidden="true">2.2.7.</strong> Handle delegation</a></li><li class="chapter-item expanded "><a href="../../user/common-use-cases/handle-metadata.html"><strong aria-hidden="true">2.2.8.</strong> Handle metadata</a></li><li class="chapter-item expanded "><a href="../../user/common-use-cases/shared-wallets.html"><strong aria-hidden="true">2.2.9.</strong> Create shared-wallets</a></li></ol></li><li class="chapter-item expanded "><a href="../../user/installation.html"><strong aria-hidden="true">2.3.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../user/installation/use-docker.html"><strong aria-hidden="true">2.3.1.</strong> Use docker</a></li><li class="chapter-item expanded "><a href="../../user/installation/use-nixos.html"><strong aria-hidden="true">2.3.2.</strong> Use NixOS</a></li></ol></li><li class="chapter-item expanded "><a href="../../user/cli.html"><strong aria-hidden="true">2.4.</strong> CLI</a></li><li class="chapter-item expanded "><a href="../../user/http-api.html"><strong aria-hidden="true">2.5.</strong> HTTP-API</a></li><li class="chapter-item expanded "><a href="../../user/hardware-recommendations.html"><strong aria-hidden="true">2.6.</strong> Hardware Recommendations</a></li><li class="chapter-item expanded "><a href="../../user/security.html"><strong aria-hidden="true">2.7.</strong> Security</a></li><li class="chapter-item expanded "><a href="../../user/integrations.html"><strong aria-hidden="true">2.8.</strong> Known integrations</a></li><li class="chapter-item expanded "><a href="../../user/ekg-and-prometheus.html"><strong aria-hidden="true">2.9.</strong> EKG and prometheus</a></li><li class="chapter-item expanded "><a href="../../user/common-use-cases/plutus-application-backend.html"><strong aria-hidden="true">2.10.</strong> Plutus application backend</a></li><li class="chapter-item expanded "><a href="../../user/faq.html"><strong aria-hidden="true">2.11.</strong> FAQ</a></li></ol></li><li class="chapter-item expanded "><a href="../../design.html"><strong aria-hidden="true">3.</strong> Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../design/architecture.html"><strong aria-hidden="true">3.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="../../design/adrestia-architecture.html"><strong aria-hidden="true">3.2.</strong> Adrestia Architecture</a></li><li class="chapter-item expanded "><a href="../../design/links.html"><strong aria-hidden="true">3.3.</strong> Links</a></li><li class="chapter-item expanded "><a href="../../design/concepts.html"><strong aria-hidden="true">3.4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../design/concepts/eras.html"><strong aria-hidden="true">3.4.1.</strong> Eras</a></li><li class="chapter-item expanded "><a href="../../design/concepts/recovery-phrases.html"><strong aria-hidden="true">3.4.2.</strong> Recovery Phrases</a></li><li class="chapter-item expanded "><a href="../../design/concepts/master-key-generation.html"><strong aria-hidden="true">3.4.3.</strong> Master Key Generation</a></li><li class="chapter-item expanded "><a href="../../design/concepts/Notes-about-BIP-44.html"><strong aria-hidden="true">3.4.4.</strong> Notes about BIP 44</a></li><li class="chapter-item expanded "><a href="../../design/concepts/address-derivation.html"><strong aria-hidden="true">3.4.5.</strong> Address Derivation</a></li><li class="chapter-item expanded "><a href="../../design/concepts/byron-address-format.html"><strong aria-hidden="true">3.4.6.</strong> Byron Address Format</a></li><li class="chapter-item expanded "><a href="../../design/concepts/coin-selection.html"><strong aria-hidden="true">3.4.7.</strong> Coin Selection</a></li><li class="chapter-item expanded "><a href="../../design/concepts/hierarchical-deterministic-wallets.html"><strong aria-hidden="true">3.4.8.</strong> Hierarchical Deterministic Wallets</a></li><li class="chapter-item expanded "><a href="../../design/concepts/transaction-lifecycle.html"><strong aria-hidden="true">3.4.9.</strong> Transaction Lifecycle</a></li><li class="chapter-item expanded "><a href="../../design/concepts/utxo.html"><strong aria-hidden="true">3.4.10.</strong> UTxO</a></li></ol></li><li class="chapter-item expanded "><a href="../../design/specs.html"><strong aria-hidden="true">3.5.</strong> Specifications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../design/specs/wallet-id.html"><strong aria-hidden="true">3.5.1.</strong> Wallet ID</a></li></ol></li><li class="chapter-item expanded "><a href="../../design/prototypes.html"><strong aria-hidden="true">3.6.</strong> Prototypes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../design/prototypes/light-mode.html"><strong aria-hidden="true">3.6.1.</strong> Light Mode</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../contributor.html"><strong aria-hidden="true">4.</strong> Contributor Manual</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../contributor/what.html"><strong aria-hidden="true">4.1.</strong> What – Code and Languages</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../contributor/what/building.html"><strong aria-hidden="true">4.1.1.</strong> Building</a></li><li class="chapter-item expanded "><a href="../../contributor/what/coding-standards.html" class="active"><strong aria-hidden="true">4.1.2.</strong> Coding Standards</a></li><li class="chapter-item expanded "><a href="../../contributor/what/logging-guidelines.html"><strong aria-hidden="true">4.1.3.</strong> Logging Guidelines</a></li><li class="chapter-item expanded "><a href="../../contributor/what/swagger-development.html"><strong aria-hidden="true">4.1.4.</strong> Swagger Development</a></li><li class="chapter-item expanded "><a href="../../contributor/what/specifying-exceptions-with-servant-and-swagger.html"><strong aria-hidden="true">4.1.5.</strong> Specifying exceptions with Servant and Swagger</a></li><li class="chapter-item expanded "><a href="../../contributor/what/nix.html"><strong aria-hidden="true">4.1.6.</strong> Nix build language</a></li><li class="chapter-item expanded "><a href="../../contributor/what/nix-flake.html"><strong aria-hidden="true">4.1.7.</strong> Nix flake</a></li></ol></li><li class="chapter-item expanded "><a href="../../contributor/how.html"><strong aria-hidden="true">4.2.</strong> How – Processes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../contributor/how/testing.html"><strong aria-hidden="true">4.2.1.</strong> Testing</a></li><li class="chapter-item expanded "><a href="../../contributor/how/continuous-integration.html"><strong aria-hidden="true">4.2.2.</strong> Continuous Integration</a></li><li class="chapter-item expanded "><a href="../../contributor/how/release-process.html"><strong aria-hidden="true">4.2.3.</strong> Release Process</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../contributor/how/release-checklist.html"><strong aria-hidden="true">4.2.3.1.</strong> Release checklist</a></li></ol></li><li class="chapter-item expanded "><a href="../../contributor/how/code-review-guidelines.html"><strong aria-hidden="true">4.2.4.</strong> Code Review Guidelines</a></li></ol></li><li class="chapter-item expanded "><a href="../../contributor/notes.html"><strong aria-hidden="true">4.3.</strong> Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../contributor/notes/updating-dependencies.html"><strong aria-hidden="true">4.3.1.</strong> Updating Dependencies</a></li><li class="chapter-item expanded "><a href="../../contributor/notes/notes-from-upgrading-ghc-version.html"><strong aria-hidden="true">4.3.2.</strong> Notes from upgrading GHC version</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cardano Wallet</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="coding-standards"><a class="header" href="#coding-standards">Coding Standards</a></h1>
<h2 id="foreword"><a class="header" href="#foreword">Foreword</a></h2>
<p>This file contains agreed-upon coding standards and best practices, as well as proposals for changes or new standards. Proposals are prefixed with <code>[PROPOSAL]</code> and are voted on by the Adrestia team through polls on Slack. To be accepted, a practice should be voted with majority + 1, with neutral votes counting as positive votes.</p>
<p>Each proposal should start with a section justifying the standard with rational arguments. When it makes sense, we should also provide examples of good and bad practices to make the point clearer.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li><a href="#coding-standards">Coding Standards</a>
<ul>
<li><a href="#foreword">Foreword</a></li>
<li><a href="#summary">Summary</a></li>
<li><a href="#code-formatting">Code Formatting</a>
<ul>
<li><a href="#editor-configuration-via-editorconfig">Editor Configuration via <code>.editorconfig</code></a></li>
<li><a href="#limit-line-length-to-80-characters">Limit line length to 80 characters</a>
<ul>
<li><a href="#examples">Examples</a>
<ul>
<li><a href="#strategy-1-wrap-code">Strategy 1: Wrap code</a></li>
<li><a href="#strategy-2-place-comments-on-their-own-line-instead-of-attempting-to-align-them-vertically">Strategy 2: Place comments on their own line instead of attempting to align them vertically</a></li>
<li><a href="#strategy-3-break-up-long-string-literals">Strategy 3: Break up long string literals</a></li>
<li><a href="#strategy-4-reduce-nesting">Strategy 4: Reduce nesting</a></li>
</ul>
</li>
<li><a href="#exceptions">Exceptions</a>
<ul>
<li><a href="#exception-1-urls-in-comments">Exception 1: URLs in comments</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#use-only-a-single-blank-line-between-top-level-definitions">Use only a single blank line between top-level definitions</a></li>
<li><a href="#avoid-variable-length-indentation">Avoid Variable-Length Indentation</a></li>
<li><a href="#stylish-haskell-is-used-to-format-grouped-imports--language-pragmas">Stylish-Haskell is used to format grouped imports &amp; language pragmas</a></li>
</ul>
</li>
<li><a href="#haskell-practices">Haskell Practices</a>
<ul>
<li><a href="#favor-newtype-and-tagged-type-over-type-aliases">Favor <code>newtype</code> and tagged type over type-aliases</a></li>
<li><a href="#language-extensions-are-specified-on-top-of-each-module">Language extensions are specified on top of each module</a></li>
<li><a href="#hlint-is-used-for-hints-and-general-code-style">HLint is used for hints and general code style</a></li>
<li><a href="#we-use-explicit-imports-by-default-and-favor-qualified-imports-for-ambiguous-functions">We use explicit imports by default, and favor qualified imports for ambiguous functions</a></li>
<li><a href="#all-modules-begin-with-a-helpful-documentation-comment">All modules begin with a helpful documentation comment</a></li>
<li><a href="#prefer-named-constants-over-magic-numbers">Prefer named constants over magic numbers</a>
<ul>
<li><a href="#bad">BAD</a></li>
<li><a href="#good">GOOD</a></li>
</ul>
</li>
<li><a href="#avoid-wildcards-when-pattern-matching-on-sum-types">Avoid wildcards when pattern-matching on sum types</a></li>
<li><a href="#prefer-pattern-matching-to-equality-testing-on-sum-types">Prefer pattern-matching to equality testing on sum types.</a></li>
<li><a href="#proposed-dont-spit-back-malformed-values-in-errors-from-user-inputs">[PROPOSED] Don't spit back malformed values in errors from user inputs.</a></li>
</ul>
</li>
<li><a href="#quickcheck">QuickCheck</a>
<ul>
<li><a href="#see-your-property-fail">See your property fail</a></li>
<li><a href="#define-properties-as-separate-functions">Define properties as separate functions</a></li>
<li><a href="#provide-readable-counter-examples-on-failures">Provide readable counter-examples on failures</a></li>
<li><a href="#tag-interesting-cases-in-complex-properties">Tag interesting cases in complex properties</a></li>
<li><a href="#write-properties-to-assert-the-validity-of-complex-generators-and-shrinkers">Write properties to assert the validity of complex generators (and shrinkers)</a></li>
<li><a href="#use-checkcoverage-to-measure-coverage-requirements">Use <code>checkCoverage</code> to measure coverage requirements</a></li>
<li><a href="#avoid-liftio-in-monadic-properties">Avoid <code>liftIO</code> in monadic properties</a></li>
</ul>
</li>
<li><a href="#testing">Testing</a>
<ul>
<li><a href="#test-files-are-separated-and-self-contained">Test files are separated and self-contained</a></li>
<li><a href="#unit-test-files-names-match-their-corresponding-module">Unit test files names match their corresponding module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="code-formatting"><a class="header" href="#code-formatting">Code Formatting</a></h2>
<h3 id="editor-configuration-via-editorconfig"><a class="header" href="#editor-configuration-via-editorconfig">Editor Configuration via <code>.editorconfig</code></a></h3>
<p>A <code>.editorconfig</code> (see https://editorconfig.org/) at the root of the project specifies for various filetype:</p>
<ul>
<li>Line length</li>
<li>Indentation style (spaces vs tabs)</li>
<li>Encoding</li>
</ul>
<p>This file should be parsed and enforced by any contributor's editor.</p>
<blockquote>
<p><em>Why</em></p>
<p>This is the kind of details we don't want to be fighting over constantly. The <code>.editorconfig</code> are widely used,
easily written and supported by any decent editor out there. Agreeing on such rules prevent our version control
system to go crazy because people use different encoding or indentation style. It makes the overall code more consistent.</p>
</blockquote>
<h3 id="limit-line-length-to-80-characters"><a class="header" href="#limit-line-length-to-80-characters">Limit line length to 80 characters</a></h3>
<p>Source code, including comments, should <strong>not</strong> exceed 80 characters in length, unless in exceptional situations.</p>
<blockquote>
<p><em>Why</em></p>
<ul>
<li><strong>To maximize readability</strong>. Human eyes find it much harder to scan long lines. For people with imperfect vision, it can be even harder. Narrower code can be read quickly without having to scan from side to side. Although monitors have grown in width and resolution in recent years, human eyes haven't changed.</li>
<li><strong>To easily view multiple sources side-by-side</strong>. This is particularly important when working on a laptop. With a readable font size of around 11 pt, 80 characters is about half the horizontal distance across a laptop monitor. Trying to fit 90 or 100 characters into the same width requires a smaller font, raising the level of discomfort for people with poorer vision.</li>
<li><strong>To avoid horizontal scrolling when viewing source code</strong>. When reading most source code, we already have to scroll vertically. Horizontal scrolling means that readers have to move their viewpoint in two dimensions rather than one. This requires more effort and can cause strain for people reading your code.</li>
</ul>
</blockquote>
<details><summary>See Examples and Exceptions</summary>
<h4 id="examples"><a class="header" href="#examples">Examples</a></h4>
<p>If you find yourself exceeding 80 characters, there are several strategies you can use.</p>
<h5 id="strategy-1-wrap-code"><a class="header" href="#strategy-1-wrap-code">Strategy 1: Wrap code</a></h5>
<p>By inserting carriage returns in the right place, we can often reveal the underlying structure of an expression. Haskell allows you to break up long expressions so that they occur over multiple lines. For example:</p>
<pre><code class="language-Haskell">-- BAD
instance Bi Block where
    encode block = encodeListLen 3 &lt;&gt; encode (blockHeader block) &lt;&gt; encode (blockBody block) &lt;&gt; encode (blockExtraData block)
</code></pre>
<pre><code class="language-Haskell">-- GOOD
instance Bi Block where
    encode block = encodeListLen 3
        &lt;&gt; encode (blockHeader block)
        &lt;&gt; encode (blockBody block)
        &lt;&gt; encode (blockExtraData block)
</code></pre>
<p>Another example of wrapping:</p>
<pre><code class="language-hs">-- BAD:
describe "Lemma 2.6 - Properties of balance" $ do
    it "2.6.1) dom u ⋂ dom v ==&gt; balance (u ⋃ v) = balance u + balance v" (checkCoverage prop_2_6_1)
    it "2.6.2) balance (ins⋪ u) = balance u - balance (ins⊲ u)" (checkCoverage prop_2_6_2)
</code></pre>
<pre><code class="language-hs">-- GOOD:
describe "Lemma 2.6 - Properties of balance" $ do
    it "2.6.1) dom u ⋂ dom v ==&gt; balance (u ⋃ v) = balance u + balance v"
        (checkCoverage prop_2_6_1)
    it "2.6.2) balance (ins⋪ u) = balance u - balance (ins⊲ u)"
        (checkCoverage prop_2_6_2)
</code></pre>
<h5 id="strategy-2-place-comments-on-their-own-line-instead-of-attempting-to-align-them-vertically"><a class="header" href="#strategy-2-place-comments-on-their-own-line-instead-of-attempting-to-align-them-vertically">Strategy 2: Place comments on their own line instead of attempting to align them vertically</a></h5>
<pre><code class="language-Haskell">-- BAD
mkMagicalBlock
    :: MagicProtocolId                     -- A unique key specifying a magic protocol.
    -&gt; MagicType                           -- The type of magic used in this block signing.
    -&gt; MagicalKey                          -- The magical key used in this block signing.
    -&gt; Maybe Delegation.MagicalCertificate -- A magical certificate of delegation, in case the specified 'MagicalKey' does not have the right to sign this block.
    -&gt; Block
</code></pre>
<pre><code class="language-Haskell">-- GOOD
mkMagicalBlock
    :: MagicProtocolId
    -- ^ A unique key specifying a magic protocol.
    -&gt; MagicType
    -- ^ The type of magic used in this block signing.
    -&gt; MagicalKey
    -- ^ The magical key used in this block signing.
    -&gt; Maybe Delegation.MagicalCertificate
    -- ^ A magical certificate of delegation, in case the specified
    -- 'MagicalKey' does not have the right to sign this block.
    -&gt; Block
</code></pre>
<h5 id="strategy-3-break-up-long-string-literals"><a class="header" href="#strategy-3-break-up-long-string-literals">Strategy 3: Break up long string literals</a></h5>
<p>Haskell provides convenient support for multi-line string literals:</p>
<pre><code class="language-Haskell">-- BAD
errorAccountFundsCompletelyExhausted = "The funds in this account have been completely spent, and its balance is now zero. Either add more funds to this account or use a different account for this transaction."
</code></pre>
<pre><code class="language-Haskell">-- GOOD
errorAccountFundsCompletelyExhausted =
    "The funds in this account have been completely spent, and its balance \
    \is now zero. Either add more funds to this account or use a different \
    \account for this transaction."
</code></pre>
<pre><code class="language-Haskell">-- BAD:
spec = do
    scenario "Only this account's balance can be retrieved while standing on one leg on the side of an extremely tall mountain, and breathing thin air with only very limited amounts of oxygen." $ do
</code></pre>
<pre><code class="language-Haskell">-- GOOD:
spec = do
    scenario
        "Only this account's balance can be retrieved while standing on one \
        \leg on the side of an extremely tall mountain, and breathing thin \
        \air with only very limited amounts of oxygen." $ do
</code></pre>
<h5 id="strategy-4-reduce-nesting"><a class="header" href="#strategy-4-reduce-nesting">Strategy 4: Reduce nesting</a></h5>
<p>If your function contains so many levels of nesting that it's hard to keep things within 80 characters (even with careful use of wrapping), consider breaking your function up into smaller parts.</p>
<h4 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h4>
<p>Sometimes, it's <strong>impossible</strong> to adhere to this rule.</p>
<p>Here is a list of allowed exceptions:</p>
<h5 id="exception-1-urls-in-comments"><a class="header" href="#exception-1-urls-in-comments">Exception 1: URLs in comments</a></h5>
<p>According to the standard, URLs can be extremely long. In some situations, we need to place URLs in source code comments. If a URL is longer than 80 characters, then place it on its own line:</p>
<pre><code class="language-hs">--| For more information about this implementation, see:
--  https://an.exceptionally.long.url/7919ce329e804fc0bc1fa2df8a141fd3d996c484cf7a49e79f14d7bd974acadd
</code></pre>
</details>
<h3 id="use-only-a-single-blank-line-between-top-level-definitions"><a class="header" href="#use-only-a-single-blank-line-between-top-level-definitions">Use only a single blank line between top-level definitions</a></h3>
<p>A source code file <strong>should not</strong> contain multiple consecutive blank lines.</p>
<p>Use only a <strong>single</strong> blank line between the following top-level definitions:</p>
<ul>
<li>function definitions</li>
<li>data type definitions</li>
<li>class definitions</li>
<li>instance definitions</li>
</ul>
<blockquote>
<p><em>Why</em></p>
<ul>
<li>Consistency with other Haskell code.</li>
<li>Excessive vertical space increases the amount of unnecessary scrolling required to read a module.</li>
</ul>
</blockquote>
<details>
  <summary>See Examples</summary>
<pre><code class="language-hs">-- BAD
newtype Foo = Foo Integer
    deriving (Eq, Show)



newtype Bar = Bar Integer
    deriving (Eq, Show)
</code></pre>
<pre><code class="language-hs">-- GOOD
newtype Foo = Foo Integer
    deriving (Eq, Show)

newtype Bar = Bar Integer
    deriving (Eq, Show)
</code></pre>
<pre><code class="language-hs">-- BAD
instance FromCBOR Block where
    fromCBOR = Block &lt;$&gt; decodeBlock



newtype BlockHeader = BlockHeader
    { getBlockHeader :: Primitive.BlockHeader
    }
    deriving Eq
</code></pre>
<pre><code class="language-hs">-- GOOD
instance FromCBOR Block where
    fromCBOR = Block &lt;$&gt; decodeBlock

newtype BlockHeader = BlockHeader
    { getBlockHeader :: Primitive.BlockHeader
    }
    deriving Eq
</code></pre>
</details>
<h3 id="avoid-variable-length-indentation"><a class="header" href="#avoid-variable-length-indentation">Avoid Variable-Length Indentation</a></h3>
<p>Variables, arguments, fields and tokens in general shouldn't be aligned based
on the length of a previous token. Rather, tokens should go over a new line and
be indented one-level extra when it makes sense, or not be aligned at all.</p>
<blockquote>
<p><em>Why</em></p>
<p>Haskellers have a tendency to over-align everything vertically for the sake
of readability. In practice, this is much more of an habit than a real gain
in readability. Aligning content based on a function name, variable name or
record field tends to create unnecessarily long diffs and needless conflicts
in version control systems when making a change to add an argument, variable
or parameters. Favoring new-line and fixed-length alignment plays nicer with
version control.</p>
</blockquote>
<details>
  <summary>See Examples</summary>
<pre><code class="language-hs">-- GOOD
data AddressPool address = AddressPool
    { _addresses :: !(Map address Word32)
    , _gap :: !AddressPoolGap
    }

-- GOOD
data AddressPool address = AddressPool
    { _addresses
        :: !(Map address Word32)
    , _gap
        :: !AddressPoolGap
    }

-- GOOD
deriveAccountPrivateKey
    :: PassPhrase
    -&gt; EncryptedSecretKey
    -&gt; Word32
    -&gt; Maybe EncryptedSecretKey
deriveAccountPrivateKey passPhrase masterEncPrvKey accountIx =

-- BAD
myFunction :: Word64 -&gt; Maybe String
myFunction w = let res = Wrap w in
               case someOp res of
                 Left _err -&gt; Nothing
                 Right ()  -&gt; Just coin

-- BAD
myFunction :: Int
           -&gt; Maybe ByteString
           -&gt; Set Word32
           -&gt; Update DB (Either [Word32]
                        (Map Word32 ([String], Set ByteString)))

-- BAD
data MyRecord = MyRecord
    { _myRecordLongNameField :: !String
    , _myRecordShort         :: ![Int]
    }
</code></pre>
</details>
<h3 id="stylish-haskell-is-used-to-format-grouped-imports--language-pragmas"><a class="header" href="#stylish-haskell-is-used-to-format-grouped-imports--language-pragmas">Stylish-Haskell is used to format grouped imports &amp; language pragmas</a></h3>
<p>Contributors' editors should pick up and enforce the rules defined by the <code>.stylish-haskell.yaml</code>
configuration file at the root of the project. Also, in order to maximize readability, imports
should be grouped into three groups, separated by a blank newline.</p>
<ul>
<li>Prelude import</li>
<li>Explicit imports</li>
<li>Qualified imports</li>
</ul>
<blockquote>
<p><strong>Why</strong></p>
<p>It is rather annoying and time-consuming to align import lines or statement
as we code and it's much simpler to leave that to our editor. Yet, we do want
to enforce some common formatting such that everyone gets to be aligned (pun
intended).</p>
<p>We can use Stylish-Haskell with various set of rules, yet, the same arguments
from 'Avoid Variable-Length Indentation' applies when it comes to automatic
formatting. Imports are a real pain with git and Haskell when they are vertically
aligned based on the imported module's name.</p>
</blockquote>
<details>
    <summary>See examples</summary>
<pre><code class="language-hs">-- GOOD
import Prelude

import Cardano.Wallet.Binary
    ( txId )
import Data.Set
    ( Set )
import Data.Traversable
    ( for )

import qualified Data.Map as Map
import qualified Data.Set as Set

-- BAD
import Cardano.Wallet.Binary
    ( txId )
import Data.Set
    ( Set )
import Prelude
import Data.Traversable
    ( for )

import qualified Data.Map as Map
import qualified Data.Set as Set

-- BAD
import Prelude

import Cardano.Wallet.Binary
    ( txId )
import qualified Data.Set as Set
import Data.Set
    ( Set )
import qualified Data.Map as Map
import Data.Traversable
    ( for )
</code></pre>
</details>
<p>Here below is a proposal for the initial set of rules:</p>
<pre><code class="language-yaml">columns: 80 # Should match .editorconfig
steps:
  - imports:
      align: none
      empty_list_align: inherit
      list_align: new_line
      list_padding: 4
      long_list_align: new_line_multiline
      pad_module_names: false
      separate_lists: true
      space_surround: true

  - language_pragmas:
      align: false
      remove_redundant: true
      style: vertical
</code></pre>
<details>
  <summary>See example</summary>
<pre><code class="language-hs">{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}

module Main where

import Control.Applicative
    ( (&lt;|&gt;) )
import Control.Arrow
    ( first )
import Control.Concurrent.MVar
    ( modifyMVar_, newMVar, putMVar, readMVar, takeMVar )
import Crypto.Hash.Algorithms
    ( Blake2b_224, Blake2b_256, SHA3_256, SHA512 (..) )
import Lens.Micro
    ( at, (%~), (&amp;), (.~), (^.) )
import Network.HTTP.Client
    ( Manager
    , defaultRequest
    , httpLbs
    , path
    , port
    , responseBody
    , responseStatus
    )

import qualified Codec.CBOR.Decoding as CBOR
import qualified Codec.CBOR.Encoding as CBOR
import qualified Codec.CBOR.Read as CBOR
import qualified Codec.CBOR.Write as CBOR
import qualified Crypto.Cipher.ChaChaPoly1305 as Poly
</code></pre>
</details>
<h2 id="haskell-practices"><a class="header" href="#haskell-practices">Haskell Practices</a></h2>
<h3 id="favor-newtype-and-tagged-type-over-type-aliases"><a class="header" href="#favor-newtype-and-tagged-type-over-type-aliases">Favor <code>newtype</code> and tagged type over type-aliases</a></h3>
<p>Instead of writing type aliases, one should favor wrapping up values in newtype
when it makes sense, or, have them wrapped into a tagged type with a phantom
type to convey some extra meaning while still preserving type safeness. By
using newtypes, we actually extend our program vocabulary and increase its
robustness.</p>
<blockquote>
<p><strong>Why</strong></p>
<p>Type-aliases convey a false sense of type-safety. While they usually make
things a bit better for the reader, they have a tendency to spread through
the code-base transforming those sweet help spot into traps. We can't define
proper instances on type aliases, and we treat them as different type whereas
they are behind the scene, just another one.</p>
</blockquote>
<details>
  <summary>See examples</summary>
<pre><code class="language-hs">-- GOOD
newtype HardenedIndex = HardenedIndex { getHardenedIndex :: Word32 }
deriveAccount :: HardenedIndex -&gt; XPrv -&gt; XPrv

-- GOOD
data Scheme = Seq | Rnd
newtype Key (* :: Scheme) = Key { getKey :: XPrv }
deriveAccount :: Word32 -&gt; Key 'Seq -&gt; Key 'Seq

-- GOOD
newtype Tagged (* :: Symbol) = Tagged { getTagged :: String }
startNode :: Tagged "nodeId" -&gt; IO ()

-- BAD
type HardenedIndex = Word32
deriveAccount :: HardenedIndex -&gt; XPrv -&gt; XPrv
</code></pre>
</details>
<h3 id="language-extensions-are-specified-on-top-of-each-module"><a class="header" href="#language-extensions-are-specified-on-top-of-each-module">Language extensions are specified on top of each module</a></h3>
<p>Haskell's language extension are specified on top of each module.</p>
<blockquote>
<p><strong>Why</strong></p>
<p>Having a lot of default extensions enabled across the whole project can sometimes lead to cryptic
errors where GHC would interpret things differently because of the enabled extensions. Yet, it's
sometimes hard to distinguish by simply looking at the module themselves.</p>
<p>Also, being more explicit on extensions used by a module can help speeding up compile-time of such simple modules
that don't need to be pull in a lot of extra complexity.</p>
</blockquote>
<details>
  <summary>See examples</summary>
<pre><code class="language-hs">-- GOOD
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE DerivingStrategies #-}

module Cardano.Wallet where

-- BAD
default-extensions:
  - DataKinds
  - GeneralizedNewtypeDeriving
  - DerivingStrategies
</code></pre>
</details>
<h3 id="hlint-is-used-for-hints-and-general-code-style"><a class="header" href="#hlint-is-used-for-hints-and-general-code-style">HLint is used for hints and general code style</a></h3>
<p>Contributors' editors should pick up and enforce the rules defined by the
.hlint.yaml configuration file at the root of the project. File should be
committed without warnings or errors. When it make senses, developer may ignore
lints at a function site using a proper annotation:</p>
<blockquote>
<p><strong>Why</strong></p>
<p>Linters are common practices in software development and help maintaining consistency across a large codebase with
many developers. Hlint is de de-facto linter in Haskell and comes with a lot of different rules and features that
are <em>most of the time</em> rather relevant and convey good practices, agreed upon and shared across the team.</p>
</blockquote>
<p>e.g.</p>
<pre><code class="language-hs">{-# ANN decodeBlock ("HLint: ignore Use &lt;$&gt;" :: String) #-}
</code></pre>
<p>As a start, we'll use the following built-in rules from <code>hlint</code> with the following configuration, and refine this as we move forward:</p>
<pre><code class="language-yaml">- modules:
  # Enforce some common qualified imports aliases across the codebase
  - {name: [Data.Aeson, Data.Aeson.Types], as: Aeson}
  - {name: [Data.ByteArray], as: BA}
  - {name: [Data.ByteString.Base16], as: B16}
  - {name: [Data.ByteString.Char8], as: B8}
  - {name: [Data.ByteString.Lazy], as: BL}
  - {name: [Data.ByteString], as: BS}
  - {name: [Data.Foldable], as: F}
  - {name: [Data.List.NonEmpty], as: NE}
  - {name: [Data.List], as: L}
  - {name: [Data.Map.Strict], as: Map}
  - {name: [Data.Sequence], as: Seq}
  - {name: [Data.Set, Data.HashSet], as: Set}
  - {name: [Data.Text, Data.Text.Encoding], as: T}
  - {name: [Data.Vector], as: V}

# Ignore some build-in rules
- ignore: {name: "Reduce duplication"} # This is a decision left to developers and reviewers
- ignore: {name: "Redundant bracket"} # Not everyone knows precedences of every operators in Haskell. Brackets help readability.
- ignore: {name: "Redundant do"} # Just an annoying hlint built-in, GHC may remove redundant do if he wants
</code></pre>
<h3 id="we-use-explicit-imports-by-default-and-favor-qualified-imports-for-ambiguous-functions"><a class="header" href="#we-use-explicit-imports-by-default-and-favor-qualified-imports-for-ambiguous-functions">We use explicit imports by default, and favor qualified imports for ambiguous functions</a></h3>
<p>Apart from the chosen prelude, there should be no implicit imports. Instead,
every function or class used from a given module should be listed explicitly.
In case where a function name is ambiguous or requires context, a qualified
import should be used instead (this is mainly the case for modules coming from
<code>containers</code>, <code>bytestring</code> and <code>aeson</code>).</p>
<blockquote>
<p><strong>Why</strong></p>
<p>Imports can be a great source of pain in Haskell. When dealing with some
foreign code (and every code becomes quite hostile after a while, even if we
originally wrote it), it can be hard to understand where functions and
abstractions are pulled from. On the other hand, fully qualified imports can
become verbose and a real impediment to readability.</p>
</blockquote>
<details>
  <summary>See examples</summary>
<pre><code class="language-hs">-- GOOD
import Prelude
import Control.DeepSeq
    ( NFData (..) )
import Data.ByteString
    ( ByteString )
import Data.Map.Strict
    ( Map )
import Data.Aeson
    ( FromJSON (..), ToJSON (..) )


-- GOOD
import qualified Data.Map.Strict as Map
import qualified Data.ByteString as BS

isSubsetOf :: UTxO -&gt; UTxO -&gt; Bool
isSubsetOf (UTxO a) (UTxO b) =
    a `Map.isSubmapOf` b

(magic, filetype, version) =
    ( BS.take 8 bytes
    , BS.take 4 $ BS.drop 8 bytes
    , BS.take 4 $ BS.drop 12 bytes
    )


-- BAD
import Options.Applicative


-- BAD
import qualified Data.Aeson as Aeson

instance Aeson.FromJSON MyType where
    -- ...


-- BAD
import Data.Map.Strict
    ( filter )
import Data.Set
    ( member )

restrictedTo :: UTxO -&gt; Set TxOut -&gt;  UTxO
restrictedTo (UTxO utxo) outs =
    UTxO $ filter (`member` outs) utxo
</code></pre>
</details>
<h3 id="all-modules-begin-with-a-helpful-documentation-comment"><a class="header" href="#all-modules-begin-with-a-helpful-documentation-comment">All modules begin with a helpful documentation comment</a></h3>
<p>The comments might answer the question <em>why?</em> They <em>might</em>:</p>
<ol>
<li>Explain the relation to other modules</li>
<li>Explain the relation to business functionality</li>
<li>Provide some other good-to-know information</li>
</ol>
<p>We should keep an eye out out-of-date comments. For instance when creating and reviewing PRs.</p>
<blockquote>
<p><strong>Why</strong></p>
<p>Even if individual functions are well-documented, it can be difficult to grasp how it all fits together.</p>
<p>In the legacy code-base, it was common to have multiple functions with the same or similar names, in different modules.
Try seaching for <code>applyBlocks</code> or <code>switchToFork</code>. What is the difference between <code>DB.Spec.Update.switchToFork</code> and <code>DB.AcidState.switchToFork</code>?</p>
<p>Having a comment at the top of each module would be an easy-to-follow rule to better document this. It is also very appropriate for
generated <a href="https://cardano-foundation.github.io/cardano-wallet/haddock/">haddock docs</a>.</p>
<p>If we re-design a module and forget to update the comment, the comment is no longer useful.</p>
</blockquote>
<details>
  <summary>See examples</summary>
<pre><code class="language-hs">-- |
-- Copyright: © 2018-2019 IOHK
-- License: MIT
--
-- This module contains the core primitive of a Wallet. This is roughly a
-- Haskell translation of the [Formal Specification for a Cardano Wallet](https://github.com/cardano-foundation/cardano-wallet/blob/master/specifications/wallet/formal-specification-for-a-cardano-wallet.pdf)
--
-- It doesn't contain any particular business-logic code, but define a few
-- primitive operations on Wallet core types as well.
</code></pre>
<p>(https://github.com/cardano-foundation/cardano-wallet/blob/d3cca01f66f0abe93012343dab093a2551b6cbea/src/Cardano/Wallet/Primitive.hs#L12-L20)</p>
<pre><code class="language-hs">-- |
-- Copyright: © 2018-2019 IOHK
-- License: MIT
--
-- Provides the wallet layer functions that are used by API layer and uses both
-- "Cardano.DBLayer" and "Cardano.NetworkLayer" to realize its role as being
-- intermediary between the three.
</code></pre>
<p>(https://cardano-foundation.github.io/cardano-wallet/haddock/cardano-wallet-2.0.0/Cardano-WalletLayer.html)</p>
</details>
<h3 id="prefer-named-constants-over-magic-numbers"><a class="header" href="#prefer-named-constants-over-magic-numbers">Prefer named constants over magic numbers</a></h3>
<blockquote>
<p><strong>Why</strong></p>
<p>A <strong>magic number</strong> (or magic value) is a value that appears in source code without an accompanying explanation, which could (preferably) be replaced with a named constant.</p>
<p>The use of an unnamed magic number often obscures the developer's intent in choosing that number, increases opportunities for subtle errors and makes it more difficult for the program to be adapted and extended in the future.</p>
<p>Replacing all significant magic numbers with named constants makes programs easier to read, understand and maintain. Named constants can also be reused in multiple places, making it obvious that the value is supposed to be the same across all places that its used.</p>
</blockquote>
<details>
  <summary>See examples</summary>
<h4 id="bad"><a class="header" href="#bad">BAD</a></h4>
<pre><code class="language-hs">humanReadableCharIsValid :: Char -&gt; Bool
humanReadableCharIsValid c = c &gt;= chr 33 &amp;&amp; c &lt;= chr 126

bech32CharSet :: Set Char
bech32CharSet =
    Set.filter (not . isUpper) $
        Set.fromList [chr 33 .. chr 126]
            `Set.union` (Set.singleton '1')
            `Set.union` (Set.fromList "qpzry9x8gf2tvdw0s3jn54khce6mua7l")

instance Arbitrary HumanReadableChar where
    arbitrary = HumanReadableChar &lt;$&gt;
        choose (chr 33, chr 126)
</code></pre>
<h4 id="good"><a class="header" href="#good">GOOD</a></h4>
<pre><code class="language-hs">-- | The lower bound of the set of characters permitted to appear within the
--   human-readable part of a Bech32 string.
humanReadableCharMinBound :: Char
humanReadableCharMinBound = chr 33

-- | The upper bound of the set of characters permitted to appear within the
--   human-readable part of a Bech32 string.
humanReadableCharMaxBound :: Char
humanReadableCharMaxBound = chr 126

-- | The separator character. This character appears immediately after the
-- human-readable part and before the data part.
separatorChar :: Char
separatorChar = '1'

-- | A list of all characters that are permitted to appear within the data part
--   of a Bech32 string.
dataCharList :: String
dataCharList = "qpzry9x8gf2tvdw0s3jn54khce6mua7l"

humanReadableCharIsValid :: Char -&gt; Bool
humanReadableCharIsValid c =
    c &gt;= humanReadableCharMinBound &amp;&amp;
    c &lt;= humanReadableCharMaxBound

bech32CharSet :: Set Char
bech32CharSet =
    Set.filter (not . isUpper) $
        Set.fromList [humanReadableCharMinBound .. humanReadableCharMaxBound]
            `Set.union` (Set.singleton separatorChar)
            `Set.union` (Set.fromList dataCharList)

instance Arbitrary HumanReadableChar where
    arbitrary = HumanReadableChar &lt;$&gt;
        choose (humanReadableCharMinBound, humanReadableCharMaxBound)
</code></pre>
</details>
<h3 id="avoid-wildcards-when-pattern-matching-on-sum-types"><a class="header" href="#avoid-wildcards-when-pattern-matching-on-sum-types">Avoid wildcards when pattern-matching on sum types</a></h3>
<p>When pattern-matching on sum types or finite structures, we should avoid
the use of the wildcard <code>_</code> as much as possible, and instead favor explicit
handling of all branches. This way, we get compiler errors when extending
the underlying ADT and avoid silently handling (probably incorretly) some
of the new branches.</p>
<blockquote>
<p><strong>Why</strong></p>
<p>When pattern-matching on sum types it is tempting to handle a few similar cases
using a wildcard <code>_</code>. However, this often leads to undesirable behavior when
adding new branches to an ADT. Compilers won't trigger any warnings and, as
developers, we might miss some necessary logic updates in existing pattern
matches.</p>
</blockquote>
<details>
  <summary>See examples</summary>
<pre><code class="language-hs">-- GOOD
isPositive = \case
    InLedger -&gt; True
    Pending -&gt; False
    Invalidated -&gt; False

-- BAD
isPositive = \case
    InLedger -&gt; True
    _ -&gt; False

-- BAD
handleErr = \case
    ErrWalletNotFound -&gt; {- ... -}
    _ -&gt; ErrUnknown
</code></pre>
</details>
<h3 id="prefer-pattern-matching-to-equality-testing-on-sum-types"><a class="header" href="#prefer-pattern-matching-to-equality-testing-on-sum-types">Prefer pattern-matching to equality testing on sum types.</a></h3>
<p>For expressions that evaluate differently depending on a value of a sum type,
prefer pattern matching over equality testing for values of that type.</p>
<blockquote>
<p><strong>Why</strong></p>
<p>When conditional evaluation depends on the value of a sum type, it's tempting
to use a test for equality or inequality to branch on a particular
value.</p>
<p>However, if someone adds a new constructor to the sum type later on,
we'd ideally like the compiler to remind us to check all locations that inspect
values of this type, especially where conditional evaluation is involved.</p>
<p>Using an equality test is non-ideal because the compiler won't necessarily
fail if a new constructor is added to the underlying sum type, whereas it
will <strong>always</strong> fail if a pattern match becomes incomplete.</p>
</blockquote>
<details>
  <summary>See examples</summary>
<pre><code class="language-hs">data SortOrder = Ascending | Descending
    deriving Eq

-- BAD
sortWithOrder' :: Ord a =&gt; SortOrder -&gt; [a] -&gt; [a]
sortWithOrder' order = f . sort
  where
    f = if order == Ascending then id else reverse

-- GOOD
sortWithOrder :: Ord a =&gt; SortOrder -&gt; [a] -&gt; [a]
sortWithOrder order = f . sort
  where
    f = case order of
        Ascending -&gt; id
        Descending -&gt; reverse
</code></pre>
</details>
<h3 id="proposed-dont-spit-back-malformed-values-in-errors-from-user-inputs"><a class="header" href="#proposed-dont-spit-back-malformed-values-in-errors-from-user-inputs">[PROPOSED] Don't spit back malformed values in errors from user inputs.</a></h3>
<p>When failing to parse user inputs, error message should not contain the malformed input. Instead, the error message should contain hints or examples of well-formed values expected by the parser. It is acceptable to show a raw input value if it is known to be within acceptable boundaries (e.g. parsing a <code>Word32</code> into a more refined type, there is little chance that the <code>Word32</code> will be inadequate to display).</p>
<blockquote>
<p><strong>Why</strong></p>
<p>Spitting back what the user has just entered is generally not very helpful. Users can generally easily replay what they've entered and see for themselves. More importantly, an input that didn't parse successfully may be arbitrary long or improper for display; since it failed to parse, we have actually not much control or knowledge about it.</p>
</blockquote>
<details>
  <summary>See examples</summary>
<pre><code class="language-hs">-- BAD
err =
    "Invalid value: " &lt;&gt; show v &lt;&gt; ". Please provide a valid value."

-- GOOD
err =
    "EpochNo value is out of bounds (" &lt;&gt;
    show (minBound @Word31) &lt;&gt;
    ", " &lt;&gt;
    show (maxBound @Word31) &lt;&gt;
    ")."

-- GOOD
err =
    "Unable to decode FeePolicy: \
    \Linear equation not in expected format: a + bx + cy \
    \where 'a', 'b', and 'c' are numbers"
</code></pre>
</details>
<h2 id="quickcheck"><a class="header" href="#quickcheck">QuickCheck</a></h2>
<h3 id="see-your-property-fail"><a class="header" href="#see-your-property-fail">See your property fail</a></h3>
<p>This is a general practice in TDD (<strong>T</strong>est <strong>D</strong>riven <strong>D</strong>evelopment) but
even more important in property-based testing.  You want to see <em>how</em> your
property fails and whether, as a developer, you have enough information to
understand the reason of the failure and debug it.</p>
<blockquote>
<p><strong>Why</strong></p>
<p>It is really easy to write all sort of properties which, once they fail, give
close to no details about the reason why they failed. Yet, as with any tests,
one wants to understand what happens. It is therefore important to see
properties failing at least once to see whether the level of details is
sufficient, as well as the efficiency of the shrinkers.</p>
</blockquote>
<h3 id="define-properties-as-separate-functions"><a class="header" href="#define-properties-as-separate-functions">Define properties as separate functions</a></h3>
<p>It is often tempting to write properties inlined with <code>hspec</code> other combinators
instead of having them as separate functions. However, we recommend writing
properties as separate functions, prefixed with a <code>prop_</code> prefix to clearly
identify them.</p>
<blockquote>
<p><strong>Why</strong></p>
<p>It makes for more readable test files where the set of properties can be easily
identified by looking at the top-level exported spec. But more importantly, it
allows for re-using the property with some regression test cases coming from past
failures. Having a separate function makes it easy to simply apply counter examples
yielded by QuickCheck as arguments!</p>
</blockquote>
<details>
  <summary>See examples</summary>
<pre><code class="language-hs">-- GOOD
describe "selectCoinsForMigration properties" $ do
    it "Total input UTxO value &gt;= sum of selection change coins" $
        property $ withMaxSuccess 1000 prop_inputsGreaterThanOutputs

describe "selectCoinsForMigration regressions" $ do
    it "regression #1" $ do
        let feeOpts = FeeOptions
                { dustThreshold = Coin 9
                , estimateFee = \s -&gt; Fee
                    $ fromIntegral
                    $ 5 * (length (inputs s) + length (outputs s))
                }
        let batchSize = 1
        let utxo = UTxO $ Map.fromList
                [ ( TxIn { inputId = Hash "|\243^\SUBg\242\231\&amp;1\213\203", inputIx = 2 }
                  , TxOut { address = Address "ADDR03", coin = Coin 2 }
                  )
                ]
        property $ prop_inputsGreaterThanOutputs feeOpts batchSize utxo


-- | Total input UTxO value &gt;= sum of selection change coins
prop_inputsGreaterThanOutputs
    :: FeeOptions
    -&gt; Word8
    -&gt; UTxO
    -&gt; Property
prop_inputsGreaterThanOutputs feeOpts batchSize utxo = {- ... -}


-- BAD
it "Eventually converge for decreasing functions" $ do
    property $ \coinselOpts -&gt; do
        let batchSize = idealBatchSize coinselOpts
        label (show batchSize) True
</code></pre>
</details>
<h3 id="provide-readable-counter-examples-on-failures"><a class="header" href="#provide-readable-counter-examples-on-failures">Provide readable counter-examples on failures</a></h3>
<p>Use <a href="https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck.html#v:counterexample">counterexample</a> to display human-readable
counter examples when a test fails; in particular, for data-types which have a <a href="https://hackage.haskell.org/package/fmt-0.6.1.2/docs/Fmt.html#t:Buildable">Buildable</a> instances
that are typically hard to read through their standard <code>Show</code> instance. For monadic properties, this can be used via <a href="https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck-Monadic.html#v:monitor">monitor</a>.</p>
<blockquote>
<p><strong>Why</strong></p>
<p>Some property-based tests can use complex combinations of inputs that can be hard to decipher
when printed out to the console using only the stock <code>Show</code> instance. On the other hand, we
want to keep using the stock <code>Show</code> instance in order to be able to easily copy-paste failing
cases and turn them into regression tests. QuickCheck however provides a good set of tools to
display counter examples on failures to ease debbugging.</p>
</blockquote>
<details>
  <summary>See examples</summary>
<pre><code class="language-hs">property (Bech32.decode corruptedString `shouldSatisfy` isLeft)
    &amp; counterexample $ unlines
        [ "index of char #1: " &lt;&gt; show index
        , "index of char #2: " &lt;&gt; show (index + 1)
        , "         char #1: " &lt;&gt; show char1
        , "         char #2: " &lt;&gt; show char2
        , " original string: " &lt;&gt; show originalString
        , "corrupted string: " &lt;&gt; show corruptedString
        ]

property (bs' === Just expected)
    &amp; counterexamples $ unlines
        [ "k = " ++ show k
        , "Local chain: " ++ showChain localChain
        , "Node chain:  " ++ showChain nodeChain
        , "Intersects:  " ++ maybe "-" showSlot isect
        , "Expected:    " ++ showBlockHeaders expected
        , "Actual:      " ++ maybe "-" showBlockHeaders bs'
        ]
</code></pre>
</details>
<h3 id="tag-interesting-cases-in-complex-properties"><a class="header" href="#tag-interesting-cases-in-complex-properties">Tag interesting cases in complex properties</a></h3>
<p>Quickcheck provides good tooling for labelling (see <a href="https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck.html#v:label">label</a> and classifying (see <a href="https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck.html#v:classify">classify</a>)
inputs or results of a property. These should be used in properties dealing with several classes of values.</p>
<blockquote>
<p><strong>Why</strong></p>
<p>It is quite common for properties to deal with different class of values and for us developers to get a false sense of
coverage. QuickCheck default generators are typically skewed towards certain edge values to favor bug finding but this
is sometimes counter-intuitive. For example, when testing with lists or maps, it often happens that most of the test cases
are actually testing on empty values. In order to make sure that some interesting test cases are still covered, it is
necessary to instrument properties so that they can mesure how often certain cases appear in a particular property.</p>
</blockquote>
<details>
  <summary>See Examples</summary>
<pre><code class="language-hs">prop_sync :: S -&gt; Property
prop_sync s0 = monadicIO $ do
    {- ... -}
    monitor (label (intersectionHitRate consumer))
    monitor (classify (initialChainLength (const (== 1))) "started with an empty chain")
    monitor (classify (initialChainLength (\k -&gt; (&gt; k))) "started with more than k blocks")
    monitor (classify addMoreThanK "advanced more than k blocks")
    monitor (classify rollbackK "rolled back full k")
    monitor (classify (switchChain (&lt;)) "switched to a longer chain")
    monitor (classify (switchChain (&gt;)) "switched to a shorter chain")
    monitor (classify (switchChain (const (== 0))) "rewinded without switch")
    monitor (classify (recoveredFromGenesis s) "recovered from genesis")
    monitor (classify (startedFromScratch c0Cps) "started from scratch")
    {- ... -}

-- Syncs with mock node
--   64.709% started from scratch
--   55.969% advanced more than k blocks
--   53.260% started with an empty chain
--   41.094% started with more than k blocks
--   10.421% switched to a shorter chain
--    7.195% switched to a longer chain
--    6.773% rewinded without switch
--    0.880% rolled back full k
--
--   57.516% Intersection hit rate GREAT (75% - 100%)
--   32.183% Intersection hit rate GOOD  (50% - 75%)
--   10.292% Intersection hit rate POOR  (10% - 50%)
--    0.009% Intersection hit rate BAD   (0%  - 10%)


prop_rollbackPools db pairs = monadicIO $ do
    {- ... -}
    Monitor $ classify (any (&gt; sl) beforeRollback) "something to roll back"
    Monitor $ classify (all (&lt;= sl) beforeRollback) "nothing to roll back"
    {- ... -}

-- Rollback of stake pool production
--   57% nothing to roll back
--   43% something to roll back

prop_accuracy r = withMaxSuccess 1000 $ monadicIO $ do
    {- ... -}
    monitor $ label $ accuracy dust balance balance'
  where
    accuracy :: Coin -&gt; Natural -&gt; Natural -&gt; String
    accuracy (Coin dust) sup real
        | a &gt;= 1.0 =
            "PERFECT  (== 100%)"
        | a &gt; 0.99 || (sup - real) &lt; fromIntegral dust =
            "OKAY     (&gt;   99%)"
        | otherwise =
            "MEDIOCRE (&lt;=  99%)"
      where
        a = double real / double sup

-- Accuracy of selectCoinsForMigration
--   dust=1%
--     +++ OK, passed 1000 tests (100.0% PERFECT  (== 100%)).
--   dust=5%
--     +++ OK, passed 1000 tests (100.0% PERFECT  (== 100%)).
--   dust=10%
--     +++ OK, passed 1000 tests:
--     99.8% PERFECT  (== 100%)
--      0.2% OKAY     (&gt;   99%)
--   dust=25%
--     +++ OK, passed 1000 tests:
--     99.6% PERFECT  (== 100%)
--      0.4% OKAY     (&gt;   99%)
--   dust=50%
--     +++ OK, passed 1000 tests:
--     98.8% PERFECT  (== 100%)
--      1.2% OKAY     (&gt;   99%)
</code></pre>
</details>
<h3 id="write-properties-to-assert-the-validity-of-complex-generators-and-shrinkers"><a class="header" href="#write-properties-to-assert-the-validity-of-complex-generators-and-shrinkers">Write properties to assert the validity of complex generators (and shrinkers)</a></h3>
<p>Arbitrary generators, and in particular complex ones, should be tested independently
to make sure they yield correct values. This also includes shrinkers associated with
the generator which can often break some invariants enforced by the generator itself.</p>
<blockquote>
<p><strong>Why</strong></p>
<p>Generators and shrinkers are at the heart of property-based testing. Writing properties
using clunky generators will lead to poor or wrong results. Above all, it may take an
important amount of time to debug failures due to an invalid generator. So it's best
to start by verifying the a given generator is somewhat correct. Often enough, generators
are obvious, but when they are slightly more engineered, testing them is a must.</p>
</blockquote>
<details>
    <summary>See Examples</summary>
<pre><code class="language-hs">--| Checks that generated mock node test cases are valid
prop_MockNodeGenerator :: S -&gt; Property
prop_MockNodeGenerator (S n0 ops _ _) =
    prop_continuous .&amp;&amp;. prop_uniqueIds
  where
    prop_continuous :: Property
    prop_continuous =
        conjoin (follow &lt;$&gt; scanl (flip applyNodeOp) n0 (concat ops))

    prop_uniqueIds :: Property
    prop_uniqueIds =
        length (nub bids) === length bids
            &amp; counterexample ("Non-unique ID: " ++ show bids)
      where
        bids = concat [map mockBlockId bs | NodeAddBlocks bs &lt;- concat ops]

prop_nonSingletonRangeGenerator :: NonSingletonRange Int -&gt; Property
prop_nonSingletonRangeGenerator = property $ \(nsr :: NonSingletonRange Int) -&gt;
    isValidNonSingleton nsr .&amp;&amp;. all isValidNonSingleton (shrink nsr)
  where
    isValidNonSingleton (NonSingletonRange r) =
        rangeIsValid r &amp;&amp; not (rangeIsSingleton r) in
</code></pre>
</details>
<h3 id="use-checkcoverage-to-measure-coverage-requirements"><a class="header" href="#use-checkcoverage-to-measure-coverage-requirements">Use <code>checkCoverage</code> to measure coverage requirements</a></h3>
<p>Using <a href="https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck.html#v:label">label</a> or <a href="https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck.html#v:classify">classify</a>
instruments QuickCheck to gather some metrics about a particular properties and print out results in the console. However,
it also possible to <em>enforce</em> that some collected values stay above a certain threshold using <a href="https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck.html#v:checkCoverage">checkCoverage</a>.
When used, QuickCheck will run the property as many times as necessary until a particular coverage requirement is satisfied, with a certain confidence.</p>
<blockquote>
<p><strong>Why</strong></p>
<p>Labelling and classifying is good but, in an evolving code-base where
generators are sometimes shared between multiple properties, it is possible
for someone to accidentally make a generator worse for an existing property
without noticing it. Therefore, by enforcing clear coverage requirements with
<code>checkCoverage</code>, one can make a property fail if the coverage drops below an
acceptable threshold. For example, a property can measure the proportion of
empty lists its generator yield and require that at least 50% of all generated
list are not empty.</p>
</blockquote>
<details>
    <summary>See examples</summary>
<pre><code class="language-hs">prop_rangeIsValid :: Property
prop_rangeIsValid = property $ \(r :: Range Integer) -&gt;
    rangeIsValid r .&amp;&amp;.  all rangeIsValid (shrink r)
        &amp; cover 10 (rangeIsFinite r) "finite range" $
        &amp; checkCoverage

spec :: Spec
spec = do
    describe "Coin selection properties : shuffle" $ do
        it "every non-empty list can be shuffled, ultimately" $
            checkCoverageWith lowerConfidence prop_shuffleCanShuffle
        it "shuffle is non-deterministic" $
            checkCoverageWith lowerConfidence prop_shuffleNotDeterministic
        it "sort (shuffled xs) == sort xs" $
            checkCoverageWith lowerConfidence prop_shufflePreserveElements
  where
    lowerConfidence :: Confidence
    lowerConfidence = Confidence (10^(6 :: Integer)) 0.75
</code></pre>
</details>
<h3 id="avoid-liftio-in-monadic-properties"><a class="header" href="#avoid-liftio-in-monadic-properties">Avoid <code>liftIO</code> in monadic properties</a></h3>
<p>When running monadic properties in IO, it is often required to lift a
particular IO action.  Unfortunately, the <code>PropertyM</code> monad in which the
monadic properties are defined have a <code>MonadIO</code> instance so using <code>liftIO</code> is
tempting. However, one should use <a href="https://hackage.haskell.org/package/QuickCheck-2.13.2/docs/Test-QuickCheck-Monadic.html#v:run">run</a>
in order to lift operation in the property monad.</p>
<blockquote>
<p><strong>Why</strong></p>
<p>This is very important if the property also contains calls to <code>monitor</code>, <code>label</code>, <code>counterexample</code>
and so forth... Using <code>liftIO</code> actually breaks the abstraction boundary of the property monad which
then makes the reporting with these combinator ineffective. Using <code>run</code> however correctly inserts
monadic operations and preserve reporting and measures done during the property.</p>
</blockquote>
<details>
    <summary>See examples</summary>
<pre><code class="language-hs">-- GOOD
setup wid meta = run $ do
    cleanDB db
    unsafeRunExceptT $ createWallet db wid cp0 meta mempty
    unsafeRunExceptT $ putTxHistory db wid txs0

prop wid point = do
    run $ unsafeRunExceptT $ rollbackTo db wid point
    txs &lt;- run $ readTxHistory db wid Descending wholeRange Nothing
    monitor $ counterexample $ "\nTx history after rollback: \n" &lt;&gt; fmt txs
    {- ... -}

-- BAD
prop_createWalletTwice db (key@(PrimaryKey wid), cp, meta) =
    monadicIO (setup &gt;&gt; prop)
  where
    setup = liftIO (cleanDB db)
    prop = liftIO $ do
        let err = ErrWalletAlreadyExists wid
        runExceptT (createWallet db key cp meta mempty) `shouldReturn` Right ()
        runExceptT (createWallet db key cp meta mempty) `shouldReturn` Left err
</code></pre>
</details>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<h3 id="test-files-are-separated-and-self-contained"><a class="header" href="#test-files-are-separated-and-self-contained">Test files are separated and self-contained</a></h3>
<p>Test files do not import other test files. Arbitrary instances are not shared
across test files and are defined locally. If we do observe a recurring pattern
in tests (like for instance, testing roundtrips), we may consider making this a
library that test can import.</p>
<blockquote>
<p><strong>Why</strong></p>
<p>It is really easy to make the testing code more complex than the actual code
it's initially testing. Limiting the interaction between test modules helps
keeping a good maintainability and a rather low overhead when it comes to
extend, modify, read or comprehend some tests. Also, in many cases, we do
actually want to have different arbitrary generators for different test cases
so sharing instances is risky and cumbersome.</p>
</blockquote>
<h3 id="unit-test-files-names-match-their-corresponding-module"><a class="header" href="#unit-test-files-names-match-their-corresponding-module">Unit test files names match their corresponding module</a></h3>
<p>Every module from a library has a corresponding test file, within the same
folder architecture, and, sharing a same name prefix. Test files are postfixed
with 'Spec' to distinguish them from their corresponding sources.</p>
<blockquote>
<p><strong>Why</strong></p>
<p>It is much easier to find the corresponding test to a module if they share
a same name. Also, this gives consistency and a clear pattern for naming
tests in order to avoid chaos.</p>
</blockquote>
<details>
  <summary>See examples</summary>
<pre><code>src/
├── Cardano
│   ├── Environment.hs
│   └── Wallet
│       ├── Binary
│       │   └── HttpBridge.hs
│       ├── Compatibility
│       │   └── HttpBridge.hs
│       ├── Network
│       │   ├── HttpBridge
│       │   │   └── Api.hs
│       │   └── HttpBridge.hs
│       └── Transaction
│           └── HttpBridge.hs
├── Data
│   └── Packfile.hs
└── Servant
    └── Extra
        └── ContentTypes.hs
test/unit/
├── Cardano
│   ├── EnvironmentSpec.hs
│   └── Wallet
│       ├── Binary
│       │   └── HttpBridgeSpec.hs
│       ├── Network
│       │   ├── HttpBridge
│       │   │   └── ApiSpec.hs
│       │   └── HttpBridgeSpec.hs
│       └── Transaction
│           └── HttpBridgeSpec.hs
├── Data
│   └── PackfileSpec.hs
└── Servant
    └── Extra
        └── ContentTypesSpec.hs
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../contributor/what/building.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../contributor/what/logging-guidelines.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../contributor/what/building.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../contributor/what/logging-guidelines.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../mermaid.min.js"></script>
        <script src="../../mermaid-init.js"></script>


    </div>
    </body>
</html>
