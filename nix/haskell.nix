############################################################################
# Builds Haskell packages with Haskell.nix
############################################################################
CHaP: haskell-nix: nixpkgs-recent: nodePkgs: mithrilPkgs: set-git-rev: rewrite-libs: haskell-nix.cabalProject' [
  ({ lib, pkgs, buildProject, ... }: {
    options = {
      gitrev = lib.mkOption {
        type = lib.types.str;
        description = "Git revision of sources";
        default = "0000000000000000000000000000000000000000";
      };
      profiling = lib.mkOption {
        type = lib.types.bool;
        description = "Enable profiling";
        default = false;
      };
      coverage = lib.mkOption {
        type = lib.types.bool;
        description = "Enable Haskell Program Coverage for cardano-wallet libraries and test suites.";
        default = false;
      };
      cacheTestFailures = lib.mkOption {
        type = lib.types.bool;
        description = ''If false, prevent check results from being cached on `nix build`'';
        default = true;
      };

    };
  })
  ({ pkgs
   , lib
   , config
   , buildProject
   , ...
   }:

    let
      inherit (pkgs) stdenv;
      inherit (haskell-nix) haskellLib;

      # Add this string to a tests preCheck to prevent test results from
      # being cached.
      #
      # It is useful to have when your tests are flaky and fail a lot --
      # we don't want to cache false failures.
      noCacheCookie = ''
        # Causes tests to be re-run whenever the git revision
        # changes, even if everything else is identical.
        echo "Git revision is ${toString config.gitrev}"
      '';

      noCacheTestFailuresCookie = lib.optionalString (!config.cacheTestFailures) noCacheCookie;

      # setGitRev is a postInstall script to stamp executables with
      # version info. It uses the "gitrev" option.
      setGitRevPostInstall = ''
         ${set-git-rev}/bin/set-git-rev "${config.gitrev}" $out/bin/*
        '';

      rewriteLibsPostInstall = lib.optionalString (pkgs.stdenv.hostPlatform.isDarwin) ''
        export PATH=$PATH:${lib.makeBinPath (with pkgs.buildPackages; [ binutils nix ])}
        ${rewrite-libs}/bin/rewrite-libs $out/bin $out/bin/*
      '';

      stripBinariesPostInstall = lib.optionalString stdenv.hostPlatform.isLinux ''
        ${pkgs.buildPackages.binutils-unwrapped}/bin/*strip $out/bin/*
      '';

      # This exe component postInstall script adds shell completion
      # scripts. These completion
      # scripts will be picked up automatically if the resulting
      # derivation is installed, e.g. by `nix-env -i`.
      optparseCompletionPostInstall = lib.optionalString stdenv.hostPlatform.isUnix ''
        exeName=$(ls -1 $out/bin | head -n1)  # FIXME add $exeName to Haskell.nix
        bashCompDir="$out/share/bash-completion/completions"
        zshCompDir="$out/share/zsh/vendor-completions"
        fishCompDir="$out/share/fish/vendor_completions.d"
        mkdir -p "$bashCompDir" "$zshCompDir" "$fishCompDir"
        "$out/bin/$exeName" --bash-completion-script "$exeName" >"$bashCompDir/$exeName"
        "$out/bin/$exeName" --zsh-completion-script "$exeName" >"$zshCompDir/_$exeName"
        "$out/bin/$exeName" --fish-completion-script "$exeName" >"$fishCompDir/$exeName.fish"
      '';

      # The list of project packages is not automatically discovered yet,
      # instead it is generated by ./nix/regenerate.sh
      projectPackages = import ./project-package-list.nix;

      srcAll = lib.cleanSourceWith {
        name = "cardano-wallet-src-all";
        src = ../.;
        filter = lib.cleanSourceFilter;
      };

      # this is a local variable, it controls only the index-state of the
      # tools
      indexState = "2026-01-20T00:00:00Z";

      localClusterConfigs = config.src + /lib/local-cluster/test/data/cluster-configs;

    in {
      name = "cardano-wallet";
      compiler-nix-name = "ghc9122";

      src = haskellLib.cleanSourceWith {
        name = "cardano-wallet-src";
        src = srcAll;
        filter = haskell-nix.haskellSourceFilter;
      };

      shell = {
        name = "cardano-wallet-shell${lib.optionalString config.profiling "-profiled"}";
        packages = ps: builtins.attrValues (haskellLib.selectProjectPackages ps);
        tools = {
          cabal = { index-state = indexState; };
          # cabal-fmt doesn't support base-4.20 (GHC 9.10) yet
          # cabal-fmt = { index-state = indexState; };
          haskell-language-server = {
            index-state = indexState;
            version = "latest";
            # Patch ghc-lib-parser genSym.c: atomic_inc64 → atomic_inc
            # (upstream bug in 9.8.5.20250214)
            modules = [{
              packages.ghc-lib-parser.postPatch = ''
                if [ -f compiler/cbits/genSym.c ] \
                    && grep -q 'atomic_inc64' compiler/cbits/genSym.c; then
                  substituteInPlace compiler/cbits/genSym.c \
                    --replace-fail 'atomic_inc64' 'atomic_inc'
                fi
              '';
            }];
          };
          hoogle = {
            index-state = indexState;
            version = "latest";
          };
        };
        withHoogle = true;
        nativeBuildInputs = (with buildProject.hsPkgs; [
          # Wrap cardano-cli/node to only expose binaries, not Haskell libraries
          # This prevents GHC package database pollution with conflicting versions
          (pkgs.runCommand "cardano-cli-bin" {} ''
            mkdir -p $out/bin
            ln -s ${nodePkgs.cardano-cli}/bin/cardano-cli $out/bin/
          '')
          (pkgs.runCommand "cardano-node-bin" {} ''
            mkdir -p $out/bin
            ln -s ${nodePkgs.cardano-node}/bin/cardano-node $out/bin/
          '')
          cardano-addresses.components.exes.cardano-address
          bech32.components.exes.bech32
        ]) ++ (with pkgs.buildPackages.buildPackages; [
          just
          pkg-config
          nixpkgs-recent.python3Packages.openapi-spec-validator
          (ruby_3_1.withPackages (ps: [ ps.rake ps.thor ]))
          rubyPackages_3_1.rubocop
          sqlite-interactive
          curlFull
          jq
          yq
          mdbook
          haskellPackages.ghcid
          haskellPackages.hp2pretty
          haskellPackages.lentil
          haskellPackages.markdown-unlit
          haskellPackages.pretty-simple
          haskellPackages.weeder
          mithrilPkgs.mithril-client-cli
        ]) ++ [
          # These tools depend on ghc-lib-parser which needs patching.
          # Pull from top-level pkgs where the ghc-lib-parser overlay applies,
          # rather than buildPackages.buildPackages where it doesn't propagate.
          pkgs.haskellPackages.fourmolu
          pkgs.haskellPackages.hlint
          pkgs.haskellPackages.stylish-haskell
        ];
        shellHook = "export LOCAL_CLUSTER_CONFIGS=${localClusterConfigs}";
      };

      inputMap = { "https://chap.intersectmbo.org/" = CHaP; };

      modules =
        let inherit (config) src coverage profiling;
        in
        [
          {
            packages = lib.genAttrs projectPackages (name: {
              # Enable release flag (optimization and -Werror)
              flags.release = true;

              # Enable Haskell Program Coverage for all local libraries
              # and test suites.
              doCoverage = coverage;

              # GHC 9.12: suppress 'deriving Typeable' warning (all types
              # auto-derive Typeable, making explicit deriving redundant).
              ghcOptions = [ "-Wno-deriving-typeable" ];
            });
          }

          # Provide configuration and dependencies to cardano-wallet components
          ({ config, pkgs, ... }:
            let
              cardanoNodeExes = [ nodePkgs.cardano-cli nodePkgs.cardano-node ];
            in
            {
              reinstallableLibGhc = true;

              packages.cardano-wallet-unit.components.tests = {
                unit.build-tools = cardanoNodeExes;
                unit.preCheck = noCacheTestFailuresCookie + ''
                    export LOCAL_CLUSTER_CONFIGS=${localClusterConfigs}
                  '' + lib.optionalString stdenv.isDarwin ''
                    # cardano-node socket path becomes too long otherwise
                    export TMPDIR=/tmp
                  '';
                  };

              packages.cardano-wallet-integration.components.tests = {
                # NOTE:
                # We are concerned with building integration test executables here,
                # but we are no longer concerned with *running* the integration
                # tests as part of building a nix derivation.
                #
                # provide cardano-node & cardano-cli to tests
                integration.build-tools = cardanoNodeExes;
              };

              # Add node backend to the PATH of the latency benchmarks, and
              # set the source tree as its working directory.
              packages.cardano-wallet-benchmarks.components.benchmarks.latency =
                lib.optionalAttrs (!stdenv.hostPlatform.isWindows) {
                  build-tools = [ pkgs.buildPackages.makeWrapper ];
                  postInstall = ''
                    wrapProgram $out/bin/* \
                      --run "cd ${srcAll}/lib/wallet" \
                      --add-flags --cluster-configs="${localClusterConfigs}" \
                      --prefix PATH : ${lib.makeBinPath cardanoNodeExes}
                  '';
                };

              # Add cardano-node to the PATH of the byroon restore benchmark.
              # cardano-node will want to write logs to a subdirectory of the working directory.
              # We don't `cd $src` because of that.
              packages.cardano-wallet-benchmarks.components.benchmarks.restore =
                lib.optionalAttrs (!stdenv.hostPlatform.isWindows) {
                  build-tools = [ pkgs.buildPackages.makeWrapper ];
                  postInstall = ''
                    wrapProgram $out/bin/restore \
                      --set CARDANO_NODE_CONFIGS ${pkgs.cardano-node-deployments} \
                      --prefix PATH : ${lib.makeBinPath cardanoNodeExes}
                  '';
                };

              packages.cardano-wallet.components.exes.local-cluster = {
                  build-tools = [ pkgs.buildPackages.makeWrapper ];
                  postInstall = ''
                    wrapProgram $out/bin/* \
                      --add-flags --cluster-configs="${localClusterConfigs}" \
                      --prefix PATH : ${lib.makeBinPath cardanoNodeExes}
                  '';
                };

              # Add shell completions for main executables.
              packages.cardano-wallet-application.components.exes.cardano-wallet.postInstall = optparseCompletionPostInstall + rewriteLibsPostInstall + stripBinariesPostInstall;
              packages.cardano-wallet.components.exes.cardano-wallet.postInstall = optparseCompletionPostInstall + rewriteLibsPostInstall + stripBinariesPostInstall;
            })

          # Provide the swagger file in an environment variable for
          # tests because it is located outside of the Cabal package
          # source tree.
          {
            packages.cardano-wallet-unit.components.tests.unit.preBuild = ''
              export SWAGGER_YAML=${src + /specifications/api/swagger.yaml}
            '';
          }

          ({ lib, pkgs, ... }: {
            # Use our forked libsodium from iohk-nix crypto overlay.
            packages.plutus-tx.components.library.pkgconfig = lib.mkForce [ [ pkgs.libsodium-vrf pkgs.secp256k1 ] ];
            packages.byron-spec-ledger.components.library.pkgconfig = lib.mkForce [ [ pkgs.libsodium-vrf pkgs.secp256k1 ] ];
            packages.cardano-crypto-praos.components.library.pkgconfig = lib.mkForce [ [ pkgs.libsodium-vrf pkgs.secp256k1 ] ];
            packages.cardano-crypto-class.components.library.pkgconfig = lib.mkForce [ [ pkgs.libsodium-vrf pkgs.secp256k1 pkgs.libblst ] ];
          })

          # Windows cross-compilation fixes (from cardano-node)
          ({ lib, pkgs, ... }: lib.mkIf pkgs.stdenv.hostPlatform.isWindows {
            packages.unix-compat.postPatch = ''
              sed -i 's/msvcrt//g' unix-compat.cabal
            '';
            packages.unix-time.postPatch = ''
              sed -i 's/mingwex//g' unix-time.cabal
            '';
            # haskell.nix patch for crypton-x509-system is outdated for 1.8.0
            # Clear their patch and apply the fix via postPatch
            packages.crypton-x509-system.patches = lib.mkForce [];
            packages.crypton-x509-system.postPatch = ''
              sed -i 's/Crypt32/crypt32/g' crypton-x509-system.cabal
            '';
            # haskell.nix patch for streaming-commons is already applied in 0.2.3.1
            packages.streaming-commons.patches = lib.mkForce [];
            # fgl's {-# ANN #-} pragmas trigger TH evaluation via iserv-proxy
            # which crashes during Windows cross-compilation
            packages.fgl.postPatch = ''
              sed -i '/ANN.*HLint/d' Data/Graph/Inductive/Monad.hs
              sed -i '/ANN.*HLint/d' Data/Graph/Inductive/Query/Dominators.hs
            '';
            # cardano-addresses' System.Git.TH uses a TH splice that embeds
            # a string literal, triggering a GHC 9.10 ByteCode.Asm panic
            # (mallocStrings:spliceLit) during cross-compilation.
            # Replace the TH splice with a plain string.
            packages.cardano-addresses.postPatch = ''
              cat > lib/System/Git/TH.hs << 'PATCH'
{-# OPTIONS_HADDOCK hide #-}
module System.Git.TH (gitRevParseHEAD) where
import Prelude
import Language.Haskell.TH (Exp (..), Lit (..), Q)
gitRevParseHEAD :: Q Exp
gitRevParseHEAD = pure (LitE (StringL "cross-compiled"))
PATCH
            '';
            # iserv-proxy (used for TH during cross-compilation) does not
            # support parallel module compilation — the protocol is strictly
            # synchronous.  Force -j1 globally for Windows builds.
            ghcOptions = [ "-j1" ];
          })

          # Build fixes for library dependencies
          {
            # Packages we wish to ignore version bounds of.
            # This is similar to jailbreakCabal, however it
            # does not require any messing with cabal files.
            packages.katip.doExactConfig = true;

            # Lets us put the pretty-simple tool in shell.nix.
            packages.pretty-simple.flags.buildexe = true;
          }

          # Enable profiling on executables if the profiling argument is set.
          (lib.optionalAttrs profiling {
            enableLibraryProfiling = true;
            packages.cardano-wallet-application.components.exes.cardano-wallet.enableProfiling = true;
            packages.cardano-wallet-benchmarks.components.benchmarks.restore.enableProfiling = true;
            packages.plutus-core.ghcOptions = [ "-fexternal-interpreter" ];
          })

          # Musl libc fully static build
          (lib.optionalAttrs stdenv.hostPlatform.isMusl (
            let
              staticLibs = with pkgs; [ zlib openssl libffi gmp6 pkgs.secp256k1 ];

              # Module options which add GHC flags and libraries for a fully static build
              fullyStaticOptions = {
                enableShared = false;
                enableStatic = true;
                configureFlags = map (drv: "--ghc-option=-optl=-L${drv}/lib") staticLibs;
              };
            in
            {
              # Apply fully static options to our Haskell executables
              packages.cardano-wallet-benchmarks.components.benchmarks.restore = fullyStaticOptions;
              packages.cardano-wallet-application.components.exes.cardano-wallet = fullyStaticOptions;
              packages.cardano-wallet-integration.components.tests.integration = fullyStaticOptions;
              packages.cardano-wallet-unit.components.tests.unit = fullyStaticOptions;
              packages.cardano-wallet-benchmarks.components.benchmarks.db = fullyStaticOptions;
              packages.cardano-wallet-launcher.components.tests.unit = fullyStaticOptions;
              packages.cardano-wallet-application-tls.components.tests.unit = fullyStaticOptions;

              # Haddock not working for cross builds and is not needed anyway
              doHaddock = false;
            }
          ))

          # Silence some warnings about "cleaning component source not
          # supported for hpack package" which appear in nix-shell
          {
            packages.cardano-addresses.cabal-generator = lib.mkForce null;
          }

        ];
    })
]
