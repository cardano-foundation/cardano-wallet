-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Core integration test library.
--   
--   Shared core functionality for our integration test suites.
@package cardano-wallet-core-integration
@version 2019.6.24

module Test.Integration.Faucet

-- | An opaque <a>Faucet</a> type from which one can get a wallet with
--   funds
newtype Faucet
Faucet :: MVar [Mnemonic 15] -> Faucet

-- | Get the next faucet wallet. Requires the <tt>initFaucet</tt> to be
--   called in order to get a hand on a <a>Faucet</a>.
nextWallet :: Faucet -> IO (Mnemonic 15)

module Test.Integration.Framework.Request

-- | Makes a request to the API and decodes the response.
request :: forall a m s. (FromJSON a, MonadIO m, MonadCatch m, HasType (Text, Manager) s) => s -> (Method, Text) -> Headers -> Payload -> m (Status, Either RequestException a)

-- | Makes a request to the API, but throws if it fails.
unsafeRequest :: forall a m t. (FromJSON a, MonadIO m, MonadCatch m) => Context t -> (Method, Text) -> Payload -> m (Status, a)

-- | The headers of the request
data Headers
Headers :: RequestHeaders -> Headers
Default :: Headers
None :: Headers

-- | The payload of the request
data Payload
Json :: Value -> Payload
NonJson :: ByteString -> Payload
Empty :: Payload

-- | The result when <a>request</a> fails.
data RequestException

-- | JSON decoding the given response data failed.
DecodeFailure :: ByteString -> RequestException

-- | The HTTP response status code indicated failure.
ClientError :: Value -> RequestException

-- | A wild exception upon sending the request
HttpException :: HttpExceptionContent -> RequestException

-- | Running Context for our integration test
data Context t
Context :: IO () -> (Text, Manager) -> Port "wallet" -> Port "node" -> Faucet -> (TxDescription -> (Natural, Natural)) -> Proxy t -> Context t

-- | An action to clean up open processes after tests
[_cleanup] :: Context t -> IO ()

-- | The underlying BaseUrl and Manager used by the Wallet Client
[_manager] :: Context t -> (Text, Manager)

-- | Server TCP port
[_walletPort] :: Context t -> Port "wallet"

-- | Jormungandr REST API port
[_nodePort] :: Context t -> Port "node"

-- | A <a>Faucet</a> handle in to have access to funded wallets in
--   integration tests.
[_faucet] :: Context t -> Faucet

-- | A fee estimator for the integration tests
[_feeEstimator] :: Context t -> TxDescription -> (Natural, Natural)
[_target] :: Context t -> Proxy t

-- | Describe a transaction in terms of its inputs and outputs
data TxDescription
TxDescription :: Int -> Int -> TxDescription
[nInputs] :: TxDescription -> Int
[nOutputs] :: TxDescription -> Int
instance GHC.Show.Show Test.Integration.Framework.Request.Headers
instance GHC.Show.Show Test.Integration.Framework.Request.Payload
instance GHC.Show.Show Test.Integration.Framework.Request.RequestException
instance GHC.Generics.Generic (Test.Integration.Framework.Request.Context t)
instance GHC.Show.Show Test.Integration.Framework.Request.TxDescription
instance GHC.Exception.Type.Exception Test.Integration.Framework.Request.RequestException

module Test.Integration.Framework.DSL

-- | Running Context for our integration test
data Context t
Context :: IO () -> (Text, Manager) -> Port "wallet" -> Port "node" -> Faucet -> (TxDescription -> (Natural, Natural)) -> Proxy t -> Context t

-- | An action to clean up open processes after tests
[_cleanup] :: Context t -> IO ()

-- | The underlying BaseUrl and Manager used by the Wallet Client
[_manager] :: Context t -> (Text, Manager)

-- | Server TCP port
[_walletPort] :: Context t -> Port "wallet"

-- | Jormungandr REST API port
[_nodePort] :: Context t -> Port "node"

-- | A <a>Faucet</a> handle in to have access to funded wallets in
--   integration tests.
[_faucet] :: Context t -> Faucet

-- | A fee estimator for the integration tests
[_feeEstimator] :: Context t -> TxDescription -> (Natural, Natural)
[_target] :: Context t -> Proxy t

-- | A class to select the right command for a given 'Context t'
class KnownCommand t
commandName :: KnownCommand t => String

-- | Describe a transaction in terms of its inputs and outputs
data TxDescription
TxDescription :: Int -> Int -> TxDescription
[nInputs] :: TxDescription -> Int
[nOutputs] :: TxDescription -> Int

-- | Makes a request to the API and decodes the response.
request :: forall a m s. (FromJSON a, MonadIO m, MonadCatch m, HasType (Text, Manager) s) => s -> (Method, Text) -> Headers -> Payload -> m (Status, Either RequestException a)

-- | Makes a request to the API, but throws if it fails.
unsafeRequest :: forall a m t. (FromJSON a, MonadIO m, MonadCatch m) => Context t -> (Method, Text) -> Payload -> m (Status, a)

-- | A file is eventually created on the given location
expectPathEventuallyExist :: FilePath -> IO ()

-- | Expect a successful response, without any further assumptions
expectSuccess :: (MonadIO m, MonadFail m) => (s, Either RequestException a) -> m ()

-- | Expect an errored response, without any further assumptions
expectError :: (MonadIO m, MonadFail m, Show a) => (s, Either RequestException a) -> m ()

-- | Expect an errored response, without any further assumptions
expectErrorMessage :: (MonadIO m, MonadFail m, Show a) => String -> (s, Either RequestException a) -> m ()
expectFieldEqual :: (MonadIO m, MonadFail m, Show a, Eq a) => Lens' s a -> a -> (Status, Either RequestException s) -> m ()
expectFieldNotEqual :: (MonadIO m, MonadFail m, Show a, Eq a) => Lens' s a -> a -> (Status, Either RequestException s) -> m ()
expectFieldBetween :: (MonadIO m, MonadFail m, Show a, Ord a) => Lens' s a -> (a, a) -> (Status, Either RequestException s) -> m ()
expectListItemFieldBetween :: (MonadIO m, MonadFail m, Show a, Eq a, Ord a) => Int -> Lens' s a -> (a, a) -> (Status, Either RequestException [s]) -> m ()

-- | Expects that returned data list's particular item field matches the
--   expected value e.g. expectListItemFieldEqual 0 walletName "first"
--   response expectListItemFieldEqual 1 walletName "second" response
expectListItemFieldEqual :: (MonadIO m, MonadFail m, Show a, Eq a) => Int -> Lens' s a -> a -> (Status, Either RequestException [s]) -> m ()

-- | Expects data list returned by the API to be of certain length
expectListSizeEqual :: (MonadIO m, MonadFail m, Foldable xs) => Int -> (Status, Either RequestException (xs a)) -> m ()

-- | Expect a given response code on the response
expectResponseCode :: MonadIO m => Status -> (Status, a) -> m ()

-- | Expects wallet from the request to eventually reach the given state or
--   beyond
expectEventually :: (MonadIO m, MonadCatch m, MonadFail m) => (Ord a, Show a) => HasType (Text, Manager) ctx => ctx -> Lens' ApiWallet a -> a -> (Status, Either RequestException ApiWallet) -> m ()

-- | Same as <a>expectEventually</a> but work directly on ApiWallet , not
--   response from the API
expectEventually' :: (MonadIO m, MonadCatch m, MonadFail m) => (Ord a, Show a) => HasType (Text, Manager) ctx => ctx -> Lens' ApiWallet a -> a -> ApiWallet -> m ()

-- | Expects a given string to be a valid JSON output corresponding to some
--   given data-type <tt>a</tt>. Returns this type if successful.
expectValidJSON :: forall m a. (MonadFail m, FromJSON a) => Proxy a -> String -> m a
expectCliFieldBetween :: (MonadIO m, MonadFail m, Show a, Ord a) => Lens' s a -> (a, a) -> s -> m ()
expectCliFieldEqual :: (MonadIO m, Show a, Eq a) => Lens' s a -> a -> s -> m ()
expectCliFieldNotEqual :: (MonadIO m, Show a, Eq a) => Lens' s a -> a -> s -> m ()
expectCliListItemFieldBetween :: (MonadIO m, MonadFail m, Show a, Eq a, Ord a) => Int -> Lens' s a -> (a, a) -> [s] -> m ()

-- | Same as <a>expectListItemFieldEqual</a> but for CLI
expectCliListItemFieldEqual :: (MonadIO m, MonadFail m, Show a, Eq a) => Int -> Lens' s a -> a -> [s] -> m ()

-- | Expects wallet UTxO statistics from the request to be equal to
--   pre-calculated
expectWalletUTxO :: (MonadIO m, MonadFail m) => [Word64] -> Either RequestException ApiUtxoStatistics -> m ()

-- | Apply <tt>a</tt> to all actions in sequence
verify :: Monad m => a -> [a -> m ()] -> m ()

-- | The headers of the request
data Headers
Headers :: RequestHeaders -> Headers
Default :: Headers
None :: Headers

-- | The payload of the request
data Payload
Json :: Value -> Payload
NonJson :: ByteString -> Payload
Empty :: Payload

-- | The result when <a>request</a> fails.
data RequestException

-- | JSON decoding the given response data failed.
DecodeFailure :: ByteString -> RequestException

-- | The HTTP response status code indicated failure.
ClientError :: Value -> RequestException

-- | A wild exception upon sending the request
HttpException :: HttpExceptionContent -> RequestException
addressPoolGap :: HasType (ApiT AddressPoolGap) s => Lens' s Int
amount :: HasType (Quantity "lovelace" Natural) s => Lens' s Natural
balanceAvailable :: HasType (ApiT WalletBalance) s => Lens' s Natural
balanceTotal :: HasType (ApiT WalletBalance) s => Lens' s Natural
delegation :: HasType (ApiT (WalletDelegation (ApiT PoolId))) s => Lens' s (WalletDelegation (ApiT PoolId))
direction :: HasType (ApiT Direction) s => Lens' s Direction
feeEstimator :: Lens' (Context t) (TxDescription -> (Natural, Natural))
inputs :: HasType [ApiTxInput t] s => Lens' s [ApiTxInput t]
passphraseLastUpdate :: HasType (Maybe (ApiT WalletPassphraseInfo)) s => Lens' s (Maybe Text)
state :: HasField' "state" s (ApiT t) => Lens' s t
status :: HasType (ApiT TxStatus) s => Lens' s TxStatus
outputs :: HasType (NonEmpty (AddressAmount t)) s => Lens' s [AddressAmount t]
walletId :: HasType (ApiT WalletId) s => Lens' s Text
walletName :: HasType (ApiT WalletName) s => Lens' s Text
(</>) :: ToHttpApiData a => Text -> a -> Text
infixr 5 </>

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: () => [a] -> Int -> a
infixl 9 !!

-- | Create an empty wallet
emptyWallet :: Context t -> IO ApiWallet

-- | Create an empty wallet
emptyWalletWith :: Context t -> (Text, Text, Int) -> IO ApiWallet
getFromResponse :: Lens' s a -> (Status, Either RequestException s) -> a
getFromResponseList :: Int -> Lens' s a -> (Status, Either RequestException [s]) -> a
getJormungandrBlock0H :: IO String
json :: QuasiQuoter
listAddresses :: forall t. DecodeAddress t => Context t -> ApiWallet -> IO [ApiAddress t]
listTransactions :: forall t. DecodeAddress t => Context t -> ApiWallet -> Maybe UTCTime -> Maybe UTCTime -> Maybe SortOrder -> IO [ApiTransaction t]
listAllTransactions :: forall t. DecodeAddress t => Context t -> ApiWallet -> IO [ApiTransaction t]

-- | teardown after each test (currently only deleting all wallets)
tearDown :: Context t -> IO ()

-- | Restore a faucet and wait until funds are available.
fixtureWallet :: Context t -> IO ApiWallet

-- | Restore a wallet with the given UTxO distribution. Note that there's a
--   limitation to what can be done here. We only have 10 UTxO available in
--   each faucet and they "only" have 'faucetUtxoAmt = 100_000 Ada' in
--   each.
--   
--   This function makes no attempt at ensuring the request is valid, so be
--   careful.
fixtureWalletWith :: forall t. (EncodeAddress t, DecodeAddress t) => Context t -> [Natural] -> IO ApiWallet

-- | Total amount on each faucet wallet
faucetAmt :: Natural

-- | Each faucet wallet is composed of 10 times a single faucet UTxO of
--   100_000 Ada.
faucetUtxoAmt :: Natural
proc' :: FilePath -> [String] -> CreateProcess

-- | Wait for a booting wallet server to start. Wait up to 30s or fail.
waitForServer :: forall t ctx. (HasType (Port "wallet") ctx, KnownCommand t) => ctx -> IO ()

-- | Collect lines from standard output and error streams for 30 seconds,
--   or, until a given limit is for both streams.
collectStreams :: (Int, Int) -> CreateProcess -> IO (Text, Text)

-- | Like <a>shouldContain</a>, but with <a>Text</a>
shouldContainT :: Text -> Text -> IO ()

-- | Like <a>shouldNotContain</a>, but with <a>Text</a>
shouldNotContainT :: Text -> Text -> IO ()

-- | <a>map</a> flipped.
for :: [a] -> (a -> b) -> [b]
toQueryString :: [(Text, Text)] -> Text
utcIso8601ToText :: UTCTime -> Text

-- | Prepare externally signed Tx for Jormungandr
prepExternalTxViaJcli :: Port "node" -> Text -> Natural -> IO Text
getWalletEp :: ApiWallet -> (Method, Text)
deleteWalletEp :: ApiWallet -> (Method, Text)
getWalletUtxoEp :: ApiWallet -> (Method, Text)
getAddressesEp :: ApiWallet -> Text -> (Method, Text)
postTxEp :: ApiWallet -> (Method, Text)
postExternalTxEp :: (Method, Text)
postTxFeeEp :: ApiWallet -> (Method, Text)
listTxEp :: ApiWallet -> Text -> (Method, Text)
updateWalletPassEp :: ApiWallet -> (Method, Text)
runJcli :: CmdResult r => [String] -> IO r
command :: CmdResult r => [CmdOption] -> String -> [String] -> IO r

-- | Run a command using the 'cardano-wallet' executable. We run it through
--   stack as we intend to also get code-coverage from running these
--   commands!
cardanoWalletCLI :: forall t r. (CmdResult r, KnownCommand t) => [String] -> IO r
generateMnemonicsViaCLI :: forall t r. (CmdResult r, KnownCommand t) => [String] -> IO r
createWalletViaCLI :: forall t s. (HasType (Port "wallet") s, KnownCommand t) => s -> [String] -> String -> String -> String -> IO (ExitCode, String, Text)
deleteWalletViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> String -> IO r
getWalletUtxoStatisticsViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> String -> IO r
getWalletViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> String -> IO r
listAddressesViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> [String] -> IO r
listWalletsViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> IO r
updateWalletNameViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> [String] -> IO r
updateWalletPassphraseViaCLI :: forall t s. (KnownCommand t, HasType (Port "wallet") s) => s -> String -> String -> String -> String -> IO (ExitCode, Text, Text)
postTransactionViaCLI :: forall t s. (HasType (Port "wallet") s, KnownCommand t) => s -> String -> [String] -> IO (ExitCode, String, Text)
postTransactionFeeViaCLI :: forall t s. (HasType (Port "wallet") s, KnownCommand t) => s -> [String] -> IO (ExitCode, String, Text)
listTransactionsViaCLI :: forall t r s. (CmdResult r, HasType (Port "wallet") s, KnownCommand t) => s -> [String] -> IO r
postExternalTransactionViaCLI :: forall t r s. (CmdResult r, HasType (Port "wallet") s, KnownCommand t) => s -> [String] -> IO r

module Test.Integration.Framework.TestData
chineseMnemonics9 :: [Text]
chineseMnemonics18 :: [Text]
frenchMnemonics12 :: [Text]
frenchMnemonics21 :: [Text]
invalidMnemonics12 :: [Text]
invalidMnemonics15 :: [Text]
japaneseMnemonics12 :: [Text]
japaneseMnemonics15 :: [Text]
mnemonics3 :: [Text]
mnemonics6 :: [Text]
mnemonics9 :: [Text]
mnemonics12 :: [Text]
mnemonics15 :: [Text]
mnemonics18 :: [Text]
mnemonics21 :: [Text]
mnemonics24 :: [Text]
specMnemonicSentence :: [Text]
specMnemonicSecondFactor :: [Text]
arabicWalletName :: Text
falseWalletIds :: [(String, String)]
kanjiWalletName :: Text
polishWalletName :: Text
russianWalletName :: Text
wildcardsWalletName :: Text
addressPoolGapMax :: Int
addressPoolGapMin :: Int
cmdOk :: String
versionLine :: Text
passphraseMaxLength :: Int
passphraseMinLength :: Int
payloadWith :: Text -> [Text] -> Payload
simplePayload :: Payload
updateNamePayload :: Text -> Payload
updatePassPayload :: Text -> Text -> Payload
errMsgWalletIdEncoding :: String
errMsg400StartTimeLaterThanEndTime :: String -> String -> String
errMsg403Fee :: String
errMsg403NotEnoughMoney :: Int -> Int -> String
errMsg403UTxO :: String
errMsg403WrongPass :: String
errMsg404NoEndpoint :: String
errMsg404NoRootKey :: Text -> String
errMsg404NoWallet :: Text -> String
errMsg403InputsDepleted :: String
errMsg403TxTooBig :: Int -> String
errMsg400MalformedTxPayload :: String
errMsg400WronglyEncodedTxPayload :: String
errMsg403ZeroAmtOutput :: String
errMsg405 :: String
errMsg406 :: String
errMsg415 :: String
errMsg500 :: String

module Test.Integration.Scenario.API.Addresses
spec :: forall t. (DecodeAddress t, EncodeAddress t) => SpecWith (Context t)

module Test.Integration.Scenario.API.Transactions
spec :: forall t. (EncodeAddress t, DecodeAddress t) => SpecWith (Context t)

module Test.Integration.Scenario.API.Wallets
spec :: forall t. (EncodeAddress t, DecodeAddress t) => SpecWith (Context t)

module Test.Integration.Scenario.CLI.Addresses
spec :: forall t. (EncodeAddress t, DecodeAddress t, KnownCommand t) => SpecWith (Context t)

module Test.Integration.Scenario.CLI.Miscellaneous
spec :: forall t. KnownCommand t => SpecWith ()

module Test.Integration.Scenario.CLI.Mnemonics
spec :: forall t. KnownCommand t => SpecWith ()

module Test.Integration.Scenario.CLI.Port
specNegative :: forall t. KnownCommand t => SpecWith ()
specCommon :: forall t s. (HasType (Port "wallet") s, KnownCommand t) => SpecWith s
specWithDefaultPort :: forall t s. (HasType (Port "wallet") s, KnownCommand t) => SpecWith s
specWithRandomPort :: forall t s. (HasType (Port "wallet") s, KnownCommand t) => Port "wallet" -> SpecWith s

module Test.Integration.Scenario.CLI.Transactions
spec :: forall t. (EncodeAddress t, DecodeAddress t, KnownCommand t) => SpecWith (Context t)

module Test.Integration.Scenario.CLI.Wallets
spec :: forall t. (EncodeAddress t, DecodeAddress t, KnownCommand t) => SpecWith (Context t)
