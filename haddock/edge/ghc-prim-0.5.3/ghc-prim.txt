-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | GHC primitives
--   
--   This package contains the primitive types and operations supplied by
--   GHC.
@package ghc-prim
@version 0.5.3


-- | GHC type definitions. Use GHC.Exts from the base package instead of
--   importing this module directly.
module GHC.Types
data {-# CTYPE "HsBool" #-} Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data {-# CTYPE "HsChar" #-} Char
C# :: Char# -> Char

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data {-# CTYPE "HsInt" #-} Int
I# :: Int# -> Int

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data {-# CTYPE "HsWord" #-} Word
W# :: Word# -> Word

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data {-# CTYPE "HsFloat" #-} Float
F# :: Float# -> Float

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data {-# CTYPE "HsDouble" #-} Double
D# :: Double# -> Double
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
newtype IO a
IO :: (State# RealWorld -> (# State# RealWorld, a #)) -> IO a

-- | Alias for <a>tagToEnum#</a>. Returns True if its parameter is 1# and
--   False if it is 0#.
isTrue# :: Int# -> Bool

-- | <a>SPEC</a> is used by GHC in the <tt>SpecConstr</tt> pass in order to
--   inform the compiler when to be particularly aggressive. In particular,
--   it tells GHC to specialize regardless of size or the number of
--   specializations. However, not all loops fall into this category.
--   
--   Libraries can specify this by using <a>SPEC</a> data type to inform
--   which loops should be aggressively specialized.
data SPEC
SPEC :: SPEC
SPEC2 :: SPEC

-- | (Kind) This is the kind of type-level natural numbers.
data Nat

-- | (Kind) This is the kind of type-level symbols. Declared here because
--   class IP needs it
data Symbol

-- | The type constructor <a>Any</a> is type to which you can unsafely
--   coerce any lifted type, and back. More concretely, for a lifted type
--   <tt>t</tt> and value <tt>x :: t</tt>, -- <tt>unsafeCoerce
--   (unsafeCoerce x :: Any) :: t</tt> is equivalent to <tt>x</tt>.
type family Any :: k

-- | Lifted, heterogeneous equality. By lifted, we mean that it can be
--   bogus (deferred type error). By heterogeneous, the two types
--   <tt>a</tt> and <tt>b</tt> might have different kinds. Because
--   <tt>~~</tt> can appear unexpectedly in error messages to users who do
--   not care about the difference between heterogeneous equality
--   <tt>~~</tt> and homogeneous equality <tt>~</tt>, this is printed as
--   <tt>~</tt> unless <tt>-fprint-equality-relations</tt> is set.
class a ~~ b

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class Coercible a b
data TYPE (a :: RuntimeRep) :: RuntimeRep -> Type

-- | GHC maintains a property that the kind of all inhabited types (as
--   distinct from type constructors or type-level data) tells us the
--   runtime representation of values of that type. This datatype encodes
--   the choice of runtime value. Note that <a>TYPE</a> is parameterised by
--   <a>RuntimeRep</a>; this is precisely what we mean by the fact that a
--   type's kind encodes the runtime representation.
--   
--   For boxed values (that is, values that are represented by a pointer),
--   a further distinction is made, between lifted types (that contain âŠ¥),
--   and unlifted ones (that don't).
data RuntimeRep

-- | a SIMD vector type
VecRep :: VecCount -> VecElem -> RuntimeRep

-- | An unboxed tuple of the given reps
TupleRep :: [RuntimeRep] -> RuntimeRep

-- | An unboxed sum of the given reps
SumRep :: [RuntimeRep] -> RuntimeRep

-- | lifted; represented by a pointer
LiftedRep :: RuntimeRep

-- | unlifted; represented by a pointer
UnliftedRep :: RuntimeRep

-- | signed, word-sized value
IntRep :: RuntimeRep

-- | unsigned, word-sized value
WordRep :: RuntimeRep

-- | signed, 64-bit value (on 32-bit only)
Int64Rep :: RuntimeRep

-- | unsigned, 64-bit value (on 32-bit only)
Word64Rep :: RuntimeRep

-- | A pointer, but <i>not</i> to a Haskell value
AddrRep :: RuntimeRep

-- | a 32-bit floating point number
FloatRep :: RuntimeRep

-- | a 64-bit floating point number
DoubleRep :: RuntimeRep

-- | The kind of types with values. For example <tt>Int :: Type</tt>.
type Type = TYPE  'LiftedRep

-- | The kind of constraints, like <tt>Show a</tt>
data Constraint

-- | Length of a SIMD vector type
data VecCount
Vec2 :: VecCount
Vec4 :: VecCount
Vec8 :: VecCount
Vec16 :: VecCount
Vec32 :: VecCount
Vec64 :: VecCount

-- | Element of a SIMD vector type
data VecElem
Int8ElemRep :: VecElem
Int16ElemRep :: VecElem
Int32ElemRep :: VecElem
Int64ElemRep :: VecElem
Word8ElemRep :: VecElem
Word16ElemRep :: VecElem
Word32ElemRep :: VecElem
Word64ElemRep :: VecElem
FloatElemRep :: VecElem
DoubleElemRep :: VecElem
data Module
Module :: TrName -> TrName -> Module
data TrName
TrNameS :: Addr# -> TrName
TrNameD :: [Char] -> TrName
data TyCon
TyCon :: Word# -> Word# -> Module -> TrName -> Int# -> KindRep -> TyCon
data TypeLitSort
TypeLitSymbol :: TypeLitSort
TypeLitNat :: TypeLitSort

-- | The representation produced by GHC for conjuring up the kind of a
--   <tt>TypeRep</tt>. See Note [Representing TyCon kinds: KindRep] in
--   TcTypeable.
data KindRep
KindRepTyConApp :: TyCon -> [KindRep] -> KindRep
KindRepVar :: !KindBndr -> KindRep
KindRepApp :: KindRep -> KindRep -> KindRep
KindRepFun :: KindRep -> KindRep -> KindRep
KindRepTYPE :: !RuntimeRep -> KindRep
KindRepTypeLitS :: TypeLitSort -> Addr# -> KindRep
KindRepTypeLitD :: TypeLitSort -> [Char] -> KindRep

-- | A de Bruijn index for a binder within a <a>KindRep</a>.
type KindBndr = Int


-- | GHC's primitive types and operations. Use GHC.Exts from the base
--   package instead of importing this module directly.
module GHC.Prim
data Char#
gtChar# :: Char# -> Char# -> Int#
geChar# :: Char# -> Char# -> Int#
eqChar# :: Char# -> Char# -> Int#
neChar# :: Char# -> Char# -> Int#
ltChar# :: Char# -> Char# -> Int#
leChar# :: Char# -> Char# -> Int#
ord# :: Char# -> Int#
data Int#
(+#) :: Int# -> Int# -> Int#
infixl 6 +#
(-#) :: Int# -> Int# -> Int#
infixl 6 -#

-- | Low word of signed integer multiply.
(*#) :: Int# -> Int# -> Int#
infixl 7 *#

-- | Return non-zero if there is any possibility that the upper word of a
--   signed integer multiply might contain useful information. Return zero
--   only if you are completely sure that no overflow can occur. On a
--   32-bit platform, the recommended implementation is to do a 32 x 32
--   -&gt; 64 signed multiply, and subtract result[63:32] from (result[31]
--   &gt;&gt;signed 31). If this is zero, meaning that the upper word is
--   merely a sign extension of the lower one, no overflow can occur.
--   
--   On a 64-bit platform it is not always possible to acquire the top 64
--   bits of the result. Therefore, a recommended implementation is to take
--   the absolute value of both operands, and return 0 iff bits[63:31] of
--   them are zero, since that means that their magnitudes fit within 31
--   bits, so the magnitude of the product must fit into 62 bits.
--   
--   If in doubt, return non-zero, but do make an effort to create the
--   correct answer for small args, since otherwise the performance of
--   <tt>(*) :: Integer -&gt; Integer -&gt; Integer</tt> will be poor.
mulIntMayOflo# :: Int# -> Int# -> Int#

-- | Rounds towards zero. The behavior is undefined if the second argument
--   is zero.
quotInt# :: Int# -> Int# -> Int#

-- | Satisfies <tt>(quotInt# x y) *# y +# (remInt# x y) == x</tt>. The
--   behavior is undefined if the second argument is zero.
remInt# :: Int# -> Int# -> Int#

-- | Rounds towards zero.
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
andI# :: Int# -> Int# -> Int#
orI# :: Int# -> Int# -> Int#
xorI# :: Int# -> Int# -> Int#
notI# :: Int# -> Int#
negateInt# :: Int# -> Int#

-- | Add signed integers reporting overflow. First member of result is the
--   sum truncated to an <tt>Int#</tt>; second member is zero if the true
--   sum fits in an <tt>Int#</tt>, nonzero if overflow occurred (the sum is
--   either too large or too small to fit in an <tt>Int#</tt>).
addIntC# :: Int# -> Int# -> (# Int#, Int# #)

-- | Subtract signed integers reporting overflow. First member of result is
--   the difference truncated to an <tt>Int#</tt>; second member is zero if
--   the true difference fits in an <tt>Int#</tt>, nonzero if overflow
--   occurred (the difference is either too large or too small to fit in an
--   <tt>Int#</tt>).
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
(>#) :: Int# -> Int# -> Int#
infix 4 >#
(>=#) :: Int# -> Int# -> Int#
infix 4 >=#
(==#) :: Int# -> Int# -> Int#
infix 4 ==#
(/=#) :: Int# -> Int# -> Int#
infix 4 /=#
(<#) :: Int# -> Int# -> Int#
infix 4 <#
(<=#) :: Int# -> Int# -> Int#
infix 4 <=#
chr# :: Int# -> Char#
int2Word# :: Int# -> Word#
int2Float# :: Int# -> Float#
int2Double# :: Int# -> Double#
word2Float# :: Word# -> Float#
word2Double# :: Word# -> Double#

-- | Shift left. Result undefined if shift amount is not in the range 0 to
--   word size - 1 inclusive.
uncheckedIShiftL# :: Int# -> Int# -> Int#

-- | Shift right arithmetic. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRA# :: Int# -> Int# -> Int#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRL# :: Int# -> Int# -> Int#
data Word#
plusWord# :: Word# -> Word# -> Word#

-- | Add unsigned integers reporting overflow. The first element of the
--   pair is the result. The second element is the carry flag, which is
--   nonzero on overflow. See also <tt>plusWord2#</tt>.
addWordC# :: Word# -> Word# -> (# Word#, Int# #)

-- | Subtract unsigned integers reporting overflow. The first element of
--   the pair is the result. The second element is the carry flag, which is
--   nonzero on overflow.
subWordC# :: Word# -> Word# -> (# Word#, Int# #)

-- | Add unsigned integers, with the high part (carry) in the first
--   component of the returned pair and the low part in the second
--   component of the pair. See also <tt>addWordC#</tt>.
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
minusWord# :: Word# -> Word# -> Word#
timesWord# :: Word# -> Word# -> Word#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
quotWord# :: Word# -> Word# -> Word#
remWord# :: Word# -> Word# -> Word#
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
and# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
xor# :: Word# -> Word# -> Word#
not# :: Word# -> Word#

-- | Shift left logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftL# :: Word# -> Int# -> Word#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftRL# :: Word# -> Int# -> Word#
word2Int# :: Word# -> Int#
gtWord# :: Word# -> Word# -> Int#
geWord# :: Word# -> Word# -> Int#
eqWord# :: Word# -> Word# -> Int#
neWord# :: Word# -> Word# -> Int#
ltWord# :: Word# -> Word# -> Int#
leWord# :: Word# -> Word# -> Int#

-- | Count the number of set bits in the lower 8 bits of a word.
popCnt8# :: Word# -> Word#

-- | Count the number of set bits in the lower 16 bits of a word.
popCnt16# :: Word# -> Word#

-- | Count the number of set bits in the lower 32 bits of a word.
popCnt32# :: Word# -> Word#

-- | Count the number of set bits in a 64-bit word.
popCnt64# :: Word# -> Word#

-- | Count the number of set bits in a word.
popCnt# :: Word# -> Word#

-- | Deposit bits to lower 8 bits of a word at locations specified by a
--   mask.
pdep8# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 16 bits of a word at locations specified by a
--   mask.
pdep16# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 32 bits of a word at locations specified by a
--   mask.
pdep32# :: Word# -> Word# -> Word#

-- | Deposit bits to a word at locations specified by a mask.
pdep64# :: Word# -> Word# -> Word#

-- | Deposit bits to a word at locations specified by a mask.
pdep# :: Word# -> Word# -> Word#

-- | Extract bits from lower 8 bits of a word at locations specified by a
--   mask.
pext8# :: Word# -> Word# -> Word#

-- | Extract bits from lower 16 bits of a word at locations specified by a
--   mask.
pext16# :: Word# -> Word# -> Word#

-- | Extract bits from lower 32 bits of a word at locations specified by a
--   mask.
pext32# :: Word# -> Word# -> Word#

-- | Extract bits from a word at locations specified by a mask.
pext64# :: Word# -> Word# -> Word#

-- | Extract bits from a word at locations specified by a mask.
pext# :: Word# -> Word# -> Word#

-- | Count leading zeros in the lower 8 bits of a word.
clz8# :: Word# -> Word#

-- | Count leading zeros in the lower 16 bits of a word.
clz16# :: Word# -> Word#

-- | Count leading zeros in the lower 32 bits of a word.
clz32# :: Word# -> Word#

-- | Count leading zeros in a 64-bit word.
clz64# :: Word# -> Word#

-- | Count leading zeros in a word.
clz# :: Word# -> Word#

-- | Count trailing zeros in the lower 8 bits of a word.
ctz8# :: Word# -> Word#

-- | Count trailing zeros in the lower 16 bits of a word.
ctz16# :: Word# -> Word#

-- | Count trailing zeros in the lower 32 bits of a word.
ctz32# :: Word# -> Word#

-- | Count trailing zeros in a 64-bit word.
ctz64# :: Word# -> Word#

-- | Count trailing zeros in a word.
ctz# :: Word# -> Word#

-- | Swap bytes in the lower 16 bits of a word. The higher bytes are
--   undefined.
byteSwap16# :: Word# -> Word#

-- | Swap bytes in the lower 32 bits of a word. The higher bytes are
--   undefined.
byteSwap32# :: Word# -> Word#

-- | Swap bytes in a 64 bits of a word.
byteSwap64# :: Word# -> Word#

-- | Swap bytes in a word.
byteSwap# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow32Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow32Word# :: Word# -> Word#
data Double#
(>##) :: Double# -> Double# -> Int#
infix 4 >##
(>=##) :: Double# -> Double# -> Int#
infix 4 >=##
(==##) :: Double# -> Double# -> Int#
infix 4 ==##
(/=##) :: Double# -> Double# -> Int#
infix 4 /=##
(<##) :: Double# -> Double# -> Int#
infix 4 <##
(<=##) :: Double# -> Double# -> Int#
infix 4 <=##
(+##) :: Double# -> Double# -> Double#
infixl 6 +##
(-##) :: Double# -> Double# -> Double#
infixl 6 -##
(*##) :: Double# -> Double# -> Double#
infixl 7 *##
(/##) :: Double# -> Double# -> Double#
infixl 7 /##
negateDouble# :: Double# -> Double#
fabsDouble# :: Double# -> Double#

-- | Truncates a <tt>Double#</tt> value to the nearest <tt>Int#</tt>.
--   Results are undefined if the truncation if truncation yields a value
--   outside the range of <tt>Int#</tt>.
double2Int# :: Double# -> Int#
double2Float# :: Double# -> Float#
expDouble# :: Double# -> Double#
logDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#
asinDouble# :: Double# -> Double#
acosDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#

-- | Exponentiation.
(**##) :: Double# -> Double# -> Double#

-- | Convert to integer. First component of the result is -1 or 1,
--   indicating the sign of the mantissa. The next two are the high and low
--   32 bits of the mantissa respectively, and the last is the exponent.
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)

-- | Decode <tt>Double#</tt> into mantissa and base-2 exponent.
decodeDouble_Int64# :: Double# -> (# Int#, Int# #)
data Float#
gtFloat# :: Float# -> Float# -> Int#
geFloat# :: Float# -> Float# -> Int#
eqFloat# :: Float# -> Float# -> Int#
neFloat# :: Float# -> Float# -> Int#
ltFloat# :: Float# -> Float# -> Int#
leFloat# :: Float# -> Float# -> Int#
plusFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#
divideFloat# :: Float# -> Float# -> Float#
negateFloat# :: Float# -> Float#
fabsFloat# :: Float# -> Float#

-- | Truncates a <tt>Float#</tt> value to the nearest <tt>Int#</tt>.
--   Results are undefined if the truncation if truncation yields a value
--   outside the range of <tt>Int#</tt>.
float2Int# :: Float# -> Int#
expFloat# :: Float# -> Float#
logFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#
asinFloat# :: Float# -> Float#
acosFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
powerFloat# :: Float# -> Float# -> Float#
float2Double# :: Float# -> Double#

-- | Convert to integers. First <tt>Int#</tt> in result is the mantissa;
--   second is the exponent.
decodeFloat_Int# :: Float# -> (# Int#, Int# #)
data Array# a
data MutableArray# s a

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newArray# :: Int# -> a -> State# s -> (# State# s, MutableArray# s a #)
sameMutableArray# :: MutableArray# s a -> MutableArray# s a -> Int#

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
readArray# :: MutableArray# s a -> Int# -> State# s -> (# State# s, a #)

-- | Write to specified index of mutable array.
writeArray# :: MutableArray# s a -> Int# -> a -> State# s -> State# s

-- | Return the number of elements in the array.
sizeofArray# :: Array# a -> Int#

-- | Return the number of elements in the array.
sizeofMutableArray# :: MutableArray# s a -> Int#

-- | Read from the specified index of an immutable array. The result is
--   packaged into an unboxed unary tuple; the result itself is not yet
--   evaluated. Pattern matching on the tuple forces the indexing of the
--   array to happen but does not evaluate the element itself. Evaluating
--   the thunk prevents additional thunks from building up on the heap.
--   Avoiding these thunks, in turn, reduces references to the argument
--   array, allowing it to be garbage collected more promptly.
indexArray# :: Array# a -> Int# -> (# a #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeArray# :: MutableArray# s a -> State# s -> (# State# s, Array# a #)

-- | Make an immutable array mutable, without copying.
unsafeThawArray# :: Array# a -> State# s -> (# State# s, MutableArray# s a #)

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
copyArray# :: Array# a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. In the case where the source and destination are the
--   same array the source and destination regions may overlap.
copyMutableArray# :: MutableArray# s a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
cloneArray# :: Array# a -> Int# -> Int# -> Array# a

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
cloneMutableArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
freezeArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, Array# a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
thawArray# :: Array# a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)

-- | Unsafe, machine-level atomic compare and swap on an element within an
--   Array.
casArray# :: MutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s, Int#, a #)
data SmallArray# a
data SmallMutableArray# s a

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newSmallArray# :: Int# -> a -> State# s -> (# State# s, SmallMutableArray# s a #)
sameSmallMutableArray# :: SmallMutableArray# s a -> SmallMutableArray# s a -> Int#

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
readSmallArray# :: SmallMutableArray# s a -> Int# -> State# s -> (# State# s, a #)

-- | Write to specified index of mutable array.
writeSmallArray# :: SmallMutableArray# s a -> Int# -> a -> State# s -> State# s

-- | Return the number of elements in the array.
sizeofSmallArray# :: SmallArray# a -> Int#

-- | Return the number of elements in the array.
sizeofSmallMutableArray# :: SmallMutableArray# s a -> Int#

-- | Read from specified index of immutable array. Result is packaged into
--   an unboxed singleton; the result itself is not yet evaluated.
indexSmallArray# :: SmallArray# a -> Int# -> (# a #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeSmallArray# :: SmallMutableArray# s a -> State# s -> (# State# s, SmallArray# a #)

-- | Make an immutable array mutable, without copying.
unsafeThawSmallArray# :: SmallArray# a -> State# s -> (# State# s, SmallMutableArray# s a #)

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
copySmallArray# :: SmallArray# a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. The source and destination arrays can refer to the same array.
--   Both arrays must fully contain the specified ranges, but this is not
--   checked. The regions are allowed to overlap, although this is only
--   possible when the same array is provided as both the source and the
--   destination.
copySmallMutableArray# :: SmallMutableArray# s a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
cloneSmallArray# :: SmallArray# a -> Int# -> Int# -> SmallArray# a

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
cloneSmallMutableArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
freezeSmallArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, SmallArray# a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
thawSmallArray# :: SmallArray# a -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s a #)

-- | Unsafe, machine-level atomic compare and swap on an element within an
--   array.
casSmallArray# :: SmallMutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s, Int#, a #)
data ByteArray#
data MutableByteArray# s

-- | Create a new mutable byte array of specified size (in bytes), in the
--   specified state thread.
newByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Create a mutable byte array that the GC guarantees not to move.
newPinnedByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Create a mutable byte array, aligned by the specified amount, that the
--   GC guarantees not to move.
newAlignedPinnedByteArray# :: Int# -> Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Determine whether a <tt>MutableByteArray#</tt> is guaranteed not to
--   move during GC.
isMutableByteArrayPinned# :: MutableByteArray# s -> Int#

-- | Determine whether a <tt>ByteArray#</tt> is guaranteed not to move
--   during GC.
isByteArrayPinned# :: ByteArray# -> Int#

-- | Intended for use with pinned arrays; otherwise very unsafe!
byteArrayContents# :: ByteArray# -> Addr#
sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Int#

-- | Shrink mutable byte array to new specified size (in bytes), in the
--   specified state thread. The new size argument must be less than or
--   equal to the current size as reported by <tt>sizeofMutableArray#</tt>.
shrinkMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> State# s

-- | Resize (unpinned) mutable byte array to new specified size (in bytes).
--   The returned <tt>MutableByteArray#</tt> is either the original
--   <tt>MutableByteArray#</tt> resized in-place or, if not possible, a
--   newly allocated (unpinned) <tt>MutableByteArray#</tt> (with the
--   original content copied over).
--   
--   To avoid undefined behaviour, the original <tt>MutableByteArray#</tt>
--   shall not be accessed anymore after a <tt>resizeMutableByteArray#</tt>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <tt>MutableByteArray#</tt> in case a new <tt>MutableByteArray#</tt>
--   had to be allocated.
resizeMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Make a mutable byte array immutable, without copying.
unsafeFreezeByteArray# :: MutableByteArray# s -> State# s -> (# State# s, ByteArray# #)

-- | Return the size of the array in bytes.
sizeofByteArray# :: ByteArray# -> Int#

-- | Return the size of the array in bytes. Note that this is deprecated as
--   it is unsafe in the presence of concurrent resize operations on the
--   same byte array. See <tt>getSizeofMutableByteArray</tt>.
sizeofMutableByteArray# :: MutableByteArray# s -> Int#

-- | Return the number of elements in the array.
getSizeofMutableByteArray# :: MutableByteArray# s -> State# s -> (# State# s, Int# #)

-- | Read 8-bit character; offset in bytes.
indexCharArray# :: ByteArray# -> Int# -> Char#

-- | Read 31-bit character; offset in 4-byte words.
indexWideCharArray# :: ByteArray# -> Int# -> Char#
indexIntArray# :: ByteArray# -> Int# -> Int#
indexWordArray# :: ByteArray# -> Int# -> Word#
indexAddrArray# :: ByteArray# -> Int# -> Addr#
indexFloatArray# :: ByteArray# -> Int# -> Float#
indexDoubleArray# :: ByteArray# -> Int# -> Double#
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a

-- | Read 8-bit integer; offset in bytes.
indexInt8Array# :: ByteArray# -> Int# -> Int#

-- | Read 16-bit integer; offset in 16-bit words.
indexInt16Array# :: ByteArray# -> Int# -> Int#

-- | Read 32-bit integer; offset in 32-bit words.
indexInt32Array# :: ByteArray# -> Int# -> Int#

-- | Read 64-bit integer; offset in 64-bit words.
indexInt64Array# :: ByteArray# -> Int# -> Int#

-- | Read 8-bit word; offset in bytes.
indexWord8Array# :: ByteArray# -> Int# -> Word#

-- | Read 16-bit word; offset in 16-bit words.
indexWord16Array# :: ByteArray# -> Int# -> Word#

-- | Read 32-bit word; offset in 32-bit words.
indexWord32Array# :: ByteArray# -> Int# -> Word#

-- | Read 64-bit word; offset in 64-bit words.
indexWord64Array# :: ByteArray# -> Int# -> Word#

-- | Read 8-bit character; offset in bytes.
indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#

-- | Read 31-bit character; offset in bytes.
indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#

-- | Read address; offset in bytes.
indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#

-- | Read float; offset in bytes.
indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#

-- | Read double; offset in bytes.
indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#

-- | Read stable pointer; offset in bytes.
indexWord8ArrayAsStablePtr# :: ByteArray# -> Int# -> StablePtr# a

-- | Read 16-bit int; offset in bytes.
indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int#

-- | Read 32-bit int; offset in bytes.
indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int#

-- | Read 64-bit int; offset in bytes.
indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int#

-- | Read int; offset in bytes.
indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#

-- | Read 16-bit word; offset in bytes.
indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word#

-- | Read 32-bit word; offset in bytes.
indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word#

-- | Read 64-bit word; offset in bytes.
indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word#

-- | Read word; offset in bytes.
indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#

-- | Read 8-bit character; offset in bytes.
readCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)

-- | Read 31-bit character; offset in 4-byte words.
readWideCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)

-- | Read integer; offset in words.
readIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | Read word; offset in words.
readWordArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readAddrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)
readFloatArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)
readDoubleArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)
readWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)
readWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)
readWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)
readWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)

-- | Write 8-bit character; offset in bytes.
writeCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s

-- | Write 31-bit character; offset in 4-byte words.
writeWideCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWordArray# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeAddrArray# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeFloatArray# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeDoubleArray# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeStablePtrArray# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt16Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt32Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt64Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord16Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord32Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord64Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s

-- | <tt>compareByteArrays# src1 src1_ofs src2 src2_ofs n</tt> compares
--   <tt>n</tt> bytes starting at offset <tt>src1_ofs</tt> in the first
--   <tt>ByteArray#</tt> <tt>src1</tt> to the range of <tt>n</tt> bytes
--   (i.e. same length) starting at offset <tt>src2_ofs</tt> of the second
--   <tt>ByteArray#</tt> <tt>src2</tt>. Both arrays must fully contain the
--   specified ranges, but this is not checked. Returns an <tt>Int#</tt>
--   less than, equal to, or greater than zero if the range is found,
--   respectively, to be byte-wise lexicographically less than, to match,
--   or be greater than the second range.
compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#

-- | <tt>copyByteArray# src src_ofs dst dst_ofs n</tt> copies the range
--   starting at offset <tt>src_ofs</tt> of length <tt>n</tt> from the
--   <tt>ByteArray#</tt> <tt>src</tt> to the <tt>MutableByteArray#</tt>
--   <tt>dst</tt> starting at offset <tt>dst_ofs</tt>. Both arrays must
--   fully contain the specified ranges, but this is not checked. The two
--   arrays must not be the same array in different states, but this is not
--   checked either.
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the first MutableByteArray. Both arrays must fully
--   contain the specified ranges, but this is not checked. The regions are
--   allowed to overlap, although this is only possible when the same array
--   is provided as both the source and the destination.
copyMutableByteArray# :: MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the ByteArray. The ByteArray must fully contain the
--   specified ranges, but this is not checked. The Addr# must not point
--   into the ByteArray were pinned), but this is not checked either.
copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# s -> State# s

-- | Copy a range of the MutableByteArray# to the memory range starting at
--   the Addr and the memory region at Addr# must fully contain the
--   specified ranges, but this is not checked. The Addr# must not point
--   into the MutableByteArray were pinned), but this is not checked
--   either.
copyMutableByteArrayToAddr# :: MutableByteArray# s -> Int# -> Addr# -> Int# -> State# s -> State# s

-- | Copy a memory range starting at the Addr# to the specified range in
--   the MutableByteArray and the ByteArray# must fully contain the
--   specified ranges, but this is not checked. The Addr# must not point
--   into the MutableByteArray were pinned), but this is not checked
--   either.
copyAddrToByteArray# :: Addr# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | <tt>setByteArray# ba off len c</tt> sets the byte range <tt>[off,
--   off+len]</tt> of the <tt>MutableByteArray#</tt> to the byte
--   <tt>c</tt>.
setByteArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> State# s

-- | Given an array and an offset in Int units, read an element. The index
--   is assumed to be in bounds. Implies a full memory barrier.
atomicReadIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array and an offset in Int units, write an element. The index
--   is assumed to be in bounds. Implies a full memory barrier.
atomicWriteIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Given an array, an offset in Int units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
casIntArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in Int units, and a value to add,
--   atomically add the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
fetchAddIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in Int units, and a value to subtract,
--   atomically substract the value to the element. Returns the value of
--   the element before the operation. Implies a full memory barrier.
fetchSubIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in Int units, and a value to AND,
--   atomically AND the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
fetchAndIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in Int units, and a value to NAND,
--   atomically NAND the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
fetchNandIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in Int units, and a value to OR, atomically
--   OR the value to the element. Returns the value of the element before
--   the operation. Implies a full memory barrier.
fetchOrIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in Int units, and a value to XOR,
--   atomically XOR the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
fetchXorIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
data ArrayArray#
data MutableArrayArray# s

-- | Create a new mutable array of arrays with the specified number of
--   elements, in the specified state thread, with each element recursively
--   referring to the newly created array.
newArrayArray# :: Int# -> State# s -> (# State# s, MutableArrayArray# s #)
sameMutableArrayArray# :: MutableArrayArray# s -> MutableArrayArray# s -> Int#

-- | Make a mutable array of arrays immutable, without copying.
unsafeFreezeArrayArray# :: MutableArrayArray# s -> State# s -> (# State# s, ArrayArray# #)

-- | Return the number of elements in the array.
sizeofArrayArray# :: ArrayArray# -> Int#

-- | Return the number of elements in the array.
sizeofMutableArrayArray# :: MutableArrayArray# s -> Int#
indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
readByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ByteArray# #)
readMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
readArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ArrayArray# #)
readMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableArrayArray# s #)
writeByteArrayArray# :: MutableArrayArray# s -> Int# -> ByteArray# -> State# s -> State# s
writeMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> MutableByteArray# s -> State# s -> State# s
writeArrayArrayArray# :: MutableArrayArray# s -> Int# -> ArrayArray# -> State# s -> State# s
writeMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> State# s -> State# s

-- | Copy a range of the ArrayArray. Both arrays must fully contain the
--   specified ranges, but this is not checked. The two arrays must not be
--   the same array in different states, but this is not checked either.
copyArrayArray# :: ArrayArray# -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the first MutableArrayArray# to the specified region
--   in the second MutableArrayArray#. Both arrays must fully contain the
--   specified ranges, but this is not checked. The regions are allowed to
--   overlap, although this is only possible when the same array is
--   provided as both the source and the destination.
copyMutableArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s

-- | An arbitrary machine address assumed to point outside the
--   garbage-collected heap.
data Addr#

-- | The null address.
nullAddr# :: Addr#
plusAddr# :: Addr# -> Int# -> Addr#

-- | Result is meaningless if two <tt>Addr#</tt>s are so far apart that
--   their difference doesn't fit in an <tt>Int#</tt>.
minusAddr# :: Addr# -> Addr# -> Int#

-- | Return the remainder when the <tt>Addr#</tt> arg, treated like an
--   <tt>Int#</tt>, is divided by the <tt>Int#</tt> arg.
remAddr# :: Addr# -> Int# -> Int#

-- | Coerce directly from address to int. Strongly deprecated.
addr2Int# :: Addr# -> Int#

-- | Coerce directly from int to address. Strongly deprecated.
int2Addr# :: Int# -> Addr#
gtAddr# :: Addr# -> Addr# -> Int#
geAddr# :: Addr# -> Addr# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
neAddr# :: Addr# -> Addr# -> Int#
ltAddr# :: Addr# -> Addr# -> Int#
leAddr# :: Addr# -> Addr# -> Int#

-- | Reads 8-bit character; offset in bytes.
indexCharOffAddr# :: Addr# -> Int# -> Char#

-- | Reads 31-bit character; offset in 4-byte words.
indexWideCharOffAddr# :: Addr# -> Int# -> Char#
indexIntOffAddr# :: Addr# -> Int# -> Int#
indexWordOffAddr# :: Addr# -> Int# -> Word#
indexAddrOffAddr# :: Addr# -> Int# -> Addr#
indexFloatOffAddr# :: Addr# -> Int# -> Float#
indexDoubleOffAddr# :: Addr# -> Int# -> Double#
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a
indexInt8OffAddr# :: Addr# -> Int# -> Int#
indexInt16OffAddr# :: Addr# -> Int# -> Int#
indexInt32OffAddr# :: Addr# -> Int# -> Int#
indexInt64OffAddr# :: Addr# -> Int# -> Int#
indexWord8OffAddr# :: Addr# -> Int# -> Word#
indexWord16OffAddr# :: Addr# -> Int# -> Word#
indexWord32OffAddr# :: Addr# -> Int# -> Word#
indexWord64OffAddr# :: Addr# -> Int# -> Word#

-- | Reads 8-bit character; offset in bytes.
readCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)

-- | Reads 31-bit character; offset in 4-byte words.
readWideCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readIntOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWordOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readAddrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Addr# #)
readFloatOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Float# #)
readDoubleOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWord8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# s -> State# s
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# s -> State# s
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# s -> State# s
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt16OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt32OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt64OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWord8OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord16OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord32OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord64OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s

-- | A <tt>MutVar#</tt> behaves like a single-element mutable array.
data MutVar# s a

-- | Create <tt>MutVar#</tt> with specified initial value in specified
--   state thread.
newMutVar# :: a -> State# s -> (# State# s, MutVar# s a #)

-- | Read contents of <tt>MutVar#</tt>. Result is not yet evaluated.
readMutVar# :: MutVar# s a -> State# s -> (# State# s, a #)

-- | Write contents of <tt>MutVar#</tt>.
writeMutVar# :: MutVar# s a -> a -> State# s -> State# s
sameMutVar# :: MutVar# s a -> MutVar# s a -> Int#

-- | Modify the contents of a <tt>MutVar#</tt>. Note that this isn't
--   strictly speaking the correct type for this function, it should really
--   be <tt>MutVar s -&gt; ( s, b #)</tt>, however we don't know about
--   pairs here.
atomicModifyMutVar# :: MutVar# s a -> (a -> b) -> State# s -> (# State# s, c #)
casMutVar# :: MutVar# s a -> a -> a -> State# s -> (# State# s, Int#, a #)
catch# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
raise# :: b -> o
raiseIO# :: a -> State# RealWorld -> (# State# RealWorld, b #)
maskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
maskUninterruptible# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
unmaskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)
data TVar# s a
atomically# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
retry# :: State# RealWorld -> (# State# RealWorld, a #)
catchRetry# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
catchSTM# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | Create a new <tt>TVar#</tt> holding a specified initial value.
newTVar# :: a -> State# s -> (# State# s, TVar# s a #)

-- | Read contents of <tt>TVar#</tt>. Result is not yet evaluated.
readTVar# :: TVar# s a -> State# s -> (# State# s, a #)

-- | Read contents of <tt>TVar#</tt> outside an STM transaction
readTVarIO# :: TVar# s a -> State# s -> (# State# s, a #)

-- | Write contents of <tt>TVar#</tt>.
writeTVar# :: TVar# s a -> a -> State# s -> State# s
sameTVar# :: TVar# s a -> TVar# s a -> Int#

-- | A shared mutable variable (<i>not</i> the same as a
--   <tt>MutVar#</tt>!). (Note: in a non-concurrent implementation,
--   <tt>(MVar# a)</tt> can be represented by <tt>(MutVar# (Maybe
--   a))</tt>.)
data MVar# s a

-- | Create new <tt>MVar#</tt>; initially empty.
newMVar# :: State# s -> (# State# s, MVar# s a #)

-- | If <tt>MVar#</tt> is empty, block until it becomes full. Then remove
--   and return its contents, and set it empty.
takeMVar# :: MVar# s a -> State# s -> (# State# s, a #)

-- | If <tt>MVar#</tt> is empty, immediately return with integer 0 and
--   value undefined. Otherwise, return with integer 1 and contents of
--   <tt>MVar#</tt>, and set <tt>MVar#</tt> empty.
tryTakeMVar# :: MVar# s a -> State# s -> (# State# s, Int#, a #)

-- | If <tt>MVar#</tt> is full, block until it becomes empty. Then store
--   value arg as its new contents.
putMVar# :: MVar# s a -> a -> State# s -> State# s

-- | If <tt>MVar#</tt> is full, immediately return with integer 0.
--   Otherwise, store value arg as <tt>MVar#</tt>'s new contents, and
--   return with integer 1.
tryPutMVar# :: MVar# s a -> a -> State# s -> (# State# s, Int# #)

-- | If <tt>MVar#</tt> is empty, block until it becomes full. Then read its
--   contents without modifying the MVar, without possibility of
--   intervention from other threads.
readMVar# :: MVar# s a -> State# s -> (# State# s, a #)

-- | If <tt>MVar#</tt> is empty, immediately return with integer 0 and
--   value undefined. Otherwise, return with integer 1 and contents of
--   <tt>MVar#</tt>.
tryReadMVar# :: MVar# s a -> State# s -> (# State# s, Int#, a #)
sameMVar# :: MVar# s a -> MVar# s a -> Int#

-- | Return 1 if <tt>MVar#</tt> is empty; 0 otherwise.
isEmptyMVar# :: MVar# s a -> State# s -> (# State# s, Int# #)

-- | Sleep specified number of microseconds.
delay# :: Int# -> State# s -> State# s

-- | Block until input is available on specified file descriptor.
waitRead# :: Int# -> State# s -> State# s

-- | Block until output is possible on specified file descriptor.
waitWrite# :: Int# -> State# s -> State# s

-- | <tt>State#</tt> is the primitive, unlifted type of states. It has one
--   type parameter, thus <tt>State# RealWorld</tt>, or <tt>State# s</tt>,
--   where s is a type variable. The only purpose of the type parameter is
--   to keep different state threads separate. It is represented by nothing
--   at all.
data State# s

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld

-- | (In a non-concurrent implementation, this can be a singleton type,
--   whose (unique) value is returned by <tt>myThreadId#</tt>. The other
--   operations can be omitted.)
data ThreadId#
fork# :: a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
forkOn# :: Int# -> a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
killThread# :: ThreadId# -> a -> State# RealWorld -> State# RealWorld
yield# :: State# RealWorld -> State# RealWorld
myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
labelThread# :: ThreadId# -> Addr# -> State# RealWorld -> State# RealWorld
isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)
noDuplicate# :: State# s -> State# s
threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)
data Weak# b

-- | <tt>mkWeak# k v finalizer s</tt> creates a weak reference to value
--   <tt>k</tt>, with an associated reference to some value <tt>v</tt>. If
--   <tt>k</tt> is still alive then <tt>v</tt> can be retrieved using
--   <tt>deRefWeak#</tt>. Note that the type of <tt>k</tt> must be
--   represented by a pointer (i.e. of kind <tt>TYPE 'LiftedRep</tt> or
--   <tt>TYPE 'UnliftedRep</tt>).
mkWeak# :: o -> b -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)
mkWeakNoFinalizer# :: o -> b -> State# RealWorld -> (# State# RealWorld, Weak# b #)

-- | <tt>addCFinalizerToWeak# fptr ptr flag eptr w</tt> attaches a C
--   function pointer <tt>fptr</tt> to a weak pointer <tt>w</tt> as a
--   finalizer. If <tt>flag</tt> is zero, <tt>fptr</tt> will be called with
--   one argument, <tt>ptr</tt>. Otherwise, it will be called with two
--   arguments, <tt>eptr</tt> and <tt>ptr</tt>.
--   <tt>addCFinalizerToWeak#</tt> returns 1 on success, or 0 if <tt>w</tt>
--   is already dead.
addCFinalizerToWeak# :: Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)
deRefWeak# :: Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)

-- | Finalize a weak pointer. The return value is an unboxed tuple
--   containing the new state of the world and an "unboxed Maybe",
--   represented by an <tt>Int#</tt> and a (possibly invalid) finalization
--   action. An <tt>Int#</tt> of <tt>1</tt> indicates that the finalizer is
--   valid. The return value <tt>b</tt> from the finalizer should be
--   ignored.
finalizeWeak# :: Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
touch# :: o -> State# RealWorld -> State# RealWorld
data StablePtr# a
data StableName# a
makeStablePtr# :: a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)
deRefStablePtr# :: StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
eqStablePtr# :: StablePtr# a -> StablePtr# a -> Int#
makeStableName# :: a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
eqStableName# :: StableName# a -> StableName# b -> Int#
stableNameToInt# :: StableName# a -> Int#
data Compact#

-- | Create a new Compact with the given size (in bytes, not words). The
--   size is rounded up to a multiple of the allocator block size, and
--   capped to one mega block.
compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)

-- | Set the new allocation size of the compact. This value (in bytes)
--   determines the size of each block in the compact chain.
compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld

-- | Returns 1 otherwise.
compactContains# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Returns 1 otherwise.
compactContainsAny# :: a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Returns the address and the size (in bytes) of the first block of a
--   compact.
compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Given a compact and the address of one its blocks, returns the next
--   block and its size, or #nullAddr if the argument was the last block in
--   the compact.
compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Attempt to allocate a compact block with the given size (in bytes) at
--   the given address. The first argument is a hint to the allocator,
--   allocation might be satisfied at a different address (which is
--   returned). The resulting block is not known to the GC until
--   compactFixupPointers# is called on it, and care must be taken so that
--   the address does not escape or memory will be leaked.
compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)

-- | Given the pointer to the first block of a compact, and the address of
--   the root object in the old address space, fix up the internal pointers
--   inside the compact to account for a different position in memory than
--   when it was serialized. This method must be called exactly once after
--   importing a serialized compact, and returns the new compact and the
--   new adjusted root address.
compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)

-- | Recursively add a closure and its transitive closure to a {texttt
--   Compact#}, evaluating any unevaluated components at the same time.
--   Note: {texttt compactAdd#} is not thread-safe, so only one thread may
--   call {texttt compactAdd#} with a particular {texttt Compact#} at any
--   given time. The primop does not enforce any mutual exclusion; the
--   caller is expected to arrange this.
compactAdd# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Like {texttt compactAdd#}, but retains sharing and cycles during
--   compaction.
compactAddWithSharing# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Return the size (in bytes) of the total amount of data in the Compact#
compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)

-- | Returns {texttt 1#} if the given pointers are equal and {texttt 0#}
--   otherwise.
reallyUnsafePtrEquality# :: a -> a -> Int#
par# :: a -> Int#
spark# :: a -> State# s -> (# State# s, a #)
seq# :: a -> State# s -> (# State# s, a #)
getSpark# :: State# s -> (# State# s, Int#, a #)

-- | Returns the number of sparks in the local spark pool.
numSparks# :: State# s -> (# State# s, Int# #)
dataToTag# :: a -> Int#
tagToEnum# :: Int# -> a

-- | Primitive bytecode type.
data BCO#

-- | Convert an <tt>Addr#</tt> to a followable Any type.
addrToAny# :: Addr# -> (# a #)

-- | Retrieve the address of any Haskell value. This is essentially an
--   {texttt unsafeCoerce#}, but if implemented as such the core lint pass
--   complains and fails to compile. As a primop, it is opaque to core/stg,
--   and only appears in cmm (where the copy propagation pass will get rid
--   of it). Note that "a" must be a value, not a thunk! It's too late for
--   strictness analysis to enforce this, so you're on your own to
--   guarantee this. Also note that {texttt Addr#} is not a GC pointer - up
--   to you to guarantee that it does not become a dangling pointer
--   immediately after you get it.
anyToAddr# :: a -> State# RealWorld -> (# State# RealWorld, Addr# #)

-- | Wrap a BCO in a <tt>AP_UPD</tt> thunk which will be updated with the
--   value of the BCO when evaluated.
mkApUpd0# :: BCO# -> (# a #)

-- | <tt>newBCO# instrs lits ptrs arity bitmap</tt> creates a new bytecode
--   object. The resulting object encodes a function of the given arity
--   with the instructions encoded in <tt>instrs</tt>, and a static
--   reference table usage bitmap given by <tt>bitmap</tt>.
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# s -> (# State# s, BCO# #)

-- | <tt>unpackClosure# closure</tt> copies the closure and pointers in the
--   payload of the given closure into two new arrays, and returns a
--   pointer to the first word of the closure's info table, a non-pointer
--   array for the raw bytes of the closure, and a pointer array for the
--   pointers in the payload.
unpackClosure# :: a -> (# Addr#, ByteArray#, Array# b #)
getApStackVal# :: a -> Int# -> (# Int#, b #)
getCCSOf# :: a -> State# s -> (# State# s, Addr# #)

-- | Returns the current <tt>CostCentreStack</tt> (value is <tt>NULL</tt>
--   if not profiling). Takes a dummy argument which can be used to avoid
--   the call to <tt>getCurrentCCS#</tt> being floated out by the
--   simplifier, which would result in an uninformative stack ("CAF").
getCurrentCCS# :: a -> State# s -> (# State# s, Addr# #)

-- | Run the supplied IO action with an empty CCS. For example, this is
--   used by the interpreter to run an interpreted computation without the
--   call stack showing that it was invoked from GHC.
clearCCS# :: (State# s -> (# State# s, a #)) -> State# s -> (# State# s, a #)

-- | The type constructor <tt>Proxy#</tt> is used to bear witness to some
--   type variable. It's used when you want to pass around proxy values for
--   doing things like modelling type applications. A <tt>Proxy#</tt> is
--   not only unboxed, it also has a polymorphic kind, and has no runtime
--   representation, being totally free.
data Proxy# a

-- | Witness for an unboxed <tt>Proxy#</tt> value, which has no runtime
--   representation.
proxy# :: Proxy# a

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: a -> b -> b

-- | The function <tt>unsafeCoerce#</tt> allows you to side-step the
--   typechecker entirely. That is, it allows you to coerce any type into
--   any other type. If you use this function, you had better get it right,
--   otherwise segmentation faults await. It is generally used when you
--   want to write a program that you know is well-typed, but where
--   Haskell's type system is not expressive enough to prove that it is
--   well typed.
--   
--   The following uses of <tt>unsafeCoerce#</tt> are supposed to work
--   (i.e. not lead to spurious compile-time or run-time crashes):
--   
--   <ul>
--   <li>Casting any lifted type to <tt>Any</tt></li>
--   <li>Casting <tt>Any</tt> back to the real type</li>
--   <li>Casting an unboxed type to another unboxed type of the same size.
--   (Casting between floating-point and integral types does not work. See
--   the <tt>GHC.Float</tt> module for functions to do work.)</li>
--   <li>Casting between two types that have the same runtime
--   representation. One case is when the two types differ only in
--   "phantom" type parameters, for example <tt>Ptr Int</tt> to <tt>Ptr
--   Float</tt>, or <tt>[Int]</tt> to <tt>[Float]</tt> when the list is
--   known to be empty. Also, a <tt>newtype</tt> of a type <tt>T</tt> has
--   the same representation at runtime as <tt>T</tt>.</li>
--   </ul>
--   
--   Other uses of <tt>unsafeCoerce#</tt> are undefined. In particular, you
--   should not use <tt>unsafeCoerce#</tt> to cast a T to an algebraic data
--   type D, unless T is also an algebraic data type. For example, do not
--   cast <tt>Int-&gt;Int</tt> to <tt>Bool</tt>, even if you later cast
--   that <tt>Bool</tt> back to <tt>Int-&gt;Int</tt> before applying it.
--   The reasons have to do with GHC's internal representation details (for
--   the cognoscenti, data values can be entered but function closures
--   cannot). If you want a safe type to cast things to, use <tt>Any</tt>,
--   which is not an algebraic data type.
unsafeCoerce# :: a -> b

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the zero-terminated byte string passed as the first argument.
--   The event will be emitted either to the .eventlog file, or to stderr,
--   depending on the runtime RTS flags.
traceEvent# :: Addr# -> State# s -> State# s

-- | Emits a marker event via the RTS tracing framework. The contents of
--   the event is the zero-terminated byte string passed as the first
--   argument. The event will be emitted either to the .eventlog file, or
--   to stderr, depending on the runtime RTS flags.
traceMarker# :: Addr# -> State# s -> State# s

-- | Retrieves the allocation counter for the current thread.
getThreadAllocationCounter# :: State# RealWorld -> (# State# RealWorld, Int# #)

-- | Sets the allocation counter for the current thread to the given value.
setThreadAllocationCounter# :: Int# -> State# RealWorld -> State# RealWorld

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
coerce :: Coercible a b => a -> b
data Int8X16#
data Int16X8#
data Int32X4#
data Int64X2#
data Int8X32#
data Int16X16#
data Int32X8#
data Int64X4#
data Int8X64#
data Int16X32#
data Int32X16#
data Int64X8#
data Word8X16#
data Word16X8#
data Word32X4#
data Word64X2#
data Word8X32#
data Word16X16#
data Word32X8#
data Word64X4#
data Word8X64#
data Word16X32#
data Word32X16#
data Word64X8#
data FloatX4#
data DoubleX2#
data FloatX8#
data DoubleX4#
data FloatX16#
data DoubleX8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X16# :: Int# -> Int8X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X8# :: Int# -> Int16X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X4# :: Int# -> Int32X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X2# :: Int# -> Int64X2#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X32# :: Int# -> Int8X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X16# :: Int# -> Int16X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X8# :: Int# -> Int32X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X4# :: Int# -> Int64X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X64# :: Int# -> Int8X64#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X32# :: Int# -> Int16X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X16# :: Int# -> Int32X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X8# :: Int# -> Int64X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X16# :: Word# -> Word8X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X8# :: Word# -> Word16X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X4# :: Word# -> Word32X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X2# :: Word# -> Word64X2#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X32# :: Word# -> Word8X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X16# :: Word# -> Word16X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X8# :: Word# -> Word32X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X4# :: Word# -> Word64X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X64# :: Word# -> Word8X64#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X32# :: Word# -> Word16X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X16# :: Word# -> Word32X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X8# :: Word# -> Word64X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX4# :: Float# -> FloatX4#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX2# :: Double# -> DoubleX2#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX8# :: Float# -> FloatX8#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX4# :: Double# -> DoubleX4#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX16# :: Float# -> FloatX16#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX8# :: Double# -> DoubleX8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X4# :: (# Int#, Int#, Int#, Int# #) -> Int32X4#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X2# :: (# Int#, Int# #) -> Int64X2#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X32# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X32#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X4# :: (# Int#, Int#, Int#, Int# #) -> Int64X4#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X64# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X64#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X32# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X32#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int64X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X4# :: (# Word#, Word#, Word#, Word# #) -> Word32X4#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X2# :: (# Word#, Word# #) -> Word64X2#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X32# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X32#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word32X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X4# :: (# Word#, Word#, Word#, Word# #) -> Word64X4#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X64# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X64#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X32# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X32#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word32X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word64X8#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX4# :: (# Float#, Float#, Float#, Float# #) -> FloatX4#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX2# :: (# Double#, Double# #) -> DoubleX2#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX8# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX4# :: (# Double#, Double#, Double#, Double# #) -> DoubleX4#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX16# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX8# :: (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X16# :: Int8X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X8# :: Int16X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X4# :: Int32X4# -> (# Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X2# :: Int64X2# -> (# Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X32# :: Int8X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X16# :: Int16X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X8# :: Int32X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X4# :: Int64X4# -> (# Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X64# :: Int8X64# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X32# :: Int16X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X16# :: Int32X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X8# :: Int64X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X16# :: Word8X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X8# :: Word16X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X4# :: Word32X4# -> (# Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X2# :: Word64X2# -> (# Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X32# :: Word8X32# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X16# :: Word16X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X8# :: Word32X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X4# :: Word64X4# -> (# Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X64# :: Word8X64# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X32# :: Word16X32# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X16# :: Word32X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X8# :: Word64X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX4# :: FloatX4# -> (# Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX2# :: DoubleX2# -> (# Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX8# :: FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX4# :: DoubleX4# -> (# Double#, Double#, Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX16# :: FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX8# :: DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)

-- | Insert a scalar at the given position in a vector.
insertInt8X16# :: Int8X16# -> Int# -> Int# -> Int8X16#

-- | Insert a scalar at the given position in a vector.
insertInt16X8# :: Int16X8# -> Int# -> Int# -> Int16X8#

-- | Insert a scalar at the given position in a vector.
insertInt32X4# :: Int32X4# -> Int# -> Int# -> Int32X4#

-- | Insert a scalar at the given position in a vector.
insertInt64X2# :: Int64X2# -> Int# -> Int# -> Int64X2#

-- | Insert a scalar at the given position in a vector.
insertInt8X32# :: Int8X32# -> Int# -> Int# -> Int8X32#

-- | Insert a scalar at the given position in a vector.
insertInt16X16# :: Int16X16# -> Int# -> Int# -> Int16X16#

-- | Insert a scalar at the given position in a vector.
insertInt32X8# :: Int32X8# -> Int# -> Int# -> Int32X8#

-- | Insert a scalar at the given position in a vector.
insertInt64X4# :: Int64X4# -> Int# -> Int# -> Int64X4#

-- | Insert a scalar at the given position in a vector.
insertInt8X64# :: Int8X64# -> Int# -> Int# -> Int8X64#

-- | Insert a scalar at the given position in a vector.
insertInt16X32# :: Int16X32# -> Int# -> Int# -> Int16X32#

-- | Insert a scalar at the given position in a vector.
insertInt32X16# :: Int32X16# -> Int# -> Int# -> Int32X16#

-- | Insert a scalar at the given position in a vector.
insertInt64X8# :: Int64X8# -> Int# -> Int# -> Int64X8#

-- | Insert a scalar at the given position in a vector.
insertWord8X16# :: Word8X16# -> Word# -> Int# -> Word8X16#

-- | Insert a scalar at the given position in a vector.
insertWord16X8# :: Word16X8# -> Word# -> Int# -> Word16X8#

-- | Insert a scalar at the given position in a vector.
insertWord32X4# :: Word32X4# -> Word# -> Int# -> Word32X4#

-- | Insert a scalar at the given position in a vector.
insertWord64X2# :: Word64X2# -> Word# -> Int# -> Word64X2#

-- | Insert a scalar at the given position in a vector.
insertWord8X32# :: Word8X32# -> Word# -> Int# -> Word8X32#

-- | Insert a scalar at the given position in a vector.
insertWord16X16# :: Word16X16# -> Word# -> Int# -> Word16X16#

-- | Insert a scalar at the given position in a vector.
insertWord32X8# :: Word32X8# -> Word# -> Int# -> Word32X8#

-- | Insert a scalar at the given position in a vector.
insertWord64X4# :: Word64X4# -> Word# -> Int# -> Word64X4#

-- | Insert a scalar at the given position in a vector.
insertWord8X64# :: Word8X64# -> Word# -> Int# -> Word8X64#

-- | Insert a scalar at the given position in a vector.
insertWord16X32# :: Word16X32# -> Word# -> Int# -> Word16X32#

-- | Insert a scalar at the given position in a vector.
insertWord32X16# :: Word32X16# -> Word# -> Int# -> Word32X16#

-- | Insert a scalar at the given position in a vector.
insertWord64X8# :: Word64X8# -> Word# -> Int# -> Word64X8#

-- | Insert a scalar at the given position in a vector.
insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#

-- | Insert a scalar at the given position in a vector.
insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#

-- | Insert a scalar at the given position in a vector.
insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#

-- | Insert a scalar at the given position in a vector.
insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#

-- | Insert a scalar at the given position in a vector.
insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#

-- | Insert a scalar at the given position in a vector.
insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#

-- | Add two vectors element-wise.
plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Add two vectors element-wise.
plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Add two vectors element-wise.
plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Add two vectors element-wise.
plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Add two vectors element-wise.
plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Add two vectors element-wise.
plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Add two vectors element-wise.
plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Add two vectors element-wise.
plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Add two vectors element-wise.
plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Add two vectors element-wise.
plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Add two vectors element-wise.
plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Add two vectors element-wise.
plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Add two vectors element-wise.
plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Add two vectors element-wise.
plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Add two vectors element-wise.
plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Add two vectors element-wise.
plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Add two vectors element-wise.
plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Add two vectors element-wise.
plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Add two vectors element-wise.
plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Add two vectors element-wise.
plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Add two vectors element-wise.
plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Add two vectors element-wise.
plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Add two vectors element-wise.
plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Add two vectors element-wise.
plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Add two vectors element-wise.
plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Add two vectors element-wise.
plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Add two vectors element-wise.
plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Add two vectors element-wise.
plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Add two vectors element-wise.
plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Add two vectors element-wise.
plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Subtract two vectors element-wise.
minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Subtract two vectors element-wise.
minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Subtract two vectors element-wise.
minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Subtract two vectors element-wise.
minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Subtract two vectors element-wise.
minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Subtract two vectors element-wise.
minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Subtract two vectors element-wise.
minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Subtract two vectors element-wise.
minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Subtract two vectors element-wise.
minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Subtract two vectors element-wise.
minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Subtract two vectors element-wise.
minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Subtract two vectors element-wise.
minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Subtract two vectors element-wise.
minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Subtract two vectors element-wise.
minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Subtract two vectors element-wise.
minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Subtract two vectors element-wise.
minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Subtract two vectors element-wise.
minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Subtract two vectors element-wise.
minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Subtract two vectors element-wise.
minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Subtract two vectors element-wise.
minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Subtract two vectors element-wise.
minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Subtract two vectors element-wise.
minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Subtract two vectors element-wise.
minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Subtract two vectors element-wise.
minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Subtract two vectors element-wise.
minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Subtract two vectors element-wise.
minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Subtract two vectors element-wise.
minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Subtract two vectors element-wise.
minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Subtract two vectors element-wise.
minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Subtract two vectors element-wise.
minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Multiply two vectors element-wise.
timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Multiply two vectors element-wise.
timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Multiply two vectors element-wise.
timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Multiply two vectors element-wise.
timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Multiply two vectors element-wise.
timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Multiply two vectors element-wise.
timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Multiply two vectors element-wise.
timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Multiply two vectors element-wise.
timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Multiply two vectors element-wise.
timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Multiply two vectors element-wise.
timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Multiply two vectors element-wise.
timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Multiply two vectors element-wise.
timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Multiply two vectors element-wise.
timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Multiply two vectors element-wise.
timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Multiply two vectors element-wise.
timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Multiply two vectors element-wise.
timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Multiply two vectors element-wise.
timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Multiply two vectors element-wise.
timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Multiply two vectors element-wise.
timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Multiply two vectors element-wise.
timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Multiply two vectors element-wise.
timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Multiply two vectors element-wise.
timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Multiply two vectors element-wise.
timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Multiply two vectors element-wise.
timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Multiply two vectors element-wise.
timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Multiply two vectors element-wise.
timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Multiply two vectors element-wise.
timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Multiply two vectors element-wise.
timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Multiply two vectors element-wise.
timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Multiply two vectors element-wise.
timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Divide two vectors element-wise.
divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Divide two vectors element-wise.
divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Divide two vectors element-wise.
divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Divide two vectors element-wise.
divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Divide two vectors element-wise.
divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Divide two vectors element-wise.
divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Rounds towards zero element-wise.
quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Rounds towards zero element-wise.
quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Rounds towards zero element-wise.
quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Rounds towards zero element-wise.
quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Rounds towards zero element-wise.
quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Rounds towards zero element-wise.
quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Rounds towards zero element-wise.
quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Rounds towards zero element-wise.
quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Rounds towards zero element-wise.
quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Rounds towards zero element-wise.
quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Rounds towards zero element-wise.
quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Rounds towards zero element-wise.
quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Rounds towards zero element-wise.
quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Rounds towards zero element-wise.
quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Rounds towards zero element-wise.
quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Rounds towards zero element-wise.
quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Rounds towards zero element-wise.
quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Rounds towards zero element-wise.
quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Rounds towards zero element-wise.
quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Rounds towards zero element-wise.
quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Rounds towards zero element-wise.
quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Rounds towards zero element-wise.
quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Rounds towards zero element-wise.
quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Rounds towards zero element-wise.
quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Negate element-wise.
negateInt8X16# :: Int8X16# -> Int8X16#

-- | Negate element-wise.
negateInt16X8# :: Int16X8# -> Int16X8#

-- | Negate element-wise.
negateInt32X4# :: Int32X4# -> Int32X4#

-- | Negate element-wise.
negateInt64X2# :: Int64X2# -> Int64X2#

-- | Negate element-wise.
negateInt8X32# :: Int8X32# -> Int8X32#

-- | Negate element-wise.
negateInt16X16# :: Int16X16# -> Int16X16#

-- | Negate element-wise.
negateInt32X8# :: Int32X8# -> Int32X8#

-- | Negate element-wise.
negateInt64X4# :: Int64X4# -> Int64X4#

-- | Negate element-wise.
negateInt8X64# :: Int8X64# -> Int8X64#

-- | Negate element-wise.
negateInt16X32# :: Int16X32# -> Int16X32#

-- | Negate element-wise.
negateInt32X16# :: Int32X16# -> Int32X16#

-- | Negate element-wise.
negateInt64X8# :: Int64X8# -> Int64X8#

-- | Negate element-wise.
negateFloatX4# :: FloatX4# -> FloatX4#

-- | Negate element-wise.
negateDoubleX2# :: DoubleX2# -> DoubleX2#

-- | Negate element-wise.
negateFloatX8# :: FloatX8# -> FloatX8#

-- | Negate element-wise.
negateDoubleX4# :: DoubleX4# -> DoubleX4#

-- | Negate element-wise.
negateFloatX16# :: FloatX16# -> FloatX16#

-- | Negate element-wise.
negateDoubleX8# :: DoubleX8# -> DoubleX8#

-- | Read a vector from specified index of immutable array.
indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array.
indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array.
indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array.
indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array.
indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array.
indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array.
indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array.
indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array.
indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array.
indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array.
indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array.
indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array.
indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array.
indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array.
indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array.
indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array.
indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array.
indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array.
indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array.
indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array.
indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array.
indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array.
indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array.
indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array.
indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array.
indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array.
indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array.
indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array.
indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array.
indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a vector from specified index of mutable array.
readInt8X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Read a vector from specified index of mutable array.
readInt16X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Read a vector from specified index of mutable array.
readInt32X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Read a vector from specified index of mutable array.
readInt64X2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Read a vector from specified index of mutable array.
readInt8X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Read a vector from specified index of mutable array.
readInt16X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Read a vector from specified index of mutable array.
readInt32X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Read a vector from specified index of mutable array.
readInt64X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Read a vector from specified index of mutable array.
readInt8X64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Read a vector from specified index of mutable array.
readInt16X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Read a vector from specified index of mutable array.
readInt32X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Read a vector from specified index of mutable array.
readInt64X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Read a vector from specified index of mutable array.
readWord8X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Read a vector from specified index of mutable array.
readWord16X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Read a vector from specified index of mutable array.
readWord32X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Read a vector from specified index of mutable array.
readWord64X2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Read a vector from specified index of mutable array.
readWord8X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Read a vector from specified index of mutable array.
readWord16X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Read a vector from specified index of mutable array.
readWord32X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Read a vector from specified index of mutable array.
readWord64X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Read a vector from specified index of mutable array.
readWord8X64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Read a vector from specified index of mutable array.
readWord16X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Read a vector from specified index of mutable array.
readWord32X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Read a vector from specified index of mutable array.
readWord64X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Read a vector from specified index of mutable array.
readFloatX4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Read a vector from specified index of mutable array.
readDoubleX2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Read a vector from specified index of mutable array.
readFloatX8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Read a vector from specified index of mutable array.
readDoubleX4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Read a vector from specified index of mutable array.
readFloatX16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Read a vector from specified index of mutable array.
readDoubleX8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write a vector to specified index of mutable array.
writeInt8X16Array# :: MutableByteArray# s -> Int# -> Int8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt16X8Array# :: MutableByteArray# s -> Int# -> Int16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt32X4Array# :: MutableByteArray# s -> Int# -> Int32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt64X2Array# :: MutableByteArray# s -> Int# -> Int64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt8X32Array# :: MutableByteArray# s -> Int# -> Int8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt16X16Array# :: MutableByteArray# s -> Int# -> Int16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt32X8Array# :: MutableByteArray# s -> Int# -> Int32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt64X4Array# :: MutableByteArray# s -> Int# -> Int64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt8X64Array# :: MutableByteArray# s -> Int# -> Int8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt16X32Array# :: MutableByteArray# s -> Int# -> Int16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt32X16Array# :: MutableByteArray# s -> Int# -> Int32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeInt64X8Array# :: MutableByteArray# s -> Int# -> Int64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord8X16Array# :: MutableByteArray# s -> Int# -> Word8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord16X8Array# :: MutableByteArray# s -> Int# -> Word16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord32X4Array# :: MutableByteArray# s -> Int# -> Word32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord64X2Array# :: MutableByteArray# s -> Int# -> Word64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord8X32Array# :: MutableByteArray# s -> Int# -> Word8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord16X16Array# :: MutableByteArray# s -> Int# -> Word16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord32X8Array# :: MutableByteArray# s -> Int# -> Word32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord64X4Array# :: MutableByteArray# s -> Int# -> Word64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord8X64Array# :: MutableByteArray# s -> Int# -> Word8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord16X32Array# :: MutableByteArray# s -> Int# -> Word16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord32X16Array# :: MutableByteArray# s -> Int# -> Word32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeWord64X8Array# :: MutableByteArray# s -> Int# -> Word64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeFloatX4Array# :: MutableByteArray# s -> Int# -> FloatX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeDoubleX2Array# :: MutableByteArray# s -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeFloatX8Array# :: MutableByteArray# s -> Int# -> FloatX8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeDoubleX4Array# :: MutableByteArray# s -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeFloatX16Array# :: MutableByteArray# s -> Int# -> FloatX16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
writeDoubleX8Array# :: MutableByteArray# s -> Int# -> DoubleX8# -> State# s -> State# s

-- | Reads vector; offset in bytes.
indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#

-- | Reads vector; offset in bytes.
indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#

-- | Reads vector; offset in bytes.
indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in bytes.
indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in bytes.
indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in bytes.
indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in bytes.
indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#

-- | Reads vector; offset in bytes.
indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in bytes.
indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#

-- | Reads vector; offset in bytes.
indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in bytes.
indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in bytes.
indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#

-- | Reads vector; offset in bytes.
indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in bytes.
indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#

-- | Reads vector; offset in bytes.
indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in bytes.
indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in bytes.
indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in bytes.
indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in bytes.
indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#

-- | Reads vector; offset in bytes.
indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in bytes.
indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#

-- | Reads vector; offset in bytes.
indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in bytes.
indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in bytes.
indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#

-- | Reads vector; offset in bytes.
indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in bytes.
indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in bytes.
indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#

-- | Reads vector; offset in bytes.
indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in bytes.
indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in bytes.
indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#

-- | Reads vector; offset in bytes.
readInt8X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Reads vector; offset in bytes.
readInt16X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Reads vector; offset in bytes.
readInt32X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Reads vector; offset in bytes.
readInt64X2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Reads vector; offset in bytes.
readInt8X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Reads vector; offset in bytes.
readInt16X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Reads vector; offset in bytes.
readInt32X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Reads vector; offset in bytes.
readInt64X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Reads vector; offset in bytes.
readInt8X64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Reads vector; offset in bytes.
readInt16X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Reads vector; offset in bytes.
readInt32X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Reads vector; offset in bytes.
readInt64X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Reads vector; offset in bytes.
readWord8X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Reads vector; offset in bytes.
readWord16X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Reads vector; offset in bytes.
readWord32X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Reads vector; offset in bytes.
readWord64X2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Reads vector; offset in bytes.
readWord8X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Reads vector; offset in bytes.
readWord16X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Reads vector; offset in bytes.
readWord32X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Reads vector; offset in bytes.
readWord64X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Reads vector; offset in bytes.
readWord8X64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Reads vector; offset in bytes.
readWord16X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Reads vector; offset in bytes.
readWord32X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Reads vector; offset in bytes.
readWord64X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Reads vector; offset in bytes.
readFloatX4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Reads vector; offset in bytes.
readDoubleX2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Reads vector; offset in bytes.
readFloatX8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Reads vector; offset in bytes.
readDoubleX4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Reads vector; offset in bytes.
readFloatX16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Reads vector; offset in bytes.
readDoubleX8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write vector; offset in bytes.
writeInt8X16OffAddr# :: Addr# -> Int# -> Int8X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt16X8OffAddr# :: Addr# -> Int# -> Int16X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt32X4OffAddr# :: Addr# -> Int# -> Int32X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt64X2OffAddr# :: Addr# -> Int# -> Int64X2# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt8X32OffAddr# :: Addr# -> Int# -> Int8X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt16X16OffAddr# :: Addr# -> Int# -> Int16X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt32X8OffAddr# :: Addr# -> Int# -> Int32X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt64X4OffAddr# :: Addr# -> Int# -> Int64X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt8X64OffAddr# :: Addr# -> Int# -> Int8X64# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt16X32OffAddr# :: Addr# -> Int# -> Int16X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt32X16OffAddr# :: Addr# -> Int# -> Int32X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeInt64X8OffAddr# :: Addr# -> Int# -> Int64X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord8X16OffAddr# :: Addr# -> Int# -> Word8X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord16X8OffAddr# :: Addr# -> Int# -> Word16X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord32X4OffAddr# :: Addr# -> Int# -> Word32X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord64X2OffAddr# :: Addr# -> Int# -> Word64X2# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord8X32OffAddr# :: Addr# -> Int# -> Word8X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord16X16OffAddr# :: Addr# -> Int# -> Word16X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord32X8OffAddr# :: Addr# -> Int# -> Word32X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord64X4OffAddr# :: Addr# -> Int# -> Word64X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord8X64OffAddr# :: Addr# -> Int# -> Word8X64# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord16X32OffAddr# :: Addr# -> Int# -> Word16X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord32X16OffAddr# :: Addr# -> Int# -> Word32X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeWord64X8OffAddr# :: Addr# -> Int# -> Word64X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeFloatX4OffAddr# :: Addr# -> Int# -> FloatX4# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeFloatX8OffAddr# :: Addr# -> Int# -> FloatX8# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeFloatX16OffAddr# :: Addr# -> Int# -> FloatX16# -> State# s -> State# s

-- | Write vector; offset in bytes.
writeDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8# -> State# s -> State# s

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt8ArrayAsInt8X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt16ArrayAsInt16X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt32ArrayAsInt32X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt64ArrayAsInt64X2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt8ArrayAsInt8X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt16ArrayAsInt16X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt32ArrayAsInt32X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt64ArrayAsInt64X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt8ArrayAsInt8X64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt16ArrayAsInt16X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt32ArrayAsInt32X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt64ArrayAsInt64X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord8ArrayAsWord8X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord16ArrayAsWord16X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord32ArrayAsWord32X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord64ArrayAsWord64X2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord8ArrayAsWord8X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord16ArrayAsWord16X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord32ArrayAsWord32X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord64ArrayAsWord64X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord8ArrayAsWord8X64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord16ArrayAsWord16X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord32ArrayAsWord32X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord64ArrayAsWord64X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readFloatArrayAsFloatX4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readDoubleArrayAsDoubleX2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readFloatArrayAsFloatX8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readDoubleArrayAsDoubleX4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readFloatArrayAsFloatX16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readDoubleArrayAsDoubleX8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt8ArrayAsInt8X16# :: MutableByteArray# s -> Int# -> Int8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt16ArrayAsInt16X8# :: MutableByteArray# s -> Int# -> Int16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt32ArrayAsInt32X4# :: MutableByteArray# s -> Int# -> Int32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt64ArrayAsInt64X2# :: MutableByteArray# s -> Int# -> Int64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt8ArrayAsInt8X32# :: MutableByteArray# s -> Int# -> Int8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt16ArrayAsInt16X16# :: MutableByteArray# s -> Int# -> Int16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt32ArrayAsInt32X8# :: MutableByteArray# s -> Int# -> Int32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt64ArrayAsInt64X4# :: MutableByteArray# s -> Int# -> Int64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt8ArrayAsInt8X64# :: MutableByteArray# s -> Int# -> Int8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt16ArrayAsInt16X32# :: MutableByteArray# s -> Int# -> Int16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt32ArrayAsInt32X16# :: MutableByteArray# s -> Int# -> Int32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt64ArrayAsInt64X8# :: MutableByteArray# s -> Int# -> Int64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord8ArrayAsWord8X16# :: MutableByteArray# s -> Int# -> Word8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord16ArrayAsWord16X8# :: MutableByteArray# s -> Int# -> Word16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord32ArrayAsWord32X4# :: MutableByteArray# s -> Int# -> Word32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord64ArrayAsWord64X2# :: MutableByteArray# s -> Int# -> Word64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord8ArrayAsWord8X32# :: MutableByteArray# s -> Int# -> Word8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord16ArrayAsWord16X16# :: MutableByteArray# s -> Int# -> Word16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord32ArrayAsWord32X8# :: MutableByteArray# s -> Int# -> Word32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord64ArrayAsWord64X4# :: MutableByteArray# s -> Int# -> Word64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord8ArrayAsWord8X64# :: MutableByteArray# s -> Int# -> Word8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord16ArrayAsWord16X32# :: MutableByteArray# s -> Int# -> Word16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord32ArrayAsWord32X16# :: MutableByteArray# s -> Int# -> Word32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord64ArrayAsWord64X8# :: MutableByteArray# s -> Int# -> Word64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeFloatArrayAsFloatX4# :: MutableByteArray# s -> Int# -> FloatX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeDoubleArrayAsDoubleX2# :: MutableByteArray# s -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeFloatArrayAsFloatX8# :: MutableByteArray# s -> Int# -> FloatX8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeDoubleArrayAsDoubleX4# :: MutableByteArray# s -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeFloatArrayAsFloatX16# :: MutableByteArray# s -> Int# -> FloatX16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeDoubleArrayAsDoubleX8# :: MutableByteArray# s -> Int# -> DoubleX8# -> State# s -> State# s

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#

-- | Reads vector; offset in scalar elements.
readInt8OffAddrAsInt8X16# :: Addr# -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Reads vector; offset in scalar elements.
readInt16OffAddrAsInt16X8# :: Addr# -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Reads vector; offset in scalar elements.
readInt32OffAddrAsInt32X4# :: Addr# -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Reads vector; offset in scalar elements.
readInt64OffAddrAsInt64X2# :: Addr# -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Reads vector; offset in scalar elements.
readInt8OffAddrAsInt8X32# :: Addr# -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Reads vector; offset in scalar elements.
readInt16OffAddrAsInt16X16# :: Addr# -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Reads vector; offset in scalar elements.
readInt32OffAddrAsInt32X8# :: Addr# -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Reads vector; offset in scalar elements.
readInt64OffAddrAsInt64X4# :: Addr# -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Reads vector; offset in scalar elements.
readInt8OffAddrAsInt8X64# :: Addr# -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Reads vector; offset in scalar elements.
readInt16OffAddrAsInt16X32# :: Addr# -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Reads vector; offset in scalar elements.
readInt32OffAddrAsInt32X16# :: Addr# -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Reads vector; offset in scalar elements.
readInt64OffAddrAsInt64X8# :: Addr# -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Reads vector; offset in scalar elements.
readWord8OffAddrAsWord8X16# :: Addr# -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Reads vector; offset in scalar elements.
readWord16OffAddrAsWord16X8# :: Addr# -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Reads vector; offset in scalar elements.
readWord32OffAddrAsWord32X4# :: Addr# -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Reads vector; offset in scalar elements.
readWord64OffAddrAsWord64X2# :: Addr# -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Reads vector; offset in scalar elements.
readWord8OffAddrAsWord8X32# :: Addr# -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Reads vector; offset in scalar elements.
readWord16OffAddrAsWord16X16# :: Addr# -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Reads vector; offset in scalar elements.
readWord32OffAddrAsWord32X8# :: Addr# -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Reads vector; offset in scalar elements.
readWord64OffAddrAsWord64X4# :: Addr# -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Reads vector; offset in scalar elements.
readWord8OffAddrAsWord8X64# :: Addr# -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Reads vector; offset in scalar elements.
readWord16OffAddrAsWord16X32# :: Addr# -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Reads vector; offset in scalar elements.
readWord32OffAddrAsWord32X16# :: Addr# -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Reads vector; offset in scalar elements.
readWord64OffAddrAsWord64X8# :: Addr# -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Reads vector; offset in scalar elements.
readFloatOffAddrAsFloatX4# :: Addr# -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Reads vector; offset in scalar elements.
readDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Reads vector; offset in scalar elements.
readFloatOffAddrAsFloatX8# :: Addr# -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Reads vector; offset in scalar elements.
readDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Reads vector; offset in scalar elements.
readFloatOffAddrAsFloatX16# :: Addr# -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Reads vector; offset in scalar elements.
readDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write vector; offset in scalar elements.
writeInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
writeDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8# -> State# s -> State# s
prefetchByteArray3# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray3# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr3# :: Addr# -> Int# -> State# s -> State# s
prefetchValue3# :: a -> State# s -> State# s
prefetchByteArray2# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray2# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr2# :: Addr# -> Int# -> State# s -> State# s
prefetchValue2# :: a -> State# s -> State# s
prefetchByteArray1# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray1# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr1# :: Addr# -> Int# -> State# s -> State# s
prefetchValue1# :: a -> State# s -> State# s
prefetchByteArray0# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray0# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr0# :: Addr# -> Int# -> State# s -> State# s
prefetchValue0# :: a -> State# s -> State# s


-- | GHC C strings definitions (previously in GHC.Base). Use GHC.Exts from
--   the base package instead of importing this module directly.
module GHC.CString
unpackCString# :: Addr# -> [Char]
unpackAppendCString# :: Addr# -> [Char] -> [Char]
unpackFoldrCString# :: Addr# -> (Char -> a -> a) -> a -> a
unpackCStringUtf8# :: Addr# -> [Char]
unpackNBytes# :: Addr# -> Int# -> [Char]


-- | The tuple data types
module GHC.Tuple

-- | The unit datatype <tt>()</tt> has one non-undefined member, the
--   nullary constructor <tt>()</tt>.
data ()
() :: ()
data Unit a
Unit :: a -> Unit a
data (,) a b
(,) :: a -> b -> (,) a b
data (,,) a b c
(,,) :: a -> b -> c -> (,,) a b c
data (,,,) a b c d
(,,,) :: a -> b -> c -> d -> (,,,) a b c d
data (,,,,) a b c d e
(,,,,) :: a -> b -> c -> d -> e -> (,,,,) a b c d e
data (,,,,,) a b c d e f
(,,,,,) :: a -> b -> c -> d -> e -> f -> (,,,,,) a b c d e f
data (,,,,,,) a b c d e f g
(,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> (,,,,,,) a b c d e f g
data (,,,,,,,) a b c d e f g h
(,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> (,,,,,,,) a b c d e f g h
data (,,,,,,,,) a b c d e f g h i
(,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> (,,,,,,,,) a b c d e f g h i
data (,,,,,,,,,) a b c d e f g h i j
(,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (,,,,,,,,,) a b c d e f g h i j
data (,,,,,,,,,,) a b c d e f g h i j k
(,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (,,,,,,,,,,) a b c d e f g h i j k
data (,,,,,,,,,,,) a b c d e f g h i j k l
(,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> (,,,,,,,,,,,) a b c d e f g h i j k l
data (,,,,,,,,,,,,) a b c d e f g h i j k l m
(,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (,,,,,,,,,,,,) a b c d e f g h i j k l m
data (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
(,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
data (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
(,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
data (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
(,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
data (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
(,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
data (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
(,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
data (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
(,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
data (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
(,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
data (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
(,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
data (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v
(,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v
data (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w
(,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w
data (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x
(,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x
data (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y
(,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y
data (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z
(,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z
data (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1
(,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> g2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> g2 -> h2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> g2 -> h2 -> i2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2 j2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> g2 -> h2 -> i2 -> j2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2 j2

module GHC.PrimopWrappers
gtChar# :: Char# -> Char# -> Int#
geChar# :: Char# -> Char# -> Int#
eqChar# :: Char# -> Char# -> Int#
neChar# :: Char# -> Char# -> Int#
ltChar# :: Char# -> Char# -> Int#
leChar# :: Char# -> Char# -> Int#
ord# :: Char# -> Int#
(+#) :: Int# -> Int# -> Int#
(-#) :: Int# -> Int# -> Int#
(*#) :: Int# -> Int# -> Int#
mulIntMayOflo# :: Int# -> Int# -> Int#
quotInt# :: Int# -> Int# -> Int#
remInt# :: Int# -> Int# -> Int#
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
andI# :: Int# -> Int# -> Int#
orI# :: Int# -> Int# -> Int#
xorI# :: Int# -> Int# -> Int#
notI# :: Int# -> Int#
negateInt# :: Int# -> Int#
addIntC# :: Int# -> Int# -> (# Int#, Int# #)
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
(>#) :: Int# -> Int# -> Int#
(>=#) :: Int# -> Int# -> Int#
(==#) :: Int# -> Int# -> Int#
(/=#) :: Int# -> Int# -> Int#
(<#) :: Int# -> Int# -> Int#
(<=#) :: Int# -> Int# -> Int#
chr# :: Int# -> Char#
int2Word# :: Int# -> Word#
int2Float# :: Int# -> Float#
int2Double# :: Int# -> Double#
word2Float# :: Word# -> Float#
word2Double# :: Word# -> Double#
uncheckedIShiftL# :: Int# -> Int# -> Int#
uncheckedIShiftRA# :: Int# -> Int# -> Int#
uncheckedIShiftRL# :: Int# -> Int# -> Int#
plusWord# :: Word# -> Word# -> Word#
addWordC# :: Word# -> Word# -> (# Word#, Int# #)
subWordC# :: Word# -> Word# -> (# Word#, Int# #)
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
minusWord# :: Word# -> Word# -> Word#
timesWord# :: Word# -> Word# -> Word#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
quotWord# :: Word# -> Word# -> Word#
remWord# :: Word# -> Word# -> Word#
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
and# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
xor# :: Word# -> Word# -> Word#
not# :: Word# -> Word#
uncheckedShiftL# :: Word# -> Int# -> Word#
uncheckedShiftRL# :: Word# -> Int# -> Word#
word2Int# :: Word# -> Int#
gtWord# :: Word# -> Word# -> Int#
geWord# :: Word# -> Word# -> Int#
eqWord# :: Word# -> Word# -> Int#
neWord# :: Word# -> Word# -> Int#
ltWord# :: Word# -> Word# -> Int#
leWord# :: Word# -> Word# -> Int#
popCnt8# :: Word# -> Word#
popCnt16# :: Word# -> Word#
popCnt32# :: Word# -> Word#
popCnt64# :: Word# -> Word#
popCnt# :: Word# -> Word#
pdep8# :: Word# -> Word# -> Word#
pdep16# :: Word# -> Word# -> Word#
pdep32# :: Word# -> Word# -> Word#
pdep64# :: Word# -> Word# -> Word#
pdep# :: Word# -> Word# -> Word#
pext8# :: Word# -> Word# -> Word#
pext16# :: Word# -> Word# -> Word#
pext32# :: Word# -> Word# -> Word#
pext64# :: Word# -> Word# -> Word#
pext# :: Word# -> Word# -> Word#
clz8# :: Word# -> Word#
clz16# :: Word# -> Word#
clz32# :: Word# -> Word#
clz64# :: Word# -> Word#
clz# :: Word# -> Word#
ctz8# :: Word# -> Word#
ctz16# :: Word# -> Word#
ctz32# :: Word# -> Word#
ctz64# :: Word# -> Word#
ctz# :: Word# -> Word#
byteSwap16# :: Word# -> Word#
byteSwap32# :: Word# -> Word#
byteSwap64# :: Word# -> Word#
byteSwap# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow32Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow32Word# :: Word# -> Word#
(>##) :: Double# -> Double# -> Int#
(>=##) :: Double# -> Double# -> Int#
(==##) :: Double# -> Double# -> Int#
(/=##) :: Double# -> Double# -> Int#
(<##) :: Double# -> Double# -> Int#
(<=##) :: Double# -> Double# -> Int#
(+##) :: Double# -> Double# -> Double#
(-##) :: Double# -> Double# -> Double#
(*##) :: Double# -> Double# -> Double#
(/##) :: Double# -> Double# -> Double#
negateDouble# :: Double# -> Double#
fabsDouble# :: Double# -> Double#
double2Int# :: Double# -> Int#
double2Float# :: Double# -> Float#
expDouble# :: Double# -> Double#
logDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#
asinDouble# :: Double# -> Double#
acosDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#
(**##) :: Double# -> Double# -> Double#
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)
decodeDouble_Int64# :: Double# -> (# Int#, Int# #)
gtFloat# :: Float# -> Float# -> Int#
geFloat# :: Float# -> Float# -> Int#
eqFloat# :: Float# -> Float# -> Int#
neFloat# :: Float# -> Float# -> Int#
ltFloat# :: Float# -> Float# -> Int#
leFloat# :: Float# -> Float# -> Int#
plusFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#
divideFloat# :: Float# -> Float# -> Float#
negateFloat# :: Float# -> Float#
fabsFloat# :: Float# -> Float#
float2Int# :: Float# -> Int#
expFloat# :: Float# -> Float#
logFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#
asinFloat# :: Float# -> Float#
acosFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
powerFloat# :: Float# -> Float# -> Float#
float2Double# :: Float# -> Double#
decodeFloat_Int# :: Float# -> (# Int#, Int# #)
newArray# :: Int# -> a -> State# s -> (# State# s, MutableArray# s a #)
sameMutableArray# :: MutableArray# s a -> MutableArray# s a -> Int#
readArray# :: MutableArray# s a -> Int# -> State# s -> (# State# s, a #)
writeArray# :: MutableArray# s a -> Int# -> a -> State# s -> State# s
sizeofArray# :: Array# a -> Int#
sizeofMutableArray# :: MutableArray# s a -> Int#
indexArray# :: Array# a -> Int# -> (# a #)
unsafeFreezeArray# :: MutableArray# s a -> State# s -> (# State# s, Array# a #)
unsafeThawArray# :: Array# a -> State# s -> (# State# s, MutableArray# s a #)
copyArray# :: Array# a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s
copyMutableArray# :: MutableArray# s a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s
cloneArray# :: Array# a -> Int# -> Int# -> Array# a
cloneMutableArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)
freezeArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, Array# a #)
thawArray# :: Array# a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)
casArray# :: MutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s, Int#, a #)
newSmallArray# :: Int# -> a -> State# s -> (# State# s, SmallMutableArray# s a #)
sameSmallMutableArray# :: SmallMutableArray# s a -> SmallMutableArray# s a -> Int#
readSmallArray# :: SmallMutableArray# s a -> Int# -> State# s -> (# State# s, a #)
writeSmallArray# :: SmallMutableArray# s a -> Int# -> a -> State# s -> State# s
sizeofSmallArray# :: SmallArray# a -> Int#
sizeofSmallMutableArray# :: SmallMutableArray# s a -> Int#
indexSmallArray# :: SmallArray# a -> Int# -> (# a #)
unsafeFreezeSmallArray# :: SmallMutableArray# s a -> State# s -> (# State# s, SmallArray# a #)
unsafeThawSmallArray# :: SmallArray# a -> State# s -> (# State# s, SmallMutableArray# s a #)
copySmallArray# :: SmallArray# a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s
copySmallMutableArray# :: SmallMutableArray# s a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s
cloneSmallArray# :: SmallArray# a -> Int# -> Int# -> SmallArray# a
cloneSmallMutableArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s a #)
freezeSmallArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, SmallArray# a #)
thawSmallArray# :: SmallArray# a -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s a #)
casSmallArray# :: SmallMutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s, Int#, a #)
newByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)
newPinnedByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)
newAlignedPinnedByteArray# :: Int# -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
isMutableByteArrayPinned# :: MutableByteArray# s -> Int#
isByteArrayPinned# :: ByteArray# -> Int#
byteArrayContents# :: ByteArray# -> Addr#
sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Int#
shrinkMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> State# s
resizeMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
unsafeFreezeByteArray# :: MutableByteArray# s -> State# s -> (# State# s, ByteArray# #)
sizeofByteArray# :: ByteArray# -> Int#
sizeofMutableByteArray# :: MutableByteArray# s -> Int#
getSizeofMutableByteArray# :: MutableByteArray# s -> State# s -> (# State# s, Int# #)
indexCharArray# :: ByteArray# -> Int# -> Char#
indexWideCharArray# :: ByteArray# -> Int# -> Char#
indexIntArray# :: ByteArray# -> Int# -> Int#
indexWordArray# :: ByteArray# -> Int# -> Word#
indexAddrArray# :: ByteArray# -> Int# -> Addr#
indexFloatArray# :: ByteArray# -> Int# -> Float#
indexDoubleArray# :: ByteArray# -> Int# -> Double#
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a
indexInt8Array# :: ByteArray# -> Int# -> Int#
indexInt16Array# :: ByteArray# -> Int# -> Int#
indexInt32Array# :: ByteArray# -> Int# -> Int#
indexInt64Array# :: ByteArray# -> Int# -> Int#
indexWord8Array# :: ByteArray# -> Int# -> Word#
indexWord16Array# :: ByteArray# -> Int# -> Word#
indexWord32Array# :: ByteArray# -> Int# -> Word#
indexWord64Array# :: ByteArray# -> Int# -> Word#
indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#
indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#
indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#
indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#
indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#
indexWord8ArrayAsStablePtr# :: ByteArray# -> Int# -> StablePtr# a
indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int#
indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int#
indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int#
indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#
indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word#
indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word#
indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word#
indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#
readCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWideCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWordArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readAddrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)
readFloatArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)
readDoubleArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)
readWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)
readWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)
readWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)
readWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
writeCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWideCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWordArray# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeAddrArray# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeFloatArray# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeDoubleArray# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeStablePtrArray# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt16Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt32Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt64Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord16Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord32Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord64Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyMutableByteArray# :: MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# s -> State# s
copyMutableByteArrayToAddr# :: MutableByteArray# s -> Int# -> Addr# -> Int# -> State# s -> State# s
copyAddrToByteArray# :: Addr# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
setByteArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> State# s
atomicReadIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
atomicWriteIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
casIntArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchAddIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchSubIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchAndIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchNandIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchOrIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchXorIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
newArrayArray# :: Int# -> State# s -> (# State# s, MutableArrayArray# s #)
sameMutableArrayArray# :: MutableArrayArray# s -> MutableArrayArray# s -> Int#
unsafeFreezeArrayArray# :: MutableArrayArray# s -> State# s -> (# State# s, ArrayArray# #)
sizeofArrayArray# :: ArrayArray# -> Int#
sizeofMutableArrayArray# :: MutableArrayArray# s -> Int#
indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
readByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ByteArray# #)
readMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
readArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ArrayArray# #)
readMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableArrayArray# s #)
writeByteArrayArray# :: MutableArrayArray# s -> Int# -> ByteArray# -> State# s -> State# s
writeMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> MutableByteArray# s -> State# s -> State# s
writeArrayArrayArray# :: MutableArrayArray# s -> Int# -> ArrayArray# -> State# s -> State# s
writeMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> State# s -> State# s
copyArrayArray# :: ArrayArray# -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
copyMutableArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
plusAddr# :: Addr# -> Int# -> Addr#
minusAddr# :: Addr# -> Addr# -> Int#
remAddr# :: Addr# -> Int# -> Int#
addr2Int# :: Addr# -> Int#
int2Addr# :: Int# -> Addr#
gtAddr# :: Addr# -> Addr# -> Int#
geAddr# :: Addr# -> Addr# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
neAddr# :: Addr# -> Addr# -> Int#
ltAddr# :: Addr# -> Addr# -> Int#
leAddr# :: Addr# -> Addr# -> Int#
indexCharOffAddr# :: Addr# -> Int# -> Char#
indexWideCharOffAddr# :: Addr# -> Int# -> Char#
indexIntOffAddr# :: Addr# -> Int# -> Int#
indexWordOffAddr# :: Addr# -> Int# -> Word#
indexAddrOffAddr# :: Addr# -> Int# -> Addr#
indexFloatOffAddr# :: Addr# -> Int# -> Float#
indexDoubleOffAddr# :: Addr# -> Int# -> Double#
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a
indexInt8OffAddr# :: Addr# -> Int# -> Int#
indexInt16OffAddr# :: Addr# -> Int# -> Int#
indexInt32OffAddr# :: Addr# -> Int# -> Int#
indexInt64OffAddr# :: Addr# -> Int# -> Int#
indexWord8OffAddr# :: Addr# -> Int# -> Word#
indexWord16OffAddr# :: Addr# -> Int# -> Word#
indexWord32OffAddr# :: Addr# -> Int# -> Word#
indexWord64OffAddr# :: Addr# -> Int# -> Word#
readCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readWideCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readIntOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWordOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readAddrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Addr# #)
readFloatOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Float# #)
readDoubleOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWord8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# s -> State# s
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# s -> State# s
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# s -> State# s
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt16OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt32OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt64OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWord8OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord16OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord32OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord64OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
newMutVar# :: a -> State# s -> (# State# s, MutVar# s a #)
readMutVar# :: MutVar# s a -> State# s -> (# State# s, a #)
writeMutVar# :: MutVar# s a -> a -> State# s -> State# s
sameMutVar# :: MutVar# s a -> MutVar# s a -> Int#
atomicModifyMutVar# :: MutVar# s a -> (a -> b) -> State# s -> (# State# s, c #)
casMutVar# :: MutVar# s a -> a -> a -> State# s -> (# State# s, Int#, a #)
catch# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
raise# :: b -> o
raiseIO# :: a -> State# RealWorld -> (# State# RealWorld, b #)
maskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
maskUninterruptible# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
unmaskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)
atomically# :: (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
retry# :: State# RealWorld -> (# State# RealWorld, a #)
catchRetry# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
catchSTM# :: (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
newTVar# :: a -> State# s -> (# State# s, TVar# s a #)
readTVar# :: TVar# s a -> State# s -> (# State# s, a #)
readTVarIO# :: TVar# s a -> State# s -> (# State# s, a #)
writeTVar# :: TVar# s a -> a -> State# s -> State# s
sameTVar# :: TVar# s a -> TVar# s a -> Int#
newMVar# :: State# s -> (# State# s, MVar# s a #)
takeMVar# :: MVar# s a -> State# s -> (# State# s, a #)
tryTakeMVar# :: MVar# s a -> State# s -> (# State# s, Int#, a #)
putMVar# :: MVar# s a -> a -> State# s -> State# s
tryPutMVar# :: MVar# s a -> a -> State# s -> (# State# s, Int# #)
readMVar# :: MVar# s a -> State# s -> (# State# s, a #)
tryReadMVar# :: MVar# s a -> State# s -> (# State# s, Int#, a #)
sameMVar# :: MVar# s a -> MVar# s a -> Int#
isEmptyMVar# :: MVar# s a -> State# s -> (# State# s, Int# #)
delay# :: Int# -> State# s -> State# s
waitRead# :: Int# -> State# s -> State# s
waitWrite# :: Int# -> State# s -> State# s
fork# :: a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
forkOn# :: Int# -> a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
killThread# :: ThreadId# -> a -> State# RealWorld -> State# RealWorld
yield# :: State# RealWorld -> State# RealWorld
myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
labelThread# :: ThreadId# -> Addr# -> State# RealWorld -> State# RealWorld
isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)
noDuplicate# :: State# s -> State# s
threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)
mkWeak# :: o -> b -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)
mkWeakNoFinalizer# :: o -> b -> State# RealWorld -> (# State# RealWorld, Weak# b #)
addCFinalizerToWeak# :: Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)
deRefWeak# :: Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)
finalizeWeak# :: Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
touch# :: o -> State# RealWorld -> State# RealWorld
makeStablePtr# :: a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)
deRefStablePtr# :: StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
eqStablePtr# :: StablePtr# a -> StablePtr# a -> Int#
makeStableName# :: a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
eqStableName# :: StableName# a -> StableName# b -> Int#
stableNameToInt# :: StableName# a -> Int#
compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)
compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld
compactContains# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)
compactContainsAny# :: a -> State# RealWorld -> (# State# RealWorld, Int# #)
compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)
compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)
compactAdd# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
compactAddWithSharing# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)
reallyUnsafePtrEquality# :: a -> a -> Int#
par# :: a -> Int#
spark# :: a -> State# s -> (# State# s, a #)
seq# :: a -> State# s -> (# State# s, a #)
getSpark# :: State# s -> (# State# s, Int#, a #)
numSparks# :: State# s -> (# State# s, Int# #)
dataToTag# :: a -> Int#
addrToAny# :: Addr# -> (# a #)
anyToAddr# :: a -> State# RealWorld -> (# State# RealWorld, Addr# #)
mkApUpd0# :: BCO# -> (# a #)
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# s -> (# State# s, BCO# #)
unpackClosure# :: a -> (# Addr#, ByteArray#, Array# b #)
getApStackVal# :: a -> Int# -> (# Int#, b #)
getCCSOf# :: a -> State# s -> (# State# s, Addr# #)
getCurrentCCS# :: a -> State# s -> (# State# s, Addr# #)
clearCCS# :: (State# s -> (# State# s, a #)) -> State# s -> (# State# s, a #)
traceEvent# :: Addr# -> State# s -> State# s
traceMarker# :: Addr# -> State# s -> State# s
getThreadAllocationCounter# :: State# RealWorld -> (# State# RealWorld, Int# #)
setThreadAllocationCounter# :: Int# -> State# RealWorld -> State# RealWorld
prefetchByteArray3# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray3# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr3# :: Addr# -> Int# -> State# s -> State# s
prefetchValue3# :: a -> State# s -> State# s
prefetchByteArray2# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray2# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr2# :: Addr# -> Int# -> State# s -> State# s
prefetchValue2# :: a -> State# s -> State# s
prefetchByteArray1# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray1# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr1# :: Addr# -> Int# -> State# s -> State# s
prefetchValue1# :: a -> State# s -> State# s
prefetchByteArray0# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray0# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr0# :: Addr# -> Int# -> State# s -> State# s
prefetchValue0# :: a -> State# s -> State# s

module GHC.Debug
debugLn :: [Char] -> IO ()
debugErrLn :: [Char] -> IO ()


-- | GHC magic.
--   
--   Use GHC.Exts from the base package instead of importing this module
--   directly.
module GHC.Magic

-- | The call <tt>inline f</tt> arranges that <tt>f</tt> is inlined,
--   regardless of its size. More precisely, the call <tt>inline f</tt>
--   rewrites to the right-hand side of <tt>f</tt>'s definition. This
--   allows the programmer to control inlining from a particular call site
--   rather than the definition site of the function (c.f. <tt>INLINE</tt>
--   pragmas).
--   
--   This inlining occurs regardless of the argument to the call or the
--   size of <tt>f</tt>'s definition; it is unconditional. The main caveat
--   is that <tt>f</tt>'s definition must be visible to the compiler; it is
--   therefore recommended to mark the function with an <tt>INLINABLE</tt>
--   pragma at its definition so that GHC guarantees to record its
--   unfolding regardless of size.
--   
--   If no inlining takes place, the <a>inline</a> function expands to the
--   identity function in Phase zero, so its use imposes no overhead.
inline :: a -> a

-- | The call <tt>noinline f</tt> arranges that <tt>f</tt> will not be
--   inlined. It is removed during CorePrep so that its use imposes no
--   overhead (besides the fact that it blocks inlining.)
noinline :: a -> a

-- | The <a>lazy</a> function restrains strictness analysis a little. The
--   call <tt>lazy e</tt> means the same as <tt>e</tt>, but <a>lazy</a> has
--   a magical property so far as strictness analysis is concerned: it is
--   lazy in its first argument, even though its semantics is strict. After
--   strictness analysis has run, calls to <a>lazy</a> are inlined to be
--   the identity function.
--   
--   This behaviour is occasionally useful when controlling evaluation
--   order. Notably, <a>lazy</a> is used in the library definition of
--   <a>par</a>:
--   
--   <pre>
--   par :: a -&gt; b -&gt; b
--   par x y = case (par# x) of _ -&gt; lazy y
--   </pre>
--   
--   If <a>lazy</a> were not lazy, <tt>par</tt> would look strict in
--   <tt>y</tt> which would defeat the whole purpose of <tt>par</tt>.
--   
--   Like <a>seq</a>, the argument of <a>lazy</a> can have an unboxed type.
lazy :: a -> a

-- | The <a>oneShot</a> function can be used to give a hint to the compiler
--   that its argument will be called at most once, which may (or may not)
--   enable certain optimizations. It can be useful to improve the
--   performance of code in continuation passing style.
--   
--   If <a>oneShot</a> is used wrongly, then it may be that computations
--   whose result that would otherwise be shared are re-evaluated every
--   time they are used. Otherwise, the use of <a>oneShot</a> is safe.
--   
--   <a>oneShot</a> is representation polymorphic: the type variables may
--   refer to lifted or unlifted types.
oneShot :: forall (q :: RuntimeRep) (r :: RuntimeRep) (a :: TYPE q) (b :: TYPE r). (a -> b) -> a -> b

-- | Apply a function to a 'State# RealWorld' token. When manually applying
--   a function to <tt>realWorld#</tt>, it is necessary to use
--   <tt>NOINLINE</tt> to prevent semantically undesirable floating.
--   <a>runRW#</a> is inlined, but only very late in compilation after all
--   floating is complete.
runRW# :: forall (r :: RuntimeRep) (o :: TYPE r). (State# RealWorld -> o) -> o
