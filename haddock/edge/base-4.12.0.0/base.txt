-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Basic libraries
--   
--   This package contains the Standard Haskell <a>Prelude</a> and its
--   support libraries, and a large collection of useful libraries ranging
--   from data structures to parsing combinators and debugging utilities.
@package base
@version 4.12.0.0


-- | Maybe type
module GHC.Maybe

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <tt>error</tt>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Maybe.Maybe a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Maybe.Maybe a)


-- | The arbitrary-precision <a>Natural</a> number type.
--   
--   <b>Note</b>: This is an internal GHC module with an API subject to
--   change. It's recommended use the <a>Numeric.Natural</a> module to
--   import the <a>Natural</a> type.
module GHC.Natural

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><tt>throw</tt>
--   (<tt>Underflow</tt> :: <tt>ArithException</tt>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | in <tt>[0, maxBound::Word]</tt>
NatS# :: GmpLimb# -> Natural

-- | in <tt>]maxBound::Word, +inf[</tt>
--   
--   <b>Invariant</b>: <a>NatJ#</a> is used <i>iff</i> value doesn't fit in
--   <a>NatS#</a> constructor. NB: Order of constructors *must* coincide
--   with <a>Ord</a> relation
NatJ# :: {-# UNPACK #-} !BigNat -> Natural

-- | Construct <a>Natural</a> value from list of <a>Word</a>s.
--   
--   This function is used by GHC for constructing <a>Natural</a> literals.
mkNatural :: [Word] -> Natural

-- | Test whether all internal invariants are satisfied by <a>Natural</a>
--   value
--   
--   This operation is mostly useful for test-suites and/or code which
--   constructs <a>Integer</a> values directly.
isValidNatural :: Natural -> Bool

-- | <a>Natural</a> Addition
plusNatural :: Natural -> Natural -> Natural

-- | <a>Natural</a> subtraction. May <tt><tt>throw</tt>
--   <tt>Underflow</tt></tt>.
minusNatural :: Natural -> Natural -> Natural

-- | <a>Natural</a> subtraction. Returns <a>Nothing</a>s for non-positive
--   results.
minusNaturalMaybe :: Natural -> Natural -> Maybe Natural

-- | <a>Natural</a> multiplication
timesNatural :: Natural -> Natural -> Natural
negateNatural :: Natural -> Natural
signumNatural :: Natural -> Natural
quotRemNatural :: Natural -> Natural -> (Natural, Natural)
quotNatural :: Natural -> Natural -> Natural
remNatural :: Natural -> Natural -> Natural

-- | Compute greatest common divisor.
gcdNatural :: Natural -> Natural -> Natural

-- | compute least common multiplier.
lcmNatural :: Natural -> Natural -> Natural
andNatural :: Natural -> Natural -> Natural
orNatural :: Natural -> Natural -> Natural
xorNatural :: Natural -> Natural -> Natural
bitNatural :: Int# -> Natural
testBitNatural :: Natural -> Int -> Bool
popCountNatural :: Natural -> Int
shiftLNatural :: Natural -> Int -> Natural
shiftRNatural :: Natural -> Int -> Natural

-- | @since 4.X.0.0
naturalToInteger :: Natural -> Integer
naturalToWord :: Natural -> Word
naturalToInt :: Natural -> Int

naturalFromInteger :: Integer -> Natural

-- | Construct <a>Natural</a> from <a>Word</a> value.
wordToNatural :: Word -> Natural

-- | Convert <a>Int</a> to <a>Natural</a>. Throws <tt>Underflow</tt> when
--   passed a negative <a>Int</a>.
intToNatural :: Int -> Natural

-- | Try downcasting <a>Natural</a> to <a>Word</a> value. Returns
--   <a>Nothing</a> if value doesn't fit in <a>Word</a>.
naturalToWordMaybe :: Natural -> Maybe Word

-- | Convert a Word# into a Natural
--   
--   Built-in rule ensures that applications of this function to literal
--   Word# are lifted into Natural literals.
wordToNatural# :: Word# -> Natural

-- | Convert a Word# into a Natural
--   
--   In base we can't use wordToNatural# as built-in rules transform some
--   of them into Natural literals. Use this function instead.
wordToNaturalBase :: Word# -> Natural

-- | "<tt><a>powModNatural</a> <i>b</i> <i>e</i> <i>m</i></tt>" computes
--   base <tt><i>b</i></tt> raised to exponent <tt><i>e</i></tt> modulo
--   <tt><i>m</i></tt>.
powModNatural :: Natural -> Natural -> Natural -> Natural
instance GHC.Classes.Ord GHC.Natural.Natural
instance GHC.Classes.Eq GHC.Natural.Natural


module GHC.Profiling

-- | Stop attributing ticks to cost centres. Allocations will still be
--   attributed.
stopProfTimer :: IO ()

-- | Start attributing ticks to cost centres. This is called by the RTS on
--   startup.
startProfTimer :: IO ()

module GHC.IO.Encoding.CodePage

module GHC.Constants


-- | NB. the contents of this module are only available on Windows.
--   
--   Installing Win32 console handlers.
module GHC.ConsoleHandler


-- | Functions associated with the tuple data types.
module Data.Tuple

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)


-- | The Maybe type, and associated operations.
module Data.Maybe

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <tt>error</tt>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <tt>show</tt> to a <tt>Maybe Int</tt>. If we have <tt>Just
--   n</tt>, we want to show the underlying <a>Int</a> <tt>n</tt>. But if
--   we have <a>Nothing</a>, we return the empty string instead of (for
--   example) "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: Maybe a -> a

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when not given <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]


-- | The List data type and its operations
module GHC.List

-- | <a>map</a> <tt>f xs</tt> is the list obtained by applying <tt>f</tt>
--   to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | <a>filter</a>, applied to a predicate and a list, returns the list of
--   those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | Concatenate a list of lists.
concat :: [[a]] -> [a]

-- | Extract the first element of a list, which must be non-empty.
head :: [a] -> a

-- | Extract the last element of a list, which must be finite and
--   non-empty.
last :: [a] -> a

-- | Extract the elements after the head of a list, which must be
--   non-empty.
tail :: [a] -> [a]

-- | Return all the elements of a list except the last one. The list must
--   be non-empty.
init :: [a] -> [a]

-- | Decompose a list into its head and tail. If the list is empty, returns
--   <a>Nothing</a>. If the list is non-empty, returns <tt><a>Just</a> (x,
--   xs)</tt>, where <tt>x</tt> is the head of the list and <tt>xs</tt> its
--   tail.
uncons :: [a] -> Maybe (a, [a])

-- | Test whether a list is empty.
null :: [a] -> Bool

-- | <i>O(n)</i>. <a>length</a> returns the length of a finite list as an
--   <a>Int</a>. It is an instance of the more general
--   <a>genericLength</a>, the result type of which may be any kind of
--   number.
length :: [a] -> Int

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a list, reduces the
--   list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   The list must be finite.
foldl :: forall a b. (b -> a -> b) -> b -> [a] -> b

-- | A strict version of <a>foldl</a>.
foldl' :: forall a b. (b -> a -> b) -> b -> [a] -> b

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty lists.
foldl1 :: (a -> a -> a) -> [a] -> a

-- | A strict version of <a>foldl1</a>
foldl1' :: (a -> a -> a) -> [a] -> a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | A strictly accumulating version of <a>scanl</a>
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a list, reduces
--   the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
foldr :: (a -> b -> b) -> b -> [a] -> b

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty lists.
foldr1 :: (a -> a -> a) -> [a] -> a

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See 'iterate\''
--   for a strict variant of this function.
iterate :: (a -> a) -> a -> [a]

-- | 'iterate\'' is the strict version of <a>iterate</a>.
--   
--   It ensures that the result of each application of force to weak head
--   normal form before proceeding.
iterate' :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | The <a>sum</a> function computes the sum of a finite list of numbers.
sum :: Num a => [a] -> a

-- | The <a>product</a> function computes the product of a finite list of
--   numbers.
product :: Num a => [a] -> a

-- | <a>maximum</a> returns the maximum value from a list, which must be
--   non-empty, finite, and of an ordered type. It is a special case of
--   <a>maximumBy</a>, which allows the programmer to supply their own
--   comparison function.
maximum :: Ord a => [a] -> a

-- | <a>minimum</a> returns the minimum value from a list, which must be
--   non-empty, finite, and of an ordered type. It is a special case of
--   <a>minimumBy</a>, which allows the programmer to supply their own
--   comparison function.
minimum :: Ord a => [a] -> a

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | <a>and</a> returns the conjunction of a Boolean list. For the result
--   to be <a>True</a>, the list must be finite; <a>False</a>, however,
--   results from a <a>False</a> value at a finite index of a finite or
--   infinite list.
and :: [Bool] -> Bool

-- | <a>or</a> returns the disjunction of a Boolean list. For the result to
--   be <a>False</a>, the list must be finite; <a>True</a>, however,
--   results from a <a>True</a> value at a finite index of a finite or
--   infinite list.
or :: [Bool] -> Bool

-- | Applied to a predicate and a list, <a>any</a> determines if any
--   element of the list satisfies the predicate. For the result to be
--   <a>False</a>, the list must be finite; <a>True</a>, however, results
--   from a <a>True</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
any :: (a -> Bool) -> [a] -> Bool

-- | Applied to a predicate and a list, <a>all</a> determines if all
--   elements of the list satisfy the predicate. For the result to be
--   <a>True</a>, the list must be finite; <a>False</a>, however, results
--   from a <a>False</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
all :: (a -> Bool) -> [a] -> Bool

-- | <a>elem</a> is the list membership predicate, usually written in infix
--   form, e.g., <tt>x `elem` xs</tt>. For the result to be <a>False</a>,
--   the list must be finite; <a>True</a>, however, results from an element
--   equal to <tt>x</tt> found at a finite index of a finite or infinite
--   list.
elem :: Eq a => a -> [a] -> Bool
infix 4 `elem`

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: Eq a => a -> [a] -> Bool
infix 4 `notElem`

-- | <a>lookup</a> <tt>key assocs</tt> looks up a key in an association
--   list.
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | Map a function over a list and concatenate the results.
concatMap :: (a -> [b]) -> [a] -> [b]

-- | <a>zip</a> takes two lists and returns a list of corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums.
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
errorEmptyList :: String -> a

module GHC.Char

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char
eqChar :: Char -> Char -> Bool
neChar :: Char -> Char -> Bool


-- | Functors: uniform action over a parameterized type, generalizing the
--   <a>map</a> function on lists.
module Data.Functor

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor f
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with a
--   constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with a constant <tt>String</tt>, resulting in an
--   <tt><tt>Either</tt> <tt>Int</tt> <tt>String</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <tt>$</tt>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <tt>$</tt> is function application, <a>&lt;$&gt;</a> is
--   function application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with
--   unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with unit, resulting in an <tt><tt>Either</tt>
--   <tt>Int</tt> '()'</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()


-- | Simple combinators working solely on and with functions.
module Data.Function

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>($)</tt> is levity-polymorphic in its result type, so
--   that foo $ True where foo :: Bool -&gt; Int# is well-typed
($) :: forall r a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <tt>fix'</tt> argument, hence the recursion is reintroduced.
fix :: (a -> a) -> a

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<tt>compare</tt> `on`
--   <tt>fst</tt>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`


-- | Equality
module Data.Eq

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=


-- | Safe coercions between data types.
--   
--   More in-depth information can be found on the <a>Roles wiki page</a>
module Data.Coerce

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
coerce :: Coercible a b => a -> b

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k0) (b :: k0)


-- | The <a>Bool</a> type and related functions.
module Data.Bool
data Bool
False :: Bool
True :: Bool

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> x y p</tt>
--   evaluates to <tt>x</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>y</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then y else x</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> x y p</tt> and <tt>if p then y else
--   x</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; x = "bar"; y = "foo"
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   </pre>
bool :: a -> a -> Bool -> a


-- | Basic operations on type-level Booleans.
module Data.Type.Bool

-- | Type-level <a>If</a>. <tt>If True a b</tt> ==&gt; <tt>a</tt>; <tt>If
--   False a b</tt> ==&gt; <tt>b</tt>
type family If cond tru fls

-- | Type-level "and"
type family a && b
infixr 3 &&

-- | Type-level "or"
type family a || b
infixr 2 ||

-- | Type-level "not". An injective type family since <tt>4.10.0.0</tt>.
type family Not a = res | res -> a


-- | This module defines bitwise operations for signed and unsigned
--   integers. Instances of the class <a>Bits</a> for the <a>Int</a> and
--   <a>Integer</a> types are available from this module, and instances for
--   explicitly sized integral types are available from the <a>Data.Int</a>
--   and <a>Data.Word</a> modules.
module Data.Bits

-- | The <a>Bits</a> class defines bitwise operations over integral types.
--   
--   <ul>
--   <li>Bits are numbered from 0 with bit 0 being the least significant
--   bit.</li>
--   </ul>
class Eq a => Bits a

-- | Bitwise "and"
(.&.) :: Bits a => a -> a -> a

-- | Bitwise "or"
(.|.) :: Bits a => a -> a -> a

-- | Bitwise "xor"
xor :: Bits a => a -> a -> a

-- | Reverse all the bits in the argument
complement :: Bits a => a -> a

-- | <tt><a>shift</a> x i</tt> shifts <tt>x</tt> left by <tt>i</tt> bits if
--   <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise. Right
--   shifts perform sign extension on signed number types; i.e. they fill
--   the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   An instance can define either this unified <a>shift</a> or
--   <a>shiftL</a> and <a>shiftR</a>, depending on which is more convenient
--   for the type in question.
shift :: Bits a => a -> Int -> a

-- | <tt><a>rotate</a> x i</tt> rotates <tt>x</tt> left by <tt>i</tt> bits
--   if <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise.
--   
--   For unbounded types like <a>Integer</a>, <a>rotate</a> is equivalent
--   to <a>shift</a>.
--   
--   An instance can define either this unified <a>rotate</a> or
--   <a>rotateL</a> and <a>rotateR</a>, depending on which is more
--   convenient for the type in question.
rotate :: Bits a => a -> Int -> a

-- | <a>zeroBits</a> is the value with all bits unset.
--   
--   The following laws ought to hold (for all valid bit indices
--   <tt><i>n</i></tt>):
--   
--   <ul>
--   <li><pre><a>clearBit</a> <a>zeroBits</a> <i>n</i> ==
--   <a>zeroBits</a></pre></li>
--   <li><pre><a>setBit</a> <a>zeroBits</a> <i>n</i> == <a>bit</a>
--   <i>n</i></pre></li>
--   <li><pre><a>testBit</a> <a>zeroBits</a> <i>n</i> == False</pre></li>
--   <li><pre><a>popCount</a> <a>zeroBits</a> == 0</pre></li>
--   </ul>
--   
--   This method uses <tt><a>clearBit</a> (<a>bit</a> 0) 0</tt> as its
--   default implementation (which ought to be equivalent to
--   <a>zeroBits</a> for types which possess a 0th bit).
zeroBits :: Bits a => a

-- | <tt>bit <i>i</i></tt> is a value with the <tt><i>i</i></tt>th bit set
--   and all other bits clear.
--   
--   Can be implemented using <a>bitDefault</a> if <tt>a</tt> is also an
--   instance of <a>Num</a>.
--   
--   See also <a>zeroBits</a>.
bit :: Bits a => Int -> a

-- | <tt>x `setBit` i</tt> is the same as <tt>x .|. bit i</tt>
setBit :: Bits a => a -> Int -> a

-- | <tt>x `clearBit` i</tt> is the same as <tt>x .&amp;. complement (bit
--   i)</tt>
clearBit :: Bits a => a -> Int -> a

-- | <tt>x `complementBit` i</tt> is the same as <tt>x `xor` bit i</tt>
complementBit :: Bits a => a -> Int -> a

-- | Return <a>True</a> if the <tt>n</tt>th bit of the argument is 1
--   
--   Can be implemented using <a>testBitDefault</a> if <tt>a</tt> is also
--   an instance of <a>Num</a>.
testBit :: Bits a => a -> Int -> Bool

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Returns Nothing for types that do
--   not have a fixed bitsize, like <a>Integer</a>.
bitSizeMaybe :: Bits a => a -> Maybe Int

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. The function <a>bitSize</a> is
--   undefined for types that do not have a fixed bitsize, like
--   <a>Integer</a>.
--   
--   Default implementation based upon <a>bitSizeMaybe</a> provided since
--   4.12.0.0.

-- | <i>Deprecated: Use <a>bitSizeMaybe</a> or <a>finiteBitSize</a>
--   instead</i>
bitSize :: Bits a => a -> Int

-- | Return <a>True</a> if the argument is a signed type. The actual value
--   of the argument is ignored
isSigned :: Bits a => a -> Bool

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
--   
--   An instance can define either this and <a>shiftR</a> or the unified
--   <a>shift</a>, depending on which is more convenient for the type in
--   question.
shiftL :: Bits a => a -> Int -> a

-- | Shift the argument left by the specified number of bits. The result is
--   undefined for negative shift amounts and shift amounts greater or
--   equal to the <a>bitSize</a>.
--   
--   Defaults to <a>shiftL</a> unless defined explicitly by an instance.
unsafeShiftL :: Bits a => a -> Int -> a

-- | Shift the first argument right by the specified number of bits. The
--   result is undefined for negative shift amounts and shift amounts
--   greater or equal to the <a>bitSize</a>.
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   An instance can define either this and <a>shiftL</a> or the unified
--   <a>shift</a>, depending on which is more convenient for the type in
--   question.
shiftR :: Bits a => a -> Int -> a

-- | Shift the first argument right by the specified number of bits, which
--   must be non-negative and smaller than the number of bits in the type.
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   Defaults to <a>shiftR</a> unless defined explicitly by an instance.
unsafeShiftR :: Bits a => a -> Int -> a

-- | Rotate the argument left by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateR</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateL :: Bits a => a -> Int -> a

-- | Rotate the argument right by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateL</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateR :: Bits a => a -> Int -> a

-- | Return the number of set bits in the argument. This number is known as
--   the population count or the Hamming weight.
--   
--   Can be implemented using <a>popCountDefault</a> if <tt>a</tt> is also
--   an instance of <a>Num</a>.
popCount :: Bits a => a -> Int
infixl 7 .&.
infixl 5 .|.
infixl 6 `xor`
infixl 8 `shift`
infixl 8 `rotate`
infixl 8 `shiftL`
infixl 8 `shiftR`
infixl 8 `rotateL`
infixl 8 `rotateR`

-- | The <a>FiniteBits</a> class denotes types with a finite, fixed number
--   of bits.
class Bits b => FiniteBits b

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Moreover, <a>finiteBitSize</a> is
--   total, in contrast to the deprecated <a>bitSize</a> function it
--   replaces.
--   
--   <pre>
--   <a>finiteBitSize</a> = <a>bitSize</a>
--   <a>bitSizeMaybe</a> = <a>Just</a> . <a>finiteBitSize</a>
--   </pre>
finiteBitSize :: FiniteBits b => b -> Int

-- | Count number of zero bits preceding the most significant set bit.
--   
--   <pre>
--   <a>countLeadingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   </pre>
--   
--   <a>countLeadingZeros</a> can be used to compute log base 2 via
--   
--   <pre>
--   logBase2 x = <a>finiteBitSize</a> x - 1 - <a>countLeadingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countLeadingZeros :: FiniteBits b => b -> Int

-- | Count number of zero bits following the least significant set bit.
--   
--   <pre>
--   <a>countTrailingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   <a>countTrailingZeros</a> . <a>negate</a> = <a>countTrailingZeros</a>
--   </pre>
--   
--   The related <a>find-first-set operation</a> can be expressed in terms
--   of <a>countTrailingZeros</a> as follows
--   
--   <pre>
--   findFirstSet x = 1 + <a>countTrailingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countTrailingZeros :: FiniteBits b => b -> Int

-- | Default implementation for <a>bit</a>.
--   
--   Note that: <tt>bitDefault i = 1 <a>shiftL</a> i</tt>
bitDefault :: (Bits a, Num a) => Int -> a

-- | Default implementation for <a>testBit</a>.
--   
--   Note that: <tt>testBitDefault x i = (x .&amp;. bit i) /= 0</tt>
testBitDefault :: (Bits a, Num a) => a -> Int -> Bool

-- | Default implementation for <a>popCount</a>.
--   
--   This implementation is intentionally naive. Instances are expected to
--   provide an optimized implementation for their size.
popCountDefault :: (Bits a, Num a) => a -> Int

-- | Attempt to convert an <a>Integral</a> type <tt>a</tt> to an
--   <a>Integral</a> type <tt>b</tt> using the size of the types as
--   measured by <a>Bits</a> methods.
--   
--   A simpler version of this function is:
--   
--   <pre>
--   toIntegral :: (Integral a, Integral b) =&gt; a -&gt; Maybe b
--   toIntegral x
--     | toInteger x == y = Just (fromInteger y)
--     | otherwise        = Nothing
--     where
--       y = toInteger x
--   </pre>
--   
--   This version requires going through <a>Integer</a>, which can be
--   inefficient. However, <tt>toIntegralSized</tt> is optimized to allow
--   GHC to statically determine the relative type sizes (as measured by
--   <a>bitSizeMaybe</a> and <a>isSigned</a>) and avoid going through
--   <a>Integer</a> for many types. (The implementation uses
--   <a>fromIntegral</a>, which is itself optimized with rules for
--   <tt>base</tt> types but may go through <a>Integer</a> for some type
--   pairs.)
toIntegralSized :: (Integral a, Integral b, Bits a, Bits b) => a -> Maybe b
instance Data.Bits.FiniteBits GHC.Types.Bool
instance Data.Bits.Bits GHC.Types.Int
instance Data.Bits.FiniteBits GHC.Types.Int
instance Data.Bits.Bits GHC.Types.Word
instance Data.Bits.FiniteBits GHC.Types.Word
instance Data.Bits.Bits GHC.Types.Bool
instance Data.Bits.Bits GHC.Integer.Type.Integer
instance Data.Bits.Bits GHC.Natural.Natural


-- | Transitional module providing the <a>MonadFail</a> class and primitive
--   instances.
--   
--   This module can be imported for defining forward compatible
--   <a>MonadFail</a> instances:
--   
--   <pre>
--   import qualified Control.Monad.Fail as Fail
--   
--   instance Monad Foo where
--     (&gt;&gt;=) = {- ...bind impl... -}
--   
--     -- Provide legacy <a>fail</a> implementation for when
--     -- new-style MonadFail desugaring is not enabled.
--     fail = Fail.fail
--   
--   instance Fail.MonadFail Foo where
--     fail = {- ...fail implementation... -}
--   </pre>
--   
--   See
--   <a>https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail</a>
--   for more details.
module Control.Monad.Fail

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <tt>&gt;&gt;=</tt>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <tt>MonadPlus</tt>, a popular definition
--   is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail m
fail :: MonadFail m => String -> m a
instance Control.Monad.Fail.MonadFail GHC.Maybe.Maybe
instance Control.Monad.Fail.MonadFail []
instance Control.Monad.Fail.MonadFail GHC.Types.IO


-- | The arbitrary-precision <a>Natural</a> number type.
module Numeric.Natural

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><tt>throw</tt>
--   (<tt>Underflow</tt> :: <tt>ArithException</tt>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural


-- | This is a library of parser combinators, originally written by Koen
--   Claessen. It parses all alternatives in parallel, so it never keeps
--   hold of the beginning of the input string, a common source of space
--   leaks with other parsers. The '(+++)' choice combinator is genuinely
--   commutative; it makes no difference which branch is "shorter".
module Text.ParserCombinators.ReadP
data ReadP a

-- | Consumes and returns the next character. Fails if there is no input
--   left.
get :: ReadP Char

-- | Look-ahead: returns the part of the input that is left, without
--   consuming it.
look :: ReadP String

-- | Symmetric choice.
(+++) :: ReadP a -> ReadP a -> ReadP a
infixr 5 +++

-- | Local, exclusive, left-biased choice: If left parser locally produces
--   any result at all, then right parser is not used.
(<++) :: ReadP a -> ReadP a -> ReadP a
infixr 5 <++

-- | Transforms a parser into one that does the same, but in addition
--   returns the exact characters read. IMPORTANT NOTE: <a>gather</a> gives
--   a runtime error if its first argument is built using any occurrences
--   of readS_to_P.
gather :: ReadP a -> ReadP (String, a)

-- | Always fails.
pfail :: ReadP a

-- | Succeeds iff we are at the end of input
eof :: ReadP ()

-- | Consumes and returns the next character, if it satisfies the specified
--   predicate.
satisfy :: (Char -> Bool) -> ReadP Char

-- | Parses and returns the specified character.
char :: Char -> ReadP Char

-- | Parses and returns the specified string.
string :: String -> ReadP String

-- | Parses the first zero or more characters satisfying the predicate.
--   Always succeeds, exactly once having consumed all the characters Hence
--   NOT the same as (many (satisfy p))
munch :: (Char -> Bool) -> ReadP String

-- | Parses the first one or more characters satisfying the predicate.
--   Fails if none, else succeeds exactly once having consumed all the
--   characters Hence NOT the same as (many1 (satisfy p))
munch1 :: (Char -> Bool) -> ReadP String

-- | Skips all whitespace.
skipSpaces :: ReadP ()

-- | Combines all parsers in the specified list.
choice :: [ReadP a] -> ReadP a

-- | <tt>count n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt> in
--   sequence. A list of results is returned.
count :: Int -> ReadP a -> ReadP [a]

-- | <tt>between open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and finally <tt>close</tt>. Only the value of <tt>p</tt> is
--   returned.
between :: ReadP open -> ReadP close -> ReadP a -> ReadP a

-- | <tt>option x p</tt> will either parse <tt>p</tt> or return <tt>x</tt>
--   without consuming any input.
option :: a -> ReadP a -> ReadP a

-- | <tt>optional p</tt> optionally parses <tt>p</tt> and always returns
--   <tt>()</tt>.
optional :: ReadP a -> ReadP ()

-- | Parses zero or more occurrences of the given parser.
many :: ReadP a -> ReadP [a]

-- | Parses one or more occurrences of the given parser.
many1 :: ReadP a -> ReadP [a]

-- | Like <a>many</a>, but discards the result.
skipMany :: ReadP a -> ReadP ()

-- | Like <a>many1</a>, but discards the result.
skipMany1 :: ReadP a -> ReadP ()

-- | <tt>sepBy p sep</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>sep</tt>. Returns a list of values returned by
--   <tt>p</tt>.
sepBy :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>sepBy1 p sep</tt> parses one or more occurrences of <tt>p</tt>,
--   separated by <tt>sep</tt>. Returns a list of values returned by
--   <tt>p</tt>.
sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>endBy p sep</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated and ended by <tt>sep</tt>.
endBy :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>endBy p sep</tt> parses one or more occurrences of <tt>p</tt>,
--   separated and ended by <tt>sep</tt>.
endBy1 :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>chainr p op x</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>op</tt>. Returns a value produced by a <i>right</i>
--   associative application of all functions returned by <tt>op</tt>. If
--   there are no occurrences of <tt>p</tt>, <tt>x</tt> is returned.
chainr :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a

-- | <tt>chainl p op x</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>op</tt>. Returns a value produced by a <i>left</i>
--   associative application of all functions returned by <tt>op</tt>. If
--   there are no occurrences of <tt>p</tt>, <tt>x</tt> is returned.
chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a

-- | Like <a>chainl</a>, but parses one or more occurrences of <tt>p</tt>.
chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a

-- | Like <a>chainr</a>, but parses one or more occurrences of <tt>p</tt>.
chainr1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a

-- | <tt>manyTill p end</tt> parses zero or more occurrences of <tt>p</tt>,
--   until <tt>end</tt> succeeds. Returns a list of values returned by
--   <tt>p</tt>.
manyTill :: ReadP a -> ReadP end -> ReadP [a]

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | Converts a parser into a Haskell ReadS-style function. This is the
--   main way in which you can "run" a <a>ReadP</a> parser: the expanded
--   type is <tt> readP_to_S :: ReadP a -&gt; String -&gt; [(a,String)]
--   </tt>
readP_to_S :: ReadP a -> ReadS a

-- | Converts a Haskell ReadS-style function into a parser. Warning: This
--   introduces local backtracking in the resulting parser, and therefore a
--   possible inefficiency.
readS_to_P :: ReadS a -> ReadP a
instance GHC.Base.Functor Text.ParserCombinators.ReadP.P
instance GHC.Base.Functor Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Applicative Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Monad Text.ParserCombinators.ReadP.ReadP
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Alternative Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Applicative Text.ParserCombinators.ReadP.P
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadP.P
instance GHC.Base.Monad Text.ParserCombinators.ReadP.P
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.P
instance GHC.Base.Alternative Text.ParserCombinators.ReadP.P


-- | This library defines parser combinators for precedence parsing.
module Text.ParserCombinators.ReadPrec
data ReadPrec a
type Prec = Int
minPrec :: Prec

-- | Lift a precedence-insensitive <a>ReadP</a> to a <a>ReadPrec</a>.
lift :: ReadP a -> ReadPrec a

-- | <tt>(prec n p)</tt> checks whether the precedence context is less than
--   or equal to <tt>n</tt>, and
--   
--   <ul>
--   <li>if not, fails</li>
--   <li>if so, parses <tt>p</tt> in context <tt>n</tt>.</li>
--   </ul>
prec :: Prec -> ReadPrec a -> ReadPrec a

-- | Increases the precedence context by one.
step :: ReadPrec a -> ReadPrec a

-- | Resets the precedence context to zero.
reset :: ReadPrec a -> ReadPrec a

-- | Consumes and returns the next character. Fails if there is no input
--   left.
get :: ReadPrec Char

-- | Look-ahead: returns the part of the input that is left, without
--   consuming it.
look :: ReadPrec String

-- | Symmetric choice.
(+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a

-- | Local, exclusive, left-biased choice: If left parser locally produces
--   any result at all, then right parser is not used.
(<++) :: ReadPrec a -> ReadPrec a -> ReadPrec a

-- | Always fails.
pfail :: ReadPrec a

-- | Combines all parsers in the specified list.
choice :: [ReadPrec a] -> ReadPrec a
readPrec_to_P :: ReadPrec a -> Int -> ReadP a
readP_to_Prec :: (Int -> ReadP a) -> ReadPrec a
readPrec_to_S :: ReadPrec a -> Int -> ReadS a
readS_to_Prec :: (Int -> ReadS a) -> ReadPrec a
instance GHC.Base.Functor Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.Applicative Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.Monad Text.ParserCombinators.ReadPrec.ReadPrec
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.Alternative Text.ParserCombinators.ReadPrec.ReadPrec


-- | The cut-down Haskell lexer, used by Text.Read
module Text.Read.Lex
data Lexeme

-- | Character literal
Char :: Char -> Lexeme

-- | String literal, with escapes interpreted
String :: String -> Lexeme

-- | Punctuation or reserved symbol, e.g. <tt>(</tt>, <tt>::</tt>
Punc :: String -> Lexeme

-- | Haskell identifier, e.g. <tt>foo</tt>, <tt>Baz</tt>
Ident :: String -> Lexeme

-- | Haskell symbol, e.g. <tt>&gt;&gt;</tt>, <tt>:%</tt>
Symbol :: String -> Lexeme

Number :: Number -> Lexeme
EOF :: Lexeme

data Number

numberToInteger :: Number -> Maybe Integer

numberToFixed :: Integer -> Number -> Maybe (Integer, Integer)

numberToRational :: Number -> Rational

numberToRangedRational :: (Int, Int) -> Number -> Maybe Rational
lex :: ReadP Lexeme

expect :: Lexeme -> ReadP ()

-- | Haskell lexer: returns the lexed string, rather than the lexeme
hsLex :: ReadP String
lexChar :: ReadP Char
readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
readOctP :: (Eq a, Num a) => ReadP a
readDecP :: (Eq a, Num a) => ReadP a
readHexP :: (Eq a, Num a) => ReadP a
isSymbolChar :: Char -> Bool
instance GHC.Show.Show Text.Read.Lex.Lexeme
instance GHC.Classes.Eq Text.Read.Lex.Lexeme
instance GHC.Show.Show Text.Read.Lex.Number
instance GHC.Classes.Eq Text.Read.Lex.Number


-- | Odds and ends, mostly functions for reading and showing
--   <a>RealFloat</a>-like kind of values.
module Numeric

-- | Converts a possibly-negative <a>Real</a> value to a string.
showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS

-- | Shows a <i>non-negative</i> <a>Integral</a> number using the base
--   specified by the first argument, and the character representation
--   specified by the second.
showIntAtBase :: (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 10.
showInt :: Integral a => a -> ShowS

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 16.
showHex :: (Integral a, Show a) => a -> ShowS

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 8.
showOct :: (Integral a, Show a) => a -> ShowS

-- | Show a signed <a>RealFloat</a> value using scientific (exponential)
--   notation (e.g. <tt>2.45e2</tt>, <tt>1.5e-3</tt>).
--   
--   In the call <tt><a>showEFloat</a> digs val</tt>, if <tt>digs</tt> is
--   <a>Nothing</a>, the value is shown to full precision; if <tt>digs</tt>
--   is <tt><a>Just</a> d</tt>, then at most <tt>d</tt> digits after the
--   decimal point are shown.
showEFloat :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   (e.g. <tt>245000</tt>, <tt>0.0015</tt>).
--   
--   In the call <tt><a>showFFloat</a> digs val</tt>, if <tt>digs</tt> is
--   <a>Nothing</a>, the value is shown to full precision; if <tt>digs</tt>
--   is <tt><a>Just</a> d</tt>, then at most <tt>d</tt> digits after the
--   decimal point are shown.
showFFloat :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   for arguments whose absolute value lies between <tt>0.1</tt> and
--   <tt>9,999,999</tt>, and scientific notation otherwise.
--   
--   In the call <tt><a>showGFloat</a> digs val</tt>, if <tt>digs</tt> is
--   <a>Nothing</a>, the value is shown to full precision; if <tt>digs</tt>
--   is <tt><a>Just</a> d</tt>, then at most <tt>d</tt> digits after the
--   decimal point are shown.
showGFloat :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   (e.g. <tt>245000</tt>, <tt>0.0015</tt>).
--   
--   This behaves as <a>showFFloat</a>, except that a decimal point is
--   always guaranteed, even if not needed.
showFFloatAlt :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   for arguments whose absolute value lies between <tt>0.1</tt> and
--   <tt>9,999,999</tt>, and scientific notation otherwise.
--   
--   This behaves as <a>showFFloat</a>, except that a decimal point is
--   always guaranteed, even if not needed.
showGFloatAlt :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value to full precision using standard
--   decimal notation for arguments whose absolute value lies between
--   <tt>0.1</tt> and <tt>9,999,999</tt>, and scientific notation
--   otherwise.
showFloat :: RealFloat a => a -> ShowS

-- | Show a floating-point value in the hexadecimal format, similar to the
--   <tt>%a</tt> specifier in C's printf.
--   
--   <pre>
--   &gt;&gt;&gt; showHFloat (212.21 :: Double) ""
--   "0x1.a86b851eb851fp7"
--   
--   &gt;&gt;&gt; showHFloat (-12.76 :: Float) ""
--   "-0x1.9851ecp3"
--   
--   &gt;&gt;&gt; showHFloat (-0 :: Double) ""
--   "-0x0p+0"
--   </pre>
showHFloat :: RealFloat a => a -> ShowS

-- | <a>floatToDigits</a> takes a base and a non-negative <a>RealFloat</a>
--   number, and returns a list of digits and an exponent. In particular,
--   if <tt>x&gt;=0</tt>, and
--   
--   <pre>
--   floatToDigits base x = ([d1,d2,...,dn], e)
--   </pre>
--   
--   then
--   
--   <ol>
--   <li><pre>n &gt;= 1</pre></li>
--   <li><pre>x = 0.d1d2...dn * (base**e)</pre></li>
--   <li><pre>0 &lt;= di &lt;= base-1</pre></li>
--   </ol>
floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)

-- | Reads a <i>signed</i> <a>Real</a> value, given a reader for an
--   unsigned value.
readSigned :: Real a => ReadS a -> ReadS a

-- | Reads an <i>unsigned</i> <a>Integral</a> value in an arbitrary base.
readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a

-- | Read an unsigned number in decimal notation.
--   
--   <pre>
--   &gt;&gt;&gt; readDec "0644"
--   [(644,"")]
--   </pre>
readDec :: (Eq a, Num a) => ReadS a

-- | Read an unsigned number in octal notation.
--   
--   <pre>
--   &gt;&gt;&gt; readOct "0644"
--   [(420,"")]
--   </pre>
readOct :: (Eq a, Num a) => ReadS a

-- | Read an unsigned number in hexadecimal notation. Both upper or lower
--   case letters are allowed.
--   
--   <pre>
--   &gt;&gt;&gt; readHex "deadbeef"
--   [(3735928559,"")]
--   </pre>
readHex :: (Eq a, Num a) => ReadS a

-- | Reads an <i>unsigned</i> <a>RealFrac</a> value, expressed in decimal
--   scientific notation.
readFloat :: RealFrac a => ReadS a

-- | Reads a non-empty string of decimal digits.
lexDigits :: ReadS String

-- | Converts a <a>Rational</a> value into any type in class
--   <a>RealFloat</a>.
fromRat :: RealFloat a => Rational -> a

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   '(+)', '(*)' and <a>exp</a> are customarily expected to define an
--   exponential field and have the following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = @exp a * exp b</li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class (Fractional a) => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a

-- | <tt><a>log1p</a> x</tt> computes <tt><a>log</a> (1 + x)</tt>, but
--   provides more precise results for small (absolute) values of
--   <tt>x</tt> if possible.
log1p :: Floating a => a -> a

-- | <tt><a>expm1</a> x</tt> computes <tt><a>exp</a> x - 1</tt>, but
--   provides more precise results for small (absolute) values of
--   <tt>x</tt> if possible.
expm1 :: Floating a => a -> a

-- | <tt><a>log1pexp</a> x</tt> computes <tt><a>log</a> (1 + <a>exp</a>
--   x)</tt>, but provides more precise results if possible.
--   
--   Examples:
--   
--   <ul>
--   <li>if <tt>x</tt> is a large negative number, <tt><a>log</a> (1 +
--   <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>log1p</a>.</li>
--   <li>if <tt><a>exp</a> x</tt> is close to <tt>-1</tt>, <tt><a>log</a>
--   (1 + <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>expm1</a>.</li>
--   </ul>
log1pexp :: Floating a => a -> a

-- | <tt><a>log1mexp</a> x</tt> computes <tt><a>log</a> (1 - <a>exp</a>
--   x)</tt>, but provides more precise results if possible.
--   
--   Examples:
--   
--   <ul>
--   <li>if <tt>x</tt> is a large negative number, <tt><a>log</a> (1 -
--   <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>log1p</a>.</li>
--   <li>if <tt><a>exp</a> x</tt> is close to <tt>1</tt>, <tt><a>log</a> (1
--   - <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>expm1</a>.</li>
--   </ul>
log1mexp :: Floating a => a -> a
infixr 8 **


-- | This module is part of the Foreign Function Interface (FFI) and will
--   usually be imported via the module <a>Foreign</a>.
module Foreign.StablePtr

-- | A <i>stable pointer</i> is a reference to a Haskell expression that is
--   guaranteed not to be affected by garbage collection, i.e., it will
--   neither be deallocated nor will the value of the stable pointer itself
--   change during garbage collection (ordinary references may be relocated
--   during garbage collection). Consequently, stable pointers can be
--   passed to foreign code, which can treat it as an opaque reference to a
--   Haskell value.
--   
--   A value of type <tt>StablePtr a</tt> is a stable pointer to a Haskell
--   expression of type <tt>a</tt>.
data {-# CTYPE "HsStablePtr" #-} StablePtr a

-- | Create a stable pointer referring to the given Haskell value.
newStablePtr :: a -> IO (StablePtr a)

-- | Obtain the Haskell value referenced by a stable pointer, i.e., the
--   same value that was passed to the corresponding call to
--   <tt>makeStablePtr</tt>. If the argument to <a>deRefStablePtr</a> has
--   already been freed using <a>freeStablePtr</a>, the behaviour of
--   <a>deRefStablePtr</a> is undefined.
deRefStablePtr :: StablePtr a -> IO a

-- | Dissolve the association between the stable pointer and the Haskell
--   value. Afterwards, if the stable pointer is passed to
--   <a>deRefStablePtr</a> or <a>freeStablePtr</a>, the behaviour is
--   undefined. However, the stable pointer may still be passed to
--   <a>castStablePtrToPtr</a>, but the <tt><a>Ptr</a> ()</tt> value
--   returned by <a>castStablePtrToPtr</a>, in this case, is undefined (in
--   particular, it may be <a>nullPtr</a>). Nevertheless, the call to
--   <a>castStablePtrToPtr</a> is guaranteed not to diverge.
freeStablePtr :: StablePtr a -> IO ()

-- | Coerce a stable pointer to an address. No guarantees are made about
--   the resulting value, except that the original stable pointer can be
--   recovered by <a>castPtrToStablePtr</a>. In particular, the address may
--   not refer to an accessible memory location and any attempt to pass it
--   to the member functions of the class <a>Storable</a> leads to
--   undefined behaviour.
castStablePtrToPtr :: StablePtr a -> Ptr ()

-- | The inverse of <a>castStablePtrToPtr</a>, i.e., we have the identity
--   
--   <pre>
--   sp == castPtrToStablePtr (castStablePtrToPtr sp)
--   </pre>
--   
--   for any stable pointer <tt>sp</tt> on which <a>freeStablePtr</a> has
--   not been executed yet. Moreover, <a>castPtrToStablePtr</a> may only be
--   applied to pointers that have been produced by
--   <a>castStablePtrToPtr</a>.
castPtrToStablePtr :: Ptr () -> StablePtr a

module GHC.Fingerprint.Type
data Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
instance GHC.Classes.Ord GHC.Fingerprint.Type.Fingerprint
instance GHC.Classes.Eq GHC.Fingerprint.Type.Fingerprint
instance GHC.Show.Show GHC.Fingerprint.Type.Fingerprint


-- | The module <a>Foreign.Storable</a> provides most elementary support
--   for marshalling and is part of the language-independent portion of the
--   Foreign Function Interface (FFI), and will normally be imported via
--   the <a>Foreign</a> module.
module Foreign.Storable

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class Storable a

-- | Computes the storage requirements (in bytes) of the argument. The
--   value of the argument is not used.
sizeOf :: Storable a => a -> Int

-- | Computes the alignment constraint of the argument. An alignment
--   constraint <tt>x</tt> is fulfilled by any address divisible by
--   <tt>x</tt>. The value of the argument is not used.
alignment :: Storable a => a -> Int

-- | Read a value from a memory area regarded as an array of values of the
--   same kind. The first argument specifies the start address of the array
--   and the second the index into the array (the first element of the
--   array has index <tt>0</tt>). The following equality holds,
--   
--   <pre>
--   peekElemOff addr idx = IOExts.fixIO $ \result -&gt;
--     peek (addr `plusPtr` (idx * sizeOf result))
--   </pre>
--   
--   Note that this is only a specification, not necessarily the concrete
--   implementation of the function.
peekElemOff :: Storable a => Ptr a -> Int -> IO a

-- | Write a value to a memory area regarded as an array of values of the
--   same kind. The following equality holds:
--   
--   <pre>
--   pokeElemOff addr idx x = 
--     poke (addr `plusPtr` (idx * sizeOf x)) x
--   </pre>
pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()

-- | Read a value from a memory location given by a base address and
--   offset. The following equality holds:
--   
--   <pre>
--   peekByteOff addr off = peek (addr `plusPtr` off)
--   </pre>
peekByteOff :: Storable a => Ptr b -> Int -> IO a

-- | Write a value to a memory location given by a base address and offset.
--   The following equality holds:
--   
--   <pre>
--   pokeByteOff addr off x = poke (addr `plusPtr` off) x
--   </pre>
pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()

-- | Read a value from the given memory location.
--   
--   Note that the peek and poke functions might require properly aligned
--   addresses to function correctly. This is architecture dependent; thus,
--   portable code should ensure that when peeking or poking values of some
--   type <tt>a</tt>, the alignment constraint for <tt>a</tt>, as given by
--   the function <a>alignment</a> is fulfilled.
peek :: Storable a => Ptr a -> IO a

-- | Write the given value to the given memory location. Alignment
--   restrictions might apply; see <a>peek</a>.
poke :: Storable a => Ptr a -> a -> IO ()
instance Foreign.Storable.Storable ()
instance Foreign.Storable.Storable GHC.Types.Bool
instance Foreign.Storable.Storable GHC.Types.Char
instance Foreign.Storable.Storable GHC.Types.Int
instance Foreign.Storable.Storable GHC.Types.Word
instance Foreign.Storable.Storable (GHC.Ptr.Ptr a)
instance Foreign.Storable.Storable (GHC.Ptr.FunPtr a)
instance Foreign.Storable.Storable (GHC.Stable.StablePtr a)
instance Foreign.Storable.Storable GHC.Types.Float
instance Foreign.Storable.Storable GHC.Types.Double
instance Foreign.Storable.Storable GHC.Word.Word8
instance Foreign.Storable.Storable GHC.Word.Word16
instance Foreign.Storable.Storable GHC.Word.Word32
instance Foreign.Storable.Storable GHC.Word.Word64
instance Foreign.Storable.Storable GHC.Int.Int8
instance Foreign.Storable.Storable GHC.Int.Int16
instance Foreign.Storable.Storable GHC.Int.Int32
instance Foreign.Storable.Storable GHC.Int.Int64
instance (Foreign.Storable.Storable a, GHC.Real.Integral a) => Foreign.Storable.Storable (GHC.Real.Ratio a)
instance Foreign.Storable.Storable GHC.Fingerprint.Type.Fingerprint


-- | Signed integer types
module Data.Int

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | 8-bit signed integer type
data {-# CTYPE "HsInt8" #-} Int8

-- | 16-bit signed integer type
data {-# CTYPE "HsInt16" #-} Int16

-- | 32-bit signed integer type
data {-# CTYPE "HsInt32" #-} Int32

-- | 64-bit signed integer type
data {-# CTYPE "HsInt64" #-} Int64


-- | This module provides typed pointers to foreign data. It is part of the
--   Foreign Function Interface (FFI) and will normally be imported via the
--   <a>Foreign</a> module.
module Foreign.Ptr

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data Ptr a

-- | The constant <a>nullPtr</a> contains a distinguished value of
--   <a>Ptr</a> that is not associated with a valid memory location.
nullPtr :: Ptr a

-- | The <a>castPtr</a> function casts a pointer from one type to another.
castPtr :: Ptr a -> Ptr b

-- | Advances the given address by the given offset in bytes.
plusPtr :: Ptr a -> Int -> Ptr b

-- | Given an arbitrary address and an alignment constraint,
--   <a>alignPtr</a> yields the next higher address that fulfills the
--   alignment constraint. An alignment constraint <tt>x</tt> is fulfilled
--   by any address divisible by <tt>x</tt>. This operation is idempotent.
alignPtr :: Ptr a -> Int -> Ptr a

-- | Computes the offset required to get from the second to the first
--   argument. We have
--   
--   <pre>
--   p2 == p1 `plusPtr` (p2 `minusPtr` p1)
--   </pre>
minusPtr :: Ptr a -> Ptr b -> Int

-- | A value of type <tt><a>FunPtr</a> a</tt> is a pointer to a function
--   callable from foreign code. The type <tt>a</tt> will normally be a
--   <i>foreign type</i>, a function type with zero or more arguments where
--   
--   <ul>
--   <li>the argument types are <i>marshallable foreign types</i>, i.e.
--   <a>Char</a>, <a>Int</a>, <a>Double</a>, <a>Float</a>, <a>Bool</a>,
--   <a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>, <a>Word8</a>,
--   <a>Word16</a>, <a>Word32</a>, <a>Word64</a>, <tt><a>Ptr</a> a</tt>,
--   <tt><a>FunPtr</a> a</tt>, <tt><a>StablePtr</a> a</tt> or a renaming of
--   any of these using <tt>newtype</tt>.</li>
--   <li>the return type is either a marshallable foreign type or has the
--   form <tt><a>IO</a> t</tt> where <tt>t</tt> is a marshallable foreign
--   type or <tt>()</tt>.</li>
--   </ul>
--   
--   A value of type <tt><a>FunPtr</a> a</tt> may be a pointer to a foreign
--   function, either returned by another foreign function or imported with
--   a a static address import like
--   
--   <pre>
--   foreign import ccall "stdlib.h &amp;free"
--     p_free :: FunPtr (Ptr a -&gt; IO ())
--   </pre>
--   
--   or a pointer to a Haskell function created using a <i>wrapper</i> stub
--   declared to produce a <a>FunPtr</a> of the correct type. For example:
--   
--   <pre>
--   type Compare = Int -&gt; Int -&gt; Bool
--   foreign import ccall "wrapper"
--     mkCompare :: Compare -&gt; IO (FunPtr Compare)
--   </pre>
--   
--   Calls to wrapper stubs like <tt>mkCompare</tt> allocate storage, which
--   should be released with <a>freeHaskellFunPtr</a> when no longer
--   required.
--   
--   To convert <a>FunPtr</a> values to corresponding Haskell functions,
--   one can define a <i>dynamic</i> stub for the specific foreign type,
--   e.g.
--   
--   <pre>
--   type IntFunction = CInt -&gt; IO ()
--   foreign import ccall "dynamic"
--     mkFun :: FunPtr IntFunction -&gt; IntFunction
--   </pre>
data FunPtr a

-- | The constant <a>nullFunPtr</a> contains a distinguished value of
--   <a>FunPtr</a> that is not associated with a valid memory location.
nullFunPtr :: FunPtr a

-- | Casts a <a>FunPtr</a> to a <a>FunPtr</a> of a different type.
castFunPtr :: FunPtr a -> FunPtr b

-- | Casts a <a>FunPtr</a> to a <a>Ptr</a>.
--   
--   <i>Note:</i> this is valid only on architectures where data and
--   function pointers range over the same set of addresses, and should
--   only be used for bindings to external libraries whose interface
--   already relies on this assumption.
castFunPtrToPtr :: FunPtr a -> Ptr b

-- | Casts a <a>Ptr</a> to a <a>FunPtr</a>.
--   
--   <i>Note:</i> this is valid only on architectures where data and
--   function pointers range over the same set of addresses, and should
--   only be used for bindings to external libraries whose interface
--   already relies on this assumption.
castPtrToFunPtr :: Ptr a -> FunPtr b

-- | Release the storage associated with the given <a>FunPtr</a>, which
--   must have been obtained from a wrapper stub. This should be called
--   whenever the return value from a foreign import wrapper function is no
--   longer required; otherwise, the storage it uses will leak.
freeHaskellFunPtr :: FunPtr a -> IO ()

-- | A signed integral type that can be losslessly converted to and from
--   <tt>Ptr</tt>. This type is also compatible with the C99 type
--   <tt>intptr_t</tt>, and can be marshalled to and from that type safely.
newtype IntPtr
IntPtr :: Int -> IntPtr

-- | casts a <tt>Ptr</tt> to an <tt>IntPtr</tt>
ptrToIntPtr :: Ptr a -> IntPtr

-- | casts an <tt>IntPtr</tt> to a <tt>Ptr</tt>
intPtrToPtr :: IntPtr -> Ptr a

-- | An unsigned integral type that can be losslessly converted to and from
--   <tt>Ptr</tt>. This type is also compatible with the C99 type
--   <tt>uintptr_t</tt>, and can be marshalled to and from that type
--   safely.
newtype WordPtr
WordPtr :: Word -> WordPtr

-- | casts a <tt>Ptr</tt> to a <tt>WordPtr</tt>
ptrToWordPtr :: Ptr a -> WordPtr

-- | casts a <tt>WordPtr</tt> to a <tt>Ptr</tt>
wordPtrToPtr :: WordPtr -> Ptr a
instance GHC.Show.Show Foreign.Ptr.IntPtr
instance GHC.Read.Read Foreign.Ptr.IntPtr
instance Data.Bits.FiniteBits Foreign.Ptr.IntPtr
instance Data.Bits.Bits Foreign.Ptr.IntPtr
instance GHC.Real.Integral Foreign.Ptr.IntPtr
instance GHC.Enum.Bounded Foreign.Ptr.IntPtr
instance GHC.Real.Real Foreign.Ptr.IntPtr
instance Foreign.Storable.Storable Foreign.Ptr.IntPtr
instance GHC.Enum.Enum Foreign.Ptr.IntPtr
instance GHC.Num.Num Foreign.Ptr.IntPtr
instance GHC.Classes.Ord Foreign.Ptr.IntPtr
instance GHC.Classes.Eq Foreign.Ptr.IntPtr
instance GHC.Show.Show Foreign.Ptr.WordPtr
instance GHC.Read.Read Foreign.Ptr.WordPtr
instance Data.Bits.FiniteBits Foreign.Ptr.WordPtr
instance Data.Bits.Bits Foreign.Ptr.WordPtr
instance GHC.Real.Integral Foreign.Ptr.WordPtr
instance GHC.Enum.Bounded Foreign.Ptr.WordPtr
instance GHC.Real.Real Foreign.Ptr.WordPtr
instance Foreign.Storable.Storable Foreign.Ptr.WordPtr
instance GHC.Enum.Enum Foreign.Ptr.WordPtr
instance GHC.Num.Num Foreign.Ptr.WordPtr
instance GHC.Classes.Ord Foreign.Ptr.WordPtr
instance GHC.Classes.Eq Foreign.Ptr.WordPtr


-- | Unsigned integer types.
module Data.Word

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word

-- | 8-bit unsigned integer type
data {-# CTYPE "HsWord8" #-} Word8

-- | 16-bit unsigned integer type
data {-# CTYPE "HsWord16" #-} Word16

-- | 32-bit unsigned integer type
data {-# CTYPE "HsWord32" #-} Word32

-- | 64-bit unsigned integer type
data {-# CTYPE "HsWord64" #-} Word64

-- | Swap bytes in <a>Word16</a>.
byteSwap16 :: Word16 -> Word16

-- | Reverse order of bytes in <a>Word32</a>.
byteSwap32 :: Word32 -> Word32

-- | Reverse order of bytes in <a>Word64</a>.
byteSwap64 :: Word64 -> Word64

module GHC.Clock

-- | Return monotonic time in seconds, since some unspecified starting
--   point
getMonotonicTime :: IO Double

-- | Return monotonic time in nanoseconds, since some unspecified starting
--   point
getMonotonicTimeNSec :: IO Word64


-- | Mapping of C types to corresponding Haskell types.
module Foreign.C.Types

-- | Haskell type representing the C <tt>char</tt> type.
newtype CChar
CChar :: Int8 -> CChar

-- | Haskell type representing the C <tt>signed char</tt> type.
newtype CSChar
CSChar :: Int8 -> CSChar

-- | Haskell type representing the C <tt>unsigned char</tt> type.
newtype CUChar
CUChar :: Word8 -> CUChar

-- | Haskell type representing the C <tt>short</tt> type.
newtype CShort
CShort :: Int16 -> CShort

-- | Haskell type representing the C <tt>unsigned short</tt> type.
newtype CUShort
CUShort :: Word16 -> CUShort

-- | Haskell type representing the C <tt>int</tt> type.
newtype CInt
CInt :: Int32 -> CInt

-- | Haskell type representing the C <tt>unsigned int</tt> type.
newtype CUInt
CUInt :: Word32 -> CUInt

-- | Haskell type representing the C <tt>long</tt> type.
newtype CLong
CLong :: Int64 -> CLong

-- | Haskell type representing the C <tt>unsigned long</tt> type.
newtype CULong
CULong :: Word64 -> CULong

-- | Haskell type representing the C <tt>ptrdiff_t</tt> type.
newtype CPtrdiff
CPtrdiff :: Int64 -> CPtrdiff

-- | Haskell type representing the C <tt>size_t</tt> type.
newtype CSize
CSize :: Word64 -> CSize

-- | Haskell type representing the C <tt>wchar_t</tt> type.
newtype CWchar
CWchar :: Int32 -> CWchar

-- | Haskell type representing the C <tt>sig_atomic_t</tt> type.
newtype CSigAtomic
CSigAtomic :: Int32 -> CSigAtomic

-- | Haskell type representing the C <tt>long long</tt> type.
newtype CLLong
CLLong :: Int64 -> CLLong

-- | Haskell type representing the C <tt>unsigned long long</tt> type.
newtype CULLong
CULLong :: Word64 -> CULLong

-- | Haskell type representing the C <tt>bool</tt> type.
newtype {-# CTYPE "bool" #-} CBool
CBool :: Word8 -> CBool
newtype CIntPtr
CIntPtr :: Int64 -> CIntPtr
newtype CUIntPtr
CUIntPtr :: Word64 -> CUIntPtr
newtype CIntMax
CIntMax :: Int64 -> CIntMax
newtype CUIntMax
CUIntMax :: Word64 -> CUIntMax

-- | Haskell type representing the C <tt>clock_t</tt> type.
newtype CClock
CClock :: Int64 -> CClock

-- | Haskell type representing the C <tt>time_t</tt> type.
newtype CTime
CTime :: Int64 -> CTime

-- | Haskell type representing the C <tt>useconds_t</tt> type.
newtype CUSeconds
CUSeconds :: Word32 -> CUSeconds

-- | Haskell type representing the C <tt>suseconds_t</tt> type.
newtype CSUSeconds
CSUSeconds :: Int64 -> CSUSeconds

-- | Haskell type representing the C <tt>float</tt> type.
newtype CFloat
CFloat :: Float -> CFloat

-- | Haskell type representing the C <tt>double</tt> type.
newtype CDouble
CDouble :: Double -> CDouble

-- | Haskell type representing the C <tt>FILE</tt> type.
data CFile

-- | Haskell type representing the C <tt>fpos_t</tt> type.
data CFpos

-- | Haskell type representing the C <tt>jmp_buf</tt> type.
data CJmpBuf
instance GHC.Show.Show Foreign.C.Types.CUIntMax
instance GHC.Read.Read Foreign.C.Types.CUIntMax
instance Data.Bits.FiniteBits Foreign.C.Types.CUIntMax
instance Data.Bits.Bits Foreign.C.Types.CUIntMax
instance GHC.Real.Integral Foreign.C.Types.CUIntMax
instance GHC.Enum.Bounded Foreign.C.Types.CUIntMax
instance GHC.Real.Real Foreign.C.Types.CUIntMax
instance Foreign.Storable.Storable Foreign.C.Types.CUIntMax
instance GHC.Enum.Enum Foreign.C.Types.CUIntMax
instance GHC.Num.Num Foreign.C.Types.CUIntMax
instance GHC.Classes.Ord Foreign.C.Types.CUIntMax
instance GHC.Classes.Eq Foreign.C.Types.CUIntMax
instance GHC.Show.Show Foreign.C.Types.CIntMax
instance GHC.Read.Read Foreign.C.Types.CIntMax
instance Data.Bits.FiniteBits Foreign.C.Types.CIntMax
instance Data.Bits.Bits Foreign.C.Types.CIntMax
instance GHC.Real.Integral Foreign.C.Types.CIntMax
instance GHC.Enum.Bounded Foreign.C.Types.CIntMax
instance GHC.Real.Real Foreign.C.Types.CIntMax
instance Foreign.Storable.Storable Foreign.C.Types.CIntMax
instance GHC.Enum.Enum Foreign.C.Types.CIntMax
instance GHC.Num.Num Foreign.C.Types.CIntMax
instance GHC.Classes.Ord Foreign.C.Types.CIntMax
instance GHC.Classes.Eq Foreign.C.Types.CIntMax
instance GHC.Show.Show Foreign.C.Types.CUIntPtr
instance GHC.Read.Read Foreign.C.Types.CUIntPtr
instance Data.Bits.FiniteBits Foreign.C.Types.CUIntPtr
instance Data.Bits.Bits Foreign.C.Types.CUIntPtr
instance GHC.Real.Integral Foreign.C.Types.CUIntPtr
instance GHC.Enum.Bounded Foreign.C.Types.CUIntPtr
instance GHC.Real.Real Foreign.C.Types.CUIntPtr
instance Foreign.Storable.Storable Foreign.C.Types.CUIntPtr
instance GHC.Enum.Enum Foreign.C.Types.CUIntPtr
instance GHC.Num.Num Foreign.C.Types.CUIntPtr
instance GHC.Classes.Ord Foreign.C.Types.CUIntPtr
instance GHC.Classes.Eq Foreign.C.Types.CUIntPtr
instance GHC.Show.Show Foreign.C.Types.CIntPtr
instance GHC.Read.Read Foreign.C.Types.CIntPtr
instance Data.Bits.FiniteBits Foreign.C.Types.CIntPtr
instance Data.Bits.Bits Foreign.C.Types.CIntPtr
instance GHC.Real.Integral Foreign.C.Types.CIntPtr
instance GHC.Enum.Bounded Foreign.C.Types.CIntPtr
instance GHC.Real.Real Foreign.C.Types.CIntPtr
instance Foreign.Storable.Storable Foreign.C.Types.CIntPtr
instance GHC.Enum.Enum Foreign.C.Types.CIntPtr
instance GHC.Num.Num Foreign.C.Types.CIntPtr
instance GHC.Classes.Ord Foreign.C.Types.CIntPtr
instance GHC.Classes.Eq Foreign.C.Types.CIntPtr
instance GHC.Show.Show Foreign.C.Types.CSUSeconds
instance GHC.Read.Read Foreign.C.Types.CSUSeconds
instance GHC.Real.Real Foreign.C.Types.CSUSeconds
instance Foreign.Storable.Storable Foreign.C.Types.CSUSeconds
instance GHC.Enum.Enum Foreign.C.Types.CSUSeconds
instance GHC.Num.Num Foreign.C.Types.CSUSeconds
instance GHC.Classes.Ord Foreign.C.Types.CSUSeconds
instance GHC.Classes.Eq Foreign.C.Types.CSUSeconds
instance GHC.Show.Show Foreign.C.Types.CUSeconds
instance GHC.Read.Read Foreign.C.Types.CUSeconds
instance GHC.Real.Real Foreign.C.Types.CUSeconds
instance Foreign.Storable.Storable Foreign.C.Types.CUSeconds
instance GHC.Enum.Enum Foreign.C.Types.CUSeconds
instance GHC.Num.Num Foreign.C.Types.CUSeconds
instance GHC.Classes.Ord Foreign.C.Types.CUSeconds
instance GHC.Classes.Eq Foreign.C.Types.CUSeconds
instance GHC.Show.Show Foreign.C.Types.CTime
instance GHC.Read.Read Foreign.C.Types.CTime
instance GHC.Real.Real Foreign.C.Types.CTime
instance Foreign.Storable.Storable Foreign.C.Types.CTime
instance GHC.Enum.Enum Foreign.C.Types.CTime
instance GHC.Num.Num Foreign.C.Types.CTime
instance GHC.Classes.Ord Foreign.C.Types.CTime
instance GHC.Classes.Eq Foreign.C.Types.CTime
instance GHC.Show.Show Foreign.C.Types.CClock
instance GHC.Read.Read Foreign.C.Types.CClock
instance GHC.Real.Real Foreign.C.Types.CClock
instance Foreign.Storable.Storable Foreign.C.Types.CClock
instance GHC.Enum.Enum Foreign.C.Types.CClock
instance GHC.Num.Num Foreign.C.Types.CClock
instance GHC.Classes.Ord Foreign.C.Types.CClock
instance GHC.Classes.Eq Foreign.C.Types.CClock
instance GHC.Show.Show Foreign.C.Types.CSigAtomic
instance GHC.Read.Read Foreign.C.Types.CSigAtomic
instance Data.Bits.FiniteBits Foreign.C.Types.CSigAtomic
instance Data.Bits.Bits Foreign.C.Types.CSigAtomic
instance GHC.Real.Integral Foreign.C.Types.CSigAtomic
instance GHC.Enum.Bounded Foreign.C.Types.CSigAtomic
instance GHC.Real.Real Foreign.C.Types.CSigAtomic
instance Foreign.Storable.Storable Foreign.C.Types.CSigAtomic
instance GHC.Enum.Enum Foreign.C.Types.CSigAtomic
instance GHC.Num.Num Foreign.C.Types.CSigAtomic
instance GHC.Classes.Ord Foreign.C.Types.CSigAtomic
instance GHC.Classes.Eq Foreign.C.Types.CSigAtomic
instance GHC.Show.Show Foreign.C.Types.CWchar
instance GHC.Read.Read Foreign.C.Types.CWchar
instance Data.Bits.FiniteBits Foreign.C.Types.CWchar
instance Data.Bits.Bits Foreign.C.Types.CWchar
instance GHC.Real.Integral Foreign.C.Types.CWchar
instance GHC.Enum.Bounded Foreign.C.Types.CWchar
instance GHC.Real.Real Foreign.C.Types.CWchar
instance Foreign.Storable.Storable Foreign.C.Types.CWchar
instance GHC.Enum.Enum Foreign.C.Types.CWchar
instance GHC.Num.Num Foreign.C.Types.CWchar
instance GHC.Classes.Ord Foreign.C.Types.CWchar
instance GHC.Classes.Eq Foreign.C.Types.CWchar
instance GHC.Show.Show Foreign.C.Types.CSize
instance GHC.Read.Read Foreign.C.Types.CSize
instance Data.Bits.FiniteBits Foreign.C.Types.CSize
instance Data.Bits.Bits Foreign.C.Types.CSize
instance GHC.Real.Integral Foreign.C.Types.CSize
instance GHC.Enum.Bounded Foreign.C.Types.CSize
instance GHC.Real.Real Foreign.C.Types.CSize
instance Foreign.Storable.Storable Foreign.C.Types.CSize
instance GHC.Enum.Enum Foreign.C.Types.CSize
instance GHC.Num.Num Foreign.C.Types.CSize
instance GHC.Classes.Ord Foreign.C.Types.CSize
instance GHC.Classes.Eq Foreign.C.Types.CSize
instance GHC.Show.Show Foreign.C.Types.CPtrdiff
instance GHC.Read.Read Foreign.C.Types.CPtrdiff
instance Data.Bits.FiniteBits Foreign.C.Types.CPtrdiff
instance Data.Bits.Bits Foreign.C.Types.CPtrdiff
instance GHC.Real.Integral Foreign.C.Types.CPtrdiff
instance GHC.Enum.Bounded Foreign.C.Types.CPtrdiff
instance GHC.Real.Real Foreign.C.Types.CPtrdiff
instance Foreign.Storable.Storable Foreign.C.Types.CPtrdiff
instance GHC.Enum.Enum Foreign.C.Types.CPtrdiff
instance GHC.Num.Num Foreign.C.Types.CPtrdiff
instance GHC.Classes.Ord Foreign.C.Types.CPtrdiff
instance GHC.Classes.Eq Foreign.C.Types.CPtrdiff
instance GHC.Show.Show Foreign.C.Types.CDouble
instance GHC.Read.Read Foreign.C.Types.CDouble
instance GHC.Float.RealFloat Foreign.C.Types.CDouble
instance GHC.Real.RealFrac Foreign.C.Types.CDouble
instance GHC.Float.Floating Foreign.C.Types.CDouble
instance GHC.Real.Fractional Foreign.C.Types.CDouble
instance GHC.Real.Real Foreign.C.Types.CDouble
instance Foreign.Storable.Storable Foreign.C.Types.CDouble
instance GHC.Enum.Enum Foreign.C.Types.CDouble
instance GHC.Num.Num Foreign.C.Types.CDouble
instance GHC.Classes.Ord Foreign.C.Types.CDouble
instance GHC.Classes.Eq Foreign.C.Types.CDouble
instance GHC.Show.Show Foreign.C.Types.CFloat
instance GHC.Read.Read Foreign.C.Types.CFloat
instance GHC.Float.RealFloat Foreign.C.Types.CFloat
instance GHC.Real.RealFrac Foreign.C.Types.CFloat
instance GHC.Float.Floating Foreign.C.Types.CFloat
instance GHC.Real.Fractional Foreign.C.Types.CFloat
instance GHC.Real.Real Foreign.C.Types.CFloat
instance Foreign.Storable.Storable Foreign.C.Types.CFloat
instance GHC.Enum.Enum Foreign.C.Types.CFloat
instance GHC.Num.Num Foreign.C.Types.CFloat
instance GHC.Classes.Ord Foreign.C.Types.CFloat
instance GHC.Classes.Eq Foreign.C.Types.CFloat
instance GHC.Show.Show Foreign.C.Types.CBool
instance GHC.Read.Read Foreign.C.Types.CBool
instance Data.Bits.FiniteBits Foreign.C.Types.CBool
instance Data.Bits.Bits Foreign.C.Types.CBool
instance GHC.Real.Integral Foreign.C.Types.CBool
instance GHC.Enum.Bounded Foreign.C.Types.CBool
instance GHC.Real.Real Foreign.C.Types.CBool
instance Foreign.Storable.Storable Foreign.C.Types.CBool
instance GHC.Enum.Enum Foreign.C.Types.CBool
instance GHC.Num.Num Foreign.C.Types.CBool
instance GHC.Classes.Ord Foreign.C.Types.CBool
instance GHC.Classes.Eq Foreign.C.Types.CBool
instance GHC.Show.Show Foreign.C.Types.CULLong
instance GHC.Read.Read Foreign.C.Types.CULLong
instance Data.Bits.FiniteBits Foreign.C.Types.CULLong
instance Data.Bits.Bits Foreign.C.Types.CULLong
instance GHC.Real.Integral Foreign.C.Types.CULLong
instance GHC.Enum.Bounded Foreign.C.Types.CULLong
instance GHC.Real.Real Foreign.C.Types.CULLong
instance Foreign.Storable.Storable Foreign.C.Types.CULLong
instance GHC.Enum.Enum Foreign.C.Types.CULLong
instance GHC.Num.Num Foreign.C.Types.CULLong
instance GHC.Classes.Ord Foreign.C.Types.CULLong
instance GHC.Classes.Eq Foreign.C.Types.CULLong
instance GHC.Show.Show Foreign.C.Types.CLLong
instance GHC.Read.Read Foreign.C.Types.CLLong
instance Data.Bits.FiniteBits Foreign.C.Types.CLLong
instance Data.Bits.Bits Foreign.C.Types.CLLong
instance GHC.Real.Integral Foreign.C.Types.CLLong
instance GHC.Enum.Bounded Foreign.C.Types.CLLong
instance GHC.Real.Real Foreign.C.Types.CLLong
instance Foreign.Storable.Storable Foreign.C.Types.CLLong
instance GHC.Enum.Enum Foreign.C.Types.CLLong
instance GHC.Num.Num Foreign.C.Types.CLLong
instance GHC.Classes.Ord Foreign.C.Types.CLLong
instance GHC.Classes.Eq Foreign.C.Types.CLLong
instance GHC.Show.Show Foreign.C.Types.CULong
instance GHC.Read.Read Foreign.C.Types.CULong
instance Data.Bits.FiniteBits Foreign.C.Types.CULong
instance Data.Bits.Bits Foreign.C.Types.CULong
instance GHC.Real.Integral Foreign.C.Types.CULong
instance GHC.Enum.Bounded Foreign.C.Types.CULong
instance GHC.Real.Real Foreign.C.Types.CULong
instance Foreign.Storable.Storable Foreign.C.Types.CULong
instance GHC.Enum.Enum Foreign.C.Types.CULong
instance GHC.Num.Num Foreign.C.Types.CULong
instance GHC.Classes.Ord Foreign.C.Types.CULong
instance GHC.Classes.Eq Foreign.C.Types.CULong
instance GHC.Show.Show Foreign.C.Types.CLong
instance GHC.Read.Read Foreign.C.Types.CLong
instance Data.Bits.FiniteBits Foreign.C.Types.CLong
instance Data.Bits.Bits Foreign.C.Types.CLong
instance GHC.Real.Integral Foreign.C.Types.CLong
instance GHC.Enum.Bounded Foreign.C.Types.CLong
instance GHC.Real.Real Foreign.C.Types.CLong
instance Foreign.Storable.Storable Foreign.C.Types.CLong
instance GHC.Enum.Enum Foreign.C.Types.CLong
instance GHC.Num.Num Foreign.C.Types.CLong
instance GHC.Classes.Ord Foreign.C.Types.CLong
instance GHC.Classes.Eq Foreign.C.Types.CLong
instance GHC.Show.Show Foreign.C.Types.CUInt
instance GHC.Read.Read Foreign.C.Types.CUInt
instance Data.Bits.FiniteBits Foreign.C.Types.CUInt
instance Data.Bits.Bits Foreign.C.Types.CUInt
instance GHC.Real.Integral Foreign.C.Types.CUInt
instance GHC.Enum.Bounded Foreign.C.Types.CUInt
instance GHC.Real.Real Foreign.C.Types.CUInt
instance Foreign.Storable.Storable Foreign.C.Types.CUInt
instance GHC.Enum.Enum Foreign.C.Types.CUInt
instance GHC.Num.Num Foreign.C.Types.CUInt
instance GHC.Classes.Ord Foreign.C.Types.CUInt
instance GHC.Classes.Eq Foreign.C.Types.CUInt
instance GHC.Show.Show Foreign.C.Types.CInt
instance GHC.Read.Read Foreign.C.Types.CInt
instance Data.Bits.FiniteBits Foreign.C.Types.CInt
instance Data.Bits.Bits Foreign.C.Types.CInt
instance GHC.Real.Integral Foreign.C.Types.CInt
instance GHC.Enum.Bounded Foreign.C.Types.CInt
instance GHC.Real.Real Foreign.C.Types.CInt
instance Foreign.Storable.Storable Foreign.C.Types.CInt
instance GHC.Enum.Enum Foreign.C.Types.CInt
instance GHC.Num.Num Foreign.C.Types.CInt
instance GHC.Classes.Ord Foreign.C.Types.CInt
instance GHC.Classes.Eq Foreign.C.Types.CInt
instance GHC.Show.Show Foreign.C.Types.CUShort
instance GHC.Read.Read Foreign.C.Types.CUShort
instance Data.Bits.FiniteBits Foreign.C.Types.CUShort
instance Data.Bits.Bits Foreign.C.Types.CUShort
instance GHC.Real.Integral Foreign.C.Types.CUShort
instance GHC.Enum.Bounded Foreign.C.Types.CUShort
instance GHC.Real.Real Foreign.C.Types.CUShort
instance Foreign.Storable.Storable Foreign.C.Types.CUShort
instance GHC.Enum.Enum Foreign.C.Types.CUShort
instance GHC.Num.Num Foreign.C.Types.CUShort
instance GHC.Classes.Ord Foreign.C.Types.CUShort
instance GHC.Classes.Eq Foreign.C.Types.CUShort
instance GHC.Show.Show Foreign.C.Types.CShort
instance GHC.Read.Read Foreign.C.Types.CShort
instance Data.Bits.FiniteBits Foreign.C.Types.CShort
instance Data.Bits.Bits Foreign.C.Types.CShort
instance GHC.Real.Integral Foreign.C.Types.CShort
instance GHC.Enum.Bounded Foreign.C.Types.CShort
instance GHC.Real.Real Foreign.C.Types.CShort
instance Foreign.Storable.Storable Foreign.C.Types.CShort
instance GHC.Enum.Enum Foreign.C.Types.CShort
instance GHC.Num.Num Foreign.C.Types.CShort
instance GHC.Classes.Ord Foreign.C.Types.CShort
instance GHC.Classes.Eq Foreign.C.Types.CShort
instance GHC.Show.Show Foreign.C.Types.CUChar
instance GHC.Read.Read Foreign.C.Types.CUChar
instance Data.Bits.FiniteBits Foreign.C.Types.CUChar
instance Data.Bits.Bits Foreign.C.Types.CUChar
instance GHC.Real.Integral Foreign.C.Types.CUChar
instance GHC.Enum.Bounded Foreign.C.Types.CUChar
instance GHC.Real.Real Foreign.C.Types.CUChar
instance Foreign.Storable.Storable Foreign.C.Types.CUChar
instance GHC.Enum.Enum Foreign.C.Types.CUChar
instance GHC.Num.Num Foreign.C.Types.CUChar
instance GHC.Classes.Ord Foreign.C.Types.CUChar
instance GHC.Classes.Eq Foreign.C.Types.CUChar
instance GHC.Show.Show Foreign.C.Types.CSChar
instance GHC.Read.Read Foreign.C.Types.CSChar
instance Data.Bits.FiniteBits Foreign.C.Types.CSChar
instance Data.Bits.Bits Foreign.C.Types.CSChar
instance GHC.Real.Integral Foreign.C.Types.CSChar
instance GHC.Enum.Bounded Foreign.C.Types.CSChar
instance GHC.Real.Real Foreign.C.Types.CSChar
instance Foreign.Storable.Storable Foreign.C.Types.CSChar
instance GHC.Enum.Enum Foreign.C.Types.CSChar
instance GHC.Num.Num Foreign.C.Types.CSChar
instance GHC.Classes.Ord Foreign.C.Types.CSChar
instance GHC.Classes.Eq Foreign.C.Types.CSChar
instance GHC.Show.Show Foreign.C.Types.CChar
instance GHC.Read.Read Foreign.C.Types.CChar
instance Data.Bits.FiniteBits Foreign.C.Types.CChar
instance Data.Bits.Bits Foreign.C.Types.CChar
instance GHC.Real.Integral Foreign.C.Types.CChar
instance GHC.Enum.Bounded Foreign.C.Types.CChar
instance GHC.Real.Real Foreign.C.Types.CChar
instance Foreign.Storable.Storable Foreign.C.Types.CChar
instance GHC.Enum.Enum Foreign.C.Types.CChar
instance GHC.Num.Num Foreign.C.Types.CChar
instance GHC.Classes.Ord Foreign.C.Types.CChar
instance GHC.Classes.Eq Foreign.C.Types.CChar


-- | Definition of propositional equality <tt>(:~:)</tt>. Pattern-matching
--   on a variable of type <tt>(a :~: b)</tt> produces a proof that <tt>a ~
--   b</tt>.
module Data.Type.Equality

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data a :~: b
[Refl] :: a :~: a
infix 4 :~:

-- | Lifted, heterogeneous equality. By lifted, we mean that it can be
--   bogus (deferred type error). By heterogeneous, the two types
--   <tt>a</tt> and <tt>b</tt> might have different kinds. Because
--   <tt>~~</tt> can appear unexpectedly in error messages to users who do
--   not care about the difference between heterogeneous equality
--   <tt>~~</tt> and homogeneous equality <tt>~</tt>, this is printed as
--   <tt>~</tt> unless <tt>-fprint-equality-relations</tt> is set.
class a ~# b => (~~) (a :: k0) (b :: k1)

-- | Kind heterogeneous propositional equality. Like <a>:~:</a>, <tt>a :~~:
--   b</tt> is inhabited by a terminating value if and only if <tt>a</tt>
--   is the same type as <tt>b</tt>.
data (a :: k1) :~~: (b :: k2)
[HRefl] :: a :~~: a
infix 4 :~~:

-- | Symmetry of equality
sym :: (a :~: b) -> b :~: a

-- | Transitivity of equality
trans :: (a :~: b) -> (b :~: c) -> a :~: c

-- | Type-safe cast, using propositional equality
castWith :: (a :~: b) -> a -> b

-- | Generalized form of type-safe cast using propositional equality
gcastWith :: (a :~: b) -> (a ~ b => r) -> r

-- | Apply one equality to another, respectively
apply :: (f :~: g) -> (a :~: b) -> f a :~: g b

-- | Extract equality of the arguments from an equality of applied types
inner :: (f a :~: g b) -> a :~: b

-- | Extract equality of type constructors from an equality of applied
--   types
outer :: (f a :~: g b) -> f :~: g

-- | This class contains types where you can learn the equality of two
--   types from information contained in <i>terms</i>. Typically, only
--   singleton types should inhabit this class.
class TestEquality f

-- | Conditionally prove the equality of <tt>a</tt> and <tt>b</tt>.
testEquality :: TestEquality f => f a -> f b -> Maybe (a :~: b)

-- | A type family to compute Boolean equality.
type family (a :: k) == (b :: k) :: Bool
infix 4 ==
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (a Data.Type.Equality.:~: b)
instance forall k (a :: k) (b :: k). GHC.Show.Show (a Data.Type.Equality.:~: b)
instance forall k (a :: k) (b :: k). GHC.Classes.Ord (a Data.Type.Equality.:~: b)
instance forall k (a :: k) (b :: k). (a Data.Type.Equality.~ b) => GHC.Read.Read (a Data.Type.Equality.:~: b)
instance forall k (a :: k) (b :: k). (a Data.Type.Equality.~ b) => GHC.Enum.Bounded (a Data.Type.Equality.:~: b)
instance forall k2 k1 (a :: k1) (b :: k2). GHC.Classes.Eq (a Data.Type.Equality.:~~: b)
instance forall k2 k1 (a :: k1) (b :: k2). GHC.Show.Show (a Data.Type.Equality.:~~: b)
instance forall k2 k1 (a :: k1) (b :: k2). GHC.Classes.Ord (a Data.Type.Equality.:~~: b)
instance forall k2 k1 (a :: k1) (b :: k2). (a GHC.Types.~~ b) => GHC.Read.Read (a Data.Type.Equality.:~~: b)
instance forall k2 k1 (a :: k1) (b :: k2). (a GHC.Types.~~ b) => GHC.Enum.Bounded (a Data.Type.Equality.:~~: b)
instance forall k (a :: k). Data.Type.Equality.TestEquality ((Data.Type.Equality.:~:) a)
instance forall k k1 (a :: k1). Data.Type.Equality.TestEquality ((Data.Type.Equality.:~~:) a)
instance forall k2 k1 (a :: k1) (b :: k2). (a GHC.Types.~~ b) => GHC.Enum.Enum (a Data.Type.Equality.:~~: b)
instance forall k (a :: k) (b :: k). (a Data.Type.Equality.~ b) => GHC.Enum.Enum (a Data.Type.Equality.:~: b)
instance forall k (a :: k) (b :: k). (a ~ b) => a Data.Type.Equality.~ b


-- | Definition of representational equality (<a>Coercion</a>).
module Data.Type.Coercion

-- | Representational equality. If <tt>Coercion a b</tt> is inhabited by
--   some terminating value, then the type <tt>a</tt> has the same
--   underlying representation as the type <tt>b</tt>.
--   
--   To use this equality in practice, pattern-match on the <tt>Coercion a
--   b</tt> to get out the <tt>Coercible a b</tt> instance, and then use
--   <a>coerce</a> to apply it.
data Coercion a b
[Coercion] :: Coercible a b => Coercion a b

-- | Type-safe cast, using representational equality
coerceWith :: Coercion a b -> a -> b

-- | Generalized form of type-safe cast using representational equality
gcoerceWith :: Coercion a b -> (Coercible a b => r) -> r

-- | Symmetry of representational equality
sym :: Coercion a b -> Coercion b a

-- | Transitivity of representational equality
trans :: Coercion a b -> Coercion b c -> Coercion a c

-- | Convert propositional (nominal) equality to representational equality
repr :: (a :~: b) -> Coercion a b

-- | This class contains types where you can learn the equality of two
--   types from information contained in <i>terms</i>. Typically, only
--   singleton types should inhabit this class.
class TestCoercion f

-- | Conditionally prove the representational equality of <tt>a</tt> and
--   <tt>b</tt>.
testCoercion :: TestCoercion f => f a -> f b -> Maybe (Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Show.Show (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Classes.Ord (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Read.Read (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Enum.Bounded (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k). Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~:) a)
instance forall k k1 (a :: k1). Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~~:) a)
instance forall k (a :: k). Data.Type.Coercion.TestCoercion (Data.Type.Coercion.Coercion a)
instance forall k (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Enum.Enum (Data.Type.Coercion.Coercion a b)


module Control.Category

-- | A class for categories. Instances should satisfy the laws
--   
--   <pre>
--   f <a>.</a> <a>id</a>  =  f  -- (right identity)
--   <a>id</a> <a>.</a> f  =  f  -- (left identity)
--   f <a>.</a> (g <a>.</a> h)  =  (f <a>.</a> g) <a>.</a> h  -- (associativity)
--   </pre>
class Category cat

-- | the identity morphism
id :: Category cat => cat a a

-- | morphism composition
(.) :: Category cat => cat b c -> cat a b -> cat a c
infixr 9 .

-- | Right-to-left composition
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
infixr 1 <<<

-- | Left-to-right composition
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>
instance Control.Category.Category (->)
instance Control.Category.Category (Data.Type.Equality.:~:)
instance Control.Category.Category (Data.Type.Equality.:~~:)
instance Control.Category.Category Data.Type.Coercion.Coercion


-- | Definition of a Proxy type (poly-kinded in GHC)
module Data.Proxy

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt>'undefined :: a'</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy t
Proxy :: Proxy t

-- | <a>asProxyTypeOf</a> is a type-restricted version of <a>const</a>. It
--   is usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   tag of the second.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Word
--   
--   &gt;&gt;&gt; :type asProxyTypeOf 123 (Proxy :: Proxy Word8)
--   asProxyTypeOf 123 (Proxy :: Proxy Word8) :: Word8
--   </pre>
--   
--   Note the lower-case <tt>proxy</tt> in the definition. This allows any
--   type constructor with just one argument to be passed to the function,
--   for example we could also write
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Word
--   
--   &gt;&gt;&gt; :type asProxyTypeOf 123 (Just (undefined :: Word8))
--   asProxyTypeOf 123 (Just (undefined :: Word8)) :: Word8
--   </pre>
asProxyTypeOf :: a -> proxy a -> a

-- | A concrete, promotable proxy type, for use at the kind level There are
--   no instances for this because it is intended at the kind level only
data KProxy (t :: Type)
KProxy :: KProxy
instance forall k (t :: k). GHC.Read.Read (Data.Proxy.Proxy t)
instance forall k (t :: k). GHC.Enum.Bounded (Data.Proxy.Proxy t)
instance forall k (s :: k). GHC.Classes.Eq (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Classes.Ord (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Show.Show (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Enum.Enum (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Arr.Ix (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Base.Semigroup (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Base.Monoid (Data.Proxy.Proxy s)
instance GHC.Base.Functor Data.Proxy.Proxy
instance GHC.Base.Applicative Data.Proxy.Proxy
instance GHC.Base.Alternative Data.Proxy.Proxy
instance GHC.Base.Monad Data.Proxy.Proxy
instance GHC.Base.MonadPlus Data.Proxy.Proxy


-- | Orderings
module Data.Ord

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 <=
infix 4 >=
infix 4 <
infix 4 >
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>). If <tt>a</tt> has
--   an <tt><a>Ord</a></tt> instance associated with it then comparing two
--   values thus wrapped will give you the opposite of their normal sort
--   order. This is particularly useful when sorting in generalised list
--   comprehensions, as in: <tt>then sortWith by <a>Down</a> x</tt>
newtype Down a
Down :: a -> Down a

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => (b -> a) -> b -> b -> Ordering
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Ord.Down a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Ord.Down a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Ord.Down a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Ord.Down a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Ord.Down a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Ord.Down a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Ord.Down a)
instance GHC.Base.Functor Data.Ord.Down
instance GHC.Base.Applicative Data.Ord.Down
instance GHC.Base.Monad Data.Ord.Down


-- | The Either type, and associated operations.
module Data.Either

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <tt>length</tt> function (if we have a <a>String</a>) or the
--   "times-two" function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: [Either a b] -> [a]

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: [Either a b] -> [b]

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: Either a b -> Bool

-- | Return the contents of a <a>Left</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromLeft 1 (Left 3)
--   3
--   
--   &gt;&gt;&gt; fromLeft 1 (Right "foo")
--   1
--   </pre>
fromLeft :: a -> Either a b -> a

-- | Return the contents of a <a>Right</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 1 (Right 3)
--   3
--   
--   &gt;&gt;&gt; fromRight 1 (Left "foo")
--   1
--   </pre>
fromRight :: b -> Either a b -> b

-- | Partitions a list of <a>Either</a> into two lists. All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list
--   (["foo","bar","baz"],[3,7])
--   </pre>
--   
--   The pair returned by <tt><a>partitionEithers</a> x</tt> should be the
--   same pair as <tt>(<a>lefts</a> x, <a>rights</a> x)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list == (lefts list, rights list)
--   True
--   </pre>
partitionEithers :: [Either a b] -> ([a], [b])
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Either.Either a b)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Data.Either.Either a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Data.Either.Either a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Either.Either a b)
instance GHC.Base.Functor (Data.Either.Either a)
instance GHC.Base.Semigroup (Data.Either.Either a b)
instance GHC.Base.Applicative (Data.Either.Either e)
instance GHC.Base.Monad (Data.Either.Either e)


-- | Converting strings to values.
--   
--   The <a>Text.Read</a> library is the canonical library to import for
--   <a>Read</a>-class facilities. For GHC only, it offers an extended and
--   much improved <a>Read</a> class, which constitutes a proposed
--   alternative to the Haskell 2010 <a>Read</a>. In particular, writing
--   parsers is easier, and the parsers are much more efficient.
module Text.Read

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]

-- | Proposed replacement for <a>readsPrec</a> using new-style parsers (GHC
--   only).
readPrec :: Read a => ReadPrec a

-- | Proposed replacement for <a>readList</a> using new-style parsers (GHC
--   only). The default definition uses <a>readList</a>. Instances that
--   define <a>readPrec</a> should also define <a>readListPrec</a> as
--   <a>readListPrecDefault</a>.
readListPrec :: Read a => ReadPrec [a]

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String
data Lexeme

-- | Character literal
Char :: Char -> Lexeme

-- | String literal, with escapes interpreted
String :: String -> Lexeme

-- | Punctuation or reserved symbol, e.g. <tt>(</tt>, <tt>::</tt>
Punc :: String -> Lexeme

-- | Haskell identifier, e.g. <tt>foo</tt>, <tt>Baz</tt>
Ident :: String -> Lexeme

-- | Haskell symbol, e.g. <tt>&gt;&gt;</tt>, <tt>:%</tt>
Symbol :: String -> Lexeme

Number :: Number -> Lexeme
EOF :: Lexeme

-- | Parse a single lexeme
lexP :: ReadPrec Lexeme

-- | <tt>(parens p)</tt> parses "P", "(P0)", "((P0))", etc, where
--   <tt>p</tt> parses "P" in the current precedence context and parses
--   "P0" in precedence context zero
parens :: ReadPrec a -> ReadPrec a

-- | A possible replacement definition for the <a>readList</a> method (GHC
--   only). This is only needed for GHC, and even then only for <a>Read</a>
--   instances where <a>readListPrec</a> isn't defined as
--   <a>readListPrecDefault</a>.
readListDefault :: Read a => ReadS [a]

-- | A possible replacement definition for the <a>readListPrec</a> method,
--   defined using <a>readPrec</a> (GHC only).
readListPrecDefault :: Read a => ReadPrec [a]

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result. A <a>Left</a> value indicates a parse error.
--   
--   <pre>
--   &gt;&gt;&gt; readEither "123" :: Either String Int
--   Right 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readEither "hello" :: Either String Int
--   Left "Prelude.read: no parse"
--   </pre>
readEither :: Read a => String -> Either String a

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "123" :: Maybe Int
--   Just 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "hello" :: Maybe Int
--   Nothing
--   </pre>
readMaybe :: Read a => String -> Maybe a


-- | The Char type and associated operations.
module Data.Char

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char

-- | Selects control characters, which are the non-printing characters of
--   the Latin-1 subset of Unicode.
isControl :: Char -> Bool

-- | Returns <a>True</a> for any Unicode space character, and the control
--   characters <tt>\t</tt>, <tt>\n</tt>, <tt>\r</tt>, <tt>\f</tt>,
--   <tt>\v</tt>.
isSpace :: Char -> Bool

-- | Selects lower-case alphabetic Unicode characters (letters).
isLower :: Char -> Bool

-- | Selects upper-case or title-case alphabetic Unicode characters
--   (letters). Title case is used by a small number of letter ligatures
--   like the single-character form of <i>Lj</i>.
isUpper :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isLetter</a>.
isAlpha :: Char -> Bool

-- | Selects alphabetic or numeric Unicode characters.
--   
--   Note that numeric digits outside the ASCII range, as well as numeric
--   characters which aren't digits, are selected by this function but not
--   by <a>isDigit</a>. Such characters may be part of identifiers but are
--   not used by the printer and reader to represent numbers.
isAlphaNum :: Char -> Bool

-- | Selects printable Unicode characters (letters, numbers, marks,
--   punctuation, symbols and spaces).
isPrint :: Char -> Bool

-- | Selects ASCII digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>.
isDigit :: Char -> Bool

-- | Selects ASCII octal digits, i.e. <tt>'0'</tt>..<tt>'7'</tt>.
isOctDigit :: Char -> Bool

-- | Selects ASCII hexadecimal digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>,
--   <tt>'a'</tt>..<tt>'f'</tt>, <tt>'A'</tt>..<tt>'F'</tt>.
isHexDigit :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isAlpha</a>.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>UppercaseLetter</a></li>
--   <li><a>LowercaseLetter</a></li>
--   <li><a>TitlecaseLetter</a></li>
--   <li><a>ModifierLetter</a></li>
--   <li><a>OtherLetter</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Letter".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLetter 'a'
--   True
--   
--   &gt;&gt;&gt; isLetter 'A'
--   True
--   
--   &gt;&gt;&gt; isLetter 'λ'
--   True
--   
--   &gt;&gt;&gt; isLetter '0'
--   False
--   
--   &gt;&gt;&gt; isLetter '%'
--   False
--   
--   &gt;&gt;&gt; isLetter '♥'
--   False
--   
--   &gt;&gt;&gt; isLetter '\31'
--   False
--   </pre>
--   
--   Ensure that <a>isLetter</a> and <a>isAlpha</a> are equivalent.
--   
--   <pre>
--   &gt;&gt;&gt; let chars = [(chr 0)..]
--   
--   &gt;&gt;&gt; let letters = map isLetter chars
--   
--   &gt;&gt;&gt; let alphas = map isAlpha chars
--   
--   &gt;&gt;&gt; letters == alphas
--   True
--   </pre>
isLetter :: Char -> Bool

-- | Selects Unicode mark characters, for example accents and the like,
--   which combine with preceding characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>NonSpacingMark</a></li>
--   <li><a>SpacingCombiningMark</a></li>
--   <li><a>EnclosingMark</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Mark".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isMark 'a'
--   False
--   
--   &gt;&gt;&gt; isMark '0'
--   False
--   </pre>
--   
--   Combining marks such as accent characters usually need to follow
--   another character before they become printable:
--   
--   <pre>
--   &gt;&gt;&gt; map isMark "ò"
--   [False,True]
--   </pre>
--   
--   Puns are not necessarily supported:
--   
--   <pre>
--   &gt;&gt;&gt; isMark '✓'
--   False
--   </pre>
isMark :: Char -> Bool

-- | Selects Unicode numeric characters, including digits from various
--   scripts, Roman numerals, et cetera.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>DecimalNumber</a></li>
--   <li><a>LetterNumber</a></li>
--   <li><a>OtherNumber</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Number".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'a'
--   False
--   
--   &gt;&gt;&gt; isNumber '%'
--   False
--   
--   &gt;&gt;&gt; isNumber '3'
--   True
--   </pre>
--   
--   ASCII <tt>'0'</tt> through <tt>'9'</tt> are all numbers:
--   
--   <pre>
--   &gt;&gt;&gt; and $ map isNumber ['0'..'9']
--   True
--   </pre>
--   
--   Unicode Roman numerals are "numbers" as well:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'Ⅸ'
--   True
--   </pre>
isNumber :: Char -> Bool

-- | Selects Unicode punctuation characters, including various kinds of
--   connectors, brackets and quotes.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>ConnectorPunctuation</a></li>
--   <li><a>DashPunctuation</a></li>
--   <li><a>OpenPunctuation</a></li>
--   <li><a>ClosePunctuation</a></li>
--   <li><a>InitialQuote</a></li>
--   <li><a>FinalQuote</a></li>
--   <li><a>OtherPunctuation</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Punctuation".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isPunctuation 'a'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '7'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '♥'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '"'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '?'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '—'
--   True
--   </pre>
isPunctuation :: Char -> Bool

-- | Selects Unicode symbol characters, including mathematical and currency
--   symbols.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>MathSymbol</a></li>
--   <li><a>CurrencySymbol</a></li>
--   <li><a>ModifierSymbol</a></li>
--   <li><a>OtherSymbol</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Symbol".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol 'a'
--   False
--   
--   &gt;&gt;&gt; isSymbol '6'
--   False
--   
--   &gt;&gt;&gt; isSymbol '='
--   True
--   </pre>
--   
--   The definition of "math symbol" may be a little counter-intuitive
--   depending on one's background:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol '+'
--   True
--   
--   &gt;&gt;&gt; isSymbol '-'
--   False
--   </pre>
isSymbol :: Char -> Bool

-- | Selects Unicode space and separator characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>Space</a></li>
--   <li><a>LineSeparator</a></li>
--   <li><a>ParagraphSeparator</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Separator".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator 'a'
--   False
--   
--   &gt;&gt;&gt; isSeparator '6'
--   False
--   
--   &gt;&gt;&gt; isSeparator ' '
--   True
--   </pre>
--   
--   Warning: newlines and tab characters are not considered separators.
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\n'
--   False
--   
--   &gt;&gt;&gt; isSeparator '\t'
--   False
--   </pre>
--   
--   But some more exotic characters are (like HTML's <tt>&amp;nbsp;</tt>):
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\160'
--   True
--   </pre>
isSeparator :: Char -> Bool

-- | Selects the first 128 characters of the Unicode character set,
--   corresponding to the ASCII character set.
isAscii :: Char -> Bool

-- | Selects the first 256 characters of the Unicode character set,
--   corresponding to the ISO 8859-1 (Latin-1) character set.
isLatin1 :: Char -> Bool

-- | Selects ASCII upper-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isUpper</a>.
isAsciiUpper :: Char -> Bool

-- | Selects ASCII lower-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isLower</a>.
isAsciiLower :: Char -> Bool

-- | Unicode General Categories (column 2 of the UnicodeData table) in the
--   order they are listed in the Unicode standard (the Unicode Character
--   Database, in particular).
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; :t OtherLetter
--   OtherLetter :: GeneralCategory
--   </pre>
--   
--   <a>Eq</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; UppercaseLetter == UppercaseLetter
--   True
--   
--   &gt;&gt;&gt; UppercaseLetter == LowercaseLetter
--   False
--   </pre>
--   
--   <a>Ord</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; NonSpacingMark &lt;= MathSymbol
--   True
--   </pre>
--   
--   <a>Enum</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; enumFromTo ModifierLetter SpacingCombiningMark
--   [ModifierLetter,OtherLetter,NonSpacingMark,SpacingCombiningMark]
--   </pre>
--   
--   <tt>Read</tt> instance:
--   
--   <pre>
--   &gt;&gt;&gt; read "DashPunctuation" :: GeneralCategory
--   DashPunctuation
--   
--   &gt;&gt;&gt; read "17" :: GeneralCategory
--   *** Exception: Prelude.read: no parse
--   </pre>
--   
--   <a>Show</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; show EnclosingMark
--   "EnclosingMark"
--   </pre>
--   
--   <a>Bounded</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: GeneralCategory
--   UppercaseLetter
--   
--   &gt;&gt;&gt; maxBound :: GeneralCategory
--   NotAssigned
--   </pre>
--   
--   <a>Ix</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ix ( index )
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) FinalQuote
--   12
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) Format
--   *** Exception: Error in array index
--   </pre>
data GeneralCategory

-- | Lu: Letter, Uppercase
UppercaseLetter :: GeneralCategory

-- | Ll: Letter, Lowercase
LowercaseLetter :: GeneralCategory

-- | Lt: Letter, Titlecase
TitlecaseLetter :: GeneralCategory

-- | Lm: Letter, Modifier
ModifierLetter :: GeneralCategory

-- | Lo: Letter, Other
OtherLetter :: GeneralCategory

-- | Mn: Mark, Non-Spacing
NonSpacingMark :: GeneralCategory

-- | Mc: Mark, Spacing Combining
SpacingCombiningMark :: GeneralCategory

-- | Me: Mark, Enclosing
EnclosingMark :: GeneralCategory

-- | Nd: Number, Decimal
DecimalNumber :: GeneralCategory

-- | Nl: Number, Letter
LetterNumber :: GeneralCategory

-- | No: Number, Other
OtherNumber :: GeneralCategory

-- | Pc: Punctuation, Connector
ConnectorPunctuation :: GeneralCategory

-- | Pd: Punctuation, Dash
DashPunctuation :: GeneralCategory

-- | Ps: Punctuation, Open
OpenPunctuation :: GeneralCategory

-- | Pe: Punctuation, Close
ClosePunctuation :: GeneralCategory

-- | Pi: Punctuation, Initial quote
InitialQuote :: GeneralCategory

-- | Pf: Punctuation, Final quote
FinalQuote :: GeneralCategory

-- | Po: Punctuation, Other
OtherPunctuation :: GeneralCategory

-- | Sm: Symbol, Math
MathSymbol :: GeneralCategory

-- | Sc: Symbol, Currency
CurrencySymbol :: GeneralCategory

-- | Sk: Symbol, Modifier
ModifierSymbol :: GeneralCategory

-- | So: Symbol, Other
OtherSymbol :: GeneralCategory

-- | Zs: Separator, Space
Space :: GeneralCategory

-- | Zl: Separator, Line
LineSeparator :: GeneralCategory

-- | Zp: Separator, Paragraph
ParagraphSeparator :: GeneralCategory

-- | Cc: Other, Control
Control :: GeneralCategory

-- | Cf: Other, Format
Format :: GeneralCategory

-- | Cs: Other, Surrogate
Surrogate :: GeneralCategory

-- | Co: Other, Private Use
PrivateUse :: GeneralCategory

-- | Cn: Other, Not Assigned
NotAssigned :: GeneralCategory

-- | The Unicode general category of the character. This relies on the
--   <a>Enum</a> instance of <a>GeneralCategory</a>, which must remain in
--   the same order as the categories are presented in the Unicode
--   standard.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; generalCategory 'a'
--   LowercaseLetter
--   
--   &gt;&gt;&gt; generalCategory 'A'
--   UppercaseLetter
--   
--   &gt;&gt;&gt; generalCategory '0'
--   DecimalNumber
--   
--   &gt;&gt;&gt; generalCategory '%'
--   OtherPunctuation
--   
--   &gt;&gt;&gt; generalCategory '♥'
--   OtherSymbol
--   
--   &gt;&gt;&gt; generalCategory '\31'
--   Control
--   
--   &gt;&gt;&gt; generalCategory ' '
--   Space
--   </pre>
generalCategory :: Char -> GeneralCategory

-- | Convert a letter to the corresponding upper-case letter, if any. Any
--   other character is returned unchanged.
toUpper :: Char -> Char

-- | Convert a letter to the corresponding lower-case letter, if any. Any
--   other character is returned unchanged.
toLower :: Char -> Char

-- | Convert a letter to the corresponding title-case or upper-case letter,
--   if any. (Title case differs from upper case only for a small number of
--   ligature letters.) Any other character is returned unchanged.
toTitle :: Char -> Char

-- | Convert a single digit <a>Char</a> to the corresponding <a>Int</a>.
--   This function fails unless its argument satisfies <a>isHexDigit</a>,
--   but recognises both upper- and lower-case hexadecimal digits (that is,
--   <tt>'0'</tt>..<tt>'9'</tt>, <tt>'a'</tt>..<tt>'f'</tt>,
--   <tt>'A'</tt>..<tt>'F'</tt>).
--   
--   <h4><b>Examples</b></h4>
--   
--   Characters <tt>'0'</tt> through <tt>'9'</tt> are converted properly to
--   <tt>0..9</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['0'..'9']
--   [0,1,2,3,4,5,6,7,8,9]
--   </pre>
--   
--   Both upper- and lower-case <tt>'A'</tt> through <tt>'F'</tt> are
--   converted as well, to <tt>10..15</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['a'..'f']
--   [10,11,12,13,14,15]
--   
--   &gt;&gt;&gt; map digitToInt ['A'..'F']
--   [10,11,12,13,14,15]
--   </pre>
--   
--   Anything else throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; digitToInt 'G'
--   *** Exception: Char.digitToInt: not a digit 'G'
--   
--   &gt;&gt;&gt; digitToInt '♥'
--   *** Exception: Char.digitToInt: not a digit '\9829'
--   </pre>
digitToInt :: Char -> Int

-- | Convert an <a>Int</a> in the range <tt>0</tt>..<tt>15</tt> to the
--   corresponding single digit <a>Char</a>. This function fails on other
--   inputs, and generates lower-case hexadecimal digits.
intToDigit :: Int -> Char

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char

-- | Convert a character to a string using only printable characters, using
--   Haskell source-language escape conventions. For example:
--   
--   <pre>
--   showLitChar '\n' s  =  "\\n" ++ s
--   </pre>
showLitChar :: Char -> ShowS

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions. For example:
--   
--   <pre>
--   lexLitChar  "\\nHello"  =  [("\\n", "Hello")]
--   </pre>
lexLitChar :: ReadS String

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions, and convert it to the character
--   that it encodes. For example:
--   
--   <pre>
--   readLitChar "\\nHello"  =  [('\n', "Hello")]
--   </pre>
readLitChar :: ReadS Char


-- | This legacy module provides access to the list-specialised operations
--   of <a>Data.List</a>. This module may go away again in future GHC
--   versions and is provided as transitional tool to access some of the
--   list-specialised operations that had to be generalised due to the
--   implementation of the <a>Foldable/Traversable-in-Prelude Proposal
--   (FTP)</a>.
--   
--   If the operations needed are available in <a>GHC.List</a>, it's
--   recommended to avoid importing this module and use <a>GHC.List</a>
--   instead for now.
module GHC.OldList

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | Extract the first element of a list, which must be non-empty.
head :: [a] -> a

-- | Extract the last element of a list, which must be finite and
--   non-empty.
last :: [a] -> a

-- | Extract the elements after the head of a list, which must be
--   non-empty.
tail :: [a] -> [a]

-- | Return all the elements of a list except the last one. The list must
--   be non-empty.
init :: [a] -> [a]

-- | Decompose a list into its head and tail. If the list is empty, returns
--   <a>Nothing</a>. If the list is non-empty, returns <tt><a>Just</a> (x,
--   xs)</tt>, where <tt>x</tt> is the head of the list and <tt>xs</tt> its
--   tail.
uncons :: [a] -> Maybe (a, [a])

-- | Test whether a list is empty.
null :: [a] -> Bool

-- | <i>O(n)</i>. <a>length</a> returns the length of a finite list as an
--   <a>Int</a>. It is an instance of the more general
--   <a>genericLength</a>, the result type of which may be any kind of
--   number.
length :: [a] -> Int

-- | <a>map</a> <tt>f xs</tt> is the list obtained by applying <tt>f</tt>
--   to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | The <a>intersperse</a> function takes an element and a list and
--   `intersperses' that element between the elements of the list. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; intersperse ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
intersperse :: a -> [a] -> [a]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[10,11],[20],[],[30,31,32]]
--   [[10,20,30],[11,31],[32]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; subsequences "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: [a] -> [[a]]

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a list, reduces the
--   list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   The list must be finite.
foldl :: forall a b. (b -> a -> b) -> b -> [a] -> b

-- | A strict version of <a>foldl</a>.
foldl' :: forall a b. (b -> a -> b) -> b -> [a] -> b

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty lists.
foldl1 :: (a -> a -> a) -> [a] -> a

-- | A strict version of <a>foldl1</a>
foldl1' :: (a -> a -> a) -> [a] -> a

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a list, reduces
--   the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
foldr :: (a -> b -> b) -> b -> [a] -> b

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty lists.
foldr1 :: (a -> a -> a) -> [a] -> a

-- | Concatenate a list of lists.
concat :: [[a]] -> [a]

-- | Map a function over a list and concatenate the results.
concatMap :: (a -> [b]) -> [a] -> [b]

-- | <a>and</a> returns the conjunction of a Boolean list. For the result
--   to be <a>True</a>, the list must be finite; <a>False</a>, however,
--   results from a <a>False</a> value at a finite index of a finite or
--   infinite list.
and :: [Bool] -> Bool

-- | <a>or</a> returns the disjunction of a Boolean list. For the result to
--   be <a>False</a>, the list must be finite; <a>True</a>, however,
--   results from a <a>True</a> value at a finite index of a finite or
--   infinite list.
or :: [Bool] -> Bool

-- | Applied to a predicate and a list, <a>any</a> determines if any
--   element of the list satisfies the predicate. For the result to be
--   <a>False</a>, the list must be finite; <a>True</a>, however, results
--   from a <a>True</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
any :: (a -> Bool) -> [a] -> Bool

-- | Applied to a predicate and a list, <a>all</a> determines if all
--   elements of the list satisfy the predicate. For the result to be
--   <a>True</a>, the list must be finite; <a>False</a>, however, results
--   from a <a>False</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
all :: (a -> Bool) -> [a] -> Bool

-- | The <a>sum</a> function computes the sum of a finite list of numbers.
sum :: Num a => [a] -> a

-- | The <a>product</a> function computes the product of a finite list of
--   numbers.
product :: Num a => [a] -> a

-- | <a>maximum</a> returns the maximum value from a list, which must be
--   non-empty, finite, and of an ordered type. It is a special case of
--   <a>maximumBy</a>, which allows the programmer to supply their own
--   comparison function.
maximum :: Ord a => [a] -> a

-- | <a>minimum</a> returns the minimum value from a list, which must be
--   non-empty, finite, and of an ordered type. It is a special case of
--   <a>minimumBy</a>, which allows the programmer to supply their own
--   comparison function.
minimum :: Ord a => [a] -> a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | A strictly accumulating version of <a>scanl</a>
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | The <a>mapAccumL</a> function behaves like a combination of <a>map</a>
--   and <a>foldl</a>; it applies a function to each element of a list,
--   passing an accumulating parameter from left to right, and returning a
--   final value of this accumulator together with the new list.
mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and <a>foldr</a>; it applies a function to each element of a list,
--   passing an accumulating parameter from right to left, and returning a
--   final value of this accumulator together with the new list.
mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See 'iterate\''
--   for a strict variant of this function.
iterate :: (a -> a) -> a -> [a]

-- | 'iterate\'' is the strict version of <a>iterate</a>.
--   
--   It ensures that the result of each application of force to weak head
--   normal form before proceeding.
iterate' :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | The <a>dropWhileEnd</a> function drops the largest suffix of a list in
--   which the given predicate holds for all elements. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo\n"
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo bar"
--   "foo bar"
--   </pre>
--   
--   <pre>
--   dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined
--   </pre>
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | The <a>stripPrefix</a> function drops the given prefix from a list. It
--   returns <a>Nothing</a> if the list did not start with the prefix
--   given, or <a>Just</a> the list after the prefix, if it does.
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foobar"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foo"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoobaz"
--   Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result contains only equal elements. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Eq a => [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
inits :: [a] -> [[a]]

-- | The <a>tails</a> function returns all final segments of the argument,
--   longest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc","bc","c",""]
--   </pre>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
tails :: [a] -> [[a]]

-- | The <a>isPrefixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a prefix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. The second list must be
--   finite.
--   
--   <pre>
--   &gt;&gt;&gt; "ld!" `isSuffixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "World" `isSuffixOf` "Hello World!"
--   False
--   </pre>
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Haskell" "I really like Haskell."
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Ial" "I really like Haskell."
--   False
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | <a>elem</a> is the list membership predicate, usually written in infix
--   form, e.g., <tt>x `elem` xs</tt>. For the result to be <a>False</a>,
--   the list must be finite; <a>True</a>, however, results from an element
--   equal to <tt>x</tt> found at a finite index of a finite or infinite
--   list.
elem :: Eq a => a -> [a] -> Bool
infix 4 `elem`

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: Eq a => a -> [a] -> Bool
infix 4 `notElem`

-- | <a>lookup</a> <tt>key assocs</tt> looks up a key in an association
--   list.
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | The <a>find</a> function takes a predicate and a list and returns the
--   first element in the list matching the predicate, or <a>Nothing</a> if
--   there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 4) [1..]
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find (&lt; 0) [1..10]
--   Nothing
--   </pre>
find :: (a -> Bool) -> [a] -> Maybe a

-- | <a>filter</a>, applied to a predicate and a list, returns the list of
--   those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate a list and returns the
--   pair of lists of elements which do and do not satisfy the predicate,
--   respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partition (`elem` "aeiou") "Hello World!"
--   ("eoo","Hll Wrld!")
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 4 [0..]
--   Just 4
--   </pre>
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 'o' "Hello World"
--   [4,7]
--   </pre>
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; findIndex isSpace "Hello World!"
--   Just 5
--   </pre>
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (`elem` "aeiou") "Hello World!"
--   [1,4,7]
--   </pre>
findIndices :: (a -> Bool) -> [a] -> [Int]

-- | <a>zip</a> takes two lists and returns a list of corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums.
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | <i>O(n^2)</i>. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
--   
--   <pre>
--   &gt;&gt;&gt; nub [1,2,3,4,3,2,1,2,4,3,5]
--   [1,2,3,4,5]
--   </pre>
nub :: Eq a => [a] -> [a]

-- | <a>delete</a> <tt>x</tt> removes the first occurrence of <tt>x</tt>
--   from its list argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; delete 'a' "banana"
--   "bnana"
--   </pre>
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
delete :: Eq a => a -> [a] -> [a]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus
--   
--   <pre>
--   (xs ++ ys) \\ xs == ys.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello World!" \\ "ell W"
--   "Hoorld!"
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
(\\) :: Eq a => [a] -> [a] -> [a]
infix 5 \\

-- | The <a>union</a> function returns the list union of the two lists. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; "dog" `union` "cow"
--   "dogcw"
--   </pre>
--   
--   Duplicates, and elements of the first list, are removed from the the
--   second list, but if the first list contains duplicates, so will the
--   result. It is a special case of <a>unionBy</a>, which allows the
--   programmer to supply their own equality test.
union :: Eq a => [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] `intersect` [2,4,6,8]
--   [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,2,3,4] `intersect` [6,4,4,2]
--   [2,2,4]
--   </pre>
--   
--   It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. If the element is found
--   in both the first and the second list, the element from the first list
--   will be used.
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from from lowest to highest, keeping duplicates
--   in the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
sort :: Ord a => [a] -> [a]

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt>sortOn f</tt> is equivalent to <tt>sortBy (comparing
--   f)</tt>, but has the performance advantage of only evaluating
--   <tt>f</tt> once for each element in the input list. This is called the
--   decorate-sort-undecorate paradigm, or Schwartzian transform.
--   
--   Elements are arranged from from lowest to highest, keeping duplicates
--   in the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | The <a>insert</a> function takes an element and a list and inserts the
--   element into the list at the first position where it is less than or
--   equal to the next element. In particular, if the list is sorted before
--   the call, the result will also be sorted. It is a special case of
--   <a>insertBy</a>, which allows the programmer to supply their own
--   comparison function.
--   
--   <pre>
--   &gt;&gt;&gt; insert 4 [1,2,3,5,6,7]
--   [1,2,3,4,5,6,7]
--   </pre>
insert :: Ord a => a -> [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
--   [1,2,6]
--   </pre>
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | The <a>deleteBy</a> function behaves like <a>delete</a>, but takes a
--   user-supplied equality predicate.
--   
--   <pre>
--   &gt;&gt;&gt; deleteBy (&lt;=) 4 [1..10]
--   [1,2,3,5,6,7,8,9,10]
--   </pre>
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | The <a>deleteFirstsBy</a> function takes a predicate and two lists and
--   returns the first list with the first occurrence of each element of
--   the second list removed.
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>.
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | The non-overloaded version of <a>insert</a>.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | The <a>maximumBy</a> function takes a comparison function and a list
--   and returns the greatest element of the list by the comparison
--   function. The list must be finite and non-empty.
--   
--   We can use this to find the longest entry of a list:
--   
--   <pre>
--   &gt;&gt;&gt; maximumBy (\x y -&gt; compare (length x) (length y)) ["Hello", "World", "!", "Longest", "bar"]
--   "Longest"
--   </pre>
maximumBy :: (a -> a -> Ordering) -> [a] -> a

-- | The <a>minimumBy</a> function takes a comparison function and a list
--   and returns the least element of the list by the comparison function.
--   The list must be finite and non-empty.
--   
--   We can use this to find the shortest entry of a list:
--   
--   <pre>
--   &gt;&gt;&gt; minimumBy (\x y -&gt; compare (length x) (length y)) ["Hello", "World", "!", "Longest", "bar"]
--   "!"
--   </pre>
minimumBy :: (a -> a -> Ordering) -> [a] -> a

-- | The <a>genericLength</a> function is an overloaded version of
--   <a>length</a>. In particular, instead of returning an <a>Int</a>, it
--   returns any type which is an instance of <a>Num</a>. It is, however,
--   less efficient than <a>length</a>.
genericLength :: Num i => [a] -> i

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | The <a>genericIndex</a> function is an overloaded version of
--   <a>!!</a>, which accepts any <a>Integral</a> value as the index.
genericIndex :: Integral i => [a] -> i -> a

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]


-- | Converting values to readable strings: the <a>Show</a> class and
--   associated functions.
module Text.Show

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | Show a list (using square brackets and commas), given a function for
--   showing elements.
showListWith :: (a -> ShowS) -> [a] -> ShowS


-- | The highly unsafe primitive <a>unsafeCoerce</a> converts a value from
--   any type to any other type. Needless to say, if you use this function,
--   it is your responsibility to ensure that the old and new types have
--   identical internal representations, in order to prevent runtime
--   corruption.
--   
--   The types for which <a>unsafeCoerce</a> is representation-safe may
--   differ from compiler to compiler (and version to version).
--   
--   <ul>
--   <li>Documentation for correct usage in GHC will be found under
--   <a>unsafeCoerce#</a> in GHC.Base (around which <a>unsafeCoerce</a> is
--   just a trivial wrapper).</li>
--   <li>In nhc98, the only representation-safe coercions are between Enum
--   types with the same range (e.g. Int, Int32, Char, Word32), or between
--   a newtype and the type that it wraps.</li>
--   </ul>
module Unsafe.Coerce
unsafeCoerce :: a -> b


-- | This module is an internal GHC module. It declares the constants used
--   in the implementation of type-level natural numbers. The programmer
--   interface for working with type-level naturals should be defined in a
--   separate library.
module GHC.TypeNats

-- | (Kind) This is the kind of type-level natural numbers.
data Nat

-- | This class gives the integer associated with a type-level natural.
--   There are instances of the class for every concrete literal: 0, 1, 2,
--   etc.
class KnownNat (n :: Nat)

natVal :: forall n proxy. KnownNat n => proxy n -> Natural

natVal' :: forall n. KnownNat n => Proxy# n -> Natural

-- | This type represents unknown type-level natural numbers.
data SomeNat
SomeNat :: Proxy n -> SomeNat

-- | Convert an integer into an unknown type-level natural.
someNatVal :: Natural -> SomeNat

-- | We either get evidence that this function was instantiated with the
--   same type-level numbers, or <a>Nothing</a>.
sameNat :: (KnownNat a, KnownNat b) => Proxy a -> Proxy b -> Maybe (a :~: b)

-- | Comparison of type-level naturals, as a constraint.
type x <= y = (x <=? y) ~  'True
infix 4 <=

-- | Comparison of type-level naturals, as a function. NOTE: The
--   functionality for this function should be subsumed by <a>CmpNat</a>,
--   so this might go away in the future. Please let us know, if you
--   encounter discrepancies between the two.
type family (m :: Nat) <=? (n :: Nat) :: Bool
infix 4 <=?

-- | Addition of type-level naturals.
type family (m :: Nat) + (n :: Nat) :: Nat
infixl 6 +

-- | Multiplication of type-level naturals.
type family (m :: Nat) * (n :: Nat) :: Nat
infixl 7 *

-- | Exponentiation of type-level naturals.
type family (m :: Nat) ^ (n :: Nat) :: Nat
infixr 8 ^

-- | Subtraction of type-level naturals.
type family (m :: Nat) - (n :: Nat) :: Nat
infixl 6 -

-- | Comparison of type-level naturals, as a function.
type family CmpNat (m :: Nat) (n :: Nat) :: Ordering

-- | Division (round down) of natural numbers. <tt>Div x 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Div (m :: Nat) (n :: Nat) :: Nat
infixl 7 `Div`

-- | Modulus of natural numbers. <tt>Mod x 0</tt> is undefined (i.e., it
--   cannot be reduced).
type family Mod (m :: Nat) (n :: Nat) :: Nat
infixl 7 `Mod`

-- | Log base 2 (round down) of natural numbers. <tt>Log 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Log2 (m :: Nat) :: Nat
instance GHC.Classes.Eq GHC.TypeNats.SomeNat
instance GHC.Classes.Ord GHC.TypeNats.SomeNat
instance GHC.Show.Show GHC.TypeNats.SomeNat
instance GHC.Read.Read GHC.TypeNats.SomeNat


-- | This module is an internal GHC module. It declares the constants used
--   in the implementation of type-level natural numbers. The programmer
--   interface for working with type-level naturals should be defined in a
--   separate library.
module GHC.TypeLits

-- | (Kind) This is the kind of type-level natural numbers.
data Nat

-- | (Kind) This is the kind of type-level symbols. Declared here because
--   class IP needs it
data Symbol

-- | This class gives the integer associated with a type-level natural.
--   There are instances of the class for every concrete literal: 0, 1, 2,
--   etc.
class KnownNat (n :: Nat)

natVal :: forall n proxy. KnownNat n => proxy n -> Integer

natVal' :: forall n. KnownNat n => Proxy# n -> Integer

-- | This class gives the string associated with a type-level symbol. There
--   are instances of the class for every concrete literal: "hello", etc.
class KnownSymbol (n :: Symbol)

symbolVal :: forall n proxy. KnownSymbol n => proxy n -> String

symbolVal' :: forall n. KnownSymbol n => Proxy# n -> String

-- | This type represents unknown type-level natural numbers.
data SomeNat
SomeNat :: Proxy n -> SomeNat

-- | This type represents unknown type-level symbols.
data SomeSymbol

SomeSymbol :: Proxy n -> SomeSymbol

-- | Convert an integer into an unknown type-level natural.
someNatVal :: Integer -> Maybe SomeNat

-- | Convert a string into an unknown type-level symbol.
someSymbolVal :: String -> SomeSymbol

-- | We either get evidence that this function was instantiated with the
--   same type-level numbers, or <a>Nothing</a>.
sameNat :: (KnownNat a, KnownNat b) => Proxy a -> Proxy b -> Maybe (a :~: b)

-- | We either get evidence that this function was instantiated with the
--   same type-level symbols, or <a>Nothing</a>.
sameSymbol :: (KnownSymbol a, KnownSymbol b) => Proxy a -> Proxy b -> Maybe (a :~: b)

-- | Comparison of type-level naturals, as a constraint.
type x <= y = (x <=? y) ~  'True
infix 4 <=

-- | Comparison of type-level naturals, as a function. NOTE: The
--   functionality for this function should be subsumed by <a>CmpNat</a>,
--   so this might go away in the future. Please let us know, if you
--   encounter discrepancies between the two.
type family (m :: Nat) <=? (n :: Nat) :: Bool
infix 4 <=?

-- | Addition of type-level naturals.
type family (m :: Nat) + (n :: Nat) :: Nat
infixl 6 +

-- | Multiplication of type-level naturals.
type family (m :: Nat) * (n :: Nat) :: Nat
infixl 7 *

-- | Exponentiation of type-level naturals.
type family (m :: Nat) ^ (n :: Nat) :: Nat
infixr 8 ^

-- | Subtraction of type-level naturals.
type family (m :: Nat) - (n :: Nat) :: Nat
infixl 6 -

-- | Division (round down) of natural numbers. <tt>Div x 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Div (m :: Nat) (n :: Nat) :: Nat
infixl 7 `Div`

-- | Modulus of natural numbers. <tt>Mod x 0</tt> is undefined (i.e., it
--   cannot be reduced).
type family Mod (m :: Nat) (n :: Nat) :: Nat
infixl 7 `Mod`

-- | Log base 2 (round down) of natural numbers. <tt>Log 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Log2 (m :: Nat) :: Nat

-- | Concatenation of type-level symbols.
type family AppendSymbol (m :: Symbol) (n :: Symbol) :: Symbol

-- | Comparison of type-level naturals, as a function.
type family CmpNat (m :: Nat) (n :: Nat) :: Ordering

-- | Comparison of type-level symbols, as a function.
type family CmpSymbol (m :: Symbol) (n :: Symbol) :: Ordering

-- | The type-level equivalent of <tt>error</tt>.
--   
--   The polymorphic kind of this type allows it to be used in several
--   settings. For instance, it can be used as a constraint, e.g. to
--   provide a better error message for a non-existent instance,
--   
--   <pre>
--   -- in a context
--   instance TypeError (Text "Cannot <a>Show</a> functions." :$$:
--                       Text "Perhaps there is a missing argument?")
--         =&gt; Show (a -&gt; b) where
--       showsPrec = error "unreachable"
--   </pre>
--   
--   It can also be placed on the right-hand side of a type-level function
--   to provide an error for an invalid case,
--   
--   <pre>
--   type family ByteSize x where
--      ByteSize Word16   = 2
--      ByteSize Word8    = 1
--      ByteSize a        = TypeError (Text "The type " :&lt;&gt;: ShowType a :&lt;&gt;:
--                                     Text " is not exportable.")
--   </pre>
type family TypeError (a :: ErrorMessage) :: b

-- | A description of a custom type error.
data ErrorMessage

-- | Show the text as is.
Text :: Symbol -> ErrorMessage

-- | Pretty print the type. <tt>ShowType :: k -&gt; ErrorMessage</tt>
ShowType :: t -> ErrorMessage

-- | Put two pieces of error message next to each other.
(:<>:) :: ErrorMessage -> ErrorMessage -> ErrorMessage

-- | Stack two pieces of error message on top of each other.
(:$$:) :: ErrorMessage -> ErrorMessage -> ErrorMessage
infixl 6 :<>:
infixl 5 :$$:
instance GHC.Classes.Eq GHC.TypeLits.SomeSymbol
instance GHC.Classes.Ord GHC.TypeLits.SomeSymbol
instance GHC.Show.Show GHC.TypeLits.SomeSymbol
instance GHC.Read.Read GHC.TypeLits.SomeSymbol


-- | If you're using <tt>GHC.Generics</tt>, you should consider using the
--   <a>http://hackage.haskell.org/package/generic-deriving</a> package,
--   which contains many useful generic functions.
module GHC.Generics

-- | Void: used for datatypes without constructors
data V1 (p :: k)

-- | Unit: used for constructors without arguments
data U1 (p :: k)
U1 :: U1

-- | Used for marking occurrences of the parameter
newtype Par1 p
Par1 :: p -> Par1 p
[unPar1] :: Par1 p -> p

-- | Recursive calls of kind <tt>* -&gt; *</tt> (or kind <tt>k -&gt;
--   *</tt>, when <tt>PolyKinds</tt> is enabled)
newtype Rec1 (f :: k -> Type) (p :: k)
Rec1 :: f p -> Rec1
[unRec1] :: Rec1 -> f p

-- | Constants, additional parameters and recursion of kind <tt>*</tt>
newtype K1 (i :: Type) c (p :: k)
K1 :: c -> K1 c
[unK1] :: K1 c -> c

-- | Meta-information (constructor names, etc.)
newtype M1 (i :: Type) (c :: Meta) (f :: k -> Type) (p :: k)
M1 :: f p -> M1
[unM1] :: M1 -> f p

-- | Sums: encode choice between constructors
data (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k)
L1 :: f p -> (:+:)
R1 :: g p -> (:+:)
infixr 5 :+:

-- | Products: encode multiple arguments to constructors
data (:*:) (f :: k -> Type) (g :: k -> Type) (p :: k)
(:*:) :: f p -> g p -> (:*:)
infixr 6 :*:
infixr 6 :*:

-- | Composition of functors
newtype (:.:) (f :: k2 -> Type) (g :: k1 -> k2) (p :: k1)
Comp1 :: f (g p) -> (:.:)
[unComp1] :: (:.:) -> f (g p)
infixr 7 :.:

-- | Constants of unlifted kinds
data family URec (a :: Type) (p :: k)

-- | Type synonym for <tt><a>URec</a> <a>Addr#</a></tt>
type UAddr = URec (Ptr ())

-- | Type synonym for <tt><a>URec</a> <a>Char#</a></tt>
type UChar = URec Char

-- | Type synonym for <tt><a>URec</a> <a>Double#</a></tt>
type UDouble = URec Double

-- | Type synonym for <tt><a>URec</a> <a>Float#</a></tt>
type UFloat = URec Float

-- | Type synonym for <tt><a>URec</a> <a>Int#</a></tt>
type UInt = URec Int

-- | Type synonym for <tt><a>URec</a> <a>Word#</a></tt>
type UWord = URec Word

-- | Type synonym for encoding recursion (of kind <tt>Type</tt>)
type Rec0 = K1 R

-- | Tag for K1: recursion (of kind <tt>Type</tt>)
data R

-- | Type synonym for encoding meta-information for datatypes
type D1 = M1 D

-- | Type synonym for encoding meta-information for constructors
type C1 = M1 C

-- | Type synonym for encoding meta-information for record selectors
type S1 = M1 S

-- | Tag for M1: datatype
data D

-- | Tag for M1: constructor
data C

-- | Tag for M1: record selector
data S

-- | Class for datatypes that represent datatypes
class Datatype d

-- | The name of the datatype (unqualified)
datatypeName :: Datatype d => t d (f :: k -> Type) (a :: k) -> [Char]

-- | The fully-qualified name of the module where the type is declared
moduleName :: Datatype d => t d (f :: k -> Type) (a :: k) -> [Char]

-- | The package name of the module where the type is declared
packageName :: Datatype d => t d (f :: k -> Type) (a :: k) -> [Char]

-- | Marks if the datatype is actually a newtype
isNewtype :: Datatype d => t d (f :: k -> Type) (a :: k) -> Bool

-- | Class for datatypes that represent data constructors
class Constructor c

-- | The name of the constructor
conName :: Constructor c => t c (f :: k -> Type) (a :: k) -> [Char]

-- | The fixity of the constructor
conFixity :: Constructor c => t c (f :: k -> Type) (a :: k) -> Fixity

-- | Marks if this constructor is a record
conIsRecord :: Constructor c => t c (f :: k -> Type) (a :: k) -> Bool

-- | Class for datatypes that represent records
class Selector s

-- | The name of the selector
selName :: Selector s => t s (f :: k -> Type) (a :: k) -> [Char]

-- | The selector's unpackedness annotation (if any)
selSourceUnpackedness :: Selector s => t s (f :: k -> Type) (a :: k) -> SourceUnpackedness

-- | The selector's strictness annotation (if any)
selSourceStrictness :: Selector s => t s (f :: k -> Type) (a :: k) -> SourceStrictness

-- | The strictness that the compiler inferred for the selector
selDecidedStrictness :: Selector s => t s (f :: k -> Type) (a :: k) -> DecidedStrictness

-- | Datatype to represent the fixity of a constructor. An infix |
--   declaration directly corresponds to an application of <a>Infix</a>.
data Fixity
Prefix :: Fixity
Infix :: Associativity -> Int -> Fixity

-- | This variant of <a>Fixity</a> appears at the type level.
data FixityI
PrefixI :: FixityI
InfixI :: Associativity -> Nat -> FixityI

-- | Datatype to represent the associativity of a constructor
data Associativity
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity

-- | Get the precedence of a fixity value.
prec :: Fixity -> Int

-- | The unpackedness of a field as the user wrote it in the source code.
--   For example, in the following data type:
--   
--   <pre>
--   data E = ExampleConstructor     Int
--              {-# NOUNPACK #-} Int
--              {-#   UNPACK #-} Int
--   </pre>
--   
--   The fields of <tt>ExampleConstructor</tt> have
--   <a>NoSourceUnpackedness</a>, <a>SourceNoUnpack</a>, and
--   <a>SourceUnpack</a>, respectively.
data SourceUnpackedness
NoSourceUnpackedness :: SourceUnpackedness
SourceNoUnpack :: SourceUnpackedness
SourceUnpack :: SourceUnpackedness

-- | The strictness of a field as the user wrote it in the source code. For
--   example, in the following data type:
--   
--   <pre>
--   data E = ExampleConstructor Int ~Int !Int
--   </pre>
--   
--   The fields of <tt>ExampleConstructor</tt> have
--   <a>NoSourceStrictness</a>, <a>SourceLazy</a>, and <a>SourceStrict</a>,
--   respectively.
data SourceStrictness
NoSourceStrictness :: SourceStrictness
SourceLazy :: SourceStrictness
SourceStrict :: SourceStrictness

-- | The strictness that GHC infers for a field during compilation. Whereas
--   there are nine different combinations of <a>SourceUnpackedness</a> and
--   <a>SourceStrictness</a>, the strictness that GHC decides will
--   ultimately be one of lazy, strict, or unpacked. What GHC decides is
--   affected both by what the user writes in the source code and by GHC
--   flags. As an example, consider this data type:
--   
--   <pre>
--   data E = ExampleConstructor {-# UNPACK #-} !Int !Int Int
--   </pre>
--   
--   <ul>
--   <li>If compiled without optimization or other language extensions,
--   then the fields of <tt>ExampleConstructor</tt> will have
--   <a>DecidedStrict</a>, <a>DecidedStrict</a>, and <a>DecidedLazy</a>,
--   respectively.</li>
--   <li>If compiled with <tt>-XStrictData</tt> enabled, then the fields
--   will have <a>DecidedStrict</a>, <a>DecidedStrict</a>, and
--   <a>DecidedStrict</a>, respectively.</li>
--   <li>If compiled with <tt>-O2</tt> enabled, then the fields will have
--   <a>DecidedUnpack</a>, <a>DecidedStrict</a>, and <a>DecidedLazy</a>,
--   respectively.</li>
--   </ul>
data DecidedStrictness
DecidedLazy :: DecidedStrictness
DecidedStrict :: DecidedStrictness
DecidedUnpack :: DecidedStrictness

-- | Datatype to represent metadata associated with a datatype
--   (<tt>MetaData</tt>), constructor (<tt>MetaCons</tt>), or field
--   selector (<tt>MetaSel</tt>).
--   
--   <ul>
--   <li>In <tt>MetaData n m p nt</tt>, <tt>n</tt> is the datatype's name,
--   <tt>m</tt> is the module in which the datatype is defined, <tt>p</tt>
--   is the package in which the datatype is defined, and <tt>nt</tt> is
--   <tt>'True</tt> if the datatype is a <tt>newtype</tt>.</li>
--   <li>In <tt>MetaCons n f s</tt>, <tt>n</tt> is the constructor's name,
--   <tt>f</tt> is its fixity, and <tt>s</tt> is <tt>'True</tt> if the
--   constructor contains record selectors.</li>
--   <li>In <tt>MetaSel mn su ss ds</tt>, if the field uses record syntax,
--   then <tt>mn</tt> is <a>Just</a> the record name. Otherwise,
--   <tt>mn</tt> is <a>Nothing</a>. <tt>su</tt> and <tt>ss</tt> are the
--   field's unpackedness and strictness annotations, and <tt>ds</tt> is
--   the strictness that GHC infers for the field.</li>
--   </ul>
data Meta
MetaData :: Symbol -> Symbol -> Symbol -> Bool -> Meta
MetaCons :: Symbol -> FixityI -> Bool -> Meta
MetaSel :: Maybe Symbol -> SourceUnpackedness -> SourceStrictness -> DecidedStrictness -> Meta

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <tt>id</tt>
--   <a>to</a> . <a>from</a> ≡ <tt>id</tt>
--   </pre>
class Generic a where {
    
    -- | Generic representation type
    type family Rep a :: Type -> Type;
}

-- | Convert from the datatype to its representation
from :: Generic a => a -> Rep a x

-- | Convert from the representation to the datatype
to :: Generic a => Rep a x -> a

-- | Representable types of kind <tt>* -&gt; *</tt> (or kind <tt>k -&gt;
--   *</tt>, when <tt>PolyKinds</tt> is enabled). This class is derivable
--   in GHC with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic1</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from1</a> . <a>to1</a> ≡ <tt>id</tt>
--   <a>to1</a> . <a>from1</a> ≡ <tt>id</tt>
--   </pre>
class Generic1 (f :: k -> Type) where {
    
    -- | Generic representation type
    type family Rep1 f :: k -> Type;
}

-- | Convert from the datatype to its representation
from1 :: Generic1 f => f a -> Rep1 f a

-- | Convert from the representation to the datatype
to1 :: Generic1 f => Rep1 f a -> f a
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *). GHC.Generics.Generic1 (GHC.Generics.M1 i c f)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Generics.Generic (GHC.Generics.M1 i c f p)
instance GHC.Base.Functor f => GHC.Base.Functor (GHC.Generics.M1 i c f)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Show.Show (f p) => GHC.Show.Show (GHC.Generics.M1 i c f p)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Read.Read (f p) => GHC.Read.Read (GHC.Generics.M1 i c f p)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Classes.Ord (f p) => GHC.Classes.Ord (GHC.Generics.M1 i c f p)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Classes.Eq (f p) => GHC.Classes.Eq (GHC.Generics.M1 i c f p)
instance GHC.Generics.Generic1 GHC.Generics.V1
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.V1 p)
instance GHC.Base.Functor GHC.Generics.V1
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.V1 p)
instance forall k (p :: k). GHC.Read.Read (GHC.Generics.V1 p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.V1 p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.V1 p)
instance GHC.Generics.Generic1 GHC.Generics.U1
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.U1 p)
instance GHC.Generics.Generic1 GHC.Generics.Par1
instance GHC.Generics.Generic (GHC.Generics.Par1 p)
instance GHC.Base.Functor GHC.Generics.Par1
instance GHC.Show.Show p => GHC.Show.Show (GHC.Generics.Par1 p)
instance GHC.Read.Read p => GHC.Read.Read (GHC.Generics.Par1 p)
instance GHC.Classes.Ord p => GHC.Classes.Ord (GHC.Generics.Par1 p)
instance GHC.Classes.Eq p => GHC.Classes.Eq (GHC.Generics.Par1 p)
instance forall k (f :: k -> *). GHC.Generics.Generic1 (GHC.Generics.Rec1 f)
instance forall k (f :: k -> *) (p :: k). GHC.Generics.Generic (GHC.Generics.Rec1 f p)
instance GHC.Base.Functor f => GHC.Base.Functor (GHC.Generics.Rec1 f)
instance forall k (f :: k -> *) (p :: k). GHC.Show.Show (f p) => GHC.Show.Show (GHC.Generics.Rec1 f p)
instance forall k (f :: k -> *) (p :: k). GHC.Read.Read (f p) => GHC.Read.Read (GHC.Generics.Rec1 f p)
instance forall k (f :: k -> *) (p :: k). GHC.Classes.Ord (f p) => GHC.Classes.Ord (GHC.Generics.Rec1 f p)
instance forall k (f :: k -> *) (p :: k). GHC.Classes.Eq (f p) => GHC.Classes.Eq (GHC.Generics.Rec1 f p)
instance GHC.Generics.Generic1 (GHC.Generics.K1 i c)
instance forall i c k (p :: k). GHC.Generics.Generic (GHC.Generics.K1 i c p)
instance GHC.Base.Functor (GHC.Generics.K1 i c)
instance forall i c k (p :: k). GHC.Show.Show c => GHC.Show.Show (GHC.Generics.K1 i c p)
instance forall i c k (p :: k). GHC.Read.Read c => GHC.Read.Read (GHC.Generics.K1 i c p)
instance forall i c k (p :: k). GHC.Classes.Ord c => GHC.Classes.Ord (GHC.Generics.K1 i c p)
instance forall i c k (p :: k). GHC.Classes.Eq c => GHC.Classes.Eq (GHC.Generics.K1 i c p)
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). GHC.Generics.Generic ((GHC.Generics.:+:) f g p)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Show.Show (f p), GHC.Show.Show (g p)) => GHC.Show.Show ((GHC.Generics.:+:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Read.Read (f p), GHC.Read.Read (g p)) => GHC.Read.Read ((GHC.Generics.:+:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Ord (f p), GHC.Classes.Ord (g p)) => GHC.Classes.Ord ((GHC.Generics.:+:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Eq (f p), GHC.Classes.Eq (g p)) => GHC.Classes.Eq ((GHC.Generics.:+:) f g p)
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). GHC.Generics.Generic ((GHC.Generics.:*:) f g p)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Show.Show (f p), GHC.Show.Show (g p)) => GHC.Show.Show ((GHC.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Read.Read (f p), GHC.Read.Read (g p)) => GHC.Read.Read ((GHC.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Ord (f p), GHC.Classes.Ord (g p)) => GHC.Classes.Ord ((GHC.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Eq (f p), GHC.Classes.Eq (g p)) => GHC.Classes.Eq ((GHC.Generics.:*:) f g p)
instance forall (f :: * -> *) k (g :: k -> *). GHC.Base.Functor f => GHC.Generics.Generic1 (f GHC.Generics.:.: g)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Generics.Generic ((GHC.Generics.:.:) f g p)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (f GHC.Generics.:.: g)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Show.Show (f (g p)) => GHC.Show.Show ((GHC.Generics.:.:) f g p)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Read.Read (f (g p)) => GHC.Read.Read ((GHC.Generics.:.:) f g p)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Classes.Ord (f (g p)) => GHC.Classes.Ord ((GHC.Generics.:.:) f g p)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Classes.Eq (f (g p)) => GHC.Classes.Eq ((GHC.Generics.:.:) f g p)
instance GHC.Generics.Generic GHC.Generics.Fixity
instance GHC.Read.Read GHC.Generics.Fixity
instance GHC.Classes.Ord GHC.Generics.Fixity
instance GHC.Show.Show GHC.Generics.Fixity
instance GHC.Classes.Eq GHC.Generics.Fixity
instance GHC.Generics.Generic GHC.Generics.Associativity
instance GHC.Arr.Ix GHC.Generics.Associativity
instance GHC.Enum.Bounded GHC.Generics.Associativity
instance GHC.Enum.Enum GHC.Generics.Associativity
instance GHC.Read.Read GHC.Generics.Associativity
instance GHC.Classes.Ord GHC.Generics.Associativity
instance GHC.Show.Show GHC.Generics.Associativity
instance GHC.Classes.Eq GHC.Generics.Associativity
instance GHC.Generics.Generic GHC.Generics.SourceUnpackedness
instance GHC.Arr.Ix GHC.Generics.SourceUnpackedness
instance GHC.Enum.Bounded GHC.Generics.SourceUnpackedness
instance GHC.Enum.Enum GHC.Generics.SourceUnpackedness
instance GHC.Read.Read GHC.Generics.SourceUnpackedness
instance GHC.Classes.Ord GHC.Generics.SourceUnpackedness
instance GHC.Show.Show GHC.Generics.SourceUnpackedness
instance GHC.Classes.Eq GHC.Generics.SourceUnpackedness
instance GHC.Generics.Generic GHC.Generics.SourceStrictness
instance GHC.Arr.Ix GHC.Generics.SourceStrictness
instance GHC.Enum.Bounded GHC.Generics.SourceStrictness
instance GHC.Enum.Enum GHC.Generics.SourceStrictness
instance GHC.Read.Read GHC.Generics.SourceStrictness
instance GHC.Classes.Ord GHC.Generics.SourceStrictness
instance GHC.Show.Show GHC.Generics.SourceStrictness
instance GHC.Classes.Eq GHC.Generics.SourceStrictness
instance GHC.Generics.Generic GHC.Generics.DecidedStrictness
instance GHC.Arr.Ix GHC.Generics.DecidedStrictness
instance GHC.Enum.Bounded GHC.Generics.DecidedStrictness
instance GHC.Enum.Enum GHC.Generics.DecidedStrictness
instance GHC.Read.Read GHC.Generics.DecidedStrictness
instance GHC.Classes.Ord GHC.Generics.DecidedStrictness
instance GHC.Show.Show GHC.Generics.DecidedStrictness
instance GHC.Classes.Eq GHC.Generics.DecidedStrictness
instance GHC.Generics.Generic1 (GHC.Generics.URec (GHC.Ptr.Ptr ()))
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec (GHC.Ptr.Ptr ()) p)
instance GHC.Base.Functor (GHC.Generics.URec (GHC.Ptr.Ptr ()))
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec (GHC.Ptr.Ptr ()) p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec (GHC.Ptr.Ptr ()) p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Char)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Char p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Char)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Char p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Char p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Char p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Double)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Double p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Double)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Double p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Double p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Double p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Float)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Float p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Float)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Float p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Float p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Float p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Int)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Int p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Int)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Int p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Int p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Int p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Word)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Word p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Word)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Word p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Word p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Word p)
instance forall k (p :: k). GHC.Read.Read (GHC.Generics.U1 p)
instance GHC.Base.Semigroup p => GHC.Base.Semigroup (GHC.Generics.Par1 p)
instance GHC.Base.Monoid p => GHC.Base.Monoid (GHC.Generics.Par1 p)
instance GHC.Base.Applicative f => GHC.Base.Applicative (GHC.Generics.Rec1 f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (GHC.Generics.Rec1 f)
instance GHC.Base.MonadPlus f => GHC.Base.MonadPlus (GHC.Generics.Rec1 f)
instance forall k (f :: k -> *) (p :: k). GHC.Base.Semigroup (f p) => GHC.Base.Semigroup (GHC.Generics.Rec1 f p)
instance forall k (f :: k -> *) (p :: k). GHC.Base.Monoid (f p) => GHC.Base.Monoid (GHC.Generics.Rec1 f p)
instance forall k c i (p :: k). GHC.Base.Semigroup c => GHC.Base.Semigroup (GHC.Generics.K1 i c p)
instance forall k c i (p :: k). GHC.Base.Monoid c => GHC.Base.Monoid (GHC.Generics.K1 i c p)
instance GHC.Base.Applicative f => GHC.Base.Applicative (GHC.Generics.M1 i c f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (GHC.Generics.M1 i c f)
instance GHC.Base.Monad f => GHC.Base.Monad (GHC.Generics.M1 i c f)
instance GHC.Base.MonadPlus f => GHC.Base.MonadPlus (GHC.Generics.M1 i c f)
instance forall k (f :: k -> *) (p :: k) i (c :: GHC.Generics.Meta). GHC.Base.Semigroup (f p) => GHC.Base.Semigroup (GHC.Generics.M1 i c f p)
instance forall k (f :: k -> *) (p :: k) i (c :: GHC.Generics.Meta). GHC.Base.Monoid (f p) => GHC.Base.Monoid (GHC.Generics.M1 i c f p)
instance forall k1 k2 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). GHC.Base.Semigroup (f (g p)) => GHC.Base.Semigroup ((GHC.Generics.:.:) f g p)
instance forall k1 k2 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). GHC.Base.Monoid (f (g p)) => GHC.Base.Monoid ((GHC.Generics.:.:) f g p)
instance GHC.Generics.Generic [a]
instance GHC.Generics.Generic (GHC.Base.NonEmpty a)
instance GHC.Generics.Generic (GHC.Maybe.Maybe a)
instance GHC.Generics.Generic (Data.Either.Either a b)
instance GHC.Generics.Generic GHC.Types.Bool
instance GHC.Generics.Generic GHC.Types.Ordering
instance forall k (t :: k). GHC.Generics.Generic (Data.Proxy.Proxy t)
instance GHC.Generics.Generic ()
instance GHC.Generics.Generic (a, b)
instance GHC.Generics.Generic (a, b, c)
instance GHC.Generics.Generic (a, b, c, d)
instance GHC.Generics.Generic (a, b, c, d, e)
instance GHC.Generics.Generic (a, b, c, d, e, f)
instance GHC.Generics.Generic (a, b, c, d, e, f, g)
instance GHC.Generics.Generic (Data.Ord.Down a)
instance GHC.Generics.Generic1 []
instance GHC.Generics.Generic1 GHC.Base.NonEmpty
instance GHC.Generics.Generic1 GHC.Maybe.Maybe
instance GHC.Generics.Generic1 (Data.Either.Either a)
instance GHC.Generics.Generic1 Data.Proxy.Proxy
instance GHC.Generics.Generic1 ((,) a)
instance GHC.Generics.Generic1 ((,,) a b)
instance GHC.Generics.Generic1 ((,,,) a b c)
instance GHC.Generics.Generic1 ((,,,,) a b c d)
instance GHC.Generics.Generic1 ((,,,,,) a b c d e)
instance GHC.Generics.Generic1 ((,,,,,,) a b c d e f)
instance GHC.Generics.Generic1 Data.Ord.Down
instance (GHC.TypeLits.KnownSymbol n, GHC.TypeLits.KnownSymbol m, GHC.TypeLits.KnownSymbol p, GHC.Generics.SingI nt) => GHC.Generics.Datatype ('GHC.Generics.MetaData n m p nt)
instance (GHC.TypeLits.KnownSymbol n, GHC.Generics.SingI f, GHC.Generics.SingI r) => GHC.Generics.Constructor ('GHC.Generics.MetaCons n f r)
instance (GHC.Generics.SingI mn, GHC.Generics.SingI su, GHC.Generics.SingI ss, GHC.Generics.SingI ds) => GHC.Generics.Selector ('GHC.Generics.MetaSel mn su ss ds)
instance GHC.Generics.SingKind GHC.Types.Symbol
instance GHC.Generics.SingKind GHC.Types.Bool
instance GHC.Generics.SingKind a => GHC.Generics.SingKind (GHC.Maybe.Maybe a)
instance GHC.Generics.SingKind GHC.Generics.FixityI
instance GHC.Generics.SingKind GHC.Generics.Associativity
instance GHC.Generics.SingKind GHC.Generics.SourceUnpackedness
instance GHC.Generics.SingKind GHC.Generics.SourceStrictness
instance GHC.Generics.SingKind GHC.Generics.DecidedStrictness
instance GHC.TypeLits.KnownSymbol a => GHC.Generics.SingI a
instance GHC.Generics.SingI 'GHC.Types.True
instance GHC.Generics.SingI 'GHC.Types.False
instance GHC.Generics.SingI 'GHC.Maybe.Nothing
instance forall a1 (a2 :: a1). GHC.Generics.SingI a2 => GHC.Generics.SingI ('GHC.Maybe.Just a2)
instance GHC.Generics.SingI 'GHC.Generics.PrefixI
instance (GHC.Generics.SingI a, GHC.TypeNats.KnownNat n) => GHC.Generics.SingI ('GHC.Generics.InfixI a n)
instance GHC.Generics.SingI 'GHC.Generics.LeftAssociative
instance GHC.Generics.SingI 'GHC.Generics.RightAssociative
instance GHC.Generics.SingI 'GHC.Generics.NotAssociative
instance GHC.Generics.SingI 'GHC.Generics.NoSourceUnpackedness
instance GHC.Generics.SingI 'GHC.Generics.SourceNoUnpack
instance GHC.Generics.SingI 'GHC.Generics.SourceUnpack
instance GHC.Generics.SingI 'GHC.Generics.NoSourceStrictness
instance GHC.Generics.SingI 'GHC.Generics.SourceLazy
instance GHC.Generics.SingI 'GHC.Generics.SourceStrict
instance GHC.Generics.SingI 'GHC.Generics.DecidedLazy
instance GHC.Generics.SingI 'GHC.Generics.DecidedStrict
instance GHC.Generics.SingI 'GHC.Generics.DecidedUnpack
instance forall k (p :: k). GHC.Base.Semigroup (GHC.Generics.V1 p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.U1 p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.U1 p)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.U1 p)
instance GHC.Base.Functor GHC.Generics.U1
instance GHC.Base.Applicative GHC.Generics.U1
instance GHC.Base.Alternative GHC.Generics.U1
instance GHC.Base.Monad GHC.Generics.U1
instance GHC.Base.MonadPlus GHC.Generics.U1
instance forall k (p :: k). GHC.Base.Semigroup (GHC.Generics.U1 p)
instance forall k (p :: k). GHC.Base.Monoid (GHC.Generics.U1 p)
instance GHC.Base.Applicative GHC.Generics.Par1
instance GHC.Base.Monad GHC.Generics.Par1
instance GHC.Base.Monad f => GHC.Base.Monad (GHC.Generics.Rec1 f)
instance GHC.Base.Monoid c => GHC.Base.Applicative (GHC.Generics.K1 i c)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (f GHC.Generics.:*: g)
instance (GHC.Base.Alternative f, GHC.Base.Alternative g) => GHC.Base.Alternative (f GHC.Generics.:*: g)
instance (GHC.Base.Monad f, GHC.Base.Monad g) => GHC.Base.Monad (f GHC.Generics.:*: g)
instance (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) => GHC.Base.MonadPlus (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (GHC.Base.Semigroup (f p), GHC.Base.Semigroup (g p)) => GHC.Base.Semigroup ((GHC.Generics.:*:) f g p)
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (GHC.Base.Monoid (f p), GHC.Base.Monoid (g p)) => GHC.Base.Monoid ((GHC.Generics.:*:) f g p)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (f GHC.Generics.:.: g)
instance (GHC.Base.Alternative f, GHC.Base.Applicative g) => GHC.Base.Alternative (f GHC.Generics.:.: g)


-- | A class for monoids (types with an associative binary operation that
--   has an identity) with various general-purpose instances.
module Data.Monoid

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> <a>mempty</a> = x</pre></li>
--   <li><pre><a>mempty</a> <a>&lt;&gt;</a> x = x</pre></li>
--   <li><tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a> law)</li>
--   <li><pre><a>mconcat</a> = <a>foldr</a> '(&lt;&gt;)'
--   <a>mempty</a></pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <tt>Sum</tt> and <tt>Product</tt>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = '(&lt;&gt;)'</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
mconcat :: Monoid a => [a] -> a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>.
--   
--   <pre>
--   &gt;&gt;&gt; getDual (mappend (Dual "Hello") (Dual "World"))
--   "WorldHello"
--   </pre>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Boolean monoid under conjunction (<a>&amp;&amp;</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAll (mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8]))
--   False
--   </pre>
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Boolean monoid under disjunction (<a>||</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAny (mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8]))
--   True
--   </pre>
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
--   
--   <pre>
--   &gt;&gt;&gt; getSum (Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty)
--   3
--   </pre>
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; getProduct (Product 3 &lt;&gt; Product 4 &lt;&gt; mempty)
--   12
--   </pre>
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | Maybe monoid returning the leftmost non-Nothing value.
--   
--   <tt><a>First</a> a</tt> is isomorphic to <tt><a>Alt</a> <a>Maybe</a>
--   a</tt>, but precedes it historically.
--   
--   <pre>
--   &gt;&gt;&gt; getFirst (First (Just "hello") &lt;&gt; First Nothing &lt;&gt; First (Just "world"))
--   Just "hello"
--   </pre>
--   
--   Use of this type is discouraged. Note the following equivalence:
--   
--   <pre>
--   Data.Monoid.First x === Maybe (Data.Semigroup.First x)
--   </pre>
--   
--   In addition to being equivalent in the structural sense, the two also
--   have <a>Monoid</a> instances that behave the same. This type will be
--   marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are
--   advised to use the variant from <a>Data.Semigroup</a> and wrap it in
--   <a>Maybe</a>.
newtype First a
First :: Maybe a -> First a
[getFirst] :: First a -> Maybe a

-- | Maybe monoid returning the rightmost non-Nothing value.
--   
--   <tt><a>Last</a> a</tt> is isomorphic to <tt><a>Dual</a> (<a>First</a>
--   a)</tt>, and thus to <tt><a>Dual</a> (<a>Alt</a> <a>Maybe</a> a)</tt>
--   
--   <pre>
--   &gt;&gt;&gt; getLast (Last (Just "hello") &lt;&gt; Last Nothing &lt;&gt; Last (Just "world"))
--   Just "world"
--   </pre>
--   
--   Use of this type is discouraged. Note the following equivalence:
--   
--   <pre>
--   Data.Monoid.Last x === Maybe (Data.Semigroup.Last x)
--   </pre>
--   
--   In addition to being equivalent in the structural sense, the two also
--   have <a>Monoid</a> instances that behave the same. This type will be
--   marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are
--   advised to use the variant from <a>Data.Semigroup</a> and wrap it in
--   <a>Maybe</a>.
newtype Last a
Last :: Maybe a -> Last a
[getLast] :: Last a -> Maybe a

-- | Monoid under <a>&lt;|&gt;</a>.
newtype Alt f a
Alt :: f a -> Alt f a
[getAlt] :: Alt f a -> f a

-- | This data type witnesses the lifting of a <a>Monoid</a> into an
--   <a>Applicative</a> pointwise.
newtype Ap f a
Ap :: f a -> Ap f a
[getAp] :: Ap f a -> f a
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Monoid.Ap f a)
instance forall k (f :: k -> *) (a :: k). GHC.Read.Read (f a) => GHC.Read.Read (Data.Monoid.Ap f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Monoid.Ap f a)
instance GHC.Base.MonadPlus f => GHC.Base.MonadPlus (Data.Monoid.Ap f)
instance Control.Monad.Fail.MonadFail f => Control.Monad.Fail.MonadFail (Data.Monoid.Ap f)
instance GHC.Base.Monad f => GHC.Base.Monad (Data.Monoid.Ap f)
instance forall k (f :: k -> *). GHC.Generics.Generic1 (Data.Monoid.Ap f)
instance forall k (f :: k -> *) (a :: k). GHC.Generics.Generic (Data.Monoid.Ap f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Monoid.Ap f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Monoid.Ap f a)
instance forall k (f :: k -> *) (a :: k). GHC.Enum.Enum (f a) => GHC.Enum.Enum (Data.Monoid.Ap f a)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Monoid.Ap f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Data.Monoid.Ap f)
instance GHC.Base.Monad Data.Monoid.Last
instance GHC.Base.Applicative Data.Monoid.Last
instance GHC.Base.Functor Data.Monoid.Last
instance GHC.Generics.Generic1 Data.Monoid.Last
instance GHC.Generics.Generic (Data.Monoid.Last a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Monoid.Last a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Monoid.Last a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.Last a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.Last a)
instance GHC.Base.Monad Data.Monoid.First
instance GHC.Base.Applicative Data.Monoid.First
instance GHC.Base.Functor Data.Monoid.First
instance GHC.Generics.Generic1 Data.Monoid.First
instance GHC.Generics.Generic (Data.Monoid.First a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Monoid.First a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Monoid.First a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.First a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.First a)
instance (GHC.Base.Applicative f, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Data.Monoid.Ap f a)
instance (GHC.Base.Applicative f, GHC.Base.Monoid a) => GHC.Base.Monoid (Data.Monoid.Ap f a)
instance (GHC.Base.Applicative f, GHC.Enum.Bounded a) => GHC.Enum.Bounded (Data.Monoid.Ap f a)
instance (GHC.Base.Applicative f, GHC.Num.Num a) => GHC.Num.Num (Data.Monoid.Ap f a)
instance GHC.Base.Semigroup (Data.Monoid.Last a)
instance GHC.Base.Monoid (Data.Monoid.Last a)
instance GHC.Base.Semigroup (Data.Monoid.First a)
instance GHC.Base.Monoid (Data.Monoid.First a)


-- | Class of data structures that can be folded to a summary value.
module Data.Foldable

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable t

-- | Combine the elements of a structure using a monoid.
fold :: (Foldable t, Monoid m) => t m -> m

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Right-associative fold of a structure, but with strict application of
--   the operator.
foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl'</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl'</a> instead of <a>foldl</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>z <tt>f</tt>
--   x1</tt> in the above example) before applying them to the operator
--   (e.g. to <tt>(<tt>f</tt> x2)</tt>). This results in a thunk chain
--   <tt>O(n)</tt> elements long, which then must be evaluated from the
--   outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <a>length</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | List of elements of a structure, from left to right.
toList :: Foldable t => t a -> [a]

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
maximum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
minimum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Monadic fold over the elements of a structure, associating to the
--   right, i.e. from right to left.
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | Monadic fold over the elements of a structure, associating to the
--   left, i.e. from left to right.
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and ignore the results. For a version that doesn't
--   ignore the results see <a>traverse</a>.
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>.
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1..4] print
--   1
--   2
--   3
--   4
--   </pre>
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results see
--   <a>sequenceA</a>.
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | The sum of a collection of actions, generalizing <a>concat</a>.
--   
--   asum [Just <a>Hello</a>, Nothing, Just <a>World</a>] Just <a>Hello</a>
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   As of base 4.8.0.0, <a>forM_</a> is just <a>for_</a>, specialized to
--   <a>Monad</a>.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | The sum of a collection of actions, generalizing <a>concat</a>. As of
--   base 4.8.0.0, <a>msum</a> is just <a>asum</a>, specialized to
--   <a>MonadPlus</a>.
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
find :: Foldable t => (a -> Bool) -> t a -> Maybe a
instance Data.Foldable.Foldable GHC.Generics.V1
instance Data.Foldable.Foldable GHC.Generics.Par1
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (GHC.Generics.Rec1 f)
instance Data.Foldable.Foldable (GHC.Generics.K1 i c)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (GHC.Generics.M1 i c f)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (f GHC.Generics.:+: g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (f GHC.Generics.:*: g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (f GHC.Generics.:.: g)
instance Data.Foldable.Foldable (GHC.Generics.URec (GHC.Ptr.Ptr ()))
instance Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Char)
instance Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Double)
instance Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Float)
instance Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Int)
instance Data.Foldable.Foldable (GHC.Generics.URec GHC.Types.Word)
instance Data.Foldable.Foldable Data.Ord.Down
instance Data.Foldable.Foldable GHC.Maybe.Maybe
instance Data.Foldable.Foldable []
instance Data.Foldable.Foldable GHC.Base.NonEmpty
instance Data.Foldable.Foldable (Data.Either.Either a)
instance Data.Foldable.Foldable ((,) a)
instance Data.Foldable.Foldable (GHC.Arr.Array i)
instance Data.Foldable.Foldable Data.Proxy.Proxy
instance Data.Foldable.Foldable Data.Semigroup.Internal.Dual
instance Data.Foldable.Foldable Data.Semigroup.Internal.Sum
instance Data.Foldable.Foldable Data.Semigroup.Internal.Product
instance Data.Foldable.Foldable Data.Monoid.First
instance Data.Foldable.Foldable Data.Monoid.Last
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Semigroup.Internal.Alt f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Monoid.Ap f)
instance Data.Foldable.Foldable GHC.Generics.U1


module Data.Functor.Const

-- | The <a>Const</a> functor.
newtype Const a b
Const :: a -> Const a b
[getConst] :: Const a b -> a
instance forall a k (b :: k). Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Real.Real a => GHC.Real.Real (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Classes.Ord a => GHC.Classes.Ord (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Num.Num a => GHC.Num.Num (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Arr.Ix a => GHC.Arr.Ix (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Real.Integral a => GHC.Real.Integral (Data.Functor.Const.Const a b)
instance GHC.Generics.Generic1 (Data.Functor.Const.Const a)
instance forall a k (b :: k). GHC.Generics.Generic (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Const.Const a b)
instance forall a k (b :: k). Data.Bits.FiniteBits a => Data.Bits.FiniteBits (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Classes.Eq a => GHC.Classes.Eq (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Enum.Enum a => GHC.Enum.Enum (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Functor.Const.Const a b)
instance forall a k (b :: k). Data.Bits.Bits a => Data.Bits.Bits (Data.Functor.Const.Const a b)
instance forall k a (b :: k). GHC.Read.Read a => GHC.Read.Read (Data.Functor.Const.Const a b)
instance forall k a (b :: k). GHC.Show.Show a => GHC.Show.Show (Data.Functor.Const.Const a b)
instance Data.Foldable.Foldable (Data.Functor.Const.Const m)
instance GHC.Base.Functor (Data.Functor.Const.Const m)
instance GHC.Base.Monoid m => GHC.Base.Applicative (Data.Functor.Const.Const m)


-- | This provides a type-indexed type representation mechanism, similar to
--   that described by,
--   
--   <ul>
--   <li>Simon Peyton-Jones, Stephanie Weirich, Richard Eisenberg,
--   Dimitrios Vytiniotis. "A reflection on types." /Proc. Philip Wadler's
--   60th birthday Festschrift/, Edinburgh (April 2016).</li>
--   </ul>
--   
--   The interface provides <tt>TypeRep</tt>, a type representation which
--   can be safely decomposed and composed. See <a>Data.Dynamic</a> for an
--   example of this.
module Type.Reflection

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)
typeRep :: Typeable a => TypeRep a

-- | Use a <a>TypeRep</a> as <a>Typeable</a> evidence.
withTypeable :: forall k (a :: k) rep (r :: TYPE rep). () => TypeRep a -> (Typeable a => r) -> r

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data a :~: b
[Refl] :: a :~: a
infix 4 :~:

-- | Kind heterogeneous propositional equality. Like <a>:~:</a>, <tt>a :~~:
--   b</tt> is inhabited by a terminating value if and only if <tt>a</tt>
--   is the same type as <tt>b</tt>.
data (a :: k1) :~~: (b :: k2)
[HRefl] :: a :~~: a
infix 4 :~~:

-- | A concrete representation of a (monomorphic) type. <a>TypeRep</a>
--   supports reasonably efficient equality.
data TypeRep (a :: k)
typeOf :: Typeable a => a -> TypeRep a

-- | A type application.
--   
--   For instance,
--   
--   <pre>
--   typeRep @(Maybe Int) === App (typeRep @Maybe) (typeRep @Int)
--   </pre>
--   
--   Note that this will also match a function type,
--   
--   <pre>
--   typeRep @(Int# -&gt; Char)
--     ===
--   App (App arrow (typeRep @Int#)) (typeRep @Char)
--   </pre>
--   
--   where <tt>arrow :: TypeRep ((-&gt;) :: TYPE IntRep -&gt; Type -&gt;
--   Type)</tt>.
pattern App :: forall k2 (t :: k2). () => forall k1 (a :: k1 -> k2) (b :: k1). t ~ a b => TypeRep a -> TypeRep b -> TypeRep t

-- | Pattern match on a type constructor
pattern Con :: forall k (a :: k). () => IsApplication a ~ "" => TyCon -> TypeRep a

-- | Pattern match on a type constructor including its instantiated kind
--   variables.
--   
--   For instance,
--   
--   <pre>
--   App (Con' proxyTyCon ks) intRep = typeRep @(Proxy @Int)
--   </pre>
--   
--   will bring into scope,
--   
--   <pre>
--   proxyTyCon :: TyCon
--   ks         == [someTypeRep <tt>Type] :: [SomeTypeRep]
--   intRep     == typeRep </tt>Int
--   </pre>
pattern Con' :: forall k (a :: k). () => IsApplication a ~ "" => TyCon -> [SomeTypeRep] -> TypeRep a

-- | The function type constructor.
--   
--   For instance,
--   
--   <pre>
--   typeRep @(Int -&gt; Char) === Fun (typeRep @Int) (typeRep @Char)
--   </pre>
pattern Fun :: forall k (fun :: k). () => forall (r1 :: RuntimeRep) (r2 :: RuntimeRep) (arg :: TYPE r1) (res :: TYPE r2). (k ~ Type, fun ~~ (arg -> res)) => TypeRep arg -> TypeRep res -> TypeRep fun

-- | Observe the type constructor of a type representation
typeRepTyCon :: TypeRep a -> TyCon

-- | Helper to fully evaluate <a>TypeRep</a> for use as
--   <tt>NFData(rnf)</tt> implementation
rnfTypeRep :: TypeRep a -> ()

-- | Type equality
eqTypeRep :: forall k1 k2 (a :: k1) (b :: k2). TypeRep a -> TypeRep b -> Maybe (a :~~: b)

-- | Observe the kind of a type.
typeRepKind :: TypeRep (a :: k) -> TypeRep k
splitApps :: TypeRep a -> (TyCon, [SomeTypeRep])

-- | A non-indexed type representation.
data SomeTypeRep
[SomeTypeRep] :: forall k (a :: k). !TypeRep a -> SomeTypeRep

-- | Takes a value of type <tt>a</tt> and returns a concrete representation
--   of that type.
someTypeRep :: forall proxy a. Typeable a => proxy a -> SomeTypeRep

-- | Observe the type constructor of a quantified type representation.
someTypeRepTyCon :: SomeTypeRep -> TyCon

-- | Helper to fully evaluate <a>SomeTypeRep</a> for use as
--   <tt>NFData(rnf)</tt> implementation
rnfSomeTypeRep :: SomeTypeRep -> ()
data TyCon
tyConPackage :: TyCon -> String
tyConModule :: TyCon -> String
tyConName :: TyCon -> String
rnfTyCon :: TyCon -> ()
data Module
moduleName :: Module -> String
modulePackage :: Module -> String

-- | Helper to fully evaluate <a>TyCon</a> for use as <tt>NFData(rnf)</tt>
--   implementation
rnfModule :: Module -> ()


-- | The <a>Typeable</a> class reifies types to some extent by associating
--   type representations to types. These type representations can be
--   compared, and one can in turn define a type-safe cast operation. To
--   this end, an unsafe cast is guarded by a test for type
--   (representation) equivalence. The module <a>Data.Dynamic</a> uses
--   Typeable for an implementation of dynamics. The module
--   <a>Data.Data</a> uses Typeable and type-safe cast (but not dynamics)
--   to support the "Scrap your boilerplate" style of generic programming.
--   
--   <h2>Compatibility Notes</h2>
--   
--   Since GHC 8.2, GHC has supported type-indexed type representations.
--   <a>Data.Typeable</a> provides type representations which are qualified
--   over this index, providing an interface very similar to the
--   <a>Typeable</a> notion seen in previous releases. For the type-indexed
--   interface, see <a>Type.Reflection</a>.
--   
--   Since GHC 7.8, <a>Typeable</a> is poly-kinded. The changes required
--   for this might break some old programs involving <a>Typeable</a>. More
--   details on this, including how to fix your code, can be found on the
--   <a>PolyTypeable wiki page</a>
module Data.Typeable

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)

-- | Observe a type representation for the type of a value.
typeOf :: forall a. Typeable a => a -> TypeRep

-- | Takes a value of type <tt>a</tt> and returns a concrete representation
--   of that type.
typeRep :: forall proxy a. Typeable a => proxy a -> TypeRep

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data a :~: b
[Refl] :: a :~: a
infix 4 :~:

-- | Kind heterogeneous propositional equality. Like <a>:~:</a>, <tt>a :~~:
--   b</tt> is inhabited by a terminating value if and only if <tt>a</tt>
--   is the same type as <tt>b</tt>.
data (a :: k1) :~~: (b :: k2)
[HRefl] :: a :~~: a
infix 4 :~~:

-- | The type-safe cast operation
cast :: forall a b. (Typeable a, Typeable b) => a -> Maybe b

-- | Extract a witness of equality of two types
eqT :: forall a b. (Typeable a, Typeable b) => Maybe (a :~: b)

-- | A flexible variation parameterised in a type constructor
gcast :: forall a b c. (Typeable a, Typeable b) => c a -> Maybe (c b)

-- | Cast over <tt>k1 -&gt; k2</tt>
gcast1 :: forall c t t' a. (Typeable t, Typeable t') => c (t a) -> Maybe (c (t' a))

-- | Cast over <tt>k1 -&gt; k2 -&gt; k3</tt>
gcast2 :: forall c t t' a b. (Typeable t, Typeable t') => c (t a b) -> Maybe (c (t' a b))

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt>'undefined :: a'</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy t
Proxy :: Proxy t

-- | A quantified type representation.
type TypeRep = SomeTypeRep

-- | Force a <a>TypeRep</a> to normal form.
rnfTypeRep :: TypeRep -> ()

-- | Show a type representation
showsTypeRep :: TypeRep -> ShowS

-- | Build a function type.
mkFunTy :: TypeRep -> TypeRep -> TypeRep

-- | Applies a type to a function type. Returns: <tt>Just u</tt> if the
--   first argument represents a function of type <tt>t -&gt; u</tt> and
--   the second argument represents a function of type <tt>t</tt>.
--   Otherwise, returns <tt>Nothing</tt>.
funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep

-- | Splits a type constructor application. Note that if the type
--   constructor is polymorphic, this will not return the kinds that were
--   used.
splitTyConApp :: TypeRep -> (TyCon, [TypeRep])

-- | Observe the argument types of a type representation
typeRepArgs :: TypeRep -> [TypeRep]

-- | Observe the type constructor of a quantified type representation.
typeRepTyCon :: TypeRep -> TyCon

-- | Takes a value of type <tt>a</tt> and returns a concrete representation
--   of that type.
typeRepFingerprint :: TypeRep -> Fingerprint
data TyCon
tyConPackage :: TyCon -> String
tyConModule :: TyCon -> String
tyConName :: TyCon -> String
rnfTyCon :: TyCon -> ()
tyConFingerprint :: TyCon -> Fingerprint
typeOf1 :: forall t (a :: Type). Typeable t => t a -> TypeRep
typeOf2 :: forall t (a :: Type) (b :: Type). Typeable t => t a b -> TypeRep
typeOf3 :: forall t (a :: Type) (b :: Type) (c :: Type). Typeable t => t a b c -> TypeRep
typeOf4 :: forall t (a :: Type) (b :: Type) (c :: Type) (d :: Type). Typeable t => t a b c d -> TypeRep
typeOf5 :: forall t (a :: Type) (b :: Type) (c :: Type) (d :: Type) (e :: Type). Typeable t => t a b c d e -> TypeRep
typeOf6 :: forall t (a :: Type) (b :: Type) (c :: Type) (d :: Type) (e :: Type) (f :: Type). Typeable t => t a b c d e f -> TypeRep
typeOf7 :: forall t (a :: Type) (b :: Type) (c :: Type) (d :: Type) (e :: Type) (f :: Type) (g :: Type). Typeable t => t a b c d e f g -> TypeRep


-- | The <a>ForeignPtr</a> type and operations. This module is part of the
--   Foreign Function Interface (FFI) and will usually be imported via the
--   <a>Foreign</a> module.
--   
--   Unsafe API Only.
module Foreign.ForeignPtr.Unsafe

-- | This function extracts the pointer component of a foreign pointer.
--   This is a potentially dangerous operations, as if the argument to
--   <a>unsafeForeignPtrToPtr</a> is the last usage occurrence of the given
--   foreign pointer, then its finalizer(s) will be run, which potentially
--   invalidates the plain pointer just obtained. Hence,
--   <a>touchForeignPtr</a> must be used wherever it has to be guaranteed
--   that the pointer lives on - i.e., has another usage occurrence.
--   
--   To avoid subtle coding errors, hand written marshalling code should
--   preferably use <a>withForeignPtr</a> rather than combinations of
--   <a>unsafeForeignPtrToPtr</a> and <a>touchForeignPtr</a>. However, the
--   latter routines are occasionally preferred in tool generated
--   marshalling code.
unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a


-- | The <a>ForeignPtr</a> type and operations. This module is part of the
--   Foreign Function Interface (FFI) and will usually be imported via the
--   <a>Foreign</a> module.
--   
--   Safe API Only.

-- | <i>Deprecated: Safe is now the default, please use Foreign.ForeignPtr
--   instead</i>
module Foreign.ForeignPtr.Safe

-- | The type <a>ForeignPtr</a> represents references to objects that are
--   maintained in a foreign language, i.e., that are not part of the data
--   structures usually managed by the Haskell storage manager. The
--   essential difference between <a>ForeignPtr</a>s and vanilla memory
--   references of type <tt>Ptr a</tt> is that the former may be associated
--   with <i>finalizers</i>. A finalizer is a routine that is invoked when
--   the Haskell storage manager detects that - within the Haskell heap and
--   stack - there are no more references left that are pointing to the
--   <a>ForeignPtr</a>. Typically, the finalizer will, then, invoke
--   routines in the foreign language that free the resources bound by the
--   foreign object.
--   
--   The <a>ForeignPtr</a> is parameterised in the same way as <a>Ptr</a>.
--   The type argument of <a>ForeignPtr</a> should normally be an instance
--   of class <a>Storable</a>.
data ForeignPtr a

-- | A finalizer is represented as a pointer to a foreign function that, at
--   finalisation time, gets as an argument a plain pointer variant of the
--   foreign pointer that the finalizer is associated with.
--   
--   Note that the foreign function <i>must</i> use the <tt>ccall</tt>
--   calling convention.
type FinalizerPtr a = FunPtr (Ptr a -> IO ())
type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())

-- | Turns a plain memory reference into a foreign pointer, and associates
--   a finalizer with the reference. The finalizer will be executed after
--   the last reference to the foreign object is dropped. There is no
--   guarantee of promptness, however the finalizer will be executed before
--   the program exits.
newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)

-- | Turns a plain memory reference into a foreign pointer that may be
--   associated with finalizers by using <a>addForeignPtrFinalizer</a>.
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given foreign object. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()

-- | This variant of <a>newForeignPtr</a> adds a finalizer that expects an
--   environment in addition to the finalized pointer. The environment that
--   will be passed to the finalizer is fixed by the second argument to
--   <a>newForeignPtrEnv</a>.
newForeignPtrEnv :: FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)

-- | Like <a>addForeignPtrFinalizerEnv</a> but allows the finalizer to be
--   passed an additional environment parameter to be passed to the
--   finalizer. The environment passed to the finalizer is fixed by the
--   second argument to <a>addForeignPtrFinalizerEnv</a>
addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()

-- | This is a way to look at the pointer living inside a foreign object.
--   This function takes a function which is applied to that pointer. The
--   resulting <a>IO</a> action is then executed. The foreign object is
--   kept alive at least during the whole action, even if it is not used
--   directly inside. Note that it is not safe to return the pointer from
--   the action and use it after the action completes. All uses of the
--   pointer should be inside the <a>withForeignPtr</a> bracket. The reason
--   for this unsafeness is the same as for <a>unsafeForeignPtrToPtr</a>
--   below: the finalizer may run earlier than expected, because the
--   compiler can only track usage of the <a>ForeignPtr</a> object, not a
--   <a>Ptr</a> object made from it.
--   
--   This function is normally used for marshalling data to or from the
--   object pointed to by the <a>ForeignPtr</a>, using the operations from
--   the <a>Storable</a> class.
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | Causes the finalizers associated with a foreign pointer to be run
--   immediately.
finalizeForeignPtr :: ForeignPtr a -> IO ()

-- | This function ensures that the foreign object in question is alive at
--   the given place in the sequence of IO actions. In particular
--   <a>withForeignPtr</a> does a <a>touchForeignPtr</a> after it executes
--   the user action.
--   
--   Note that this function should not be used to express dependencies
--   between finalizers on <a>ForeignPtr</a>s. For example, if the
--   finalizer for a <a>ForeignPtr</a> <tt>F1</tt> calls
--   <a>touchForeignPtr</a> on a second <a>ForeignPtr</a> <tt>F2</tt>, then
--   the only guarantee is that the finalizer for <tt>F2</tt> is never
--   started before the finalizer for <tt>F1</tt>. They might be started
--   together if for example both <tt>F1</tt> and <tt>F2</tt> are otherwise
--   unreachable, and in that case the scheduler might end up running the
--   finalizer for <tt>F2</tt> first.
--   
--   In general, it is not recommended to use finalizers on separate
--   objects with ordering constraints between them. To express the
--   ordering robustly requires explicit synchronisation using
--   <tt>MVar</tt>s between the finalizers, but even then the runtime
--   sometimes runs multiple finalizers sequentially in a single thread
--   (for performance reasons), so synchronisation between finalizers could
--   result in artificial deadlock. Another alternative is to use explicit
--   reference counting.
touchForeignPtr :: ForeignPtr a -> IO ()

-- | This function casts a <a>ForeignPtr</a> parameterised by one type into
--   another type.
castForeignPtr :: ForeignPtr a -> ForeignPtr b

-- | Allocate some memory and return a <a>ForeignPtr</a> to it. The memory
--   will be released automatically when the <a>ForeignPtr</a> is
--   discarded.
--   
--   <a>mallocForeignPtr</a> is equivalent to
--   
--   <pre>
--   do { p &lt;- malloc; newForeignPtr finalizerFree p }
--   </pre>
--   
--   although it may be implemented differently internally: you may not
--   assume that the memory returned by <a>mallocForeignPtr</a> has been
--   allocated with <a>malloc</a>.
--   
--   GHC notes: <a>mallocForeignPtr</a> has a heavily optimised
--   implementation in GHC. It uses pinned memory in the garbage collected
--   heap, so the <a>ForeignPtr</a> does not require a finalizer to free
--   the memory. Use of <a>mallocForeignPtr</a> and associated functions is
--   strongly recommended in preference to <tt>newForeignPtr</tt> with a
--   finalizer.
mallocForeignPtr :: Storable a => IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtr</a>, except that the
--   size of the memory required is given explicitly as a number of bytes.
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray0</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)


-- | The <a>ForeignPtr</a> type and operations. This module is part of the
--   Foreign Function Interface (FFI) and will usually be imported via the
--   <a>Foreign</a> module.
--   
--   For non-portable support of Haskell finalizers, see the
--   <a>Foreign.Concurrent</a> module.
module Foreign.ForeignPtr

-- | The type <a>ForeignPtr</a> represents references to objects that are
--   maintained in a foreign language, i.e., that are not part of the data
--   structures usually managed by the Haskell storage manager. The
--   essential difference between <a>ForeignPtr</a>s and vanilla memory
--   references of type <tt>Ptr a</tt> is that the former may be associated
--   with <i>finalizers</i>. A finalizer is a routine that is invoked when
--   the Haskell storage manager detects that - within the Haskell heap and
--   stack - there are no more references left that are pointing to the
--   <a>ForeignPtr</a>. Typically, the finalizer will, then, invoke
--   routines in the foreign language that free the resources bound by the
--   foreign object.
--   
--   The <a>ForeignPtr</a> is parameterised in the same way as <a>Ptr</a>.
--   The type argument of <a>ForeignPtr</a> should normally be an instance
--   of class <a>Storable</a>.
data ForeignPtr a

-- | A finalizer is represented as a pointer to a foreign function that, at
--   finalisation time, gets as an argument a plain pointer variant of the
--   foreign pointer that the finalizer is associated with.
--   
--   Note that the foreign function <i>must</i> use the <tt>ccall</tt>
--   calling convention.
type FinalizerPtr a = FunPtr (Ptr a -> IO ())
type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())

-- | Turns a plain memory reference into a foreign pointer, and associates
--   a finalizer with the reference. The finalizer will be executed after
--   the last reference to the foreign object is dropped. There is no
--   guarantee of promptness, however the finalizer will be executed before
--   the program exits.
newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)

-- | Turns a plain memory reference into a foreign pointer that may be
--   associated with finalizers by using <a>addForeignPtrFinalizer</a>.
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given foreign object. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()

-- | This variant of <a>newForeignPtr</a> adds a finalizer that expects an
--   environment in addition to the finalized pointer. The environment that
--   will be passed to the finalizer is fixed by the second argument to
--   <a>newForeignPtrEnv</a>.
newForeignPtrEnv :: FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)

-- | Like <a>addForeignPtrFinalizerEnv</a> but allows the finalizer to be
--   passed an additional environment parameter to be passed to the
--   finalizer. The environment passed to the finalizer is fixed by the
--   second argument to <a>addForeignPtrFinalizerEnv</a>
addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()

-- | This is a way to look at the pointer living inside a foreign object.
--   This function takes a function which is applied to that pointer. The
--   resulting <a>IO</a> action is then executed. The foreign object is
--   kept alive at least during the whole action, even if it is not used
--   directly inside. Note that it is not safe to return the pointer from
--   the action and use it after the action completes. All uses of the
--   pointer should be inside the <a>withForeignPtr</a> bracket. The reason
--   for this unsafeness is the same as for <a>unsafeForeignPtrToPtr</a>
--   below: the finalizer may run earlier than expected, because the
--   compiler can only track usage of the <a>ForeignPtr</a> object, not a
--   <a>Ptr</a> object made from it.
--   
--   This function is normally used for marshalling data to or from the
--   object pointed to by the <a>ForeignPtr</a>, using the operations from
--   the <a>Storable</a> class.
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | Causes the finalizers associated with a foreign pointer to be run
--   immediately.
finalizeForeignPtr :: ForeignPtr a -> IO ()

-- | This function ensures that the foreign object in question is alive at
--   the given place in the sequence of IO actions. In particular
--   <a>withForeignPtr</a> does a <a>touchForeignPtr</a> after it executes
--   the user action.
--   
--   Note that this function should not be used to express dependencies
--   between finalizers on <a>ForeignPtr</a>s. For example, if the
--   finalizer for a <a>ForeignPtr</a> <tt>F1</tt> calls
--   <a>touchForeignPtr</a> on a second <a>ForeignPtr</a> <tt>F2</tt>, then
--   the only guarantee is that the finalizer for <tt>F2</tt> is never
--   started before the finalizer for <tt>F1</tt>. They might be started
--   together if for example both <tt>F1</tt> and <tt>F2</tt> are otherwise
--   unreachable, and in that case the scheduler might end up running the
--   finalizer for <tt>F2</tt> first.
--   
--   In general, it is not recommended to use finalizers on separate
--   objects with ordering constraints between them. To express the
--   ordering robustly requires explicit synchronisation using
--   <tt>MVar</tt>s between the finalizers, but even then the runtime
--   sometimes runs multiple finalizers sequentially in a single thread
--   (for performance reasons), so synchronisation between finalizers could
--   result in artificial deadlock. Another alternative is to use explicit
--   reference counting.
touchForeignPtr :: ForeignPtr a -> IO ()

-- | This function casts a <a>ForeignPtr</a> parameterised by one type into
--   another type.
castForeignPtr :: ForeignPtr a -> ForeignPtr b

-- | Advances the given address by the given offset in bytes.
--   
--   The new <a>ForeignPtr</a> shares the finalizer of the original,
--   equivalent from a finalization standpoint to just creating another
--   reference to the original. That is, the finalizer will not be called
--   before the new <a>ForeignPtr</a> is unreachable, nor will it be called
--   an additional time due to this call, and the finalizer will be called
--   with the same address that it would have had this call not happened,
--   *not* the new address.
plusForeignPtr :: ForeignPtr a -> Int -> ForeignPtr b

-- | Allocate some memory and return a <a>ForeignPtr</a> to it. The memory
--   will be released automatically when the <a>ForeignPtr</a> is
--   discarded.
--   
--   <a>mallocForeignPtr</a> is equivalent to
--   
--   <pre>
--   do { p &lt;- malloc; newForeignPtr finalizerFree p }
--   </pre>
--   
--   although it may be implemented differently internally: you may not
--   assume that the memory returned by <a>mallocForeignPtr</a> has been
--   allocated with <a>malloc</a>.
--   
--   GHC notes: <a>mallocForeignPtr</a> has a heavily optimised
--   implementation in GHC. It uses pinned memory in the garbage collected
--   heap, so the <a>ForeignPtr</a> does not require a finalizer to free
--   the memory. Use of <a>mallocForeignPtr</a> and associated functions is
--   strongly recommended in preference to <tt>newForeignPtr</tt> with a
--   finalizer.
mallocForeignPtr :: Storable a => IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtr</a>, except that the
--   size of the memory required is given explicitly as a number of bytes.
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray0</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)


-- | Buffers used in the IO system
module GHC.IO.Buffer

-- | A mutable array of bytes that can be passed to foreign functions.
--   
--   The buffer is represented by a record, where the record contains the
--   raw buffer and the start/end points of the filled portion. The buffer
--   contents itself is mutable, but the rest of the record is immutable.
--   This is a slightly odd mix, but it turns out to be quite practical: by
--   making all the buffer metadata immutable, we can have operations on
--   buffer metadata outside of the IO monad.
--   
--   The "live" elements of the buffer are those between the <a>bufL</a>
--   and <a>bufR</a> offsets. In an empty buffer, <a>bufL</a> is equal to
--   <a>bufR</a>, but they might not be zero: for example, the buffer might
--   correspond to a memory-mapped file and in which case <a>bufL</a> will
--   point to the next location to be written, which is not necessarily the
--   beginning of the file.
data Buffer e
Buffer :: !RawBuffer e -> BufferState -> !Int -> !Int -> !Int -> Buffer e
[bufRaw] :: Buffer e -> !RawBuffer e
[bufState] :: Buffer e -> BufferState
[bufSize] :: Buffer e -> !Int
[bufL] :: Buffer e -> !Int
[bufR] :: Buffer e -> !Int
data BufferState
ReadBuffer :: BufferState
WriteBuffer :: BufferState
type CharBuffer = Buffer Char
type CharBufElem = Char
newByteBuffer :: Int -> BufferState -> IO (Buffer Word8)
newCharBuffer :: Int -> BufferState -> IO CharBuffer
newBuffer :: Int -> Int -> BufferState -> IO (Buffer e)
emptyBuffer :: RawBuffer e -> Int -> BufferState -> Buffer e
bufferRemove :: Int -> Buffer e -> Buffer e
bufferAdd :: Int -> Buffer e -> Buffer e

-- | slides the contents of the buffer to the beginning
slideContents :: Buffer Word8 -> IO (Buffer Word8)
bufferAdjustL :: Int -> Buffer e -> Buffer e
isEmptyBuffer :: Buffer e -> Bool
isFullBuffer :: Buffer e -> Bool
isFullCharBuffer :: Buffer e -> Bool
isWriteBuffer :: Buffer e -> Bool
bufferElems :: Buffer e -> Int
bufferAvailable :: Buffer e -> Int
summaryBuffer :: Buffer a -> String
withBuffer :: Buffer e -> (Ptr e -> IO a) -> IO a
withRawBuffer :: RawBuffer e -> (Ptr e -> IO a) -> IO a
checkBuffer :: Buffer a -> IO ()
type RawBuffer e = ForeignPtr e
readWord8Buf :: RawBuffer Word8 -> Int -> IO Word8
writeWord8Buf :: RawBuffer Word8 -> Int -> Word8 -> IO ()
type RawCharBuffer = RawBuffer CharBufElem
peekCharBuf :: RawCharBuffer -> Int -> IO Char
readCharBuf :: RawCharBuffer -> Int -> IO (Char, Int)
writeCharBuf :: RawCharBuffer -> Int -> Char -> IO Int
readCharBufPtr :: Ptr CharBufElem -> Int -> IO (Char, Int)
writeCharBufPtr :: Ptr CharBufElem -> Int -> Char -> IO Int
charSize :: Int
instance GHC.Classes.Eq GHC.IO.Buffer.BufferState


-- | Types for text encoding/decoding
module GHC.IO.Encoding.Types
data BufferCodec from to state
BufferCodec :: CodeBuffer from to -> (Buffer from -> Buffer to -> IO (Buffer from, Buffer to)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state

-- | The <tt>encode</tt> function translates elements of the buffer
--   <tt>from</tt> to the buffer <tt>to</tt>. It should translate as many
--   elements as possible given the sizes of the buffers, including
--   translating zero elements if there is either not enough room in
--   <tt>to</tt>, or <tt>from</tt> does not contain a complete multibyte
--   sequence.
--   
--   If multiple CodingProgress returns are possible, OutputUnderflow must
--   be preferred to InvalidSequence. This allows GHC's IO library to
--   assume that if we observe InvalidSequence there is at least a single
--   element available in the output buffer.
--   
--   The fact that as many elements as possible are translated is used by
--   the IO library in order to report translation errors at the point they
--   actually occur, rather than when the buffer is translated.
[encode] :: BufferCodec from to state -> CodeBuffer from to

-- | The <tt>recover</tt> function is used to continue decoding in the
--   presence of invalid or unrepresentable sequences. This includes both
--   those detected by <tt>encode</tt> returning <tt>InvalidSequence</tt>
--   and those that occur because the input byte sequence appears to be
--   truncated.
--   
--   Progress will usually be made by skipping the first element of the
--   <tt>from</tt> buffer. This function should only be called if you are
--   certain that you wish to do this skipping and if the <tt>to</tt>
--   buffer has at least one element of free space. Because this function
--   deals with decoding failure, it assumes that the from buffer has at
--   least one element.
--   
--   <tt>recover</tt> may raise an exception rather than skipping anything.
--   
--   Currently, some implementations of <tt>recover</tt> may mutate the
--   input buffer. In particular, this feature is used to implement
--   transliteration.
[recover] :: BufferCodec from to state -> Buffer from -> Buffer to -> IO (Buffer from, Buffer to)

-- | Resources associated with the encoding may now be released. The
--   <tt>encode</tt> function may not be called again after calling
--   <tt>close</tt>.
[close] :: BufferCodec from to state -> IO ()

-- | Return the current state of the codec.
--   
--   Many codecs are not stateful, and in these case the state can be
--   represented as '()'. Other codecs maintain a state. For example,
--   UTF-16 recognises a BOM (byte-order-mark) character at the beginning
--   of the input, and remembers thereafter whether to use big-endian or
--   little-endian mode. In this case, the state of the codec would include
--   two pieces of information: whether we are at the beginning of the
--   stream (the BOM only occurs at the beginning), and if not, whether to
--   use the big or little-endian encoding.
[getState] :: BufferCodec from to state -> IO state
[setState] :: BufferCodec from to state -> state -> IO ()

-- | A <a>TextEncoding</a> is a specification of a conversion scheme
--   between sequences of bytes and sequences of Unicode characters.
--   
--   For example, UTF-8 is an encoding of Unicode characters into a
--   sequence of bytes. The <a>TextEncoding</a> for UTF-8 is <tt>utf8</tt>.
data TextEncoding
TextEncoding :: String -> IO (TextDecoder dstate) -> IO (TextEncoder estate) -> TextEncoding

-- | a string that can be passed to <tt>mkTextEncoding</tt> to create an
--   equivalent <a>TextEncoding</a>.
[textEncodingName] :: TextEncoding -> String

-- | Creates a means of decoding bytes into characters: the result must not
--   be shared between several byte sequences or simultaneously across
--   threads
[mkTextDecoder] :: TextEncoding -> IO (TextDecoder dstate)

-- | Creates a means of encode characters into bytes: the result must not
--   be shared between several character sequences or simultaneously across
--   threads
[mkTextEncoder] :: TextEncoding -> IO (TextEncoder estate)
type TextEncoder state = BufferCodec CharBufElem Word8 state
type TextDecoder state = BufferCodec Word8 CharBufElem state
type CodeBuffer from to = Buffer from -> Buffer to -> IO (CodingProgress, Buffer from, Buffer to)
type EncodeBuffer = CodeBuffer Char Word8
type DecodeBuffer = CodeBuffer Word8 Char

data CodingProgress

-- | Stopped because the input contains insufficient available elements, or
--   all of the input sequence has been successfully translated.
InputUnderflow :: CodingProgress

-- | Stopped because the output contains insufficient free elements
OutputUnderflow :: CodingProgress

-- | Stopped because there are sufficient free elements in the output to
--   output at least one encoded ASCII character, but the input contains an
--   invalid or unrepresentable sequence
InvalidSequence :: CodingProgress
instance GHC.Show.Show GHC.IO.Encoding.Types.CodingProgress
instance GHC.Classes.Eq GHC.IO.Encoding.Types.CodingProgress
instance GHC.Show.Show GHC.IO.Encoding.Types.TextEncoding


-- | Mutable references in the IO monad.
module Data.IORef

-- | A mutable variable in the <a>IO</a> monad
data IORef a

-- | Build a new <a>IORef</a>
newIORef :: a -> IO (IORef a)

-- | Read the value of an <a>IORef</a>
readIORef :: IORef a -> IO a

-- | Write a new value into an <a>IORef</a>
writeIORef :: IORef a -> a -> IO ()

-- | Mutate the contents of an <a>IORef</a>.
--   
--   Be warned that <a>modifyIORef</a> does not apply the function
--   strictly. This means if the program calls <a>modifyIORef</a> many
--   times, but seldomly uses the value, thunks will pile up in memory
--   resulting in a space leak. This is a common mistake made when using an
--   IORef as a counter. For example, the following will likely produce a
--   stack overflow:
--   
--   <pre>
--   ref &lt;- newIORef 0
--   replicateM_ 1000000 $ modifyIORef ref (+1)
--   readIORef ref &gt;&gt;= print
--   </pre>
--   
--   To avoid this problem, use <a>modifyIORef'</a> instead.
modifyIORef :: IORef a -> (a -> a) -> IO ()

-- | Strict version of <a>modifyIORef</a>
modifyIORef' :: IORef a -> (a -> a) -> IO ()

-- | Atomically modifies the contents of an <a>IORef</a>.
--   
--   This function is useful for using <a>IORef</a> in a safe way in a
--   multithreaded program. If you only have one <a>IORef</a>, then using
--   <a>atomicModifyIORef</a> to access and modify it will prevent race
--   conditions.
--   
--   Extending the atomicity to multiple <a>IORef</a>s is problematic, so
--   it is recommended that if you need to do anything more complicated
--   then using <a>MVar</a> instead is a good idea.
--   
--   <a>atomicModifyIORef</a> does not apply the function strictly. This is
--   important to know even if all you are doing is replacing the value.
--   For example, this will leak memory:
--   
--   <pre>
--   ref &lt;- newIORef '1'
--   forever $ atomicModifyIORef ref (\_ -&gt; ('2', ()))
--   </pre>
--   
--   Use <a>atomicModifyIORef'</a> or <a>atomicWriteIORef</a> to avoid this
--   problem.
atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b

-- | Strict version of <a>atomicModifyIORef</a>. This forces both the value
--   stored in the <a>IORef</a> as well as the value returned.
atomicModifyIORef' :: IORef a -> (a -> (a, b)) -> IO b

-- | Variant of <a>writeIORef</a> with the "barrier to reordering" property
--   that <a>atomicModifyIORef</a> has.
atomicWriteIORef :: IORef a -> a -> IO ()

-- | Make a <a>Weak</a> pointer to an <a>IORef</a>, using the second
--   argument as a finalizer to run when <a>IORef</a> is garbage-collected
mkWeakIORef :: IORef a -> IO () -> IO (Weak (IORef a))


-- | Type classes for I/O providers.
module GHC.IO.Device

-- | A low-level I/O provider where the data is bytes in memory.
class RawIO a

-- | Read up to the specified number of bytes, returning the number of
--   bytes actually read. This function should only block if there is no
--   data available. If there is not enough data available, then the
--   function should just return the available data. A return value of zero
--   indicates that the end of the data stream (e.g. end of file) has been
--   reached.
read :: RawIO a => a -> Ptr Word8 -> Int -> IO Int

-- | Read up to the specified number of bytes, returning the number of
--   bytes actually read, or <a>Nothing</a> if the end of the stream has
--   been reached.
readNonBlocking :: RawIO a => a -> Ptr Word8 -> Int -> IO (Maybe Int)

-- | Write the specified number of bytes.
write :: RawIO a => a -> Ptr Word8 -> Int -> IO ()

-- | Write up to the specified number of bytes without blocking. Returns
--   the actual number of bytes written.
writeNonBlocking :: RawIO a => a -> Ptr Word8 -> Int -> IO Int

-- | I/O operations required for implementing a <tt>Handle</tt>.
class IODevice a

-- | <tt>ready dev write msecs</tt> returns <a>True</a> if the device has
--   data to read (if <tt>write</tt> is <a>False</a>) or space to write new
--   data (if <tt>write</tt> is <a>True</a>). <tt>msecs</tt> specifies how
--   long to wait, in milliseconds.
ready :: IODevice a => a -> Bool -> Int -> IO Bool

-- | closes the device. Further operations on the device should produce
--   exceptions.
close :: IODevice a => a -> IO ()

-- | returns <a>True</a> if the device is a terminal or console.
isTerminal :: IODevice a => a -> IO Bool

-- | returns <a>True</a> if the device supports <a>seek</a> operations.
isSeekable :: IODevice a => a -> IO Bool

-- | seek to the specified position in the data.
seek :: IODevice a => a -> SeekMode -> Integer -> IO ()

-- | return the current position in the data.
tell :: IODevice a => a -> IO Integer

-- | return the size of the data.
getSize :: IODevice a => a -> IO Integer

-- | change the size of the data.
setSize :: IODevice a => a -> Integer -> IO ()

-- | for terminal devices, changes whether characters are echoed on the
--   device.
setEcho :: IODevice a => a -> Bool -> IO ()

-- | returns the current echoing status.
getEcho :: IODevice a => a -> IO Bool

-- | some devices (e.g. terminals) support a "raw" mode where characters
--   entered are immediately made available to the program. If available,
--   this operations enables raw mode.
setRaw :: IODevice a => a -> Bool -> IO ()

-- | returns the <a>IODeviceType</a> corresponding to this device.
devType :: IODevice a => a -> IO IODeviceType

-- | duplicates the device, if possible. The new device is expected to
--   share a file pointer with the original device (like Unix
--   <tt>dup</tt>).
dup :: IODevice a => a -> IO a

-- | <tt>dup2 source target</tt> replaces the target device with the source
--   device. The target device is closed first, if necessary, and then it
--   is made into a duplicate of the first device (like Unix
--   <tt>dup2</tt>).
dup2 :: IODevice a => a -> a -> IO a

-- | Type of a device that can be used to back a <a>Handle</a> (see also
--   <a>mkFileHandle</a>). The standard libraries provide creation of
--   <a>Handle</a>s via Posix file operations with file descriptors (see
--   <a>mkHandleFromFD</a>) with FD being the underlying <a>IODevice</a>
--   instance.
--   
--   Users may provide custom instances of <a>IODevice</a> which are
--   expected to conform the following rules:
data IODeviceType

-- | The standard libraries do not have direct support for this device
--   type, but a user implementation is expected to provide a list of file
--   names in the directory, in any order, separated by <tt>'\0'</tt>
--   characters, excluding the <tt>"."</tt> and <tt>".."</tt> names. See
--   also <a>getDirectoryContents</a>. Seek operations are not supported on
--   directories (other than to the zero position).
Directory :: IODeviceType

-- | A duplex communications channel (results in creation of a duplex
--   <a>Handle</a>). The standard libraries use this device type when
--   creating <a>Handle</a>s for open sockets.
Stream :: IODeviceType

-- | A file that may be read or written, and also may be seekable.
RegularFile :: IODeviceType

-- | A "raw" (disk) device which supports block binary read and write
--   operations and may be seekable only to positions of certain
--   granularity (block- aligned).
RawDevice :: IODeviceType

-- | A mode that determines the effect of <tt>hSeek</tt> <tt>hdl mode
--   i</tt>.
data SeekMode

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode
instance GHC.Show.Show GHC.IO.Device.SeekMode
instance GHC.Read.Read GHC.IO.Device.SeekMode
instance GHC.Enum.Enum GHC.IO.Device.SeekMode
instance GHC.Arr.Ix GHC.IO.Device.SeekMode
instance GHC.Classes.Ord GHC.IO.Device.SeekMode
instance GHC.Classes.Eq GHC.IO.Device.SeekMode
instance GHC.Classes.Eq GHC.IO.Device.IODeviceType


-- | Class of buffered IO devices
module GHC.IO.BufferedIO

-- | The purpose of <a>BufferedIO</a> is to provide a common interface for
--   I/O devices that can read and write data through a buffer. Devices
--   that implement <a>BufferedIO</a> include ordinary files, memory-mapped
--   files, and bytestrings. The underlying device implementing a
--   <tt>Handle</tt> must provide <a>BufferedIO</a>.
class BufferedIO dev

-- | allocate a new buffer. The size of the buffer is at the discretion of
--   the device; e.g. for a memory-mapped file the buffer will probably
--   cover the entire file.
newBuffer :: BufferedIO dev => dev -> BufferState -> IO (Buffer Word8)

-- | reads bytes into the buffer, blocking if there are no bytes available.
--   Returns the number of bytes read (zero indicates end-of-file), and the
--   new buffer.
fillReadBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)

-- | reads bytes into the buffer without blocking. Returns the number of
--   bytes read (Nothing indicates end-of-file), and the new buffer.
fillReadBuffer0 :: BufferedIO dev => dev -> Buffer Word8 -> IO (Maybe Int, Buffer Word8)

-- | Prepares an empty write buffer. This lets the device decide how to set
--   up a write buffer: the buffer may need to point to a specific location
--   in memory, for example. This is typically used by the client when
--   switching from reading to writing on a buffered read/write device.
--   
--   There is no corresponding operation for read buffers, because before
--   reading the client will always call <a>fillReadBuffer</a>.
emptyWriteBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)

-- | Flush all the data from the supplied write buffer out to the device.
--   The returned buffer should be empty, and ready for writing.
flushWriteBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)

-- | Flush data from the supplied write buffer out to the device without
--   blocking. Returns the number of bytes written and the remaining
--   buffer.
flushWriteBuffer0 :: BufferedIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)
readBuf :: RawIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)
readBufNonBlocking :: RawIO dev => dev -> Buffer Word8 -> IO (Maybe Int, Buffer Word8)
writeBuf :: RawIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)
writeBufNonBlocking :: RawIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)


-- | Types for specifying how text encoding/decoding fails
module GHC.IO.Encoding.Failure

-- | The <a>CodingFailureMode</a> is used to construct
--   <tt>TextEncoding</tt>s, and specifies how they handle illegal
--   sequences.
data CodingFailureMode

-- | Throw an error when an illegal sequence is encountered
ErrorOnCodingFailure :: CodingFailureMode

-- | Attempt to ignore and recover if an illegal sequence is encountered
IgnoreCodingFailure :: CodingFailureMode

-- | Replace with the closest visual match upon an illegal sequence
TransliterateCodingFailure :: CodingFailureMode

-- | Use the private-use escape mechanism to attempt to allow illegal
--   sequences to be roundtripped.
RoundtripFailure :: CodingFailureMode
codingFailureModeSuffix :: CodingFailureMode -> String

-- | Some characters are actually "surrogate" codepoints defined for use in
--   UTF-16. We need to signal an invalid character if we detect them when
--   encoding a sequence of <a>Char</a>s into <a>Word8</a>s because they
--   won't give valid Unicode.
--   
--   We may also need to signal an invalid character if we detect them when
--   encoding a sequence of <a>Char</a>s into <a>Word8</a>s because the
--   <a>RoundtripFailure</a> mode creates these to round-trip bytes through
--   our internal UTF-16 encoding.
isSurrogate :: Char -> Bool
recoverDecode :: CodingFailureMode -> Buffer Word8 -> Buffer Char -> IO (Buffer Word8, Buffer Char)
recoverEncode :: CodingFailureMode -> Buffer Char -> Buffer Word8 -> IO (Buffer Char, Buffer Word8)
instance GHC.Show.Show GHC.IO.Encoding.Failure.CodingFailureMode


-- | UTF-8 Codec for the IO library
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.IO.Encoding.UTF8
utf8 :: TextEncoding

mkUTF8 :: CodingFailureMode -> TextEncoding
utf8_bom :: TextEncoding
mkUTF8_bom :: CodingFailureMode -> TextEncoding


-- | UTF-32 Codecs for the IO library
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.IO.Encoding.UTF32
utf32 :: TextEncoding

mkUTF32 :: CodingFailureMode -> TextEncoding
utf32_decode :: IORef (Maybe DecodeBuffer) -> DecodeBuffer
utf32_encode :: IORef Bool -> EncodeBuffer
utf32be :: TextEncoding

mkUTF32be :: CodingFailureMode -> TextEncoding
utf32be_decode :: DecodeBuffer
utf32be_encode :: EncodeBuffer
utf32le :: TextEncoding

mkUTF32le :: CodingFailureMode -> TextEncoding
utf32le_decode :: DecodeBuffer
utf32le_encode :: EncodeBuffer


-- | UTF-16 Codecs for the IO library
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.IO.Encoding.UTF16
utf16 :: TextEncoding

mkUTF16 :: CodingFailureMode -> TextEncoding
utf16_decode :: IORef (Maybe DecodeBuffer) -> DecodeBuffer
utf16_encode :: IORef Bool -> EncodeBuffer
utf16be :: TextEncoding

mkUTF16be :: CodingFailureMode -> TextEncoding
utf16be_decode :: DecodeBuffer
utf16be_encode :: EncodeBuffer
utf16le :: TextEncoding

mkUTF16le :: CodingFailureMode -> TextEncoding
utf16le_decode :: DecodeBuffer
utf16le_encode :: EncodeBuffer


-- | Single-byte encodings that map directly to Unicode code points.
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.IO.Encoding.Latin1
latin1 :: TextEncoding

mkLatin1 :: CodingFailureMode -> TextEncoding
latin1_checked :: TextEncoding

mkLatin1_checked :: CodingFailureMode -> TextEncoding

ascii :: TextEncoding

mkAscii :: CodingFailureMode -> TextEncoding
latin1_decode :: DecodeBuffer
ascii_decode :: DecodeBuffer
latin1_encode :: EncodeBuffer
latin1_checked_encode :: EncodeBuffer
ascii_encode :: EncodeBuffer


-- | Routines for testing return values and raising a <a>userError</a>
--   exception in case of values indicating an error state.
module Foreign.Marshal.Error

-- | Execute an <a>IO</a> action, throwing a <a>userError</a> if the
--   predicate yields <a>True</a> when applied to the result returned by
--   the <a>IO</a> action. If no exception is raised, return the result of
--   the computation.
throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a

-- | Like <a>throwIf</a>, but discarding the result
throwIf_ :: (a -> Bool) -> (a -> String) -> IO a -> IO ()

-- | Guards against negative result values
throwIfNeg :: (Ord a, Num a) => (a -> String) -> IO a -> IO a

-- | Like <a>throwIfNeg</a>, but discarding the result
throwIfNeg_ :: (Ord a, Num a) => (a -> String) -> IO a -> IO ()

-- | Guards against null pointers
throwIfNull :: String -> IO (Ptr a) -> IO (Ptr a)

-- | Discard the return value of an <a>IO</a> action

-- | <i>Deprecated: use <a>void</a> instead</i>
void :: IO a -> IO ()


-- | The module <a>Foreign.Marshal.Alloc</a> provides operations to
--   allocate and deallocate blocks of raw memory (i.e., unstructured
--   chunks of memory outside of the area maintained by the Haskell storage
--   manager). These memory blocks are commonly used to pass compound data
--   structures to foreign functions or to provide space in which compound
--   result values are obtained from foreign functions.
--   
--   If any of the allocation functions fails, an exception is thrown. In
--   some cases, memory exhaustion may mean the process is terminated. If
--   <a>free</a> or <a>reallocBytes</a> is applied to a memory area that
--   has been allocated with <a>alloca</a> or <a>allocaBytes</a>, the
--   behaviour is undefined. Any further access to memory areas allocated
--   with <a>alloca</a> or <a>allocaBytes</a>, after the computation that
--   was passed to the allocation function has terminated, leads to
--   undefined behaviour. Any further access to the memory area referenced
--   by a pointer passed to <a>realloc</a>, <a>reallocBytes</a>, or
--   <a>free</a> entails undefined behaviour.
--   
--   All storage allocated by functions that allocate based on a <i>size in
--   bytes</i> must be sufficiently aligned for any of the basic foreign
--   types that fits into the newly allocated storage. All storage
--   allocated by functions that allocate based on a specific type must be
--   sufficiently aligned for that type. Array allocation routines need to
--   obey the same alignment constraints for each array element.
module Foreign.Marshal.Alloc

-- | <tt><a>alloca</a> f</tt> executes the computation <tt>f</tt>, passing
--   as argument a pointer to a temporarily allocated block of memory
--   sufficient to hold values of type <tt>a</tt>.
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception), so the pointer passed to <tt>f</tt> must <i>not</i> be
--   used after this.
alloca :: forall a b. Storable a => (Ptr a -> IO b) -> IO b

-- | <tt><a>allocaBytes</a> n f</tt> executes the computation <tt>f</tt>,
--   passing as argument a pointer to a temporarily allocated block of
--   memory of <tt>n</tt> bytes. The block of memory is sufficiently
--   aligned for any of the basic foreign types that fits into a memory
--   block of the allocated size.
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception), so the pointer passed to <tt>f</tt> must <i>not</i> be
--   used after this.
allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
allocaBytesAligned :: Int -> Int -> (Ptr a -> IO b) -> IO b

-- | Allocate a block of memory that is sufficient to hold values of type
--   <tt>a</tt>. The size of the area allocated is determined by the
--   <a>sizeOf</a> method from the instance of <a>Storable</a> for the
--   appropriate type.
--   
--   The memory may be deallocated using <a>free</a> or
--   <a>finalizerFree</a> when no longer required.
malloc :: forall a. Storable a => IO (Ptr a)

-- | Allocate a block of memory of the given number of bytes. The block of
--   memory is sufficiently aligned for any of the basic foreign types that
--   fits into a memory block of the allocated size.
--   
--   The memory may be deallocated using <a>free</a> or
--   <a>finalizerFree</a> when no longer required.
mallocBytes :: Int -> IO (Ptr a)

-- | Like <a>malloc</a> but memory is filled with bytes of value zero.
calloc :: forall a. Storable a => IO (Ptr a)

-- | Llike <a>mallocBytes</a> but memory is filled with bytes of value
--   zero.
callocBytes :: Int -> IO (Ptr a)

-- | Resize a memory area that was allocated with <a>malloc</a> or
--   <a>mallocBytes</a> to the size needed to store values of type
--   <tt>b</tt>. The returned pointer may refer to an entirely different
--   memory area, but will be suitably aligned to hold values of type
--   <tt>b</tt>. The contents of the referenced memory area will be the
--   same as of the original pointer up to the minimum of the original size
--   and the size of values of type <tt>b</tt>.
--   
--   If the argument to <a>realloc</a> is <a>nullPtr</a>, <a>realloc</a>
--   behaves like <a>malloc</a>.
realloc :: forall a b. Storable b => Ptr a -> IO (Ptr b)

-- | Resize a memory area that was allocated with <a>malloc</a> or
--   <a>mallocBytes</a> to the given size. The returned pointer may refer
--   to an entirely different memory area, but will be sufficiently aligned
--   for any of the basic foreign types that fits into a memory block of
--   the given size. The contents of the referenced memory area will be the
--   same as of the original pointer up to the minimum of the original size
--   and the given size.
--   
--   If the pointer argument to <a>reallocBytes</a> is <a>nullPtr</a>,
--   <a>reallocBytes</a> behaves like <a>malloc</a>. If the requested size
--   is 0, <a>reallocBytes</a> behaves like <a>free</a>.
reallocBytes :: Ptr a -> Int -> IO (Ptr a)

-- | Free a block of memory that was allocated with <a>malloc</a>,
--   <a>mallocBytes</a>, <a>realloc</a>, <a>reallocBytes</a>, <a>new</a> or
--   any of the <tt>new</tt><i>X</i> functions in
--   <a>Foreign.Marshal.Array</a> or <a>Foreign.C.String</a>.
free :: Ptr a -> IO ()

-- | A pointer to a foreign function equivalent to <a>free</a>, which may
--   be used as a finalizer (cf <a>ForeignPtr</a>) for storage allocated
--   with <a>malloc</a>, <a>mallocBytes</a>, <a>realloc</a> or
--   <a>reallocBytes</a>.
finalizerFree :: FinalizerPtr a


-- | Utilities for primitive marshaling
module Foreign.Marshal.Utils

-- | <tt><a>with</a> val f</tt> executes the computation <tt>f</tt>,
--   passing as argument a pointer to a temporarily allocated block of
--   memory into which <tt>val</tt> has been marshalled (the combination of
--   <a>alloca</a> and <a>poke</a>).
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception), so the pointer passed to <tt>f</tt> must <i>not</i> be
--   used after this.
with :: Storable a => a -> (Ptr a -> IO b) -> IO b

-- | Allocate a block of memory and marshal a value into it (the
--   combination of <a>malloc</a> and <a>poke</a>). The size of the area
--   allocated is determined by the <a>sizeOf</a> method from the instance
--   of <a>Storable</a> for the appropriate type.
--   
--   The memory may be deallocated using <a>free</a> or
--   <a>finalizerFree</a> when no longer required.
new :: Storable a => a -> IO (Ptr a)

-- | Convert a Haskell <a>Bool</a> to its numeric representation
fromBool :: Num a => Bool -> a

-- | Convert a Boolean in numeric representation to a Haskell value
toBool :: (Eq a, Num a) => a -> Bool

-- | Allocate storage and marshal a storable value wrapped into a
--   <a>Maybe</a>
--   
--   <ul>
--   <li>the <a>nullPtr</a> is used to represent <a>Nothing</a></li>
--   </ul>
maybeNew :: (a -> IO (Ptr b)) -> Maybe a -> IO (Ptr b)

-- | Converts a <tt>withXXX</tt> combinator into one marshalling a value
--   wrapped into a <a>Maybe</a>, using <a>nullPtr</a> to represent
--   <a>Nothing</a>.
maybeWith :: (a -> (Ptr b -> IO c) -> IO c) -> Maybe a -> (Ptr b -> IO c) -> IO c

-- | Convert a peek combinator into a one returning <a>Nothing</a> if
--   applied to a <a>nullPtr</a>
maybePeek :: (Ptr a -> IO b) -> Ptr a -> IO (Maybe b)

-- | Replicates a <tt>withXXX</tt> combinator over a list of objects,
--   yielding a list of marshalled objects
withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res

-- | Copies the given number of bytes from the second area (source) into
--   the first (destination); the copied areas may <i>not</i> overlap
copyBytes :: Ptr a -> Ptr a -> Int -> IO ()

-- | Copies the given number of bytes from the second area (source) into
--   the first (destination); the copied areas <i>may</i> overlap
moveBytes :: Ptr a -> Ptr a -> Int -> IO ()

-- | Fill a given number of bytes in memory area with a byte value.
fillBytes :: Ptr a -> Word8 -> Int -> IO ()


-- | Marshalling support: routines allocating, storing, and retrieving
--   Haskell lists that are represented as arrays in the foreign language
module Foreign.Marshal.Array

-- | Allocate storage for the given number of elements of a storable type
--   (like <a>malloc</a>, but for multiple elements).
mallocArray :: Storable a => Int -> IO (Ptr a)

-- | Like <a>mallocArray</a>, but add an extra position to hold a special
--   termination element.
mallocArray0 :: Storable a => Int -> IO (Ptr a)

-- | Temporarily allocate space for the given number of elements (like
--   <a>alloca</a>, but for multiple elements).
allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b

-- | Like <a>allocaArray</a>, but add an extra position to hold a special
--   termination element.
allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b

-- | Adjust the size of an array
reallocArray :: Storable a => Ptr a -> Int -> IO (Ptr a)

-- | Adjust the size of an array including an extra position for the end
--   marker.
reallocArray0 :: Storable a => Ptr a -> Int -> IO (Ptr a)

-- | Like <a>mallocArray</a>, but allocated memory is filled with bytes of
--   value zero.
callocArray :: Storable a => Int -> IO (Ptr a)

-- | Like <a>callocArray0</a>, but allocated memory is filled with bytes of
--   value zero.
callocArray0 :: Storable a => Int -> IO (Ptr a)

-- | Convert an array of given length into a Haskell list. The
--   implementation is tail-recursive and so uses constant stack space.
peekArray :: Storable a => Int -> Ptr a -> IO [a]

-- | Convert an array terminated by the given end marker into a Haskell
--   list
peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]

-- | Write the list elements consecutive into memory
pokeArray :: Storable a => Ptr a -> [a] -> IO ()

-- | Write the list elements consecutive into memory and terminate them
--   with the given marker element
pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()

-- | Write a list of storable elements into a newly allocated, consecutive
--   sequence of storable values (like <a>new</a>, but for multiple
--   elements).
newArray :: Storable a => [a] -> IO (Ptr a)

-- | Write a list of storable elements into a newly allocated, consecutive
--   sequence of storable values, where the end is fixed by the given end
--   marker
newArray0 :: Storable a => a -> [a] -> IO (Ptr a)

-- | Temporarily store a list of storable values in memory (like
--   <a>with</a>, but for multiple elements).
withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b

-- | Like <a>withArray</a>, but a terminator indicates where the array ends
withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b

-- | Like <a>withArray</a>, but the action gets the number of values as an
--   additional parameter
withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b

-- | Like <a>withArrayLen</a>, but a terminator indicates where the array
--   ends
withArrayLen0 :: Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b

-- | Copy the given number of elements from the second array (source) into
--   the first array (destination); the copied areas may <i>not</i> overlap
copyArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()

-- | Copy the given number of elements from the second array (source) into
--   the first array (destination); the copied areas <i>may</i> overlap
moveArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()

-- | Return the number of elements in an array, excluding the terminator
lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int

-- | Advance a pointer into an array by the given number of elements
advancePtr :: Storable a => Ptr a -> Int -> Ptr a


-- | Foreign marshalling support for CStrings with configurable encodings
module GHC.Foreign

-- | Marshal a NUL terminated C string into a Haskell string.
peekCString :: TextEncoding -> CString -> IO String

-- | Marshal a C string with explicit length into a Haskell string.
peekCStringLen :: TextEncoding -> CStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCString :: TextEncoding -> String -> IO CString

-- | Marshal a Haskell string into a C string (ie, character array) with
--   explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCStringLen :: TextEncoding -> String -> IO CStringLen

-- | Marshal a Haskell string into a NUL terminated C string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCString :: TextEncoding -> String -> (CString -> IO a) -> IO a

-- | Marshal a Haskell string into a C string (ie, character array) in
--   temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCStringLen :: TextEncoding -> String -> (CStringLen -> IO a) -> IO a

-- | Marshal a list of Haskell strings into an array of NUL terminated C
--   strings using temporary storage.
--   
--   <ul>
--   <li>the Haskell strings may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCStringsLen :: TextEncoding -> [String] -> (Int -> Ptr CString -> IO a) -> IO a

-- | Determines whether a character can be accurately encoded in a
--   <a>CString</a>.
--   
--   Pretty much anyone who uses this function is in a state of sin because
--   whether or not a character is encodable will, in general, depend on
--   the context in which it occurs.
charIsRepresentable :: TextEncoding -> Char -> IO Bool


-- | Utilities for primitive marshalling of C strings.
--   
--   The marshalling converts each Haskell character, representing a
--   Unicode code point, to one or more bytes in a manner that, by default,
--   is determined by the current locale. As a consequence, no guarantees
--   can be made about the relative length of a Haskell string and its
--   corresponding C string, and therefore all the marshalling routines
--   include memory allocation. The translation between Unicode and the
--   encoding of the current locale may be lossy.
module Foreign.C.String

-- | A C string is a reference to an array of C characters terminated by
--   NUL.
type CString = Ptr CChar

-- | A string with explicit length information in bytes instead of a
--   terminating NUL (allowing NUL characters in the middle of the string).
type CStringLen = (Ptr CChar, Int)

-- | Marshal a NUL terminated C string into a Haskell string.
peekCString :: CString -> IO String

-- | Marshal a C string with explicit length into a Haskell string.
peekCStringLen :: CStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCString :: String -> IO CString

-- | Marshal a Haskell string into a C string (ie, character array) with
--   explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCStringLen :: String -> IO CStringLen

-- | Marshal a Haskell string into a NUL terminated C string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCString :: String -> (CString -> IO a) -> IO a

-- | Marshal a Haskell string into a C string (ie, character array) in
--   temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCStringLen :: String -> (CStringLen -> IO a) -> IO a
charIsRepresentable :: Char -> IO Bool

-- | Convert a Haskell character to a C character. This function is only
--   safe on the first 256 characters.
castCharToCChar :: Char -> CChar

-- | Convert a C byte, representing a Latin-1 character, to the
--   corresponding Haskell character.
castCCharToChar :: CChar -> Char

-- | Convert a Haskell character to a C <tt>unsigned char</tt>. This
--   function is only safe on the first 256 characters.
castCharToCUChar :: Char -> CUChar

-- | Convert a C <tt>unsigned char</tt>, representing a Latin-1 character,
--   to the corresponding Haskell character.
castCUCharToChar :: CUChar -> Char

-- | Convert a Haskell character to a C <tt>signed char</tt>. This function
--   is only safe on the first 256 characters.
castCharToCSChar :: Char -> CSChar

-- | Convert a C <tt>signed char</tt>, representing a Latin-1 character, to
--   the corresponding Haskell character.
castCSCharToChar :: CSChar -> Char

-- | Marshal a NUL terminated C string into a Haskell string.
peekCAString :: CString -> IO String

-- | Marshal a C string with explicit length into a Haskell string.
peekCAStringLen :: CStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCAString :: String -> IO CString

-- | Marshal a Haskell string into a C string (ie, character array) with
--   explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCAStringLen :: String -> IO CStringLen

-- | Marshal a Haskell string into a NUL terminated C string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCAString :: String -> (CString -> IO a) -> IO a

-- | Marshal a Haskell string into a C string (ie, character array) in
--   temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCAStringLen :: String -> (CStringLen -> IO a) -> IO a

-- | A C wide string is a reference to an array of C wide characters
--   terminated by NUL.
type CWString = Ptr CWchar

-- | A wide character string with explicit length information in
--   <a>CWchar</a>s instead of a terminating NUL (allowing NUL characters
--   in the middle of the string).
type CWStringLen = (Ptr CWchar, Int)

-- | Marshal a NUL terminated C wide string into a Haskell string.
peekCWString :: CWString -> IO String

-- | Marshal a C wide string with explicit length into a Haskell string.
peekCWStringLen :: CWStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C wide string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C wide string and must be
--   explicitly freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCWString :: String -> IO CWString

-- | Marshal a Haskell string into a C wide string (ie, wide character
--   array) with explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C wide string and must be
--   explicitly freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCWStringLen :: String -> IO CWStringLen

-- | Marshal a Haskell string into a NUL terminated C wide string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCWString :: String -> (CWString -> IO a) -> IO a

-- | Marshal a Haskell string into a C wide string (i.e. wide character
--   array) in temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCWStringLen :: String -> (CWStringLen -> IO a) -> IO a


-- | Marshalling support. Unsafe API.
module Foreign.Marshal.Unsafe

-- | Sometimes an external entity is a pure function, except that it passes
--   arguments and/or results via pointers. The function
--   <tt>unsafeLocalState</tt> permits the packaging of such entities as
--   pure functions.
--   
--   The only IO operations allowed in the IO action passed to
--   <tt>unsafeLocalState</tt> are (a) local allocation (<tt>alloca</tt>,
--   <tt>allocaBytes</tt> and derived operations such as <tt>withArray</tt>
--   and <tt>withCString</tt>), and (b) pointer operations
--   (<tt>Foreign.Storable</tt> and <tt>Foreign.Ptr</tt>) on the pointers
--   to local storage, and (c) foreign functions whose only observable
--   effect is to read and/or write the locally allocated memory. Passing
--   an IO operation that does not obey these rules results in undefined
--   behaviour.
--   
--   It is expected that this operation will be replaced in a future
--   revision of Haskell.
unsafeLocalState :: IO a -> a


-- | FFI datatypes and operations that use or require concurrency (GHC
--   only).
module Foreign.Concurrent

-- | Turns a plain memory reference into a foreign object by associating a
--   finalizer - given by the monadic operation - with the reference. The
--   storage manager will start the finalizer, in a separate thread, some
--   time after the last reference to the <tt>ForeignPtr</tt> is dropped.
--   There is no guarantee of promptness, and in fact there is no guarantee
--   that the finalizer will eventually run at all.
--   
--   Note that references from a finalizer do not necessarily prevent
--   another object from being finalized. If A's finalizer refers to B
--   (perhaps using <tt>touchForeignPtr</tt>, then the only guarantee is
--   that B's finalizer will never be started before A's. If both A and B
--   are unreachable, then both finalizers will start together. See
--   <tt>touchForeignPtr</tt> for more on finalizer ordering.
newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given <tt>ForeignPtr</tt>. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
--   
--   This is a variant of
--   <tt>Foreign.ForeignPtr.addForeignPtrFinalizer</tt>, where the
--   finalizer is an arbitrary <tt>IO</tt> action. When it is invoked, the
--   finalizer will run in a new thread.
--   
--   NB. Be very careful with these finalizers. One common trap is that if
--   a finalizer references another finalized value, it does not prevent
--   that value from being finalized. In particular, <tt>Handle</tt>s are
--   finalized objects, so a finalizer should not refer to a
--   <tt>Handle</tt> (including <tt>stdout</tt>, <tt>stdin</tt> or
--   <tt>stderr</tt>).
addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()


-- | C-specific Marshalling support: Handling of C "errno" error codes.
module Foreign.C.Error

-- | Haskell representation for <tt>errno</tt> values. The implementation
--   is deliberately exposed, to allow users to add their own definitions
--   of <a>Errno</a> values.
newtype Errno
Errno :: CInt -> Errno
eOK :: Errno
e2BIG :: Errno
eACCES :: Errno
eADDRINUSE :: Errno
eADDRNOTAVAIL :: Errno
eADV :: Errno
eAFNOSUPPORT :: Errno
eAGAIN :: Errno
eALREADY :: Errno
eBADF :: Errno
eBADMSG :: Errno
eBADRPC :: Errno
eBUSY :: Errno
eCHILD :: Errno
eCOMM :: Errno
eCONNABORTED :: Errno
eCONNREFUSED :: Errno
eCONNRESET :: Errno
eDEADLK :: Errno
eDESTADDRREQ :: Errno
eDIRTY :: Errno
eDOM :: Errno
eDQUOT :: Errno
eEXIST :: Errno
eFAULT :: Errno
eFBIG :: Errno
eFTYPE :: Errno
eHOSTDOWN :: Errno
eHOSTUNREACH :: Errno
eIDRM :: Errno
eILSEQ :: Errno
eINPROGRESS :: Errno
eINTR :: Errno
eINVAL :: Errno
eIO :: Errno
eISCONN :: Errno
eISDIR :: Errno
eLOOP :: Errno
eMFILE :: Errno
eMLINK :: Errno
eMSGSIZE :: Errno
eMULTIHOP :: Errno
eNAMETOOLONG :: Errno
eNETDOWN :: Errno
eNETRESET :: Errno
eNETUNREACH :: Errno
eNFILE :: Errno
eNOBUFS :: Errno
eNODATA :: Errno
eNODEV :: Errno
eNOENT :: Errno
eNOEXEC :: Errno
eNOLCK :: Errno
eNOLINK :: Errno
eNOMEM :: Errno
eNOMSG :: Errno
eNONET :: Errno
eNOPROTOOPT :: Errno
eNOSPC :: Errno
eNOSR :: Errno
eNOSTR :: Errno
eNOSYS :: Errno
eNOTBLK :: Errno
eNOTCONN :: Errno
eNOTDIR :: Errno
eNOTEMPTY :: Errno
eNOTSOCK :: Errno

eNOTSUP :: Errno
eNOTTY :: Errno
eNXIO :: Errno
eOPNOTSUPP :: Errno
ePERM :: Errno
ePFNOSUPPORT :: Errno
ePIPE :: Errno
ePROCLIM :: Errno
ePROCUNAVAIL :: Errno
ePROGMISMATCH :: Errno
ePROGUNAVAIL :: Errno
ePROTO :: Errno
ePROTONOSUPPORT :: Errno
ePROTOTYPE :: Errno
eRANGE :: Errno
eREMCHG :: Errno
eREMOTE :: Errno
eROFS :: Errno
eRPCMISMATCH :: Errno
eRREMOTE :: Errno
eSHUTDOWN :: Errno
eSOCKTNOSUPPORT :: Errno
eSPIPE :: Errno
eSRCH :: Errno
eSRMNT :: Errno
eSTALE :: Errno
eTIME :: Errno
eTIMEDOUT :: Errno
eTOOMANYREFS :: Errno
eTXTBSY :: Errno
eUSERS :: Errno
eWOULDBLOCK :: Errno
eXDEV :: Errno

-- | Yield <a>True</a> if the given <a>Errno</a> value is valid on the
--   system. This implies that the <a>Eq</a> instance of <a>Errno</a> is
--   also system dependent as it is only defined for valid values of
--   <a>Errno</a>.
isValidErrno :: Errno -> Bool

-- | Get the current value of <tt>errno</tt> in the current thread.
getErrno :: IO Errno

-- | Reset the current thread's <tt>errno</tt> value to <a>eOK</a>.
resetErrno :: IO ()

-- | Construct an <a>IOException</a> based on the given <a>Errno</a> value.
--   The optional information can be used to improve the accuracy of error
--   messages.
errnoToIOError :: String -> Errno -> Maybe Handle -> Maybe String -> IOError

-- | Throw an <a>IOException</a> corresponding to the current value of
--   <a>getErrno</a>.
throwErrno :: String -> IO a

-- | Throw an <a>IOException</a> corresponding to the current value of
--   <a>getErrno</a> if the result value of the <a>IO</a> action meets the
--   given predicate.
throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a

-- | as <a>throwErrnoIf</a>, but discards the result of the <a>IO</a>
--   action after error handling.
throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()

-- | as <a>throwErrnoIf</a>, but retry the <a>IO</a> action when it yields
--   the error code <a>eINTR</a> - this amounts to the standard retry loop
--   for interrupted POSIX system calls.
throwErrnoIfRetry :: (a -> Bool) -> String -> IO a -> IO a

-- | as <a>throwErrnoIfRetry</a>, but discards the result.
throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()

-- | Throw an <a>IOException</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns a result of
--   <tt>-1</tt>.
throwErrnoIfMinus1 :: (Eq a, Num a) => String -> IO a -> IO a

-- | as <a>throwErrnoIfMinus1</a>, but discards the result.
throwErrnoIfMinus1_ :: (Eq a, Num a) => String -> IO a -> IO ()

-- | Throw an <a>IOException</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns a result of
--   <tt>-1</tt>, but retries in case of an interrupted operation.
throwErrnoIfMinus1Retry :: (Eq a, Num a) => String -> IO a -> IO a

-- | as <a>throwErrnoIfMinus1</a>, but discards the result.
throwErrnoIfMinus1Retry_ :: (Eq a, Num a) => String -> IO a -> IO ()

-- | Throw an <a>IOException</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns <a>nullPtr</a>.
throwErrnoIfNull :: String -> IO (Ptr a) -> IO (Ptr a)

-- | Throw an <a>IOException</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns <a>nullPtr</a>, but
--   retry in case of an interrupted operation.
throwErrnoIfNullRetry :: String -> IO (Ptr a) -> IO (Ptr a)

-- | as <a>throwErrnoIfRetry</a>, but additionally if the operation yields
--   the error code <a>eAGAIN</a> or <a>eWOULDBLOCK</a>, an alternative
--   action is executed before retrying.
throwErrnoIfRetryMayBlock :: (a -> Bool) -> String -> IO a -> IO b -> IO a

-- | as <a>throwErrnoIfRetryMayBlock</a>, but discards the result.
throwErrnoIfRetryMayBlock_ :: (a -> Bool) -> String -> IO a -> IO b -> IO ()

-- | as <a>throwErrnoIfMinus1Retry</a>, but checks for operations that
--   would block.
throwErrnoIfMinus1RetryMayBlock :: (Eq a, Num a) => String -> IO a -> IO b -> IO a

-- | as <a>throwErrnoIfMinus1RetryMayBlock</a>, but discards the result.
throwErrnoIfMinus1RetryMayBlock_ :: (Eq a, Num a) => String -> IO a -> IO b -> IO ()

-- | as <a>throwErrnoIfNullRetry</a>, but checks for operations that would
--   block.
throwErrnoIfNullRetryMayBlock :: String -> IO (Ptr a) -> IO b -> IO (Ptr a)

-- | as <a>throwErrno</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPath :: String -> FilePath -> IO a

-- | as <a>throwErrnoIf</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a

-- | as <a>throwErrnoIf_</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPathIf_ :: (a -> Bool) -> String -> FilePath -> IO a -> IO ()

-- | as <a>throwErrnoIfNull</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPathIfNull :: String -> FilePath -> IO (Ptr a) -> IO (Ptr a)

-- | as <a>throwErrnoIfMinus1</a>, but exceptions include the given path
--   when appropriate.
throwErrnoPathIfMinus1 :: (Eq a, Num a) => String -> FilePath -> IO a -> IO a

-- | as <a>throwErrnoIfMinus1_</a>, but exceptions include the given path
--   when appropriate.
throwErrnoPathIfMinus1_ :: (Eq a, Num a) => String -> FilePath -> IO a -> IO ()
instance GHC.Classes.Eq Foreign.C.Error.Errno


-- | Bundles the C specific FFI library functionality
module Foreign.C


-- | This module contains support for pooled memory management. Under this
--   scheme, (re-)allocations belong to a given pool, and everything in a
--   pool is deallocated when the pool itself is deallocated. This is
--   useful when <a>alloca</a> with its implicit allocation and
--   deallocation is not flexible enough, but explicit uses of
--   <a>malloc</a> and <a>free</a> are too awkward.
module Foreign.Marshal.Pool

-- | A memory pool.
data Pool

-- | Allocate a fresh memory pool.
newPool :: IO Pool

-- | Deallocate a memory pool and everything which has been allocated in
--   the pool itself.
freePool :: Pool -> IO ()

-- | Execute an action with a fresh memory pool, which gets automatically
--   deallocated (including its contents) after the action has finished.
withPool :: (Pool -> IO b) -> IO b

-- | Allocate space for storable type in the given pool. The size of the
--   area allocated is determined by the <a>sizeOf</a> method from the
--   instance of <a>Storable</a> for the appropriate type.
pooledMalloc :: Storable a => Pool -> IO (Ptr a)

-- | Allocate the given number of bytes of storage in the pool.
pooledMallocBytes :: Pool -> Int -> IO (Ptr a)

-- | Adjust the storage area for an element in the pool to the given size
--   of the required type.
pooledRealloc :: Storable a => Pool -> Ptr a -> IO (Ptr a)

-- | Adjust the storage area for an element in the pool to the given size.
pooledReallocBytes :: Pool -> Ptr a -> Int -> IO (Ptr a)

-- | Allocate storage for the given number of elements of a storable type
--   in the pool.
pooledMallocArray :: Storable a => Pool -> Int -> IO (Ptr a)

-- | Allocate storage for the given number of elements of a storable type
--   in the pool, but leave room for an extra element to signal the end of
--   the array.
pooledMallocArray0 :: Storable a => Pool -> Int -> IO (Ptr a)

-- | Adjust the size of an array in the given pool.
pooledReallocArray :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)

-- | Adjust the size of an array with an end marker in the given pool.
pooledReallocArray0 :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)

-- | Allocate storage for a value in the given pool and marshal the value
--   into this storage.
pooledNew :: Storable a => Pool -> a -> IO (Ptr a)

-- | Allocate consecutive storage for a list of values in the given pool
--   and marshal these values into it.
pooledNewArray :: Storable a => Pool -> [a] -> IO (Ptr a)

-- | Allocate consecutive storage for a list of values in the given pool
--   and marshal these values into it, terminating the end with the given
--   marker.
pooledNewArray0 :: Storable a => Pool -> a -> [a] -> IO (Ptr a)


-- | Marshalling support
--   
--   Safe API Only.

-- | <i>Deprecated: Safe is now the default, please use Foreign.Marshal
--   instead</i>
module Foreign.Marshal.Safe


-- | Marshalling support
module Foreign.Marshal


-- | A collection of data types, classes, and functions for interfacing
--   with another programming language.
--   
--   Safe API Only.

-- | <i>Deprecated: Safe is now the default, please use Foreign instead</i>
module Foreign.Safe


-- | A collection of data types, classes, and functions for interfacing
--   with another programming language.
module Foreign


-- | POSIX data types: Haskell equivalents of the types defined by the
--   <tt>&lt;sys/types.h&gt;</tt> C header on a POSIX system.
module System.Posix.Types
newtype CDev
CDev :: Word64 -> CDev
newtype CIno
CIno :: Word64 -> CIno
newtype {-# CTYPE "mode_t" #-} CMode
CMode :: Word32 -> CMode
newtype COff
COff :: Int64 -> COff
newtype CPid
CPid :: Int32 -> CPid
newtype CSsize
CSsize :: Int64 -> CSsize
newtype CGid
CGid :: Word32 -> CGid
newtype CNlink
CNlink :: Word64 -> CNlink
newtype CUid
CUid :: Word32 -> CUid
newtype CCc
CCc :: Word8 -> CCc
newtype CSpeed
CSpeed :: Word32 -> CSpeed
newtype CTcflag
CTcflag :: Word32 -> CTcflag
newtype CRLim
CRLim :: Word64 -> CRLim

newtype {-# CTYPE "blksize_t" #-} CBlkSize
CBlkSize :: Int64 -> CBlkSize

newtype {-# CTYPE "blkcnt_t" #-} CBlkCnt
CBlkCnt :: Int64 -> CBlkCnt

newtype {-# CTYPE "clockid_t" #-} CClockId
CClockId :: Int32 -> CClockId

newtype {-# CTYPE "fsblkcnt_t" #-} CFsBlkCnt
CFsBlkCnt :: Word64 -> CFsBlkCnt

newtype {-# CTYPE "fsfilcnt_t" #-} CFsFilCnt
CFsFilCnt :: Word64 -> CFsFilCnt

newtype {-# CTYPE "id_t" #-} CId
CId :: Word32 -> CId

newtype {-# CTYPE "key_t" #-} CKey
CKey :: Int32 -> CKey

newtype {-# CTYPE "timer_t" #-} CTimer
CTimer :: Ptr () -> CTimer
newtype Fd
Fd :: CInt -> Fd
type LinkCount = CNlink
type UserID = CUid
type GroupID = CGid
type ByteCount = CSize
type ClockTick = CClock
type EpochTime = CTime
type FileOffset = COff
type ProcessID = CPid
type ProcessGroupID = CPid
type DeviceID = CDev
type FileID = CIno
type FileMode = CMode
type Limit = CLong
instance GHC.Show.Show System.Posix.Types.Fd
instance GHC.Read.Read System.Posix.Types.Fd
instance Data.Bits.FiniteBits System.Posix.Types.Fd
instance Data.Bits.Bits System.Posix.Types.Fd
instance GHC.Real.Integral System.Posix.Types.Fd
instance GHC.Enum.Bounded System.Posix.Types.Fd
instance GHC.Real.Real System.Posix.Types.Fd
instance Foreign.Storable.Storable System.Posix.Types.Fd
instance GHC.Enum.Enum System.Posix.Types.Fd
instance GHC.Num.Num System.Posix.Types.Fd
instance GHC.Classes.Ord System.Posix.Types.Fd
instance GHC.Classes.Eq System.Posix.Types.Fd
instance GHC.Show.Show System.Posix.Types.CTimer
instance Foreign.Storable.Storable System.Posix.Types.CTimer
instance GHC.Classes.Ord System.Posix.Types.CTimer
instance GHC.Classes.Eq System.Posix.Types.CTimer
instance GHC.Show.Show System.Posix.Types.CKey
instance GHC.Read.Read System.Posix.Types.CKey
instance Data.Bits.FiniteBits System.Posix.Types.CKey
instance Data.Bits.Bits System.Posix.Types.CKey
instance GHC.Real.Integral System.Posix.Types.CKey
instance GHC.Enum.Bounded System.Posix.Types.CKey
instance GHC.Real.Real System.Posix.Types.CKey
instance Foreign.Storable.Storable System.Posix.Types.CKey
instance GHC.Enum.Enum System.Posix.Types.CKey
instance GHC.Num.Num System.Posix.Types.CKey
instance GHC.Classes.Ord System.Posix.Types.CKey
instance GHC.Classes.Eq System.Posix.Types.CKey
instance GHC.Show.Show System.Posix.Types.CId
instance GHC.Read.Read System.Posix.Types.CId
instance Data.Bits.FiniteBits System.Posix.Types.CId
instance Data.Bits.Bits System.Posix.Types.CId
instance GHC.Real.Integral System.Posix.Types.CId
instance GHC.Enum.Bounded System.Posix.Types.CId
instance GHC.Real.Real System.Posix.Types.CId
instance Foreign.Storable.Storable System.Posix.Types.CId
instance GHC.Enum.Enum System.Posix.Types.CId
instance GHC.Num.Num System.Posix.Types.CId
instance GHC.Classes.Ord System.Posix.Types.CId
instance GHC.Classes.Eq System.Posix.Types.CId
instance GHC.Show.Show System.Posix.Types.CFsFilCnt
instance GHC.Read.Read System.Posix.Types.CFsFilCnt
instance Data.Bits.FiniteBits System.Posix.Types.CFsFilCnt
instance Data.Bits.Bits System.Posix.Types.CFsFilCnt
instance GHC.Real.Integral System.Posix.Types.CFsFilCnt
instance GHC.Enum.Bounded System.Posix.Types.CFsFilCnt
instance GHC.Real.Real System.Posix.Types.CFsFilCnt
instance Foreign.Storable.Storable System.Posix.Types.CFsFilCnt
instance GHC.Enum.Enum System.Posix.Types.CFsFilCnt
instance GHC.Num.Num System.Posix.Types.CFsFilCnt
instance GHC.Classes.Ord System.Posix.Types.CFsFilCnt
instance GHC.Classes.Eq System.Posix.Types.CFsFilCnt
instance GHC.Show.Show System.Posix.Types.CFsBlkCnt
instance GHC.Read.Read System.Posix.Types.CFsBlkCnt
instance Data.Bits.FiniteBits System.Posix.Types.CFsBlkCnt
instance Data.Bits.Bits System.Posix.Types.CFsBlkCnt
instance GHC.Real.Integral System.Posix.Types.CFsBlkCnt
instance GHC.Enum.Bounded System.Posix.Types.CFsBlkCnt
instance GHC.Real.Real System.Posix.Types.CFsBlkCnt
instance Foreign.Storable.Storable System.Posix.Types.CFsBlkCnt
instance GHC.Enum.Enum System.Posix.Types.CFsBlkCnt
instance GHC.Num.Num System.Posix.Types.CFsBlkCnt
instance GHC.Classes.Ord System.Posix.Types.CFsBlkCnt
instance GHC.Classes.Eq System.Posix.Types.CFsBlkCnt
instance GHC.Show.Show System.Posix.Types.CClockId
instance GHC.Read.Read System.Posix.Types.CClockId
instance Data.Bits.FiniteBits System.Posix.Types.CClockId
instance Data.Bits.Bits System.Posix.Types.CClockId
instance GHC.Real.Integral System.Posix.Types.CClockId
instance GHC.Enum.Bounded System.Posix.Types.CClockId
instance GHC.Real.Real System.Posix.Types.CClockId
instance Foreign.Storable.Storable System.Posix.Types.CClockId
instance GHC.Enum.Enum System.Posix.Types.CClockId
instance GHC.Num.Num System.Posix.Types.CClockId
instance GHC.Classes.Ord System.Posix.Types.CClockId
instance GHC.Classes.Eq System.Posix.Types.CClockId
instance GHC.Show.Show System.Posix.Types.CBlkCnt
instance GHC.Read.Read System.Posix.Types.CBlkCnt
instance Data.Bits.FiniteBits System.Posix.Types.CBlkCnt
instance Data.Bits.Bits System.Posix.Types.CBlkCnt
instance GHC.Real.Integral System.Posix.Types.CBlkCnt
instance GHC.Enum.Bounded System.Posix.Types.CBlkCnt
instance GHC.Real.Real System.Posix.Types.CBlkCnt
instance Foreign.Storable.Storable System.Posix.Types.CBlkCnt
instance GHC.Enum.Enum System.Posix.Types.CBlkCnt
instance GHC.Num.Num System.Posix.Types.CBlkCnt
instance GHC.Classes.Ord System.Posix.Types.CBlkCnt
instance GHC.Classes.Eq System.Posix.Types.CBlkCnt
instance GHC.Show.Show System.Posix.Types.CBlkSize
instance GHC.Read.Read System.Posix.Types.CBlkSize
instance Data.Bits.FiniteBits System.Posix.Types.CBlkSize
instance Data.Bits.Bits System.Posix.Types.CBlkSize
instance GHC.Real.Integral System.Posix.Types.CBlkSize
instance GHC.Enum.Bounded System.Posix.Types.CBlkSize
instance GHC.Real.Real System.Posix.Types.CBlkSize
instance Foreign.Storable.Storable System.Posix.Types.CBlkSize
instance GHC.Enum.Enum System.Posix.Types.CBlkSize
instance GHC.Num.Num System.Posix.Types.CBlkSize
instance GHC.Classes.Ord System.Posix.Types.CBlkSize
instance GHC.Classes.Eq System.Posix.Types.CBlkSize
instance GHC.Show.Show System.Posix.Types.CRLim
instance GHC.Read.Read System.Posix.Types.CRLim
instance Data.Bits.FiniteBits System.Posix.Types.CRLim
instance Data.Bits.Bits System.Posix.Types.CRLim
instance GHC.Real.Integral System.Posix.Types.CRLim
instance GHC.Enum.Bounded System.Posix.Types.CRLim
instance GHC.Real.Real System.Posix.Types.CRLim
instance Foreign.Storable.Storable System.Posix.Types.CRLim
instance GHC.Enum.Enum System.Posix.Types.CRLim
instance GHC.Num.Num System.Posix.Types.CRLim
instance GHC.Classes.Ord System.Posix.Types.CRLim
instance GHC.Classes.Eq System.Posix.Types.CRLim
instance GHC.Show.Show System.Posix.Types.CTcflag
instance GHC.Read.Read System.Posix.Types.CTcflag
instance Data.Bits.FiniteBits System.Posix.Types.CTcflag
instance Data.Bits.Bits System.Posix.Types.CTcflag
instance GHC.Real.Integral System.Posix.Types.CTcflag
instance GHC.Enum.Bounded System.Posix.Types.CTcflag
instance GHC.Real.Real System.Posix.Types.CTcflag
instance Foreign.Storable.Storable System.Posix.Types.CTcflag
instance GHC.Enum.Enum System.Posix.Types.CTcflag
instance GHC.Num.Num System.Posix.Types.CTcflag
instance GHC.Classes.Ord System.Posix.Types.CTcflag
instance GHC.Classes.Eq System.Posix.Types.CTcflag
instance GHC.Show.Show System.Posix.Types.CSpeed
instance GHC.Read.Read System.Posix.Types.CSpeed
instance GHC.Real.Real System.Posix.Types.CSpeed
instance Foreign.Storable.Storable System.Posix.Types.CSpeed
instance GHC.Enum.Enum System.Posix.Types.CSpeed
instance GHC.Num.Num System.Posix.Types.CSpeed
instance GHC.Classes.Ord System.Posix.Types.CSpeed
instance GHC.Classes.Eq System.Posix.Types.CSpeed
instance GHC.Show.Show System.Posix.Types.CCc
instance GHC.Read.Read System.Posix.Types.CCc
instance GHC.Real.Real System.Posix.Types.CCc
instance Foreign.Storable.Storable System.Posix.Types.CCc
instance GHC.Enum.Enum System.Posix.Types.CCc
instance GHC.Num.Num System.Posix.Types.CCc
instance GHC.Classes.Ord System.Posix.Types.CCc
instance GHC.Classes.Eq System.Posix.Types.CCc
instance GHC.Show.Show System.Posix.Types.CUid
instance GHC.Read.Read System.Posix.Types.CUid
instance Data.Bits.FiniteBits System.Posix.Types.CUid
instance Data.Bits.Bits System.Posix.Types.CUid
instance GHC.Real.Integral System.Posix.Types.CUid
instance GHC.Enum.Bounded System.Posix.Types.CUid
instance GHC.Real.Real System.Posix.Types.CUid
instance Foreign.Storable.Storable System.Posix.Types.CUid
instance GHC.Enum.Enum System.Posix.Types.CUid
instance GHC.Num.Num System.Posix.Types.CUid
instance GHC.Classes.Ord System.Posix.Types.CUid
instance GHC.Classes.Eq System.Posix.Types.CUid
instance GHC.Show.Show System.Posix.Types.CNlink
instance GHC.Read.Read System.Posix.Types.CNlink
instance Data.Bits.FiniteBits System.Posix.Types.CNlink
instance Data.Bits.Bits System.Posix.Types.CNlink
instance GHC.Real.Integral System.Posix.Types.CNlink
instance GHC.Enum.Bounded System.Posix.Types.CNlink
instance GHC.Real.Real System.Posix.Types.CNlink
instance Foreign.Storable.Storable System.Posix.Types.CNlink
instance GHC.Enum.Enum System.Posix.Types.CNlink
instance GHC.Num.Num System.Posix.Types.CNlink
instance GHC.Classes.Ord System.Posix.Types.CNlink
instance GHC.Classes.Eq System.Posix.Types.CNlink
instance GHC.Show.Show System.Posix.Types.CGid
instance GHC.Read.Read System.Posix.Types.CGid
instance Data.Bits.FiniteBits System.Posix.Types.CGid
instance Data.Bits.Bits System.Posix.Types.CGid
instance GHC.Real.Integral System.Posix.Types.CGid
instance GHC.Enum.Bounded System.Posix.Types.CGid
instance GHC.Real.Real System.Posix.Types.CGid
instance Foreign.Storable.Storable System.Posix.Types.CGid
instance GHC.Enum.Enum System.Posix.Types.CGid
instance GHC.Num.Num System.Posix.Types.CGid
instance GHC.Classes.Ord System.Posix.Types.CGid
instance GHC.Classes.Eq System.Posix.Types.CGid
instance GHC.Show.Show System.Posix.Types.CSsize
instance GHC.Read.Read System.Posix.Types.CSsize
instance Data.Bits.FiniteBits System.Posix.Types.CSsize
instance Data.Bits.Bits System.Posix.Types.CSsize
instance GHC.Real.Integral System.Posix.Types.CSsize
instance GHC.Enum.Bounded System.Posix.Types.CSsize
instance GHC.Real.Real System.Posix.Types.CSsize
instance Foreign.Storable.Storable System.Posix.Types.CSsize
instance GHC.Enum.Enum System.Posix.Types.CSsize
instance GHC.Num.Num System.Posix.Types.CSsize
instance GHC.Classes.Ord System.Posix.Types.CSsize
instance GHC.Classes.Eq System.Posix.Types.CSsize
instance GHC.Show.Show System.Posix.Types.CPid
instance GHC.Read.Read System.Posix.Types.CPid
instance Data.Bits.FiniteBits System.Posix.Types.CPid
instance Data.Bits.Bits System.Posix.Types.CPid
instance GHC.Real.Integral System.Posix.Types.CPid
instance GHC.Enum.Bounded System.Posix.Types.CPid
instance GHC.Real.Real System.Posix.Types.CPid
instance Foreign.Storable.Storable System.Posix.Types.CPid
instance GHC.Enum.Enum System.Posix.Types.CPid
instance GHC.Num.Num System.Posix.Types.CPid
instance GHC.Classes.Ord System.Posix.Types.CPid
instance GHC.Classes.Eq System.Posix.Types.CPid
instance GHC.Show.Show System.Posix.Types.COff
instance GHC.Read.Read System.Posix.Types.COff
instance Data.Bits.FiniteBits System.Posix.Types.COff
instance Data.Bits.Bits System.Posix.Types.COff
instance GHC.Real.Integral System.Posix.Types.COff
instance GHC.Enum.Bounded System.Posix.Types.COff
instance GHC.Real.Real System.Posix.Types.COff
instance Foreign.Storable.Storable System.Posix.Types.COff
instance GHC.Enum.Enum System.Posix.Types.COff
instance GHC.Num.Num System.Posix.Types.COff
instance GHC.Classes.Ord System.Posix.Types.COff
instance GHC.Classes.Eq System.Posix.Types.COff
instance GHC.Show.Show System.Posix.Types.CMode
instance GHC.Read.Read System.Posix.Types.CMode
instance Data.Bits.FiniteBits System.Posix.Types.CMode
instance Data.Bits.Bits System.Posix.Types.CMode
instance GHC.Real.Integral System.Posix.Types.CMode
instance GHC.Enum.Bounded System.Posix.Types.CMode
instance GHC.Real.Real System.Posix.Types.CMode
instance Foreign.Storable.Storable System.Posix.Types.CMode
instance GHC.Enum.Enum System.Posix.Types.CMode
instance GHC.Num.Num System.Posix.Types.CMode
instance GHC.Classes.Ord System.Posix.Types.CMode
instance GHC.Classes.Eq System.Posix.Types.CMode
instance GHC.Show.Show System.Posix.Types.CIno
instance GHC.Read.Read System.Posix.Types.CIno
instance Data.Bits.FiniteBits System.Posix.Types.CIno
instance Data.Bits.Bits System.Posix.Types.CIno
instance GHC.Real.Integral System.Posix.Types.CIno
instance GHC.Enum.Bounded System.Posix.Types.CIno
instance GHC.Real.Real System.Posix.Types.CIno
instance Foreign.Storable.Storable System.Posix.Types.CIno
instance GHC.Enum.Enum System.Posix.Types.CIno
instance GHC.Num.Num System.Posix.Types.CIno
instance GHC.Classes.Ord System.Posix.Types.CIno
instance GHC.Classes.Eq System.Posix.Types.CIno
instance GHC.Show.Show System.Posix.Types.CDev
instance GHC.Read.Read System.Posix.Types.CDev
instance Data.Bits.FiniteBits System.Posix.Types.CDev
instance Data.Bits.Bits System.Posix.Types.CDev
instance GHC.Real.Integral System.Posix.Types.CDev
instance GHC.Enum.Bounded System.Posix.Types.CDev
instance GHC.Real.Real System.Posix.Types.CDev
instance Foreign.Storable.Storable System.Posix.Types.CDev
instance GHC.Enum.Enum System.Posix.Types.CDev
instance GHC.Num.Num System.Posix.Types.CDev
instance GHC.Classes.Ord System.Posix.Types.CDev
instance GHC.Classes.Eq System.Posix.Types.CDev


-- | The Dynamic interface provides basic support for dynamic types.
--   
--   Operations for injecting values of arbitrary type into a dynamically
--   typed value, Dynamic, are provided, together with operations for
--   converting dynamic values into a concrete (monomorphic) type.
module Data.Dynamic

-- | A value of type <a>Dynamic</a> is an object encapsulated together with
--   its type.
--   
--   A <a>Dynamic</a> may only represent a monomorphic value; an attempt to
--   create a value of type <a>Dynamic</a> from a polymorphically-typed
--   expression will result in an ambiguity error (see <a>toDyn</a>).
--   
--   <a>Show</a>ing a value of type <a>Dynamic</a> returns a pretty-printed
--   representation of the object's type; useful for debugging.
data Dynamic
[Dynamic] :: forall a. TypeRep a -> a -> Dynamic

-- | Converts an arbitrary value into an object of type <a>Dynamic</a>.
--   
--   The type of the object must be an instance of <a>Typeable</a>, which
--   ensures that only monomorphically-typed objects may be converted to
--   <a>Dynamic</a>. To convert a polymorphic object into <a>Dynamic</a>,
--   give it a monomorphic type signature. For example:
--   
--   <pre>
--   toDyn (id :: Int -&gt; Int)
--   </pre>
toDyn :: Typeable a => a -> Dynamic

-- | Converts a <a>Dynamic</a> object back into an ordinary Haskell value
--   of the correct type. See also <a>fromDynamic</a>.
fromDyn :: Typeable a => Dynamic -> a -> a

-- | Converts a <a>Dynamic</a> object back into an ordinary Haskell value
--   of the correct type. See also <a>fromDyn</a>.
fromDynamic :: forall a. Typeable a => Dynamic -> Maybe a
dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
dynApp :: Dynamic -> Dynamic -> Dynamic
dynTypeRep :: Dynamic -> SomeTypeRep

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)
instance GHC.Show.Show Data.Dynamic.Dynamic
instance GHC.Exception.Type.Exception Data.Dynamic.Dynamic


-- | Basic concurrency stuff.
module GHC.Conc.Sync

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
data ThreadId
ThreadId :: ThreadId# -> ThreadId

-- | Creates a new thread to run the <a>IO</a> computation passed as the
--   first argument, and returns the <a>ThreadId</a> of the newly created
--   thread.
--   
--   The new thread will be a lightweight, <i>unbound</i> thread. Foreign
--   calls made by this thread are not guaranteed to be made by any
--   particular OS thread; if you need foreign calls to be made by a
--   particular OS thread, then use <a>forkOS</a> instead.
--   
--   The new thread inherits the <i>masked</i> state of the parent (see
--   <a>mask</a>).
--   
--   The newly created thread has an exception handler that discards the
--   exceptions <a>BlockedIndefinitelyOnMVar</a>,
--   <a>BlockedIndefinitelyOnSTM</a>, and <a>ThreadKilled</a>, and passes
--   all other exceptions to the uncaught exception handler.
forkIO :: IO () -> IO ThreadId

-- | Like <a>forkIO</a>, but the child thread is passed a function that can
--   be used to unmask asynchronous exceptions. This function is typically
--   used in the following way
--   
--   <pre>
--   ... mask_ $ forkIOWithUnmask $ \unmask -&gt;
--                  catch (unmask ...) handler
--   </pre>
--   
--   so that the exception handler in the child thread is established with
--   asynchronous exceptions masked, meanwhile the main body of the child
--   thread is executed in the unmasked state.
--   
--   Note that the unmask function passed to the child thread should only
--   be used in that thread; the behaviour is undefined if it is invoked in
--   a different thread.
forkIOWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Like <a>forkIO</a>, but lets you specify on which capability the
--   thread should run. Unlike a <a>forkIO</a> thread, a thread created by
--   <a>forkOn</a> will stay on the same capability for its entire lifetime
--   (<a>forkIO</a> threads can migrate between capabilities according to
--   the scheduling policy). <a>forkOn</a> is useful for overriding the
--   scheduling policy when you know in advance how best to distribute the
--   threads.
--   
--   The <a>Int</a> argument specifies a <i>capability number</i> (see
--   <a>getNumCapabilities</a>). Typically capabilities correspond to
--   physical processors, but the exact behaviour is
--   implementation-dependent. The value passed to <a>forkOn</a> is
--   interpreted modulo the total number of capabilities as returned by
--   <a>getNumCapabilities</a>.
--   
--   GHC note: the number of capabilities is specified by the <tt>+RTS
--   -N</tt> option when the program is started. Capabilities can be fixed
--   to actual processor cores with <tt>+RTS -qa</tt> if the underlying
--   operating system supports that, although in practice this is usually
--   unnecessary (and may actually degrade performance in some cases -
--   experimentation is recommended).
forkOn :: Int -> IO () -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is pinned to the
--   given CPU, as with <a>forkOn</a>.
forkOnWithUnmask :: Int -> ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | the value passed to the <tt>+RTS -N</tt> flag. This is the number of
--   Haskell threads that can run truly simultaneously at any given time,
--   and is typically set to the number of physical processor cores on the
--   machine.
--   
--   Strictly speaking it is better to use <a>getNumCapabilities</a>,
--   because the number of capabilities might vary at runtime.
numCapabilities :: Int

-- | Returns the number of Haskell threads that can run truly
--   simultaneously (on separate physical processors) at any given time. To
--   change this value, use <a>setNumCapabilities</a>.
getNumCapabilities :: IO Int

-- | Set the number of Haskell threads that can run truly simultaneously
--   (on separate physical processors) at any given time. The number passed
--   to <a>forkOn</a> is interpreted modulo this value. The initial value
--   is given by the <tt>+RTS -N</tt> runtime flag.
--   
--   This is also the number of threads that will participate in parallel
--   garbage collection. It is strongly recommended that the number of
--   capabilities is not set larger than the number of physical processor
--   cores, and it may often be beneficial to leave one or more cores free
--   to avoid contention with other processes in the machine.
setNumCapabilities :: Int -> IO ()

-- | Returns the number of CPUs that the machine has
getNumProcessors :: IO Int

-- | Returns the number of sparks currently in the local spark pool
numSparks :: IO Int
childHandler :: SomeException -> IO ()

-- | Returns the <a>ThreadId</a> of the calling thread (GHC only).
myThreadId :: IO ThreadId

-- | <a>killThread</a> raises the <a>ThreadKilled</a> exception in the
--   given thread (GHC only).
--   
--   <pre>
--   killThread tid = throwTo tid ThreadKilled
--   </pre>
killThread :: ThreadId -> IO ()

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()
par :: a -> b -> b
infixr 0 `par`
pseq :: a -> b -> b
infixr 0 `pseq`

-- | Internal function used by the RTS to run sparks.
runSparks :: IO ()

-- | The <a>yield</a> action allows (forces, in a co-operative multitasking
--   implementation) a context-switch to any other currently runnable
--   threads (if any), and is occasionally useful when implementing
--   concurrency abstractions.
yield :: IO ()

-- | <a>labelThread</a> stores a string as identifier for this thread if
--   you built a RTS with debugging support. This identifier will be used
--   in the debugging output to make distinction of different threads
--   easier (otherwise you only have the thread state object's address in
--   the heap).
--   
--   Other applications like the graphical Concurrent Haskell Debugger
--   (<a>http://www.informatik.uni-kiel.de/~fhu/chd/</a>) may choose to
--   overload <a>labelThread</a> for their purposes as well.
labelThread :: ThreadId -> String -> IO ()

-- | Make a weak pointer to a <a>ThreadId</a>. It can be important to do
--   this if you want to hold a reference to a <a>ThreadId</a> while still
--   allowing the thread to receive the <tt>BlockedIndefinitely</tt> family
--   of exceptions (e.g. <a>BlockedIndefinitelyOnMVar</a>). Holding a
--   normal <a>ThreadId</a> reference will prevent the delivery of
--   <tt>BlockedIndefinitely</tt> exceptions because the reference could be
--   used as the target of <a>throwTo</a> at any time, which would unblock
--   the thread.
--   
--   Holding a <tt>Weak ThreadId</tt>, on the other hand, will not prevent
--   the thread from receiving <tt>BlockedIndefinitely</tt> exceptions. It
--   is still possible to throw an exception to a <tt>Weak ThreadId</tt>,
--   but the caller must use <tt>deRefWeak</tt> first to determine whether
--   the thread still exists.
mkWeakThreadId :: ThreadId -> IO (Weak ThreadId)

-- | The current status of a thread
data ThreadStatus

-- | the thread is currently runnable or running
ThreadRunning :: ThreadStatus

-- | the thread has finished
ThreadFinished :: ThreadStatus

-- | the thread is blocked on some resource
ThreadBlocked :: BlockReason -> ThreadStatus

-- | the thread received an uncaught exception
ThreadDied :: ThreadStatus
data BlockReason

-- | blocked on <a>MVar</a>
BlockedOnMVar :: BlockReason

-- | blocked on a computation in progress by another thread
BlockedOnBlackHole :: BlockReason

-- | blocked in <a>throwTo</a>
BlockedOnException :: BlockReason

-- | blocked in <a>retry</a> in an STM transaction
BlockedOnSTM :: BlockReason

-- | currently in a foreign call
BlockedOnForeignCall :: BlockReason

-- | blocked on some other resource. Without <tt>-threaded</tt>, I/O and
--   <tt>threadDelay</tt> show up as <a>BlockedOnOther</a>, with
--   <tt>-threaded</tt> they show up as <a>BlockedOnMVar</a>.
BlockedOnOther :: BlockReason
threadStatus :: ThreadId -> IO ThreadStatus

-- | Returns the number of the capability on which the thread is currently
--   running, and a boolean indicating whether the thread is locked to that
--   capability or not. A thread is locked to a capability if it was
--   created with <tt>forkOn</tt>.
threadCapability :: ThreadId -> IO (Int, Bool)

-- | Make a StablePtr that can be passed to the C function
--   <tt>hs_try_putmvar()</tt>. The RTS wants a <a>StablePtr</a> to the
--   underlying <a>MVar#</a>, but a <a>StablePtr#</a> can only refer to
--   lifted types, so we have to cheat by coercing.
newStablePtrPrimMVar :: MVar () -> IO (StablePtr PrimMVar)
data PrimMVar

-- | Every thread has an allocation counter that tracks how much memory has
--   been allocated by the thread. The counter is initialized to zero, and
--   <a>setAllocationCounter</a> sets the current value. The allocation
--   counter counts *down*, so in the absence of a call to
--   <a>setAllocationCounter</a> its value is the negation of the number of
--   bytes of memory allocated by the thread.
--   
--   There are two things that you can do with this counter:
--   
--   <ul>
--   <li>Use it as a simple profiling mechanism, with
--   <a>getAllocationCounter</a>.</li>
--   <li>Use it as a resource limit. See <a>enableAllocationLimit</a>.</li>
--   </ul>
--   
--   Allocation accounting is accurate only to about 4Kbytes.
setAllocationCounter :: Int64 -> IO ()

-- | Return the current value of the allocation counter for the current
--   thread.
getAllocationCounter :: IO Int64

-- | Enables the allocation counter to be treated as a limit for the
--   current thread. When the allocation limit is enabled, if the
--   allocation counter counts down below zero, the thread will be sent the
--   <a>AllocationLimitExceeded</a> asynchronous exception. When this
--   happens, the counter is reinitialised (by default to 100K, but tunable
--   with the <tt>+RTS -xq</tt> option) so that it can handle the exception
--   and perform any necessary clean up. If it exhausts this additional
--   allowance, another <a>AllocationLimitExceeded</a> exception is sent,
--   and so forth. Like other asynchronous exceptions, the
--   <a>AllocationLimitExceeded</a> exception is deferred while the thread
--   is inside <a>mask</a> or an exception handler in <a>catch</a>.
--   
--   Note that memory allocation is unrelated to <i>live memory</i>, also
--   known as <i>heap residency</i>. A thread can allocate a large amount
--   of memory and retain anything between none and all of it. It is better
--   to think of the allocation limit as a limit on <i>CPU time</i>, rather
--   than a limit on memory.
--   
--   Compared to using timeouts, allocation limits don't count time spent
--   blocked or in foreign calls.
enableAllocationLimit :: IO ()

-- | Disable allocation limit processing for the current thread.
disableAllocationLimit :: IO ()

-- | A monad supporting atomic memory transactions.
newtype STM a
STM :: (State# RealWorld -> (# State# RealWorld, a #)) -> STM a

-- | Perform a series of STM actions atomically.
--   
--   Using <a>atomically</a> inside an <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a> subverts some of guarantees that STM
--   provides. It makes it possible to run a transaction inside of another
--   transaction, depending on when the thunk is evaluated. If a nested
--   transaction is attempted, an exception is thrown by the runtime. It is
--   possible to safely use <a>atomically</a> inside <a>unsafePerformIO</a>
--   or <a>unsafeInterleaveIO</a>, but the typechecker does not rule out
--   programs that may attempt nested transactions, meaning that the
--   programmer must take special care to prevent these.
--   
--   However, there are functions for creating transactional variables that
--   can always be safely called in <a>unsafePerformIO</a>. See:
--   <a>newTVarIO</a>, <tt>newTChanIO</tt>, <tt>newBroadcastTChanIO</tt>,
--   <tt>newTQueueIO</tt>, <tt>newTBQueueIO</tt>, and <tt>newTMVarIO</tt>.
--   
--   Using <a>unsafePerformIO</a> inside of <a>atomically</a> is also
--   dangerous but for different reasons. See <a>unsafeIOToSTM</a> for more
--   on this.
atomically :: STM a -> IO a

-- | Retry execution of the current memory transaction because it has seen
--   values in <a>TVar</a>s which mean that it should not continue (e.g.
--   the <a>TVar</a>s represent a shared buffer that is now empty). The
--   implementation may block the thread until one of the <a>TVar</a>s that
--   it has read from has been updated. (GHC only)
retry :: STM a

-- | Compose two alternative STM actions (GHC only).
--   
--   If the first action completes without retrying then it forms the
--   result of the <a>orElse</a>. Otherwise, if the first action retries,
--   then the second action is tried in its place. If both actions retry
--   then the <a>orElse</a> as a whole retries.
orElse :: STM a -> STM a -> STM a

-- | A variant of <a>throw</a> that can only be used within the <a>STM</a>
--   monad.
--   
--   Throwing an exception in <tt>STM</tt> aborts the transaction and
--   propagates the exception.
--   
--   Although <a>throwSTM</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e    `seq` x  ===&gt; throw e
--   throwSTM e `seq` x  ===&gt; x
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwSTM</a> will only cause
--   an exception to be raised when it is used within the <a>STM</a> monad.
--   The <a>throwSTM</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>STM</a> monad because
--   it guarantees ordering with respect to other <a>STM</a> operations,
--   whereas <a>throw</a> does not.
throwSTM :: Exception e => e -> STM a

-- | Exception handling within STM actions.
catchSTM :: Exception e => STM a -> (e -> STM a) -> STM a

-- | Shared memory locations that support atomic memory transactions.
data TVar a
TVar :: TVar# RealWorld a -> TVar a

-- | Create a new <a>TVar</a> holding a value supplied
newTVar :: a -> STM (TVar a)

-- | <tt>IO</tt> version of <a>newTVar</a>. This is useful for creating
--   top-level <a>TVar</a>s using <a>unsafePerformIO</a>, because using
--   <a>atomically</a> inside <a>unsafePerformIO</a> isn't possible.
newTVarIO :: a -> IO (TVar a)

-- | Return the current value stored in a <a>TVar</a>.
readTVar :: TVar a -> STM a

-- | Return the current value stored in a <a>TVar</a>. This is equivalent
--   to
--   
--   <pre>
--   readTVarIO = atomically . readTVar
--   </pre>
--   
--   but works much faster, because it doesn't perform a complete
--   transaction, it just reads the current value of the <a>TVar</a>.
readTVarIO :: TVar a -> IO a

-- | Write the supplied value into a <a>TVar</a>.
writeTVar :: TVar a -> a -> STM ()

-- | Unsafely performs IO in the STM monad. Beware: this is a highly
--   dangerous thing to do.
--   
--   <ul>
--   <li>The STM implementation will often run transactions multiple times,
--   so you need to be prepared for this if your IO has any side
--   effects.</li>
--   <li>The STM implementation will abort transactions that are known to
--   be invalid and need to be restarted. This may happen in the middle of
--   <a>unsafeIOToSTM</a>, so make sure you don't acquire any resources
--   that need releasing (exception handlers are ignored when aborting the
--   transaction). That includes doing any IO using Handles, for example.
--   Getting this wrong will probably lead to random deadlocks.</li>
--   <li>The transaction may have seen an inconsistent view of memory when
--   the IO runs. Invariants that you expect to be true throughout your
--   program may not be true inside a transaction, due to the way
--   transactions are implemented. Normally this wouldn't be visible to the
--   programmer, but using <a>unsafeIOToSTM</a> can expose it.</li>
--   </ul>
unsafeIOToSTM :: IO a -> STM a

-- | Provide an <a>IO</a> action with the current value of an <a>MVar</a>.
--   The <a>MVar</a> will be empty for the duration that the action is
--   running.
withMVar :: MVar a -> (a -> IO b) -> IO b

-- | Modify the value of an <a>MVar</a>.
modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
setUncaughtExceptionHandler :: (SomeException -> IO ()) -> IO ()
getUncaughtExceptionHandler :: IO (SomeException -> IO ())
reportError :: SomeException -> IO ()
reportStackOverflow :: IO ()
reportHeapOverflow :: IO ()
sharedCAF :: a -> (Ptr a -> IO (Ptr a)) -> IO a
instance GHC.Show.Show GHC.Conc.Sync.ThreadStatus
instance GHC.Classes.Ord GHC.Conc.Sync.ThreadStatus
instance GHC.Classes.Eq GHC.Conc.Sync.ThreadStatus
instance GHC.Show.Show GHC.Conc.Sync.BlockReason
instance GHC.Classes.Ord GHC.Conc.Sync.BlockReason
instance GHC.Classes.Eq GHC.Conc.Sync.BlockReason
instance GHC.Classes.Eq (GHC.Conc.Sync.TVar a)
instance GHC.Base.Functor GHC.Conc.Sync.STM
instance GHC.Base.Applicative GHC.Conc.Sync.STM
instance GHC.Base.Monad GHC.Conc.Sync.STM
instance GHC.Base.Alternative GHC.Conc.Sync.STM
instance GHC.Base.MonadPlus GHC.Conc.Sync.STM
instance GHC.Show.Show GHC.Conc.Sync.ThreadId
instance GHC.Classes.Eq GHC.Conc.Sync.ThreadId
instance GHC.Classes.Ord GHC.Conc.Sync.ThreadId


-- | Extensible exceptions, except for multiple handlers.
module Control.Exception.Base

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data IOException

-- | Arithmetic exceptions.
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException

RatioZeroDenominator :: ArithException

-- | Exceptions generated by array operations
data ArrayException

-- | An attempt was made to index an array outside its declared bounds.
IndexOutOfBounds :: String -> ArrayException

-- | An attempt was made to evaluate an element of an array that had not
--   been initialized.
UndefinedElement :: String -> ArrayException

-- | <a>assert</a> was applied to <a>False</a>.
newtype AssertionFailed
AssertionFailed :: String -> AssertionFailed

-- | Superclass for asynchronous exceptions.
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException

-- | Asynchronous exceptions.
data AsyncException

-- | The current thread's stack exceeded its limit. Since an exception has
--   been raised, the thread's stack will certainly be below its limit
--   again, but the programmer should take remedial action immediately.
StackOverflow :: AsyncException

-- | The program's heap is reaching its limit, and the program should take
--   action to reduce the amount of live data it has. Notes:
--   
--   <ul>
--   <li>It is undefined which thread receives this exception. GHC
--   currently throws this to the same thread that receives
--   <a>UserInterrupt</a>, but this may change in the future.</li>
--   <li>The GHC RTS currently can only recover from heap overflow if it
--   detects that an explicit memory limit (set via RTS flags). has been
--   exceeded. Currently, failure to allocate memory from the operating
--   system results in immediate termination of the program.</li>
--   </ul>
HeapOverflow :: AsyncException

-- | This exception is raised by another thread calling <a>killThread</a>,
--   or by the system if it needs to terminate the thread for some reason.
ThreadKilled :: AsyncException

-- | This exception is raised by default in the main thread of the program
--   when the user requests to terminate the program via the usual
--   mechanism(s) (e.g. Control-C in the console).
UserInterrupt :: AsyncException

asyncExceptionToException :: Exception e => e -> SomeException

asyncExceptionFromException :: Exception e => SomeException -> Maybe e

-- | Thrown when the runtime system detects that the computation is
--   guaranteed not to terminate. Note that there is no guarantee that the
--   runtime system will notice whether any given computation is guaranteed
--   to terminate or not.
data NonTermination
NonTermination :: NonTermination

-- | Thrown when the program attempts to call <tt>atomically</tt>, from the
--   <tt>stm</tt> package, inside another call to <tt>atomically</tt>.
data NestedAtomically
NestedAtomically :: NestedAtomically

-- | The thread is blocked on an <tt>MVar</tt>, but there are no other
--   references to the <tt>MVar</tt> so it can't ever continue.
data BlockedIndefinitelyOnMVar
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar

-- | The exception thrown when an infinite cycle is detected in
--   <tt>fixIO</tt>.
data FixIOException
FixIOException :: FixIOException

-- | The thread is waiting to retry an STM transaction, but there are no
--   other references to any <tt>TVar</tt>s involved, so it can't ever
--   continue.
data BlockedIndefinitelyOnSTM
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM

-- | This thread has exceeded its allocation limit. See
--   <a>setAllocationCounter</a> and <a>enableAllocationLimit</a>.
data AllocationLimitExceeded
AllocationLimitExceeded :: AllocationLimitExceeded

-- | Compaction found an object that cannot be compacted. Functions cannot
--   be compacted, nor can mutable objects or pinned objects. See
--   <a>compact</a>.
newtype CompactionFailed
CompactionFailed :: String -> CompactionFailed

-- | There are no runnable threads, so the program is deadlocked. The
--   <tt>Deadlock</tt> exception is raised in the main thread only.
data Deadlock
Deadlock :: Deadlock

-- | A class method without a definition (neither a default definition, nor
--   a definition in the appropriate instance) was called. The
--   <tt>String</tt> gives information about which method it was.
newtype NoMethodError
NoMethodError :: String -> NoMethodError

-- | A pattern match failed. The <tt>String</tt> gives information about
--   the source location of the pattern.
newtype PatternMatchFail
PatternMatchFail :: String -> PatternMatchFail

-- | An uninitialised record field was used. The <tt>String</tt> gives
--   information about the source location where the record was
--   constructed.
newtype RecConError
RecConError :: String -> RecConError

-- | A record selector was applied to a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record selector.
newtype RecSelError
RecSelError :: String -> RecSelError

-- | A record update was performed on a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record update.
newtype RecUpdError
RecUpdError :: String -> RecUpdError

-- | This is thrown when the user calls <a>error</a>. The first
--   <tt>String</tt> is the argument given to <a>error</a>, second
--   <tt>String</tt> is the location.
data ErrorCall
ErrorCallWithLocation :: String -> String -> ErrorCall
pattern ErrorCall :: String -> ErrorCall

-- | An expression that didn't typecheck during compile time was called.
--   This is only possible with -fdefer-type-errors. The <tt>String</tt>
--   gives details about the failed type check.
newtype TypeError
TypeError :: String -> TypeError

-- | A variant of <a>throw</a> that can only be used within the <a>IO</a>
--   monad.
--   
--   Although <a>throwIO</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e   `seq` x  ===&gt; throw e
--   throwIO e `seq` x  ===&gt; x
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwIO</a> will only cause
--   an exception to be raised when it is used within the <a>IO</a> monad.
--   The <a>throwIO</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>IO</a> monad because
--   it guarantees ordering with respect to other <a>IO</a> operations,
--   whereas <a>throw</a> does not.
throwIO :: Exception e => e -> IO a

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
throw :: forall (r :: RuntimeRep). forall (a :: TYPE r). forall e. Exception e => e -> a

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | This is the simplest of the exception-catching functions. It takes a
--   single argument, runs it, and if an exception is raised the "handler"
--   is executed, with the value of the exception passed as an argument.
--   Otherwise, the result is returned as normal. For example:
--   
--   <pre>
--   catch (readFile f)
--         (\e -&gt; do let err = show (e :: IOException)
--                   hPutStr stderr ("Warning: Couldn't open " ++ f ++ ": " ++ err)
--                   return "")
--   </pre>
--   
--   Note that we have to give a type signature to <tt>e</tt>, or the
--   program will not typecheck as the type is ambiguous. While it is
--   possible to catch exceptions of any type, see the section "Catching
--   all exceptions" (in <a>Control.Exception</a>) for an explanation of
--   the problems with doing so.
--   
--   For catching exceptions in pure (non-<a>IO</a>) expressions, see the
--   function <a>evaluate</a>.
--   
--   Note that due to Haskell's unspecified evaluation order, an expression
--   may throw one of several possible exceptions: consider the expression
--   <tt>(error "urk") + (1 `div` 0)</tt>. Does the expression throw
--   <tt>ErrorCall "urk"</tt>, or <tt>DivideByZero</tt>?
--   
--   The answer is "it might throw either"; the choice is
--   non-deterministic. If you are catching any type of exception then you
--   might catch either. If you are calling <tt>catch</tt> with type <tt>IO
--   Int -&gt; (ArithException -&gt; IO Int) -&gt; IO Int</tt> then the
--   handler may get run with <tt>DivideByZero</tt> as an argument, or an
--   <tt>ErrorCall "urk"</tt> exception may be propogated further up. If
--   you call it again, you might get a the opposite behaviour. This is ok,
--   because <a>catch</a> is an <a>IO</a> computation.
catch :: Exception e => IO a -> (e -> IO a) -> IO a

-- | The function <a>catchJust</a> is like <a>catch</a>, but it takes an
--   extra argument which is an <i>exception predicate</i>, a function
--   which selects which type of exceptions we're interested in.
--   
--   <pre>
--   catchJust (\e -&gt; if isDoesNotExistErrorType (ioeGetErrorType e) then Just () else Nothing)
--             (readFile f)
--             (\_ -&gt; do hPutStrLn stderr ("No such file: " ++ show f)
--                       return "")
--   </pre>
--   
--   Any other exceptions which are not matched by the predicate are
--   re-raised, and may be caught by an enclosing <a>catch</a>,
--   <a>catchJust</a>, etc.
catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a

-- | A version of <a>catch</a> with the arguments swapped around; useful in
--   situations where the code for the handler is shorter. For example:
--   
--   <pre>
--   do handle (\NonTermination -&gt; exitWith (ExitFailure 1)) $
--      ...
--   </pre>
handle :: Exception e => (e -> IO a) -> IO a -> IO a

-- | A version of <a>catchJust</a> with the arguments swapped around (see
--   <a>handle</a>).
handleJust :: Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception of type <tt>e</tt> was
--   raised, or <tt>(<a>Left</a> ex)</tt> if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised than it will be propogated up to the next
--   enclosing exception handler.
--   
--   <pre>
--   try a = catch (Right `liftM` a) (return . Left)
--   </pre>
try :: Exception e => IO a -> IO (Either e a)

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught (c.f. <a>catchJust</a>). If the exception
--   does not match the predicate, it is re-thrown.
tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)

-- | Like <a>finally</a>, but only performs the final action if there was
--   an exception raised by the computation.
onException :: IO a -> IO b -> IO a

-- | Evaluate the argument to weak head normal form.
--   
--   <a>evaluate</a> is typically used to uncover any exceptions that a
--   lazy value may contain, and possibly handle them.
--   
--   <a>evaluate</a> only evaluates to <i>weak head normal form</i>. If
--   deeper evaluation is needed, the <tt>force</tt> function from
--   <tt>Control.DeepSeq</tt> may be handy:
--   
--   <pre>
--   evaluate $ force x
--   </pre>
--   
--   There is a subtle difference between <tt><a>evaluate</a> x</tt> and
--   <tt><a>return</a> <a>$!</a> x</tt>, analogous to the difference
--   between <a>throwIO</a> and <a>throw</a>. If the lazy value <tt>x</tt>
--   throws an exception, <tt><a>return</a> <a>$!</a> x</tt> will fail to
--   return an <a>IO</a> action and will throw an exception instead.
--   <tt><a>evaluate</a> x</tt>, on the other hand, always produces an
--   <a>IO</a> action; that action will throw an exception upon
--   <i>execution</i> iff <tt>x</tt> throws an exception upon
--   <i>evaluation</i>.
--   
--   The practical implication of this difference is that due to the
--   <i>imprecise exceptions</i> semantics,
--   
--   <pre>
--   (return $! error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   may throw either <tt>"foo"</tt> or <tt>"bar"</tt>, depending on the
--   optimizations performed by the compiler. On the other hand,
--   
--   <pre>
--   evaluate (error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   is guaranteed to throw <tt>"foo"</tt>.
--   
--   The rule of thumb is to use <a>evaluate</a> to force or handle
--   exceptions in lazy values. If, on the other hand, you are forcing a
--   lazy value for efficiency reasons only and do not care about
--   exceptions, you may use <tt><a>return</a> <a>$!</a> x</tt>.
evaluate :: a -> IO a

-- | This function maps one exception into another as proposed in the paper
--   "A semantics for imprecise exceptions".
mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a

-- | Executes an IO computation with asynchronous exceptions <i>masked</i>.
--   That is, any thread which attempts to raise an exception in the
--   current thread with <a>throwTo</a> will be blocked until asynchronous
--   exceptions are unmasked again.
--   
--   The argument passed to <a>mask</a> is a function that takes as its
--   argument another function, which can be used to restore the prevailing
--   masking state within the context of the masked computation. For
--   example, a common way to use <a>mask</a> is to protect the acquisition
--   of a resource:
--   
--   <pre>
--   mask $ \restore -&gt; do
--       x &lt;- acquire
--       restore (do_something_with x) `onException` release
--       release
--   </pre>
--   
--   This code guarantees that <tt>acquire</tt> is paired with
--   <tt>release</tt>, by masking asynchronous exceptions for the critical
--   parts. (Rather than write this code yourself, it would be better to
--   use <a>bracket</a> which abstracts the general pattern).
--   
--   Note that the <tt>restore</tt> action passed to the argument to
--   <a>mask</a> does not necessarily unmask asynchronous exceptions, it
--   just restores the masking state to that of the enclosing context. Thus
--   if asynchronous exceptions are already masked, <a>mask</a> cannot be
--   used to unmask exceptions again. This is so that if you call a library
--   function with exceptions masked, you can be sure that the library call
--   will not be able to unmask exceptions again. If you are writing
--   library code and need to use asynchronous exceptions, the only way is
--   to create a new thread; see <a>forkIOWithUnmask</a>.
--   
--   Asynchronous exceptions may still be received while in the masked
--   state if the masked thread <i>blocks</i> in certain ways; see
--   <a>Control.Exception#interruptible</a>.
--   
--   Threads created by <a>forkIO</a> inherit the <a>MaskingState</a> from
--   the parent; that is, to start a thread in the
--   <a>MaskedInterruptible</a> state, use <tt>mask_ $ forkIO ...</tt>.
--   This is particularly useful if you need to establish an exception
--   handler in the forked thread before any asynchronous exceptions are
--   received. To create a new thread in an unmasked state use
--   <a>forkIOWithUnmask</a>.
mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: IO a -> IO a

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception#interruptible</a>). THIS SHOULD BE USED WITH
--   GREAT CARE, because if a thread executing in
--   <a>uninterruptibleMask</a> blocks for any reason, then the thread (and
--   possibly the program, if this is the main thread) will be unresponsive
--   and unkillable. This function should only be necessary if you need to
--   mask exceptions around an interruptible operation, and you can
--   guarantee that the interruptible operation will only block for a short
--   period of time.
uninterruptibleMask :: ((forall a. IO a -> IO a) -> IO b) -> IO b

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: IO a -> IO a

-- | Describes the behaviour of a thread when an asynchronous exception is
--   received.
data MaskingState

-- | asynchronous exceptions are unmasked (the normal state)
Unmasked :: MaskingState

-- | the state during <a>mask</a>: asynchronous exceptions are masked, but
--   blocking operations may still be interrupted
MaskedInterruptible :: MaskingState

-- | the state during <a>uninterruptibleMask</a>: asynchronous exceptions
--   are masked, and blocking operations may not be interrupted
MaskedUninterruptible :: MaskingState

-- | Returns the <a>MaskingState</a> for the current thread.
getMaskingState :: IO MaskingState

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <tt>AssertionFailed</tt> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a

-- | When you want to acquire a resource, do some work with it, and then
--   release the resource, it is a good idea to use <a>bracket</a>, because
--   <a>bracket</a> will install the necessary exception handler to release
--   the resource in the event that an exception is raised during the
--   computation. If an exception is raised, then <a>bracket</a> will
--   re-raise the exception (after performing the release).
--   
--   A common example is opening a file:
--   
--   <pre>
--   bracket
--     (openFile "filename" ReadMode)
--     (hClose)
--     (\fileHandle -&gt; do { ... })
--   </pre>
--   
--   The arguments to <a>bracket</a> are in this order so that we can
--   partially apply it, e.g.:
--   
--   <pre>
--   withFile name mode = bracket (openFile name mode) hClose
--   </pre>
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A variant of <a>bracket</a> where the return value from the first
--   computation is not required.
bracket_ :: IO a -> IO b -> IO c -> IO c

-- | Like <a>bracket</a>, but only performs the final action if there was
--   an exception raised by the in-between computation.
bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A specialised variant of <a>bracket</a> with just a computation to run
--   afterward.
finally :: IO a -> IO b -> IO a
recSelError :: Addr# -> a
recConError :: Addr# -> a
runtimeError :: Addr# -> a
nonExhaustiveGuardsError :: Addr# -> a
patError :: Addr# -> a
noMethodBindingError :: Addr# -> a
absentError :: Addr# -> a
absentSumFieldError :: a
typeError :: Addr# -> a
nonTermination :: SomeException
nestedAtomically :: SomeException
instance GHC.Show.Show Control.Exception.Base.NestedAtomically
instance GHC.Exception.Type.Exception Control.Exception.Base.NestedAtomically
instance GHC.Show.Show Control.Exception.Base.NonTermination
instance GHC.Exception.Type.Exception Control.Exception.Base.NonTermination
instance GHC.Show.Show Control.Exception.Base.TypeError
instance GHC.Exception.Type.Exception Control.Exception.Base.TypeError
instance GHC.Show.Show Control.Exception.Base.NoMethodError
instance GHC.Exception.Type.Exception Control.Exception.Base.NoMethodError
instance GHC.Show.Show Control.Exception.Base.RecUpdError
instance GHC.Exception.Type.Exception Control.Exception.Base.RecUpdError
instance GHC.Show.Show Control.Exception.Base.RecConError
instance GHC.Exception.Type.Exception Control.Exception.Base.RecConError
instance GHC.Show.Show Control.Exception.Base.RecSelError
instance GHC.Exception.Type.Exception Control.Exception.Base.RecSelError
instance GHC.Show.Show Control.Exception.Base.PatternMatchFail
instance GHC.Exception.Type.Exception Control.Exception.Base.PatternMatchFail


-- | Standard IO Errors.
module System.IO.Error

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOException</a> instead of returning a
--   result. For a more general type of exception, including also those
--   that arise in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | Construct an <a>IOException</a> value with a string describing the
--   error. The <a>fail</a> method of the <a>IO</a> instance of the
--   <a>Monad</a> class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | Construct an <a>IOException</a> of the given type where the second
--   argument describes the error location and the third and fourth
--   argument contain the file handle and file path of the file involved in
--   the error if applicable.
mkIOError :: IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError

-- | Adds a location description and maybe a file path and file handle to
--   an <a>IOException</a>. If any of the file handle or file path is not
--   given the corresponding value in the <a>IOException</a> remains
--   unaltered.
annotateIOError :: IOError -> String -> Maybe Handle -> Maybe FilePath -> IOError

-- | An error indicating that an <a>IO</a> operation failed because one of
--   its arguments already exists.
isAlreadyExistsError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because one of
--   its arguments does not exist.
isDoesNotExistError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because one of
--   its arguments is a single-use resource, which is already being used
--   (for example, opening the same file twice for writing might give this
--   error).
isAlreadyInUseError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the
--   device is full.
isFullError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the end
--   of file has been reached.
isEOFError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the
--   operation was not possible. Any computation which returns an <a>IO</a>
--   result may fail with <a>isIllegalOperation</a>. In some cases, an
--   implementation will not be able to distinguish between the possible
--   error causes. In this case it should fail with
--   <a>isIllegalOperation</a>.
isIllegalOperation :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the
--   user does not have sufficient operating system privilege to perform
--   that operation.
isPermissionError :: IOError -> Bool

-- | A programmer-defined error value constructed using <a>userError</a>.
isUserError :: IOError -> Bool
ioeGetErrorType :: IOError -> IOErrorType
ioeGetLocation :: IOError -> String
ioeGetErrorString :: IOError -> String
ioeGetHandle :: IOError -> Maybe Handle
ioeGetFileName :: IOError -> Maybe FilePath
ioeSetErrorType :: IOError -> IOErrorType -> IOError
ioeSetErrorString :: IOError -> String -> IOError
ioeSetLocation :: IOError -> String -> IOError
ioeSetHandle :: IOError -> Handle -> IOError
ioeSetFileName :: IOError -> FilePath -> IOError

-- | An abstract type that contains a value for each variant of
--   <a>IOException</a>.
data IOErrorType

-- | I/O error where the operation failed because one of its arguments
--   already exists.
alreadyExistsErrorType :: IOErrorType

-- | I/O error where the operation failed because one of its arguments does
--   not exist.
doesNotExistErrorType :: IOErrorType

-- | I/O error where the operation failed because one of its arguments is a
--   single-use resource, which is already being used.
alreadyInUseErrorType :: IOErrorType

-- | I/O error where the operation failed because the device is full.
fullErrorType :: IOErrorType

-- | I/O error where the operation failed because the end of file has been
--   reached.
eofErrorType :: IOErrorType

-- | I/O error where the operation is not possible.
illegalOperationErrorType :: IOErrorType

-- | I/O error where the operation failed because the user does not have
--   sufficient operating system privilege to perform that operation.
permissionErrorType :: IOErrorType

-- | I/O error that is programmer-defined.
userErrorType :: IOErrorType

-- | I/O error where the operation failed because one of its arguments
--   already exists.
isAlreadyExistsErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because one of its arguments does
--   not exist.
isDoesNotExistErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because one of its arguments is a
--   single-use resource, which is already being used.
isAlreadyInUseErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because the device is full.
isFullErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because the end of file has been
--   reached.
isEOFErrorType :: IOErrorType -> Bool

-- | I/O error where the operation is not possible.
isIllegalOperationErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because the user does not have
--   sufficient operating system privilege to perform that operation.
isPermissionErrorType :: IOErrorType -> Bool

-- | I/O error that is programmer-defined.
isUserErrorType :: IOErrorType -> Bool

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | The <a>catchIOError</a> function establishes a handler that receives
--   any <a>IOException</a> raised in the action protected by
--   <a>catchIOError</a>. An <a>IOException</a> is caught by the most
--   recent handler established by one of the exception handling functions.
--   These handlers are not selective: all <a>IOException</a>s are caught.
--   Exception propagation must be explicitly provided in a handler by
--   re-raising any unwanted exceptions. For example, in
--   
--   <pre>
--   f = catchIOError g (\e -&gt; if IO.isEOFError e then return [] else ioError e)
--   </pre>
--   
--   the function <tt>f</tt> returns <tt>[]</tt> when an end-of-file
--   exception (cf. <a>isEOFError</a>) occurs in <tt>g</tt>; otherwise, the
--   exception is propagated to the next outer handler.
--   
--   When an exception propagates outside the main program, the Haskell
--   system prints the associated <a>IOException</a> value and exits the
--   program.
--   
--   Non-I/O exceptions are not caught by this variant; to catch all
--   exceptions, use <a>catch</a> from <a>Control.Exception</a>.
catchIOError :: IO a -> (IOError -> IO a) -> IO a

-- | The construct <a>tryIOError</a> <tt>comp</tt> exposes IO errors which
--   occur within a computation, and which are not fully handled.
--   
--   Non-I/O exceptions are not caught by this variant; to catch all
--   exceptions, use <a>try</a> from <a>Control.Exception</a>.
tryIOError :: IO a -> IO (Either IOError a)

-- | Catch any <a>IOException</a> that occurs in the computation and throw
--   a modified version.
modifyIOError :: (IOError -> IOError) -> IO a -> IO a


-- | This module provides support for raising and catching both built-in
--   and user-defined exceptions.
--   
--   In addition to exceptions thrown by <a>IO</a> operations, exceptions
--   may be thrown by pure code (imprecise exceptions) or by external
--   events (asynchronous exceptions), but may only be caught in the
--   <a>IO</a> monad. For more details, see:
--   
--   <ul>
--   <li><i>A semantics for imprecise exceptions</i>, by Simon Peyton
--   Jones, Alastair Reid, Tony Hoare, Simon Marlow, Fergus Henderson, in
--   <i>PLDI'99</i>.</li>
--   <li><i>Asynchronous exceptions in Haskell</i>, by Simon Marlow, Simon
--   Peyton Jones, Andy Moran and John Reppy, in <i>PLDI'01</i>.</li>
--   <li><i>An Extensible Dynamically-Typed Hierarchy of Exceptions</i>, by
--   Simon Marlow, in <i>Haskell '06</i>.</li>
--   </ul>
module Control.Exception

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data IOException

-- | Arithmetic exceptions.
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException

RatioZeroDenominator :: ArithException

-- | Exceptions generated by array operations
data ArrayException

-- | An attempt was made to index an array outside its declared bounds.
IndexOutOfBounds :: String -> ArrayException

-- | An attempt was made to evaluate an element of an array that had not
--   been initialized.
UndefinedElement :: String -> ArrayException

-- | <a>assert</a> was applied to <a>False</a>.
newtype AssertionFailed
AssertionFailed :: String -> AssertionFailed

-- | Superclass for asynchronous exceptions.
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException

-- | Asynchronous exceptions.
data AsyncException

-- | The current thread's stack exceeded its limit. Since an exception has
--   been raised, the thread's stack will certainly be below its limit
--   again, but the programmer should take remedial action immediately.
StackOverflow :: AsyncException

-- | The program's heap is reaching its limit, and the program should take
--   action to reduce the amount of live data it has. Notes:
--   
--   <ul>
--   <li>It is undefined which thread receives this exception. GHC
--   currently throws this to the same thread that receives
--   <a>UserInterrupt</a>, but this may change in the future.</li>
--   <li>The GHC RTS currently can only recover from heap overflow if it
--   detects that an explicit memory limit (set via RTS flags). has been
--   exceeded. Currently, failure to allocate memory from the operating
--   system results in immediate termination of the program.</li>
--   </ul>
HeapOverflow :: AsyncException

-- | This exception is raised by another thread calling <a>killThread</a>,
--   or by the system if it needs to terminate the thread for some reason.
ThreadKilled :: AsyncException

-- | This exception is raised by default in the main thread of the program
--   when the user requests to terminate the program via the usual
--   mechanism(s) (e.g. Control-C in the console).
UserInterrupt :: AsyncException

asyncExceptionToException :: Exception e => e -> SomeException

asyncExceptionFromException :: Exception e => SomeException -> Maybe e

-- | Thrown when the runtime system detects that the computation is
--   guaranteed not to terminate. Note that there is no guarantee that the
--   runtime system will notice whether any given computation is guaranteed
--   to terminate or not.
data NonTermination
NonTermination :: NonTermination

-- | Thrown when the program attempts to call <tt>atomically</tt>, from the
--   <tt>stm</tt> package, inside another call to <tt>atomically</tt>.
data NestedAtomically
NestedAtomically :: NestedAtomically

-- | The thread is blocked on an <tt>MVar</tt>, but there are no other
--   references to the <tt>MVar</tt> so it can't ever continue.
data BlockedIndefinitelyOnMVar
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar

-- | The thread is waiting to retry an STM transaction, but there are no
--   other references to any <tt>TVar</tt>s involved, so it can't ever
--   continue.
data BlockedIndefinitelyOnSTM
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM

-- | This thread has exceeded its allocation limit. See
--   <a>setAllocationCounter</a> and <a>enableAllocationLimit</a>.
data AllocationLimitExceeded
AllocationLimitExceeded :: AllocationLimitExceeded

-- | Compaction found an object that cannot be compacted. Functions cannot
--   be compacted, nor can mutable objects or pinned objects. See
--   <a>compact</a>.
newtype CompactionFailed
CompactionFailed :: String -> CompactionFailed

-- | There are no runnable threads, so the program is deadlocked. The
--   <tt>Deadlock</tt> exception is raised in the main thread only.
data Deadlock
Deadlock :: Deadlock

-- | A class method without a definition (neither a default definition, nor
--   a definition in the appropriate instance) was called. The
--   <tt>String</tt> gives information about which method it was.
newtype NoMethodError
NoMethodError :: String -> NoMethodError

-- | A pattern match failed. The <tt>String</tt> gives information about
--   the source location of the pattern.
newtype PatternMatchFail
PatternMatchFail :: String -> PatternMatchFail

-- | An uninitialised record field was used. The <tt>String</tt> gives
--   information about the source location where the record was
--   constructed.
newtype RecConError
RecConError :: String -> RecConError

-- | A record selector was applied to a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record selector.
newtype RecSelError
RecSelError :: String -> RecSelError

-- | A record update was performed on a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record update.
newtype RecUpdError
RecUpdError :: String -> RecUpdError

-- | This is thrown when the user calls <a>error</a>. The first
--   <tt>String</tt> is the argument given to <a>error</a>, second
--   <tt>String</tt> is the location.
data ErrorCall
ErrorCallWithLocation :: String -> String -> ErrorCall
pattern ErrorCall :: String -> ErrorCall

-- | An expression that didn't typecheck during compile time was called.
--   This is only possible with -fdefer-type-errors. The <tt>String</tt>
--   gives details about the failed type check.
newtype TypeError
TypeError :: String -> TypeError

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
throw :: forall (r :: RuntimeRep). forall (a :: TYPE r). forall e. Exception e => e -> a

-- | A variant of <a>throw</a> that can only be used within the <a>IO</a>
--   monad.
--   
--   Although <a>throwIO</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e   `seq` x  ===&gt; throw e
--   throwIO e `seq` x  ===&gt; x
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwIO</a> will only cause
--   an exception to be raised when it is used within the <a>IO</a> monad.
--   The <a>throwIO</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>IO</a> monad because
--   it guarantees ordering with respect to other <a>IO</a> operations,
--   whereas <a>throw</a> does not.
throwIO :: Exception e => e -> IO a

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | This is the simplest of the exception-catching functions. It takes a
--   single argument, runs it, and if an exception is raised the "handler"
--   is executed, with the value of the exception passed as an argument.
--   Otherwise, the result is returned as normal. For example:
--   
--   <pre>
--   catch (readFile f)
--         (\e -&gt; do let err = show (e :: IOException)
--                   hPutStr stderr ("Warning: Couldn't open " ++ f ++ ": " ++ err)
--                   return "")
--   </pre>
--   
--   Note that we have to give a type signature to <tt>e</tt>, or the
--   program will not typecheck as the type is ambiguous. While it is
--   possible to catch exceptions of any type, see the section "Catching
--   all exceptions" (in <a>Control.Exception</a>) for an explanation of
--   the problems with doing so.
--   
--   For catching exceptions in pure (non-<a>IO</a>) expressions, see the
--   function <a>evaluate</a>.
--   
--   Note that due to Haskell's unspecified evaluation order, an expression
--   may throw one of several possible exceptions: consider the expression
--   <tt>(error "urk") + (1 `div` 0)</tt>. Does the expression throw
--   <tt>ErrorCall "urk"</tt>, or <tt>DivideByZero</tt>?
--   
--   The answer is "it might throw either"; the choice is
--   non-deterministic. If you are catching any type of exception then you
--   might catch either. If you are calling <tt>catch</tt> with type <tt>IO
--   Int -&gt; (ArithException -&gt; IO Int) -&gt; IO Int</tt> then the
--   handler may get run with <tt>DivideByZero</tt> as an argument, or an
--   <tt>ErrorCall "urk"</tt> exception may be propogated further up. If
--   you call it again, you might get a the opposite behaviour. This is ok,
--   because <a>catch</a> is an <a>IO</a> computation.
catch :: Exception e => IO a -> (e -> IO a) -> IO a

-- | Sometimes you want to catch two different sorts of exception. You
--   could do something like
--   
--   <pre>
--   f = expr `catch` \ (ex :: ArithException) -&gt; handleArith ex
--            `catch` \ (ex :: IOException)    -&gt; handleIO    ex
--   </pre>
--   
--   However, there are a couple of problems with this approach. The first
--   is that having two exception handlers is inefficient. However, the
--   more serious issue is that the second exception handler will catch
--   exceptions in the first, e.g. in the example above, if
--   <tt>handleArith</tt> throws an <tt>IOException</tt> then the second
--   exception handler will catch it.
--   
--   Instead, we provide a function <a>catches</a>, which would be used
--   thus:
--   
--   <pre>
--   f = expr `catches` [Handler (\ (ex :: ArithException) -&gt; handleArith ex),
--                       Handler (\ (ex :: IOException)    -&gt; handleIO    ex)]
--   </pre>
catches :: IO a -> [Handler a] -> IO a

-- | You need this when using <a>catches</a>.
data Handler a
Handler :: (e -> IO a) -> Handler a

-- | The function <a>catchJust</a> is like <a>catch</a>, but it takes an
--   extra argument which is an <i>exception predicate</i>, a function
--   which selects which type of exceptions we're interested in.
--   
--   <pre>
--   catchJust (\e -&gt; if isDoesNotExistErrorType (ioeGetErrorType e) then Just () else Nothing)
--             (readFile f)
--             (\_ -&gt; do hPutStrLn stderr ("No such file: " ++ show f)
--                       return "")
--   </pre>
--   
--   Any other exceptions which are not matched by the predicate are
--   re-raised, and may be caught by an enclosing <a>catch</a>,
--   <a>catchJust</a>, etc.
catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a

-- | A version of <a>catch</a> with the arguments swapped around; useful in
--   situations where the code for the handler is shorter. For example:
--   
--   <pre>
--   do handle (\NonTermination -&gt; exitWith (ExitFailure 1)) $
--      ...
--   </pre>
handle :: Exception e => (e -> IO a) -> IO a -> IO a

-- | A version of <a>catchJust</a> with the arguments swapped around (see
--   <a>handle</a>).
handleJust :: Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception of type <tt>e</tt> was
--   raised, or <tt>(<a>Left</a> ex)</tt> if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised than it will be propogated up to the next
--   enclosing exception handler.
--   
--   <pre>
--   try a = catch (Right `liftM` a) (return . Left)
--   </pre>
try :: Exception e => IO a -> IO (Either e a)

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught (c.f. <a>catchJust</a>). If the exception
--   does not match the predicate, it is re-thrown.
tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)

-- | Evaluate the argument to weak head normal form.
--   
--   <a>evaluate</a> is typically used to uncover any exceptions that a
--   lazy value may contain, and possibly handle them.
--   
--   <a>evaluate</a> only evaluates to <i>weak head normal form</i>. If
--   deeper evaluation is needed, the <tt>force</tt> function from
--   <tt>Control.DeepSeq</tt> may be handy:
--   
--   <pre>
--   evaluate $ force x
--   </pre>
--   
--   There is a subtle difference between <tt><a>evaluate</a> x</tt> and
--   <tt><a>return</a> <a>$!</a> x</tt>, analogous to the difference
--   between <a>throwIO</a> and <a>throw</a>. If the lazy value <tt>x</tt>
--   throws an exception, <tt><a>return</a> <a>$!</a> x</tt> will fail to
--   return an <a>IO</a> action and will throw an exception instead.
--   <tt><a>evaluate</a> x</tt>, on the other hand, always produces an
--   <a>IO</a> action; that action will throw an exception upon
--   <i>execution</i> iff <tt>x</tt> throws an exception upon
--   <i>evaluation</i>.
--   
--   The practical implication of this difference is that due to the
--   <i>imprecise exceptions</i> semantics,
--   
--   <pre>
--   (return $! error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   may throw either <tt>"foo"</tt> or <tt>"bar"</tt>, depending on the
--   optimizations performed by the compiler. On the other hand,
--   
--   <pre>
--   evaluate (error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   is guaranteed to throw <tt>"foo"</tt>.
--   
--   The rule of thumb is to use <a>evaluate</a> to force or handle
--   exceptions in lazy values. If, on the other hand, you are forcing a
--   lazy value for efficiency reasons only and do not care about
--   exceptions, you may use <tt><a>return</a> <a>$!</a> x</tt>.
evaluate :: a -> IO a

-- | This function maps one exception into another as proposed in the paper
--   "A semantics for imprecise exceptions".
mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a

-- | Executes an IO computation with asynchronous exceptions <i>masked</i>.
--   That is, any thread which attempts to raise an exception in the
--   current thread with <a>throwTo</a> will be blocked until asynchronous
--   exceptions are unmasked again.
--   
--   The argument passed to <a>mask</a> is a function that takes as its
--   argument another function, which can be used to restore the prevailing
--   masking state within the context of the masked computation. For
--   example, a common way to use <a>mask</a> is to protect the acquisition
--   of a resource:
--   
--   <pre>
--   mask $ \restore -&gt; do
--       x &lt;- acquire
--       restore (do_something_with x) `onException` release
--       release
--   </pre>
--   
--   This code guarantees that <tt>acquire</tt> is paired with
--   <tt>release</tt>, by masking asynchronous exceptions for the critical
--   parts. (Rather than write this code yourself, it would be better to
--   use <a>bracket</a> which abstracts the general pattern).
--   
--   Note that the <tt>restore</tt> action passed to the argument to
--   <a>mask</a> does not necessarily unmask asynchronous exceptions, it
--   just restores the masking state to that of the enclosing context. Thus
--   if asynchronous exceptions are already masked, <a>mask</a> cannot be
--   used to unmask exceptions again. This is so that if you call a library
--   function with exceptions masked, you can be sure that the library call
--   will not be able to unmask exceptions again. If you are writing
--   library code and need to use asynchronous exceptions, the only way is
--   to create a new thread; see <a>forkIOWithUnmask</a>.
--   
--   Asynchronous exceptions may still be received while in the masked
--   state if the masked thread <i>blocks</i> in certain ways; see
--   <a>Control.Exception#interruptible</a>.
--   
--   Threads created by <a>forkIO</a> inherit the <a>MaskingState</a> from
--   the parent; that is, to start a thread in the
--   <a>MaskedInterruptible</a> state, use <tt>mask_ $ forkIO ...</tt>.
--   This is particularly useful if you need to establish an exception
--   handler in the forked thread before any asynchronous exceptions are
--   received. To create a new thread in an unmasked state use
--   <a>forkIOWithUnmask</a>.
mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: IO a -> IO a

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception#interruptible</a>). THIS SHOULD BE USED WITH
--   GREAT CARE, because if a thread executing in
--   <a>uninterruptibleMask</a> blocks for any reason, then the thread (and
--   possibly the program, if this is the main thread) will be unresponsive
--   and unkillable. This function should only be necessary if you need to
--   mask exceptions around an interruptible operation, and you can
--   guarantee that the interruptible operation will only block for a short
--   period of time.
uninterruptibleMask :: ((forall a. IO a -> IO a) -> IO b) -> IO b

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: IO a -> IO a

-- | Describes the behaviour of a thread when an asynchronous exception is
--   received.
data MaskingState

-- | asynchronous exceptions are unmasked (the normal state)
Unmasked :: MaskingState

-- | the state during <a>mask</a>: asynchronous exceptions are masked, but
--   blocking operations may still be interrupted
MaskedInterruptible :: MaskingState

-- | the state during <a>uninterruptibleMask</a>: asynchronous exceptions
--   are masked, and blocking operations may not be interrupted
MaskedUninterruptible :: MaskingState

-- | Returns the <a>MaskingState</a> for the current thread.
getMaskingState :: IO MaskingState

-- | Allow asynchronous exceptions to be raised even inside <a>mask</a>,
--   making the operation interruptible (see the discussion of
--   "Interruptible operations" in <a>Exception</a>).
--   
--   When called outside <a>mask</a>, or inside <a>uninterruptibleMask</a>,
--   this function has no effect.
interruptible :: IO a -> IO a

-- | When invoked inside <a>mask</a>, this function allows a masked
--   asynchronous exception to be raised, if one exists. It is equivalent
--   to performing an interruptible operation (see #interruptible), but
--   does not involve any actual blocking.
--   
--   When called outside <a>mask</a>, or inside <a>uninterruptibleMask</a>,
--   this function has no effect.
allowInterrupt :: IO ()

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <tt>AssertionFailed</tt> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a

-- | When you want to acquire a resource, do some work with it, and then
--   release the resource, it is a good idea to use <a>bracket</a>, because
--   <a>bracket</a> will install the necessary exception handler to release
--   the resource in the event that an exception is raised during the
--   computation. If an exception is raised, then <a>bracket</a> will
--   re-raise the exception (after performing the release).
--   
--   A common example is opening a file:
--   
--   <pre>
--   bracket
--     (openFile "filename" ReadMode)
--     (hClose)
--     (\fileHandle -&gt; do { ... })
--   </pre>
--   
--   The arguments to <a>bracket</a> are in this order so that we can
--   partially apply it, e.g.:
--   
--   <pre>
--   withFile name mode = bracket (openFile name mode) hClose
--   </pre>
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A variant of <a>bracket</a> where the return value from the first
--   computation is not required.
bracket_ :: IO a -> IO b -> IO c -> IO c

-- | Like <a>bracket</a>, but only performs the final action if there was
--   an exception raised by the in-between computation.
bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A specialised variant of <a>bracket</a> with just a computation to run
--   afterward.
finally :: IO a -> IO b -> IO a

-- | Like <a>finally</a>, but only performs the final action if there was
--   an exception raised by the computation.
onException :: IO a -> IO b -> IO a
instance GHC.Base.Functor Control.Exception.Handler


-- | "Unsafe" IO operations.
module System.IO.Unsafe

-- | This is the "back door" into the <a>IO</a> monad, allowing <a>IO</a>
--   computation to be performed at any time. For this to be safe, the
--   <a>IO</a> computation should be free of side effects and independent
--   of its environment.
--   
--   If the I/O computation wrapped in <a>unsafePerformIO</a> performs side
--   effects, then the relative order in which those side effects take
--   place (relative to the main I/O trunk, or other calls to
--   <a>unsafePerformIO</a>) is indeterminate. Furthermore, when using
--   <a>unsafePerformIO</a> to cause side-effects, you should take the
--   following precautions to ensure the side effects are performed as many
--   times as you expect them to be. Note that these precautions are
--   necessary for GHC, but may not be sufficient, and other compilers may
--   require different precautions:
--   
--   <ul>
--   <li>Use <tt>{-# NOINLINE foo #-}</tt> as a pragma on any function
--   <tt>foo</tt> that calls <a>unsafePerformIO</a>. If the call is
--   inlined, the I/O may be performed more than once.</li>
--   <li>Use the compiler flag <tt>-fno-cse</tt> to prevent common
--   sub-expression elimination being performed on the module, which might
--   combine two side effects that were meant to be separate. A good
--   example is using multiple global variables (like <tt>test</tt> in the
--   example below).</li>
--   <li>Make sure that the either you switch off let-floating
--   (<tt>-fno-full-laziness</tt>), or that the call to
--   <a>unsafePerformIO</a> cannot float outside a lambda. For example, if
--   you say: <tt> f x = unsafePerformIO (newIORef []) </tt> you may get
--   only one reference cell shared between all calls to <tt>f</tt>. Better
--   would be <tt> f x = unsafePerformIO (newIORef [x]) </tt> because now
--   it can't float outside the lambda.</li>
--   </ul>
--   
--   It is less well known that <a>unsafePerformIO</a> is not type safe.
--   For example:
--   
--   <pre>
--   test :: IORef [a]
--   test = unsafePerformIO $ newIORef []
--   
--   main = do
--           writeIORef test [42]
--           bang &lt;- readIORef test
--           print (bang :: [Char])
--   </pre>
--   
--   This program will core dump. This problem with polymorphic references
--   is well known in the ML community, and does not arise with normal
--   monadic use of references. There is no easy way to make it impossible
--   once you use <a>unsafePerformIO</a>. Indeed, it is possible to write
--   <tt>coerce :: a -&gt; b</tt> with the help of <a>unsafePerformIO</a>.
--   So be careful!
unsafePerformIO :: IO a -> a

-- | This version of <a>unsafePerformIO</a> is more efficient because it
--   omits the check that the IO is only being performed by a single
--   thread. Hence, when you use <a>unsafeDupablePerformIO</a>, there is a
--   possibility that the IO action may be performed multiple times (on a
--   multiprocessor), and you should therefore ensure that it gives the
--   same results each time. It may even happen that one of the duplicated
--   IO actions is only run partially, and then interrupted in the middle
--   without an exception being raised. Therefore, functions like
--   <tt>bracket</tt> cannot be used safely within
--   <a>unsafeDupablePerformIO</a>.
unsafeDupablePerformIO :: IO a -> a

-- | <a>unsafeInterleaveIO</a> allows an <a>IO</a> computation to be
--   deferred lazily. When passed a value of type <tt>IO a</tt>, the
--   <a>IO</a> will only be performed when the value of the <tt>a</tt> is
--   demanded. This is used to implement lazy file reading, see
--   <a>hGetContents</a>.
unsafeInterleaveIO :: IO a -> IO a

-- | A slightly faster version of <a>fixIO</a> that may not be safe to use
--   with multiple threads. The unsafety arises when used like this:
--   
--   <pre>
--   unsafeFixIO $ \r -&gt; do
--      forkIO (print r)
--      return (...)
--   </pre>
--   
--   In this case, the child thread will receive a <tt>NonTermination</tt>
--   exception instead of waiting for the value of <tt>r</tt> to be
--   computed.
unsafeFixIO :: (a -> IO a) -> IO a


-- | Text codecs for I/O
module GHC.IO.Encoding
data BufferCodec from to state
BufferCodec :: CodeBuffer from to -> (Buffer from -> Buffer to -> IO (Buffer from, Buffer to)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state

-- | The <tt>encode</tt> function translates elements of the buffer
--   <tt>from</tt> to the buffer <tt>to</tt>. It should translate as many
--   elements as possible given the sizes of the buffers, including
--   translating zero elements if there is either not enough room in
--   <tt>to</tt>, or <tt>from</tt> does not contain a complete multibyte
--   sequence.
--   
--   If multiple CodingProgress returns are possible, OutputUnderflow must
--   be preferred to InvalidSequence. This allows GHC's IO library to
--   assume that if we observe InvalidSequence there is at least a single
--   element available in the output buffer.
--   
--   The fact that as many elements as possible are translated is used by
--   the IO library in order to report translation errors at the point they
--   actually occur, rather than when the buffer is translated.
[encode] :: BufferCodec from to state -> CodeBuffer from to

-- | The <tt>recover</tt> function is used to continue decoding in the
--   presence of invalid or unrepresentable sequences. This includes both
--   those detected by <tt>encode</tt> returning <tt>InvalidSequence</tt>
--   and those that occur because the input byte sequence appears to be
--   truncated.
--   
--   Progress will usually be made by skipping the first element of the
--   <tt>from</tt> buffer. This function should only be called if you are
--   certain that you wish to do this skipping and if the <tt>to</tt>
--   buffer has at least one element of free space. Because this function
--   deals with decoding failure, it assumes that the from buffer has at
--   least one element.
--   
--   <tt>recover</tt> may raise an exception rather than skipping anything.
--   
--   Currently, some implementations of <tt>recover</tt> may mutate the
--   input buffer. In particular, this feature is used to implement
--   transliteration.
[recover] :: BufferCodec from to state -> Buffer from -> Buffer to -> IO (Buffer from, Buffer to)

-- | Resources associated with the encoding may now be released. The
--   <tt>encode</tt> function may not be called again after calling
--   <tt>close</tt>.
[close] :: BufferCodec from to state -> IO ()

-- | Return the current state of the codec.
--   
--   Many codecs are not stateful, and in these case the state can be
--   represented as '()'. Other codecs maintain a state. For example,
--   UTF-16 recognises a BOM (byte-order-mark) character at the beginning
--   of the input, and remembers thereafter whether to use big-endian or
--   little-endian mode. In this case, the state of the codec would include
--   two pieces of information: whether we are at the beginning of the
--   stream (the BOM only occurs at the beginning), and if not, whether to
--   use the big or little-endian encoding.
[getState] :: BufferCodec from to state -> IO state
[setState] :: BufferCodec from to state -> state -> IO ()

-- | A <a>TextEncoding</a> is a specification of a conversion scheme
--   between sequences of bytes and sequences of Unicode characters.
--   
--   For example, UTF-8 is an encoding of Unicode characters into a
--   sequence of bytes. The <a>TextEncoding</a> for UTF-8 is <tt>utf8</tt>.
data TextEncoding
TextEncoding :: String -> IO (TextDecoder dstate) -> IO (TextEncoder estate) -> TextEncoding

-- | a string that can be passed to <tt>mkTextEncoding</tt> to create an
--   equivalent <a>TextEncoding</a>.
[textEncodingName] :: TextEncoding -> String

-- | Creates a means of decoding bytes into characters: the result must not
--   be shared between several byte sequences or simultaneously across
--   threads
[mkTextDecoder] :: TextEncoding -> IO (TextDecoder dstate)

-- | Creates a means of encode characters into bytes: the result must not
--   be shared between several character sequences or simultaneously across
--   threads
[mkTextEncoder] :: TextEncoding -> IO (TextEncoder estate)
type TextEncoder state = BufferCodec CharBufElem Word8 state
type TextDecoder state = BufferCodec Word8 CharBufElem state

data CodingProgress

-- | Stopped because the input contains insufficient available elements, or
--   all of the input sequence has been successfully translated.
InputUnderflow :: CodingProgress

-- | Stopped because the output contains insufficient free elements
OutputUnderflow :: CodingProgress

-- | Stopped because there are sufficient free elements in the output to
--   output at least one encoded ASCII character, but the input contains an
--   invalid or unrepresentable sequence
InvalidSequence :: CodingProgress

-- | The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to
--   the first 256 Unicode code points, and is thus not a complete Unicode
--   encoding. An attempt to write a character greater than '\255' to a
--   <tt>Handle</tt> using the <a>latin1</a> encoding will result in an
--   error.
latin1 :: TextEncoding
latin1_encode :: CharBuffer -> Buffer Word8 -> IO (CharBuffer, Buffer Word8)
latin1_decode :: Buffer Word8 -> CharBuffer -> IO (Buffer Word8, CharBuffer)

-- | The UTF-8 Unicode encoding
utf8 :: TextEncoding

-- | The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte
--   sequence 0xEF 0xBB 0xBF). This encoding behaves like <a>utf8</a>,
--   except that on input, the BOM sequence is ignored at the beginning of
--   the stream, and on output, the BOM sequence is prepended.
--   
--   The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes
--   used to identify the encoding of a file.
utf8_bom :: TextEncoding

-- | The UTF-16 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf16 :: TextEncoding

-- | The UTF-16 Unicode encoding (litte-endian)
utf16le :: TextEncoding

-- | The UTF-16 Unicode encoding (big-endian)
utf16be :: TextEncoding

-- | The UTF-32 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf32 :: TextEncoding

-- | The UTF-32 Unicode encoding (litte-endian)
utf32le :: TextEncoding

-- | The UTF-32 Unicode encoding (big-endian)
utf32be :: TextEncoding

initLocaleEncoding :: TextEncoding

-- | The Unicode encoding of the current locale
getLocaleEncoding :: IO TextEncoding

-- | The Unicode encoding of the current locale, but allowing arbitrary
--   undecodable bytes to be round-tripped through it.
--   
--   This <a>TextEncoding</a> is used to decode and encode command line
--   arguments and environment variables on non-Windows platforms.
--   
--   On Windows, this encoding *should not* be used if possible because the
--   use of code pages is deprecated: Strings should be retrieved via the
--   "wide" W-family of UTF-16 APIs instead
getFileSystemEncoding :: IO TextEncoding

-- | The Unicode encoding of the current locale, but where undecodable
--   bytes are replaced with their closest visual match. Used for the
--   <tt>CString</tt> marshalling functions in <a>Foreign.C.String</a>
getForeignEncoding :: IO TextEncoding

setLocaleEncoding :: TextEncoding -> IO ()

setFileSystemEncoding :: TextEncoding -> IO ()

setForeignEncoding :: TextEncoding -> IO ()

-- | An encoding in which Unicode code points are translated to bytes by
--   taking the code point modulo 256. When decoding, bytes are translated
--   directly into the equivalent code point.
--   
--   This encoding never fails in either direction. However, encoding
--   discards information, so encode followed by decode is not the
--   identity.
char8 :: TextEncoding

-- | Look up the named Unicode encoding. May fail with
--   
--   <ul>
--   <li><tt>isDoesNotExistError</tt> if the encoding is unknown</li>
--   </ul>
--   
--   The set of known encodings is system-dependent, but includes at least:
--   
--   <ul>
--   <li><pre>UTF-8</pre></li>
--   <li><tt>UTF-16</tt>, <tt>UTF-16BE</tt>, <tt>UTF-16LE</tt></li>
--   <li><tt>UTF-32</tt>, <tt>UTF-32BE</tt>, <tt>UTF-32LE</tt></li>
--   </ul>
--   
--   There is additional notation (borrowed from GNU iconv) for specifying
--   how illegal characters are handled:
--   
--   <ul>
--   <li>a suffix of <tt>//IGNORE</tt>, e.g. <tt>UTF-8//IGNORE</tt>, will
--   cause all illegal sequences on input to be ignored, and on output will
--   drop all code points that have no representation in the target
--   encoding.</li>
--   <li>a suffix of <tt>//TRANSLIT</tt> will choose a replacement
--   character for illegal sequences or code points.</li>
--   <li>a suffix of <tt>//ROUNDTRIP</tt> will use a PEP383-style escape
--   mechanism to represent any invalid bytes in the input as Unicode
--   codepoints (specifically, as lone surrogates, which are normally
--   invalid in UTF-32). Upon output, these special codepoints are detected
--   and turned back into the corresponding original byte.</li>
--   </ul>
--   
--   In theory, this mechanism allows arbitrary data to be roundtripped via
--   a <a>String</a> with no loss of data. In practice, there are two
--   limitations to be aware of:
--   
--   <ol>
--   <li>This only stands a chance of working for an encoding which is an
--   ASCII superset, as for security reasons we refuse to escape any bytes
--   smaller than 128. Many encodings of interest are ASCII supersets (in
--   particular, you can assume that the locale encoding is an ASCII
--   superset) but many (such as UTF-16) are not.</li>
--   <li>If the underlying encoding is not itself roundtrippable, this
--   mechanism can fail. Roundtrippable encodings are those which have an
--   injective mapping into Unicode. Almost all encodings meet this
--   criteria, but some do not. Notably, Shift-JIS (CP932) and Big5 contain
--   several different encodings of the same Unicode codepoint.</li>
--   </ol>
--   
--   On Windows, you can access supported code pages with the prefix
--   <tt>CP</tt>; for example, <tt>"CP1250"</tt>.
mkTextEncoding :: String -> IO TextEncoding

-- | Internal encoding of argv
argvEncoding :: IO TextEncoding


-- | Access to GHC's call-stack simulation
module GHC.Stack.CCS

-- | Returns a <tt>[String]</tt> representing the current call stack. This
--   can be useful for debugging.
--   
--   The implementation uses the call-stack simulation maintained by the
--   profiler, so it only works if the program was compiled with
--   <tt>-prof</tt> and contains suitable SCC annotations (e.g. by using
--   <tt>-fprof-auto</tt>). Otherwise, the list returned is likely to be
--   empty or uninformative.
currentCallStack :: IO [String]

-- | Get the stack trace attached to an object.
whoCreated :: a -> IO [String]

-- | A cost-centre stack from GHC's cost-center profiler.
data CostCentreStack

-- | A cost-centre from GHC's cost-center profiler.
data CostCentre

-- | Returns the current <a>CostCentreStack</a> (value is <tt>nullPtr</tt>
--   if the current program was not compiled with profiling support). Takes
--   a dummy argument which can be used to avoid the call to
--   <tt>getCurrentCCS</tt> being floated out by the simplifier, which
--   would result in an uninformative stack (<a>CAF</a>).
getCurrentCCS :: dummy -> IO (Ptr CostCentreStack)

-- | Get the <a>CostCentreStack</a> associated with the given value.
getCCSOf :: a -> IO (Ptr CostCentreStack)

-- | Run a computation with an empty cost-center stack. For example, this
--   is used by the interpreter to run an interpreted computation without
--   the call stack showing that it was invoked from GHC.
clearCCS :: IO a -> IO a

-- | Get the <a>CostCentre</a> at the head of a <a>CostCentreStack</a>.
ccsCC :: Ptr CostCentreStack -> IO (Ptr CostCentre)

-- | Get the tail of a <a>CostCentreStack</a>.
ccsParent :: Ptr CostCentreStack -> IO (Ptr CostCentreStack)

-- | Get the label of a <a>CostCentre</a>.
ccLabel :: Ptr CostCentre -> IO CString

-- | Get the module of a <a>CostCentre</a>.
ccModule :: Ptr CostCentre -> IO CString

-- | Get the source span of a <a>CostCentre</a>.
ccSrcSpan :: Ptr CostCentre -> IO CString

-- | Format a <a>CostCentreStack</a> as a list of lines.
ccsToStrings :: Ptr CostCentreStack -> IO [String]
renderStack :: [String] -> String


-- | Access to GHC's call-stack simulation
module GHC.Stack

-- | Like the function <a>error</a>, but appends a stack trace to the error
--   message if one is available.

-- | <i>Deprecated: <a>error</a> appends the call stack now</i>
errorWithStackTrace :: String -> a

-- | Returns a <tt>[String]</tt> representing the current call stack. This
--   can be useful for debugging.
--   
--   The implementation uses the call-stack simulation maintained by the
--   profiler, so it only works if the program was compiled with
--   <tt>-prof</tt> and contains suitable SCC annotations (e.g. by using
--   <tt>-fprof-auto</tt>). Otherwise, the list returned is likely to be
--   empty or uninformative.
currentCallStack :: IO [String]

-- | Get the stack trace attached to an object.
whoCreated :: a -> IO [String]

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:2:1 in interactive:Ghci1
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data CallStack

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = (?callStack :: CallStack)

-- | Return the current <a>CallStack</a>.
--   
--   Does *not* include the call-site of <a>callStack</a>.
callStack :: HasCallStack => CallStack

-- | The empty <a>CallStack</a>.
emptyCallStack :: CallStack

-- | Freeze a call-stack, preventing any further call-sites from being
--   appended.
--   
--   <pre>
--   pushCallStack callSite (freezeCallStack callStack) = freezeCallStack callStack
--   </pre>
freezeCallStack :: CallStack -> CallStack

-- | Convert a list of call-sites to a <a>CallStack</a>.
fromCallSiteList :: [([Char], SrcLoc)] -> CallStack

-- | Extract a list of call-sites from the <a>CallStack</a>.
--   
--   The list is ordered by most recent call.
getCallStack :: CallStack -> [([Char], SrcLoc)]

-- | Pop the most recent call-site off the <a>CallStack</a>.
--   
--   This function, like <a>pushCallStack</a>, has no effect on a frozen
--   <a>CallStack</a>.
popCallStack :: CallStack -> CallStack

-- | Pretty print a <a>CallStack</a>.
prettyCallStack :: CallStack -> String

-- | Push a call-site onto the stack.
--   
--   This function has no effect on a frozen <a>CallStack</a>.
pushCallStack :: ([Char], SrcLoc) -> CallStack -> CallStack

-- | Perform some computation without adding new entries to the
--   <a>CallStack</a>.
withFrozenCallStack :: HasCallStack => (HasCallStack => a) -> a

-- | A single location in the source code.
data SrcLoc
SrcLoc :: [Char] -> [Char] -> [Char] -> Int -> Int -> Int -> Int -> SrcLoc
[srcLocPackage] :: SrcLoc -> [Char]
[srcLocModule] :: SrcLoc -> [Char]
[srcLocFile] :: SrcLoc -> [Char]
[srcLocStartLine] :: SrcLoc -> Int
[srcLocStartCol] :: SrcLoc -> Int
[srcLocEndLine] :: SrcLoc -> Int
[srcLocEndCol] :: SrcLoc -> Int

-- | Pretty print a <a>SrcLoc</a>.
prettySrcLoc :: SrcLoc -> String

-- | A cost-centre stack from GHC's cost-center profiler.
data CostCentreStack

-- | A cost-centre from GHC's cost-center profiler.
data CostCentre

-- | Returns the current <a>CostCentreStack</a> (value is <tt>nullPtr</tt>
--   if the current program was not compiled with profiling support). Takes
--   a dummy argument which can be used to avoid the call to
--   <tt>getCurrentCCS</tt> being floated out by the simplifier, which
--   would result in an uninformative stack (<a>CAF</a>).
getCurrentCCS :: dummy -> IO (Ptr CostCentreStack)

-- | Get the <a>CostCentreStack</a> associated with the given value.
getCCSOf :: a -> IO (Ptr CostCentreStack)

-- | Run a computation with an empty cost-center stack. For example, this
--   is used by the interpreter to run an interpreted computation without
--   the call stack showing that it was invoked from GHC.
clearCCS :: IO a -> IO a

-- | Get the <a>CostCentre</a> at the head of a <a>CostCentreStack</a>.
ccsCC :: Ptr CostCentreStack -> IO (Ptr CostCentre)

-- | Get the tail of a <a>CostCentreStack</a>.
ccsParent :: Ptr CostCentreStack -> IO (Ptr CostCentreStack)

-- | Get the label of a <a>CostCentre</a>.
ccLabel :: Ptr CostCentre -> IO CString

-- | Get the module of a <a>CostCentre</a>.
ccModule :: Ptr CostCentre -> IO CString

-- | Get the source span of a <a>CostCentre</a>.
ccSrcSpan :: Ptr CostCentre -> IO CString

-- | Format a <a>CostCentreStack</a> as a list of lines.
ccsToStrings :: Ptr CostCentreStack -> IO [String]
renderStack :: [String] -> String

module GHC.Environment

-- | Computation <a>getFullArgs</a> is the "raw" version of
--   <tt>getArgs</tt>, similar to <tt>argv</tt> in other languages. It
--   returns a list of the program's command line arguments, starting with
--   the program name, and including those normally eaten by the RTS (+RTS
--   ... -RTS).
getFullArgs :: IO [String]


-- | An <tt><a>MVar</a> t</tt> is mutable location that is either empty or
--   contains a value of type <tt>t</tt>. It has two fundamental
--   operations: <a>putMVar</a> which fills an <a>MVar</a> if it is empty
--   and blocks otherwise, and <a>takeMVar</a> which empties an <a>MVar</a>
--   if it is full and blocks otherwise. They can be used in multiple
--   different ways:
--   
--   <ol>
--   <li>As synchronized mutable variables,</li>
--   <li>As channels, with <a>takeMVar</a> and <a>putMVar</a> as receive
--   and send, and</li>
--   <li>As a binary semaphore <tt><a>MVar</a> ()</tt>, with
--   <a>takeMVar</a> and <a>putMVar</a> as wait and signal.</li>
--   </ol>
--   
--   They were introduced in the paper <a>"Concurrent Haskell"</a> by Simon
--   Peyton Jones, Andrew Gordon and Sigbjorn Finne, though some details of
--   their implementation have since then changed (in particular, a put on
--   a full <a>MVar</a> used to error, but now merely blocks.)
--   
--   <h3>Applicability</h3>
--   
--   <a>MVar</a>s offer more flexibility than <tt>IORef</tt>s, but less
--   flexibility than <tt>STM</tt>. They are appropriate for building
--   synchronization primitives and performing simple interthread
--   communication; however they are very simple and susceptible to race
--   conditions, deadlocks or uncaught exceptions. Do not use them if you
--   need perform larger atomic operations such as reading from multiple
--   variables: use <tt>STM</tt> instead.
--   
--   In particular, the "bigger" functions in this module (<a>swapMVar</a>,
--   <a>withMVar</a>, <a>modifyMVar_</a> and <a>modifyMVar</a>) are simply
--   the composition of a <a>takeMVar</a> followed by a <a>putMVar</a> with
--   exception safety. These only have atomicity guarantees if all other
--   threads perform a <a>takeMVar</a> before a <a>putMVar</a> as well;
--   otherwise, they may block.
--   
--   <h3>Fairness</h3>
--   
--   No thread can be blocked indefinitely on an <a>MVar</a> unless another
--   thread holds that <a>MVar</a> indefinitely. One usual implementation
--   of this fairness guarantee is that threads blocked on an <a>MVar</a>
--   are served in a first-in-first-out fashion, but this is not guaranteed
--   in the semantics.
--   
--   <h3>Gotchas</h3>
--   
--   Like many other Haskell data structures, <a>MVar</a>s are lazy. This
--   means that if you place an expensive unevaluated thunk inside an
--   <a>MVar</a>, it will be evaluated by the thread that consumes it, not
--   the thread that produced it. Be sure to <a>evaluate</a> values to be
--   placed in an <a>MVar</a> to the appropriate normal form, or utilize a
--   strict MVar provided by the strict-concurrency package.
--   
--   <h3>Ordering</h3>
--   
--   <a>MVar</a> operations are always observed to take place in the order
--   they are written in the program, regardless of the memory model of the
--   underlying machine. This is in contrast to <tt>IORef</tt> operations
--   which may appear out-of-order to another thread in some cases.
--   
--   <h3>Example</h3>
--   
--   Consider the following concurrent data structure, a skip channel. This
--   is a channel for an intermittent source of high bandwidth information
--   (for example, mouse movement events.) Writing to the channel never
--   blocks, and reading from the channel only returns the most recent
--   value, or blocks if there are no new values. Multiple readers are
--   supported with a <tt>dupSkipChan</tt> operation.
--   
--   A skip channel is a pair of <a>MVar</a>s. The first <a>MVar</a>
--   contains the current value, and a list of semaphores that need to be
--   notified when it changes. The second <a>MVar</a> is a semaphore for
--   this particular reader: it is full if there is a value in the channel
--   that this reader has not read yet, and empty otherwise.
--   
--   <pre>
--   data SkipChan a = SkipChan (MVar (a, [MVar ()])) (MVar ())
--   
--   newSkipChan :: IO (SkipChan a)
--   newSkipChan = do
--       sem &lt;- newEmptyMVar
--       main &lt;- newMVar (undefined, [sem])
--       return (SkipChan main sem)
--   
--   putSkipChan :: SkipChan a -&gt; a -&gt; IO ()
--   putSkipChan (SkipChan main _) v = do
--       (_, sems) &lt;- takeMVar main
--       putMVar main (v, [])
--       mapM_ (sem -&gt; putMVar sem ()) sems
--   
--   getSkipChan :: SkipChan a -&gt; IO a
--   getSkipChan (SkipChan main sem) = do
--       takeMVar sem
--       (v, sems) &lt;- takeMVar main
--       putMVar main (v, sem:sems)
--       return v
--   
--   dupSkipChan :: SkipChan a -&gt; IO (SkipChan a)
--   dupSkipChan (SkipChan main _) = do
--       sem &lt;- newEmptyMVar
--       (v, sems) &lt;- takeMVar main
--       putMVar main (v, sem:sems)
--       return (SkipChan main sem)
--   </pre>
--   
--   This example was adapted from the original Concurrent Haskell paper.
--   For more examples of <a>MVar</a>s being used to build higher-level
--   synchronization primitives, see <a>Chan</a> and <a>QSem</a>.
module Control.Concurrent.MVar

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a box, which may be empty or full.
data MVar a

-- | Create an <a>MVar</a> which is initially empty.
newEmptyMVar :: IO (MVar a)

-- | Create an <a>MVar</a> which contains the supplied value.
newMVar :: a -> IO (MVar a)

-- | Return the contents of the <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>takeMVar</a> will wait until it is full. After a
--   <a>takeMVar</a>, the <a>MVar</a> is left empty.
--   
--   There are two further important properties of <a>takeMVar</a>:
--   
--   <ul>
--   <li><a>takeMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>takeMVar</a>, and the <a>MVar</a> becomes full,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>takeMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
takeMVar :: MVar a -> IO a

-- | Put a value into an <a>MVar</a>. If the <a>MVar</a> is currently full,
--   <a>putMVar</a> will wait until it becomes empty.
--   
--   There are two further important properties of <a>putMVar</a>:
--   
--   <ul>
--   <li><a>putMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>putMVar</a>, and the <a>MVar</a> becomes empty,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>putMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
putMVar :: MVar a -> a -> IO ()

-- | Atomically read the contents of an <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>readMVar</a> will wait until it is full.
--   <a>readMVar</a> is guaranteed to receive the next <a>putMVar</a>.
--   
--   <a>readMVar</a> is multiple-wakeup, so when multiple readers are
--   blocked on an <a>MVar</a>, all of them are woken up at the same time.
--   
--   <i>Compatibility note:</i> Prior to base 4.7, <a>readMVar</a> was a
--   combination of <a>takeMVar</a> and <a>putMVar</a>. This mean that in
--   the presence of other threads attempting to <a>putMVar</a>,
--   <a>readMVar</a> could block. Furthermore, <a>readMVar</a> would not
--   receive the next <a>putMVar</a> if there was already a pending thread
--   blocked on <a>takeMVar</a>. The old behavior can be recovered by
--   implementing 'readMVar as follows:
--   
--   <pre>
--   readMVar :: MVar a -&gt; IO a
--   readMVar m =
--     mask_ $ do
--       a &lt;- takeMVar m
--       putMVar m a
--       return a
--   </pre>
readMVar :: MVar a -> IO a

-- | Take a value from an <a>MVar</a>, put a new value into the <a>MVar</a>
--   and return the value taken. This function is atomic only if there are
--   no other producers for this <a>MVar</a>.
swapMVar :: MVar a -> a -> IO a

-- | A non-blocking version of <a>takeMVar</a>. The <a>tryTakeMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>. After <a>tryTakeMVar</a>, the <a>MVar</a> is left
--   empty.
tryTakeMVar :: MVar a -> IO (Maybe a)

-- | A non-blocking version of <a>putMVar</a>. The <a>tryPutMVar</a>
--   function attempts to put the value <tt>a</tt> into the <a>MVar</a>,
--   returning <a>True</a> if it was successful, or <a>False</a> otherwise.
tryPutMVar :: MVar a -> a -> IO Bool

-- | Check whether a given <a>MVar</a> is empty.
--   
--   Notice that the boolean value returned is just a snapshot of the state
--   of the MVar. By the time you get to react on its result, the MVar may
--   have been filled (or emptied) - so be extremely careful when using
--   this operation. Use <a>tryTakeMVar</a> instead if possible.
isEmptyMVar :: MVar a -> IO Bool

-- | <a>withMVar</a> is an exception-safe wrapper for operating on the
--   contents of an <a>MVar</a>. This operation is exception-safe: it will
--   replace the original contents of the <a>MVar</a> if an exception is
--   raised (see <a>Control.Exception</a>). However, it is only atomic if
--   there are no other producers for this <a>MVar</a>.
withMVar :: MVar a -> (a -> IO b) -> IO b

-- | Like <a>withMVar</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
withMVarMasked :: MVar a -> (a -> IO b) -> IO b

-- | An exception-safe wrapper for modifying the contents of an
--   <a>MVar</a>. Like <a>withMVar</a>, <a>modifyMVar</a> will replace the
--   original contents of the <a>MVar</a> if an exception is raised during
--   the operation. This function is only atomic if there are no other
--   producers for this <a>MVar</a>.
modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()

-- | A slight variation on <a>modifyMVar_</a> that allows a value to be
--   returned (<tt>b</tt>) in addition to the modified value of the
--   <a>MVar</a>.
modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b

-- | Like <a>modifyMVar_</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
modifyMVarMasked_ :: MVar a -> (a -> IO a) -> IO ()

-- | Like <a>modifyMVar</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
modifyMVarMasked :: MVar a -> (a -> IO (a, b)) -> IO b

-- | A non-blocking version of <a>readMVar</a>. The <a>tryReadMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>.
tryReadMVar :: MVar a -> IO (Maybe a)

-- | Make a <a>Weak</a> pointer to an <a>MVar</a>, using the second
--   argument as a finalizer to run when <a>MVar</a> is garbage-collected
mkWeakMVar :: MVar a -> IO () -> IO (Weak (MVar a))

-- | <i>Deprecated: use <a>mkWeakMVar</a> instead</i>
addMVarFinalizer :: MVar a -> IO () -> IO ()

module GHC.Conc.Signal
type Signal = CInt
type HandlerFun = ForeignPtr Word8 -> IO ()
setHandler :: Signal -> Maybe (HandlerFun, Dynamic) -> IO (Maybe (HandlerFun, Dynamic))
runHandlers :: ForeignPtr Word8 -> Signal -> IO ()
runHandlersPtr :: Ptr Word8 -> Signal -> IO ()


-- | Basic concurrency stuff.
module GHC.Conc.IO
ensureIOManagerIsRunning :: IO ()
ioManagerCapabilitiesChanged :: IO ()

-- | Suspends the current thread for a given number of microseconds (GHC
--   only).
--   
--   There is no guarantee that the thread will be rescheduled promptly
--   when the delay has expired, but the thread will never continue to run
--   <i>earlier</i> than specified.
threadDelay :: Int -> IO ()

-- | Switch the value of returned <a>TVar</a> from initial value
--   <a>False</a> to <a>True</a> after a given number of microseconds. The
--   caveats associated with <a>threadDelay</a> also apply.
registerDelay :: Int -> IO (TVar Bool)

-- | Block the current thread until data is available to read on the given
--   file descriptor (GHC only).
--   
--   This will throw an <tt>IOError</tt> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitRead</a>, use <a>closeFdWith</a>.
threadWaitRead :: Fd -> IO ()

-- | Block the current thread until data can be written to the given file
--   descriptor (GHC only).
--   
--   This will throw an <tt>IOError</tt> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitWrite</a>, use <a>closeFdWith</a>.
threadWaitWrite :: Fd -> IO ()

-- | Returns an STM action that can be used to wait for data to read from a
--   file descriptor. The second returned value is an IO action that can be
--   used to deregister interest in the file descriptor.
threadWaitReadSTM :: Fd -> IO (STM (), IO ())

-- | Returns an STM action that can be used to wait until data can be
--   written to a file descriptor. The second returned value is an IO
--   action that can be used to deregister interest in the file descriptor.
threadWaitWriteSTM :: Fd -> IO (STM (), IO ())

-- | Close a file descriptor in a concurrency-safe way (GHC only). If you
--   are using <a>threadWaitRead</a> or <a>threadWaitWrite</a> to perform
--   blocking I/O, you <i>must</i> use this function to close file
--   descriptors, or blocked threads may not be woken.
--   
--   Any threads that are blocked on the file descriptor via
--   <a>threadWaitRead</a> or <a>threadWaitWrite</a> will be unblocked by
--   having IO exceptions thrown.
closeFdWith :: (Fd -> IO ()) -> Fd -> IO ()


-- | Handle operations implemented by file descriptors (FDs)
module GHC.IO.Handle.FD

-- | A handle managing input from the Haskell program's standard input
--   channel.
stdin :: Handle

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | A handle managing output to the Haskell program's standard error
--   channel.
stderr :: Handle

-- | Computation <a>openFile</a> <tt>file mode</tt> allocates and returns a
--   new, open handle to manage the file <tt>file</tt>. It manages input if
--   <tt>mode</tt> is <a>ReadMode</a>, output if <tt>mode</tt> is
--   <a>WriteMode</a> or <a>AppendMode</a>, and both input and output if
--   mode is <a>ReadWriteMode</a>.
--   
--   If the file does not exist and it is opened for output, it should be
--   created as a new file. If <tt>mode</tt> is <a>WriteMode</a> and the
--   file already exists, then it should be truncated to zero length. Some
--   operating systems delete empty files, so there is no guarantee that
--   the file will exist following an <a>openFile</a> with <tt>mode</tt>
--   <a>WriteMode</a> unless it is subsequently written to successfully.
--   The handle is positioned at the end of the file if <tt>mode</tt> is
--   <a>AppendMode</a>, and otherwise at the beginning (in which case its
--   internal position is 0). The initial buffer mode is
--   implementation-dependent.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isAlreadyInUseError</tt> if the file is already open and
--   cannot be reopened;</li>
--   <li><tt>isDoesNotExistError</tt> if the file does not exist or (on
--   POSIX systems) is a FIFO without a reader and <a>WriteMode</a> was
--   requested; or</li>
--   <li><tt>isPermissionError</tt> if the user does not have permission to
--   open the file.</li>
--   </ul>
--   
--   Note: if you will be working with files containing binary data, you'll
--   want to be using <a>openBinaryFile</a>.
openFile :: FilePath -> IOMode -> IO Handle

-- | Like <a>openFile</a>, but open the file in binary mode. On Windows,
--   reading a file in text mode (which is the default) will translate CRLF
--   to LF, and writing will translate LF to CRLF. This is usually what you
--   want with text files. With binary files this is undesirable; also, as
--   usual under Microsoft operating systems, text mode treats control-Z as
--   EOF. Binary mode turns off all special treatment of end-of-line and
--   end-of-file characters. (See also <a>hSetBinaryMode</a>.)
openBinaryFile :: FilePath -> IOMode -> IO Handle

-- | Like <a>openFile</a>, but opens the file in ordinary blocking mode.
--   This can be useful for opening a FIFO for writing: if we open in
--   non-blocking mode then the open will fail if there are no readers,
--   whereas a blocking open will block until a reader appear.
openFileBlocking :: FilePath -> IOMode -> IO Handle
mkHandleFromFD :: FD -> IODeviceType -> FilePath -> IOMode -> Bool -> Maybe TextEncoding -> IO Handle

-- | Turn an existing file descriptor into a Handle. This is used by
--   various external libraries to make Handles.
--   
--   Makes a binary Handle. This is for historical reasons; it should
--   probably be a text Handle with the default encoding and newline
--   translation instead.
fdToHandle :: FD -> IO Handle

-- | Old API kept to avoid breaking clients
fdToHandle' :: CInt -> Maybe IODeviceType -> Bool -> FilePath -> IOMode -> Bool -> IO Handle

-- | Turn an existing Handle into a file descriptor. This function throws
--   an IOError if the Handle does not reference a file descriptor.
handleToFd :: Handle -> IO FD

module GHC.IO.Handle.Lock

-- | Exception thrown by <a>hLock</a> on non-Windows platforms that don't
--   support <tt>flock</tt>.
data FileLockingNotSupported
FileLockingNotSupported :: FileLockingNotSupported

-- | Indicates a mode in which a file should be locked.
data LockMode
SharedLock :: LockMode
ExclusiveLock :: LockMode

-- | If a <a>Handle</a> references a file descriptor, attempt to lock
--   contents of the underlying file in appropriate mode. If the file is
--   already locked in incompatible mode, this function blocks until the
--   lock is established. The lock is automatically released upon closing a
--   <a>Handle</a>.
--   
--   Things to be aware of:
--   
--   1) This function may block inside a C call. If it does, in order to be
--   able to interrupt it with asynchronous exceptions and/or for other
--   threads to continue working, you MUST use threaded version of the
--   runtime system.
--   
--   2) The implementation uses <tt>LockFileEx</tt> on Windows and
--   <tt>flock</tt> otherwise, hence all of their caveats also apply here.
--   
--   3) On non-Windows plaftorms that don't support <tt>flock</tt> (e.g.
--   Solaris) this function throws <tt>FileLockingNotImplemented</tt>. We
--   deliberately choose to not provide fcntl based locking instead because
--   of its broken semantics.
hLock :: Handle -> LockMode -> IO ()

-- | Non-blocking version of <a>hLock</a>.
hTryLock :: Handle -> LockMode -> IO Bool

-- | Release a lock taken with <a>hLock</a> or <a>hTryLock</a>.
hUnlock :: Handle -> IO ()
instance GHC.Show.Show GHC.IO.Handle.Lock.FileLockingNotSupported
instance GHC.Exception.Type.Exception GHC.IO.Handle.Lock.FileLockingNotSupported


-- | External API for GHC's Handle implementation
module GHC.IO.Handle

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode

-- | makes a new <a>Handle</a>
mkFileHandle :: (IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> IOMode -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | like <a>mkFileHandle</a>, except that a <a>Handle</a> is created with
--   two independent buffers, one for reading and one for writing. Used for
--   full-duplex streams, such as network sockets.
mkDuplexHandle :: (IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | For a handle <tt>hdl</tt> which attached to a physical file,
--   <a>hFileSize</a> <tt>hdl</tt> returns the size of that file in 8-bit
--   bytes.
hFileSize :: Handle -> IO Integer

-- | <a>hSetFileSize</a> <tt>hdl</tt> <tt>size</tt> truncates the physical
--   file with handle <tt>hdl</tt> to <tt>size</tt> bytes.
hSetFileSize :: Handle -> Integer -> IO ()

-- | For a readable handle <tt>hdl</tt>, <a>hIsEOF</a> <tt>hdl</tt> returns
--   <a>True</a> if no further input can be taken from <tt>hdl</tt> or for
--   a physical file, if the current I/O position is equal to the length of
--   the file. Otherwise, it returns <a>False</a>.
--   
--   NOTE: <a>hIsEOF</a> may block, because it has to attempt to read from
--   the stream to determine whether there is any more data to be read.
hIsEOF :: Handle -> IO Bool

-- | The computation <a>isEOF</a> is identical to <a>hIsEOF</a>, except
--   that it works only on <a>stdin</a>.
isEOF :: IO Bool

-- | Computation <a>hLookAhead</a> returns the next character from the
--   handle without removing it from the input buffer, blocking until a
--   character is available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isEOFError</tt> if the end of file has been reached.</li>
--   </ul>
hLookAhead :: Handle -> IO Char

-- | Computation <a>hSetBuffering</a> <tt>hdl mode</tt> sets the mode of
--   buffering for handle <tt>hdl</tt> on subsequent reads and writes.
--   
--   If the buffer mode is changed from <a>BlockBuffering</a> or
--   <a>LineBuffering</a> to <a>NoBuffering</a>, then
--   
--   <ul>
--   <li>if <tt>hdl</tt> is writable, the buffer is flushed as for
--   <a>hFlush</a>;</li>
--   <li>if <tt>hdl</tt> is not writable, the contents of the buffer is
--   discarded.</li>
--   </ul>
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isPermissionError</tt> if the handle has already been used for
--   reading or writing and the implementation does not allow the buffering
--   mode to be changed.</li>
--   </ul>
hSetBuffering :: Handle -> BufferMode -> IO ()

-- | Select binary mode (<a>True</a>) or text mode (<a>False</a>) on a open
--   handle. (See also <a>openBinaryFile</a>.)
--   
--   This has the same effect as calling <a>hSetEncoding</a> with
--   <a>char8</a>, together with <a>hSetNewlineMode</a> with
--   <a>noNewlineTranslation</a>.
hSetBinaryMode :: Handle -> Bool -> IO ()

-- | The action <a>hSetEncoding</a> <tt>hdl</tt> <tt>encoding</tt> changes
--   the text encoding for the handle <tt>hdl</tt> to <tt>encoding</tt>.
--   The default encoding when a <a>Handle</a> is created is
--   <tt>localeEncoding</tt>, namely the default encoding for the current
--   locale.
--   
--   To create a <a>Handle</a> with no encoding at all, use
--   <a>openBinaryFile</a>. To stop further encoding or decoding on an
--   existing <a>Handle</a>, use <a>hSetBinaryMode</a>.
--   
--   <a>hSetEncoding</a> may need to flush buffered data in order to change
--   the encoding.
hSetEncoding :: Handle -> TextEncoding -> IO ()

-- | Return the current <a>TextEncoding</a> for the specified
--   <a>Handle</a>, or <a>Nothing</a> if the <a>Handle</a> is in binary
--   mode.
--   
--   Note that the <a>TextEncoding</a> remembers nothing about the state of
--   the encoder/decoder in use on this <a>Handle</a>. For example, if the
--   encoding in use is UTF-16, then using <a>hGetEncoding</a> and
--   <a>hSetEncoding</a> to save and restore the encoding may result in an
--   extra byte-order-mark being written to the file.
hGetEncoding :: Handle -> IO (Maybe TextEncoding)

-- | The action <a>hFlush</a> <tt>hdl</tt> causes any items buffered for
--   output in handle <tt>hdl</tt> to be sent immediately to the operating
--   system.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isFullError</tt> if the device is full;</li>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded. It is unspecified whether the characters in the buffer are
--   discarded or retained under these circumstances.</li>
--   </ul>
hFlush :: Handle -> IO ()

-- | The action <a>hFlushAll</a> <tt>hdl</tt> flushes all buffered data in
--   <tt>hdl</tt>, including any buffered read data. Buffered read data is
--   flushed by seeking the file position back to the point before the
--   bufferred data was read, and hence only works if <tt>hdl</tt> is
--   seekable (see <a>hIsSeekable</a>).
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isFullError</tt> if the device is full;</li>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded. It is unspecified whether the characters in the buffer are
--   discarded or retained under these circumstances;</li>
--   <li><tt>isIllegalOperation</tt> if <tt>hdl</tt> has buffered read
--   data, and is not seekable.</li>
--   </ul>
hFlushAll :: Handle -> IO ()

-- | Returns a duplicate of the original handle, with its own buffer. The
--   two Handles will share a file pointer, however. The original handle's
--   buffer is flushed, including discarding any input data, before the
--   handle is duplicated.
hDuplicate :: Handle -> IO Handle

-- | Makes the second handle a duplicate of the first handle. The second
--   handle will be closed first, if it is not already.
--   
--   This can be used to retarget the standard Handles, for example:
--   
--   <pre>
--   do h &lt;- openFile "mystdout" WriteMode
--      hDuplicateTo h stdout
--   </pre>
hDuplicateTo :: Handle -> Handle -> IO ()

-- | Computation <a>hClose</a> <tt>hdl</tt> makes handle <tt>hdl</tt>
--   closed. Before the computation finishes, if <tt>hdl</tt> is writable
--   its buffer is flushed as for <a>hFlush</a>. Performing <a>hClose</a>
--   on a handle that has already been closed has no effect; doing so is
--   not an error. All other operations on a closed handle will fail. If
--   <a>hClose</a> fails for any reason, any further operations (apart from
--   <a>hClose</a>) on the handle will still fail as if <tt>hdl</tt> had
--   been successfully closed.
hClose :: Handle -> IO ()
hClose_help :: Handle__ -> IO (Handle__, Maybe SomeException)

-- | Indicates a mode in which a file should be locked.
data LockMode
SharedLock :: LockMode
ExclusiveLock :: LockMode

-- | If a <a>Handle</a> references a file descriptor, attempt to lock
--   contents of the underlying file in appropriate mode. If the file is
--   already locked in incompatible mode, this function blocks until the
--   lock is established. The lock is automatically released upon closing a
--   <a>Handle</a>.
--   
--   Things to be aware of:
--   
--   1) This function may block inside a C call. If it does, in order to be
--   able to interrupt it with asynchronous exceptions and/or for other
--   threads to continue working, you MUST use threaded version of the
--   runtime system.
--   
--   2) The implementation uses <tt>LockFileEx</tt> on Windows and
--   <tt>flock</tt> otherwise, hence all of their caveats also apply here.
--   
--   3) On non-Windows plaftorms that don't support <tt>flock</tt> (e.g.
--   Solaris) this function throws <tt>FileLockingNotImplemented</tt>. We
--   deliberately choose to not provide fcntl based locking instead because
--   of its broken semantics.
hLock :: Handle -> LockMode -> IO ()

-- | Non-blocking version of <a>hLock</a>.
hTryLock :: Handle -> LockMode -> IO Bool
type HandlePosition = Integer
data HandlePosn
HandlePosn :: Handle -> HandlePosition -> HandlePosn

-- | Computation <a>hGetPosn</a> <tt>hdl</tt> returns the current I/O
--   position of <tt>hdl</tt> as a value of the abstract type
--   <a>HandlePosn</a>.
hGetPosn :: Handle -> IO HandlePosn

-- | If a call to <a>hGetPosn</a> <tt>hdl</tt> returns a position
--   <tt>p</tt>, then computation <a>hSetPosn</a> <tt>p</tt> sets the
--   position of <tt>hdl</tt> to the position it held at the time of the
--   call to <a>hGetPosn</a>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSetPosn :: HandlePosn -> IO ()

-- | A mode that determines the effect of <tt>hSeek</tt> <tt>hdl mode
--   i</tt>.
data SeekMode

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode

-- | Computation <a>hSeek</a> <tt>hdl mode i</tt> sets the position of
--   handle <tt>hdl</tt> depending on <tt>mode</tt>. The offset <tt>i</tt>
--   is given in terms of 8-bit bytes.
--   
--   If <tt>hdl</tt> is block- or line-buffered, then seeking to a position
--   which is not in the current buffer will first cause any items in the
--   output buffer to be written to the device, and then cause the input
--   buffer to be discarded. Some handles may not be seekable (see
--   <a>hIsSeekable</a>), or only support a subset of the possible
--   positioning operations (for instance, it may only be possible to seek
--   to the end of a tape, or to a positive offset from the beginning or
--   current position). It is not possible to set a negative I/O position,
--   or for a physical file, an I/O position beyond the current
--   end-of-file.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isIllegalOperationError</tt> if the Handle is not seekable, or
--   does not support the requested seek mode.</li>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSeek :: Handle -> SeekMode -> Integer -> IO ()

-- | Computation <a>hTell</a> <tt>hdl</tt> returns the current position of
--   the handle <tt>hdl</tt>, as the number of bytes from the beginning of
--   the file. The value returned may be subsequently passed to
--   <a>hSeek</a> to reposition the handle to the current position.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isIllegalOperationError</tt> if the Handle is not
--   seekable.</li>
--   </ul>
hTell :: Handle -> IO Integer
hIsOpen :: Handle -> IO Bool
hIsClosed :: Handle -> IO Bool
hIsReadable :: Handle -> IO Bool
hIsWritable :: Handle -> IO Bool

-- | Computation <a>hGetBuffering</a> <tt>hdl</tt> returns the current
--   buffering mode for <tt>hdl</tt>.
hGetBuffering :: Handle -> IO BufferMode
hIsSeekable :: Handle -> IO Bool

-- | Set the echoing status of a handle connected to a terminal.
hSetEcho :: Handle -> Bool -> IO ()

-- | Get the echoing status of a handle connected to a terminal.
hGetEcho :: Handle -> IO Bool

-- | Is the handle connected to a terminal?
hIsTerminalDevice :: Handle -> IO Bool

-- | Set the <a>NewlineMode</a> on the specified <a>Handle</a>. All
--   buffered data is flushed first.
hSetNewlineMode :: Handle -> NewlineMode -> IO ()

-- | The representation of a newline in the external file or stream.
data Newline

-- | '\n'
LF :: Newline

-- | '\r\n'
CRLF :: Newline

-- | Specifies the translation, if any, of newline characters between
--   internal Strings and the external file or stream. Haskell Strings are
--   assumed to represent newlines with the '\n' character; the newline
--   mode specifies how to translate '\n' on output, and what to translate
--   into '\n' on input.
data NewlineMode
NewlineMode :: Newline -> Newline -> NewlineMode

-- | the representation of newlines on input
[inputNL] :: NewlineMode -> Newline

-- | the representation of newlines on output
[outputNL] :: NewlineMode -> Newline

-- | The native newline representation for the current platform: <a>LF</a>
--   on Unix systems, <a>CRLF</a> on Windows.
nativeNewline :: Newline

-- | Do no newline translation at all.
--   
--   <pre>
--   noNewlineTranslation  = NewlineMode { inputNL  = LF, outputNL = LF }
--   </pre>
noNewlineTranslation :: NewlineMode

-- | Map '\r\n' into '\n' on input, and '\n' to the native newline
--   represetnation on output. This mode can be used on any platform, and
--   works with text files using any newline convention. The downside is
--   that <tt>readFile &gt;&gt;= writeFile</tt> might yield a different
--   file.
--   
--   <pre>
--   universalNewlineMode  = NewlineMode { inputNL  = CRLF,
--                                         outputNL = nativeNewline }
--   </pre>
universalNewlineMode :: NewlineMode

-- | Use the native newline representation on both input and output
--   
--   <pre>
--   nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline
--                                      outputNL = nativeNewline }
--   </pre>
nativeNewlineMode :: NewlineMode

-- | <a>hShow</a> is in the <a>IO</a> monad, and gives more comprehensive
--   output than the (pure) instance of <a>Show</a> for <a>Handle</a>.
hShow :: Handle -> IO String

-- | Computation <a>hWaitForInput</a> <tt>hdl t</tt> waits until input is
--   available on handle <tt>hdl</tt>. It returns <a>True</a> as soon as
--   input is available on <tt>hdl</tt>, or <a>False</a> if no input is
--   available within <tt>t</tt> milliseconds. Note that
--   <a>hWaitForInput</a> waits until one or more full <i>characters</i>
--   are available, which means that it needs to do decoding, and hence may
--   fail with a decoding error.
--   
--   If <tt>t</tt> is less than zero, then <tt>hWaitForInput</tt> waits
--   indefinitely.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   <li>a decoding error, if the input begins with an invalid byte
--   sequence in this Handle's encoding.</li>
--   </ul>
--   
--   NOTE for GHC users: unless you use the <tt>-threaded</tt> flag,
--   <tt>hWaitForInput hdl t</tt> where <tt>t &gt;= 0</tt> will block all
--   other Haskell threads for the duration of the call. It behaves like a
--   <tt>safe</tt> foreign call in this respect.
hWaitForInput :: Handle -> Int -> IO Bool

-- | Computation <a>hGetChar</a> <tt>hdl</tt> reads a character from the
--   file or channel managed by <tt>hdl</tt>, blocking until a character is
--   available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetChar :: Handle -> IO Char

-- | Computation <a>hGetLine</a> <tt>hdl</tt> reads a line from the file or
--   channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file is encountered when reading
--   the <i>first</i> character of the line.</li>
--   </ul>
--   
--   If <a>hGetLine</a> encounters end-of-file at any other point while
--   reading in a line, it is treated as a line terminator and the
--   (partial) line is returned.
hGetLine :: Handle -> IO String

-- | Computation <a>hGetContents</a> <tt>hdl</tt> returns the list of
--   characters corresponding to the unread portion of the channel or file
--   managed by <tt>hdl</tt>, which is put into an intermediate state,
--   <i>semi-closed</i>. In this state, <tt>hdl</tt> is effectively closed,
--   but items are read from <tt>hdl</tt> on demand and accumulated in a
--   special list returned by <a>hGetContents</a> <tt>hdl</tt>.
--   
--   Any operation that fails because a handle is closed, also fails if a
--   handle is semi-closed. The only exception is <tt>hClose</tt>. A
--   semi-closed handle becomes closed:
--   
--   <ul>
--   <li>if <tt>hClose</tt> is applied to it;</li>
--   <li>if an I/O error occurs when reading an item from the handle;</li>
--   <li>or once the entire contents of the handle has been read.</li>
--   </ul>
--   
--   Once a semi-closed handle becomes closed, the contents of the
--   associated list becomes fixed. The contents of this final list is only
--   partially specified: it will contain at least all the items of the
--   stream that were evaluated prior to the handle becoming closed.
--   
--   Any I/O errors encountered while a handle is semi-closed are simply
--   discarded.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetContents :: Handle -> IO String

-- | Computation <a>hPutChar</a> <tt>hdl ch</tt> writes the character
--   <tt>ch</tt> to the file or channel managed by <tt>hdl</tt>. Characters
--   may be buffered if buffering is enabled for <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutChar :: Handle -> Char -> IO ()

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()

-- | <a>hGetBuf</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is reached
--   or <tt>count</tt> 8-bit bytes have been read. It returns the number of
--   bytes actually read. This may be zero if EOF was reached before any
--   data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBuf</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBuf</a> will behave as if EOF was reached.
--   
--   <a>hGetBuf</a> ignores the prevailing <tt>TextEncoding</tt> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBuf :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufNonBlocking</a> <tt>hdl buf count</tt> reads data from the
--   handle <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is
--   reached, or <tt>count</tt> 8-bit bytes have been read, or there is no
--   more data available to read immediately.
--   
--   <a>hGetBufNonBlocking</a> is identical to <a>hGetBuf</a>, except that
--   it will never block waiting for data to become available, instead it
--   returns only whatever data is available. To wait for data to arrive
--   before calling <a>hGetBufNonBlocking</a>, use <a>hWaitForInput</a>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufNonBlocking</a> will behave as if EOF was reached.
--   
--   <a>hGetBufNonBlocking</a> ignores the prevailing <tt>TextEncoding</tt>
--   and <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
--   
--   NOTE: on Windows, this function does not work correctly; it behaves
--   identically to <a>hGetBuf</a>.
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hPutBuf</a> <tt>hdl buf count</tt> writes <tt>count</tt> 8-bit
--   bytes from the buffer <tt>buf</tt> to the handle <tt>hdl</tt>. It
--   returns ().
--   
--   <a>hPutBuf</a> ignores any text encoding that applies to the
--   <a>Handle</a>, writing the bytes directly to the underlying file or
--   device.
--   
--   <a>hPutBuf</a> ignores the prevailing <tt>TextEncoding</tt> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and writes bytes directly.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>ResourceVanished</a> if the handle is a pipe or socket, and the
--   reading end is closed. (If this is a POSIX system, and the program has
--   not asked to ignore SIGPIPE, then a SIGPIPE may be delivered instead,
--   whose default action is to terminate the program).</li>
--   </ul>
hPutBuf :: Handle -> Ptr a -> Int -> IO ()
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
instance GHC.Classes.Eq GHC.IO.Handle.HandlePosn
instance GHC.Show.Show GHC.IO.Handle.HandlePosn


-- | The standard IO library.
module System.IO

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
data IO a

-- | The implementation of <tt>mfix</tt> for <a>IO</a>. If the function
--   passed to <a>fixIO</a> inspects its argument, the resulting action
--   will throw <a>FixIOException</a>.
fixIO :: (a -> IO a) -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle

-- | A handle managing input from the Haskell program's standard input
--   channel.
stdin :: Handle

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | A handle managing output to the Haskell program's standard error
--   channel.
stderr :: Handle

-- | <tt><a>withFile</a> name mode act</tt> opens a file using
--   <a>openFile</a> and passes the resulting handle to the computation
--   <tt>act</tt>. The handle will be closed on exit from <a>withFile</a>,
--   whether by normal termination or by raising an exception. If closing
--   the handle raises an exception, then this exception will be raised by
--   <a>withFile</a> rather than any exception raised by <tt>act</tt>.
withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

-- | Computation <a>openFile</a> <tt>file mode</tt> allocates and returns a
--   new, open handle to manage the file <tt>file</tt>. It manages input if
--   <tt>mode</tt> is <a>ReadMode</a>, output if <tt>mode</tt> is
--   <a>WriteMode</a> or <a>AppendMode</a>, and both input and output if
--   mode is <a>ReadWriteMode</a>.
--   
--   If the file does not exist and it is opened for output, it should be
--   created as a new file. If <tt>mode</tt> is <a>WriteMode</a> and the
--   file already exists, then it should be truncated to zero length. Some
--   operating systems delete empty files, so there is no guarantee that
--   the file will exist following an <a>openFile</a> with <tt>mode</tt>
--   <a>WriteMode</a> unless it is subsequently written to successfully.
--   The handle is positioned at the end of the file if <tt>mode</tt> is
--   <a>AppendMode</a>, and otherwise at the beginning (in which case its
--   internal position is 0). The initial buffer mode is
--   implementation-dependent.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isAlreadyInUseError</tt> if the file is already open and
--   cannot be reopened;</li>
--   <li><tt>isDoesNotExistError</tt> if the file does not exist or (on
--   POSIX systems) is a FIFO without a reader and <a>WriteMode</a> was
--   requested; or</li>
--   <li><tt>isPermissionError</tt> if the user does not have permission to
--   open the file.</li>
--   </ul>
--   
--   Note: if you will be working with files containing binary data, you'll
--   want to be using <a>openBinaryFile</a>.
openFile :: FilePath -> IOMode -> IO Handle

-- | See <a>openFile</a>
data IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode

-- | Computation <a>hClose</a> <tt>hdl</tt> makes handle <tt>hdl</tt>
--   closed. Before the computation finishes, if <tt>hdl</tt> is writable
--   its buffer is flushed as for <a>hFlush</a>. Performing <a>hClose</a>
--   on a handle that has already been closed has no effect; doing so is
--   not an error. All other operations on a closed handle will fail. If
--   <a>hClose</a> fails for any reason, any further operations (apart from
--   <a>hClose</a>) on the handle will still fail as if <tt>hdl</tt> had
--   been successfully closed.
hClose :: Handle -> IO ()

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | For a handle <tt>hdl</tt> which attached to a physical file,
--   <a>hFileSize</a> <tt>hdl</tt> returns the size of that file in 8-bit
--   bytes.
hFileSize :: Handle -> IO Integer

-- | <a>hSetFileSize</a> <tt>hdl</tt> <tt>size</tt> truncates the physical
--   file with handle <tt>hdl</tt> to <tt>size</tt> bytes.
hSetFileSize :: Handle -> Integer -> IO ()

-- | For a readable handle <tt>hdl</tt>, <a>hIsEOF</a> <tt>hdl</tt> returns
--   <a>True</a> if no further input can be taken from <tt>hdl</tt> or for
--   a physical file, if the current I/O position is equal to the length of
--   the file. Otherwise, it returns <a>False</a>.
--   
--   NOTE: <a>hIsEOF</a> may block, because it has to attempt to read from
--   the stream to determine whether there is any more data to be read.
hIsEOF :: Handle -> IO Bool

-- | The computation <a>isEOF</a> is identical to <a>hIsEOF</a>, except
--   that it works only on <a>stdin</a>.
isEOF :: IO Bool

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode

-- | Computation <a>hSetBuffering</a> <tt>hdl mode</tt> sets the mode of
--   buffering for handle <tt>hdl</tt> on subsequent reads and writes.
--   
--   If the buffer mode is changed from <a>BlockBuffering</a> or
--   <a>LineBuffering</a> to <a>NoBuffering</a>, then
--   
--   <ul>
--   <li>if <tt>hdl</tt> is writable, the buffer is flushed as for
--   <a>hFlush</a>;</li>
--   <li>if <tt>hdl</tt> is not writable, the contents of the buffer is
--   discarded.</li>
--   </ul>
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isPermissionError</tt> if the handle has already been used for
--   reading or writing and the implementation does not allow the buffering
--   mode to be changed.</li>
--   </ul>
hSetBuffering :: Handle -> BufferMode -> IO ()

-- | Computation <a>hGetBuffering</a> <tt>hdl</tt> returns the current
--   buffering mode for <tt>hdl</tt>.
hGetBuffering :: Handle -> IO BufferMode

-- | The action <a>hFlush</a> <tt>hdl</tt> causes any items buffered for
--   output in handle <tt>hdl</tt> to be sent immediately to the operating
--   system.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isFullError</tt> if the device is full;</li>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded. It is unspecified whether the characters in the buffer are
--   discarded or retained under these circumstances.</li>
--   </ul>
hFlush :: Handle -> IO ()

-- | Computation <a>hGetPosn</a> <tt>hdl</tt> returns the current I/O
--   position of <tt>hdl</tt> as a value of the abstract type
--   <a>HandlePosn</a>.
hGetPosn :: Handle -> IO HandlePosn

-- | If a call to <a>hGetPosn</a> <tt>hdl</tt> returns a position
--   <tt>p</tt>, then computation <a>hSetPosn</a> <tt>p</tt> sets the
--   position of <tt>hdl</tt> to the position it held at the time of the
--   call to <a>hGetPosn</a>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSetPosn :: HandlePosn -> IO ()
data HandlePosn

-- | Computation <a>hSeek</a> <tt>hdl mode i</tt> sets the position of
--   handle <tt>hdl</tt> depending on <tt>mode</tt>. The offset <tt>i</tt>
--   is given in terms of 8-bit bytes.
--   
--   If <tt>hdl</tt> is block- or line-buffered, then seeking to a position
--   which is not in the current buffer will first cause any items in the
--   output buffer to be written to the device, and then cause the input
--   buffer to be discarded. Some handles may not be seekable (see
--   <a>hIsSeekable</a>), or only support a subset of the possible
--   positioning operations (for instance, it may only be possible to seek
--   to the end of a tape, or to a positive offset from the beginning or
--   current position). It is not possible to set a negative I/O position,
--   or for a physical file, an I/O position beyond the current
--   end-of-file.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isIllegalOperationError</tt> if the Handle is not seekable, or
--   does not support the requested seek mode.</li>
--   <li><tt>isPermissionError</tt> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSeek :: Handle -> SeekMode -> Integer -> IO ()

-- | A mode that determines the effect of <tt>hSeek</tt> <tt>hdl mode
--   i</tt>.
data SeekMode

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode

-- | Computation <a>hTell</a> <tt>hdl</tt> returns the current position of
--   the handle <tt>hdl</tt>, as the number of bytes from the beginning of
--   the file. The value returned may be subsequently passed to
--   <a>hSeek</a> to reposition the handle to the current position.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isIllegalOperationError</tt> if the Handle is not
--   seekable.</li>
--   </ul>
hTell :: Handle -> IO Integer
hIsOpen :: Handle -> IO Bool
hIsClosed :: Handle -> IO Bool
hIsReadable :: Handle -> IO Bool
hIsWritable :: Handle -> IO Bool
hIsSeekable :: Handle -> IO Bool

-- | Is the handle connected to a terminal?
hIsTerminalDevice :: Handle -> IO Bool

-- | Set the echoing status of a handle connected to a terminal.
hSetEcho :: Handle -> Bool -> IO ()

-- | Get the echoing status of a handle connected to a terminal.
hGetEcho :: Handle -> IO Bool

-- | <a>hShow</a> is in the <a>IO</a> monad, and gives more comprehensive
--   output than the (pure) instance of <a>Show</a> for <a>Handle</a>.
hShow :: Handle -> IO String

-- | Computation <a>hWaitForInput</a> <tt>hdl t</tt> waits until input is
--   available on handle <tt>hdl</tt>. It returns <a>True</a> as soon as
--   input is available on <tt>hdl</tt>, or <a>False</a> if no input is
--   available within <tt>t</tt> milliseconds. Note that
--   <a>hWaitForInput</a> waits until one or more full <i>characters</i>
--   are available, which means that it needs to do decoding, and hence may
--   fail with a decoding error.
--   
--   If <tt>t</tt> is less than zero, then <tt>hWaitForInput</tt> waits
--   indefinitely.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   <li>a decoding error, if the input begins with an invalid byte
--   sequence in this Handle's encoding.</li>
--   </ul>
--   
--   NOTE for GHC users: unless you use the <tt>-threaded</tt> flag,
--   <tt>hWaitForInput hdl t</tt> where <tt>t &gt;= 0</tt> will block all
--   other Haskell threads for the duration of the call. It behaves like a
--   <tt>safe</tt> foreign call in this respect.
hWaitForInput :: Handle -> Int -> IO Bool

-- | Computation <a>hReady</a> <tt>hdl</tt> indicates whether at least one
--   item is available for input from handle <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hReady :: Handle -> IO Bool

-- | Computation <a>hGetChar</a> <tt>hdl</tt> reads a character from the
--   file or channel managed by <tt>hdl</tt>, blocking until a character is
--   available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetChar :: Handle -> IO Char

-- | Computation <a>hGetLine</a> <tt>hdl</tt> reads a line from the file or
--   channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file is encountered when reading
--   the <i>first</i> character of the line.</li>
--   </ul>
--   
--   If <a>hGetLine</a> encounters end-of-file at any other point while
--   reading in a line, it is treated as a line terminator and the
--   (partial) line is returned.
hGetLine :: Handle -> IO String

-- | Computation <a>hLookAhead</a> returns the next character from the
--   handle without removing it from the input buffer, blocking until a
--   character is available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><tt>isEOFError</tt> if the end of file has been reached.</li>
--   </ul>
hLookAhead :: Handle -> IO Char

-- | Computation <a>hGetContents</a> <tt>hdl</tt> returns the list of
--   characters corresponding to the unread portion of the channel or file
--   managed by <tt>hdl</tt>, which is put into an intermediate state,
--   <i>semi-closed</i>. In this state, <tt>hdl</tt> is effectively closed,
--   but items are read from <tt>hdl</tt> on demand and accumulated in a
--   special list returned by <a>hGetContents</a> <tt>hdl</tt>.
--   
--   Any operation that fails because a handle is closed, also fails if a
--   handle is semi-closed. The only exception is <tt>hClose</tt>. A
--   semi-closed handle becomes closed:
--   
--   <ul>
--   <li>if <tt>hClose</tt> is applied to it;</li>
--   <li>if an I/O error occurs when reading an item from the handle;</li>
--   <li>or once the entire contents of the handle has been read.</li>
--   </ul>
--   
--   Once a semi-closed handle becomes closed, the contents of the
--   associated list becomes fixed. The contents of this final list is only
--   partially specified: it will contain at least all the items of the
--   stream that were evaluated prior to the handle becoming closed.
--   
--   Any I/O errors encountered while a handle is semi-closed are simply
--   discarded.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetContents :: Handle -> IO String

-- | Computation <a>hPutChar</a> <tt>hdl ch</tt> writes the character
--   <tt>ch</tt> to the file or channel managed by <tt>hdl</tt>. Characters
--   may be buffered if buffering is enabled for <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutChar :: Handle -> Char -> IO ()

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()

-- | The same as <a>hPutStr</a>, but adds a newline character.
hPutStrLn :: Handle -> String -> IO ()

-- | Computation <a>hPrint</a> <tt>hdl t</tt> writes the string
--   representation of <tt>t</tt> given by the <a>shows</a> function to the
--   file or channel managed by <tt>hdl</tt> and appends a newline.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPrint :: Show a => Handle -> a -> IO ()

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | <tt><a>withBinaryFile</a> name mode act</tt> opens a file using
--   <a>openBinaryFile</a> and passes the resulting handle to the
--   computation <tt>act</tt>. The handle will be closed on exit from
--   <a>withBinaryFile</a>, whether by normal termination or by raising an
--   exception.
withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

-- | Like <a>openFile</a>, but open the file in binary mode. On Windows,
--   reading a file in text mode (which is the default) will translate CRLF
--   to LF, and writing will translate LF to CRLF. This is usually what you
--   want with text files. With binary files this is undesirable; also, as
--   usual under Microsoft operating systems, text mode treats control-Z as
--   EOF. Binary mode turns off all special treatment of end-of-line and
--   end-of-file characters. (See also <a>hSetBinaryMode</a>.)
openBinaryFile :: FilePath -> IOMode -> IO Handle

-- | Select binary mode (<a>True</a>) or text mode (<a>False</a>) on a open
--   handle. (See also <a>openBinaryFile</a>.)
--   
--   This has the same effect as calling <a>hSetEncoding</a> with
--   <a>char8</a>, together with <a>hSetNewlineMode</a> with
--   <a>noNewlineTranslation</a>.
hSetBinaryMode :: Handle -> Bool -> IO ()

-- | <a>hPutBuf</a> <tt>hdl buf count</tt> writes <tt>count</tt> 8-bit
--   bytes from the buffer <tt>buf</tt> to the handle <tt>hdl</tt>. It
--   returns ().
--   
--   <a>hPutBuf</a> ignores any text encoding that applies to the
--   <a>Handle</a>, writing the bytes directly to the underlying file or
--   device.
--   
--   <a>hPutBuf</a> ignores the prevailing <tt>TextEncoding</tt> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and writes bytes directly.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>ResourceVanished</a> if the handle is a pipe or socket, and the
--   reading end is closed. (If this is a POSIX system, and the program has
--   not asked to ignore SIGPIPE, then a SIGPIPE may be delivered instead,
--   whose default action is to terminate the program).</li>
--   </ul>
hPutBuf :: Handle -> Ptr a -> Int -> IO ()

-- | <a>hGetBuf</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is reached
--   or <tt>count</tt> 8-bit bytes have been read. It returns the number of
--   bytes actually read. This may be zero if EOF was reached before any
--   data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBuf</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBuf</a> will behave as if EOF was reached.
--   
--   <a>hGetBuf</a> ignores the prevailing <tt>TextEncoding</tt> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBuf :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufSome</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt>. If there is any data
--   available to read, then <a>hGetBufSome</a> returns it immediately; it
--   only blocks if there is no data to be read.
--   
--   It returns the number of bytes actually read. This may be zero if EOF
--   was reached before any data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBufSome</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufSome</a> will behave as if EOF was reached.
--   
--   <a>hGetBufSome</a> ignores the prevailing <tt>TextEncoding</tt> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBufSome :: Handle -> Ptr a -> Int -> IO Int
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufNonBlocking</a> <tt>hdl buf count</tt> reads data from the
--   handle <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is
--   reached, or <tt>count</tt> 8-bit bytes have been read, or there is no
--   more data available to read immediately.
--   
--   <a>hGetBufNonBlocking</a> is identical to <a>hGetBuf</a>, except that
--   it will never block waiting for data to become available, instead it
--   returns only whatever data is available. To wait for data to arrive
--   before calling <a>hGetBufNonBlocking</a>, use <a>hWaitForInput</a>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufNonBlocking</a> will behave as if EOF was reached.
--   
--   <a>hGetBufNonBlocking</a> ignores the prevailing <tt>TextEncoding</tt>
--   and <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
--   
--   NOTE: on Windows, this function does not work correctly; it behaves
--   identically to <a>hGetBuf</a>.
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | The function creates a temporary file in ReadWrite mode. The created
--   file isn't deleted automatically, so you need to delete it manually.
--   
--   The file is created with permissions such that only the current user
--   can read/write it.
--   
--   With some exceptions (see below), the file will be created securely in
--   the sense that an attacker should not be able to cause openTempFile to
--   overwrite another file on the filesystem using your credentials, by
--   putting symbolic links (on Unix) in the place where the temporary file
--   is to be created. On Unix the <tt>O_CREAT</tt> and <tt>O_EXCL</tt>
--   flags are used to prevent this attack, but note that <tt>O_EXCL</tt>
--   is sometimes not supported on NFS filesystems, so if you rely on this
--   behaviour it is best to use local filesystems only.
openTempFile :: FilePath -> String -> IO (FilePath, Handle)

-- | Like <a>openTempFile</a>, but opens the file in binary mode. See
--   <a>openBinaryFile</a> for more comments.
openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)

-- | Like <a>openTempFile</a>, but uses the default file permissions
openTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)

-- | Like <a>openBinaryTempFile</a>, but uses the default file permissions
openBinaryTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)

-- | The action <a>hSetEncoding</a> <tt>hdl</tt> <tt>encoding</tt> changes
--   the text encoding for the handle <tt>hdl</tt> to <tt>encoding</tt>.
--   The default encoding when a <a>Handle</a> is created is
--   <tt>localeEncoding</tt>, namely the default encoding for the current
--   locale.
--   
--   To create a <a>Handle</a> with no encoding at all, use
--   <a>openBinaryFile</a>. To stop further encoding or decoding on an
--   existing <a>Handle</a>, use <a>hSetBinaryMode</a>.
--   
--   <a>hSetEncoding</a> may need to flush buffered data in order to change
--   the encoding.
hSetEncoding :: Handle -> TextEncoding -> IO ()

-- | Return the current <a>TextEncoding</a> for the specified
--   <a>Handle</a>, or <a>Nothing</a> if the <a>Handle</a> is in binary
--   mode.
--   
--   Note that the <a>TextEncoding</a> remembers nothing about the state of
--   the encoder/decoder in use on this <a>Handle</a>. For example, if the
--   encoding in use is UTF-16, then using <a>hGetEncoding</a> and
--   <a>hSetEncoding</a> to save and restore the encoding may result in an
--   extra byte-order-mark being written to the file.
hGetEncoding :: Handle -> IO (Maybe TextEncoding)

-- | A <a>TextEncoding</a> is a specification of a conversion scheme
--   between sequences of bytes and sequences of Unicode characters.
--   
--   For example, UTF-8 is an encoding of Unicode characters into a
--   sequence of bytes. The <a>TextEncoding</a> for UTF-8 is <tt>utf8</tt>.
data TextEncoding

-- | The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to
--   the first 256 Unicode code points, and is thus not a complete Unicode
--   encoding. An attempt to write a character greater than '\255' to a
--   <tt>Handle</tt> using the <a>latin1</a> encoding will result in an
--   error.
latin1 :: TextEncoding

-- | The UTF-8 Unicode encoding
utf8 :: TextEncoding

-- | The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte
--   sequence 0xEF 0xBB 0xBF). This encoding behaves like <a>utf8</a>,
--   except that on input, the BOM sequence is ignored at the beginning of
--   the stream, and on output, the BOM sequence is prepended.
--   
--   The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes
--   used to identify the encoding of a file.
utf8_bom :: TextEncoding

-- | The UTF-16 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf16 :: TextEncoding

-- | The UTF-16 Unicode encoding (litte-endian)
utf16le :: TextEncoding

-- | The UTF-16 Unicode encoding (big-endian)
utf16be :: TextEncoding

-- | The UTF-32 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf32 :: TextEncoding

-- | The UTF-32 Unicode encoding (litte-endian)
utf32le :: TextEncoding

-- | The UTF-32 Unicode encoding (big-endian)
utf32be :: TextEncoding

-- | The Unicode encoding of the current locale
--   
--   This is the initial locale encoding: if it has been subsequently
--   changed by <a>setLocaleEncoding</a> this value will not reflect that
--   change.
localeEncoding :: TextEncoding

-- | An encoding in which Unicode code points are translated to bytes by
--   taking the code point modulo 256. When decoding, bytes are translated
--   directly into the equivalent code point.
--   
--   This encoding never fails in either direction. However, encoding
--   discards information, so encode followed by decode is not the
--   identity.
char8 :: TextEncoding

-- | Look up the named Unicode encoding. May fail with
--   
--   <ul>
--   <li><tt>isDoesNotExistError</tt> if the encoding is unknown</li>
--   </ul>
--   
--   The set of known encodings is system-dependent, but includes at least:
--   
--   <ul>
--   <li><pre>UTF-8</pre></li>
--   <li><tt>UTF-16</tt>, <tt>UTF-16BE</tt>, <tt>UTF-16LE</tt></li>
--   <li><tt>UTF-32</tt>, <tt>UTF-32BE</tt>, <tt>UTF-32LE</tt></li>
--   </ul>
--   
--   There is additional notation (borrowed from GNU iconv) for specifying
--   how illegal characters are handled:
--   
--   <ul>
--   <li>a suffix of <tt>//IGNORE</tt>, e.g. <tt>UTF-8//IGNORE</tt>, will
--   cause all illegal sequences on input to be ignored, and on output will
--   drop all code points that have no representation in the target
--   encoding.</li>
--   <li>a suffix of <tt>//TRANSLIT</tt> will choose a replacement
--   character for illegal sequences or code points.</li>
--   <li>a suffix of <tt>//ROUNDTRIP</tt> will use a PEP383-style escape
--   mechanism to represent any invalid bytes in the input as Unicode
--   codepoints (specifically, as lone surrogates, which are normally
--   invalid in UTF-32). Upon output, these special codepoints are detected
--   and turned back into the corresponding original byte.</li>
--   </ul>
--   
--   In theory, this mechanism allows arbitrary data to be roundtripped via
--   a <a>String</a> with no loss of data. In practice, there are two
--   limitations to be aware of:
--   
--   <ol>
--   <li>This only stands a chance of working for an encoding which is an
--   ASCII superset, as for security reasons we refuse to escape any bytes
--   smaller than 128. Many encodings of interest are ASCII supersets (in
--   particular, you can assume that the locale encoding is an ASCII
--   superset) but many (such as UTF-16) are not.</li>
--   <li>If the underlying encoding is not itself roundtrippable, this
--   mechanism can fail. Roundtrippable encodings are those which have an
--   injective mapping into Unicode. Almost all encodings meet this
--   criteria, but some do not. Notably, Shift-JIS (CP932) and Big5 contain
--   several different encodings of the same Unicode codepoint.</li>
--   </ol>
--   
--   On Windows, you can access supported code pages with the prefix
--   <tt>CP</tt>; for example, <tt>"CP1250"</tt>.
mkTextEncoding :: String -> IO TextEncoding

-- | Set the <a>NewlineMode</a> on the specified <a>Handle</a>. All
--   buffered data is flushed first.
hSetNewlineMode :: Handle -> NewlineMode -> IO ()

-- | The representation of a newline in the external file or stream.
data Newline

-- | '\n'
LF :: Newline

-- | '\r\n'
CRLF :: Newline

-- | The native newline representation for the current platform: <a>LF</a>
--   on Unix systems, <a>CRLF</a> on Windows.
nativeNewline :: Newline

-- | Specifies the translation, if any, of newline characters between
--   internal Strings and the external file or stream. Haskell Strings are
--   assumed to represent newlines with the '\n' character; the newline
--   mode specifies how to translate '\n' on output, and what to translate
--   into '\n' on input.
data NewlineMode
NewlineMode :: Newline -> Newline -> NewlineMode

-- | the representation of newlines on input
[inputNL] :: NewlineMode -> Newline

-- | the representation of newlines on output
[outputNL] :: NewlineMode -> Newline

-- | Do no newline translation at all.
--   
--   <pre>
--   noNewlineTranslation  = NewlineMode { inputNL  = LF, outputNL = LF }
--   </pre>
noNewlineTranslation :: NewlineMode

-- | Map '\r\n' into '\n' on input, and '\n' to the native newline
--   represetnation on output. This mode can be used on any platform, and
--   works with text files using any newline convention. The downside is
--   that <tt>readFile &gt;&gt;= writeFile</tt> might yield a different
--   file.
--   
--   <pre>
--   universalNewlineMode  = NewlineMode { inputNL  = CRLF,
--                                         outputNL = nativeNewline }
--   </pre>
universalNewlineMode :: NewlineMode

-- | Use the native newline representation on both input and output
--   
--   <pre>
--   nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline
--                                      outputNL = nativeNewline }
--   </pre>
nativeNewlineMode :: NewlineMode

module GHC.Fingerprint
data Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
fingerprint0 :: Fingerprint
fingerprintData :: Ptr Word8 -> Int -> IO Fingerprint
fingerprintString :: String -> Fingerprint
fingerprintFingerprints :: [Fingerprint] -> Fingerprint

-- | Computes the hash of a given file. This function loops over the
--   handle, running in constant memory.
getFileHash :: FilePath -> IO Fingerprint


-- | Monadic fixpoints.
--   
--   For a detailed discussion, see Levent Erkok's thesis, <i>Value
--   Recursion in Monadic Computations</i>, Oregon Graduate Institute,
--   2002.
module Control.Monad.Fix

-- | Monads having fixed points with a 'knot-tying' semantics. Instances of
--   <a>MonadFix</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i><i>purity</i></i> <tt><a>mfix</a> (<tt>return</tt> . h) =
--   <tt>return</tt> (<a>fix</a> h)</tt></li>
--   <li><i><i>left shrinking</i> (or <i>tightening</i>)</i>
--   <tt><a>mfix</a> (\x -&gt; a &gt;&gt;= \y -&gt; f x y) = a &gt;&gt;= \y
--   -&gt; <a>mfix</a> (\x -&gt; f x y)</tt></li>
--   <li><i><i>sliding</i></i> <tt><a>mfix</a> (<a>liftM</a> h . f) =
--   <a>liftM</a> h (<a>mfix</a> (f . h))</tt>, for strict <tt>h</tt>.</li>
--   <li><i><i>nesting</i></i> <tt><a>mfix</a> (\x -&gt; <a>mfix</a> (\y
--   -&gt; f x y)) = <a>mfix</a> (\x -&gt; f x x)</tt></li>
--   </ul>
--   
--   This class is used in the translation of the recursive <tt>do</tt>
--   notation supported by GHC and Hugs.
class (Monad m) => MonadFix m

-- | The fixed point of a monadic computation. <tt><a>mfix</a> f</tt>
--   executes the action <tt>f</tt> only once, with the eventual output fed
--   back as the input. Hence <tt>f</tt> should not be strict, for then
--   <tt><a>mfix</a> f</tt> would diverge.
mfix :: MonadFix m => (a -> m a) -> m a

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <tt>fix'</tt> argument, hence the recursion is reintroduced.
fix :: (a -> a) -> a
instance Control.Monad.Fix.MonadFix GHC.Maybe.Maybe
instance Control.Monad.Fix.MonadFix []
instance Control.Monad.Fix.MonadFix GHC.Base.NonEmpty
instance Control.Monad.Fix.MonadFix GHC.Types.IO
instance Control.Monad.Fix.MonadFix ((->) r)
instance Control.Monad.Fix.MonadFix (Data.Either.Either e)
instance Control.Monad.Fix.MonadFix (GHC.ST.ST s)
instance Control.Monad.Fix.MonadFix Data.Semigroup.Internal.Dual
instance Control.Monad.Fix.MonadFix Data.Semigroup.Internal.Sum
instance Control.Monad.Fix.MonadFix Data.Semigroup.Internal.Product
instance Control.Monad.Fix.MonadFix Data.Monoid.First
instance Control.Monad.Fix.MonadFix Data.Monoid.Last
instance Control.Monad.Fix.MonadFix f => Control.Monad.Fix.MonadFix (Data.Semigroup.Internal.Alt f)
instance Control.Monad.Fix.MonadFix f => Control.Monad.Fix.MonadFix (Data.Monoid.Ap f)
instance Control.Monad.Fix.MonadFix GHC.Generics.Par1
instance Control.Monad.Fix.MonadFix f => Control.Monad.Fix.MonadFix (GHC.Generics.Rec1 f)
instance Control.Monad.Fix.MonadFix f => Control.Monad.Fix.MonadFix (GHC.Generics.M1 i c f)
instance (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) => Control.Monad.Fix.MonadFix (f GHC.Generics.:*: g)
instance Control.Monad.Fix.MonadFix Data.Ord.Down


-- | The identity functor and monad.
--   
--   This trivial type constructor serves two purposes:
--   
--   <ul>
--   <li>It can be used with functions parameterized by functor or monad
--   classes.</li>
--   <li>It can be used as a base monad to which a series of monad
--   transformers may be applied to construct a composite monad. Most monad
--   transformer modules include the special case of applying the
--   transformer to <a>Identity</a>. For example, <tt>State s</tt> is an
--   abbreviation for <tt>StateT s <a>Identity</a></tt>.</li>
--   </ul>
module Data.Functor.Identity

-- | Identity functor and monad. (a non-strict monad)
newtype Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Functor.Identity.Identity a)
instance GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Functor.Identity.Identity a)
instance GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Functor.Identity.Identity a)
instance GHC.Real.Real a => GHC.Real.Real (Data.Functor.Identity.Identity a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Functor.Identity.Identity a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Functor.Identity.Identity a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Identity.Identity a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Identity.Identity a)
instance GHC.Arr.Ix a => GHC.Arr.Ix (Data.Functor.Identity.Identity a)
instance GHC.Real.Integral a => GHC.Real.Integral (Data.Functor.Identity.Identity a)
instance GHC.Generics.Generic1 Data.Functor.Identity.Identity
instance GHC.Generics.Generic (Data.Functor.Identity.Identity a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Identity.Identity a)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Identity.Identity a)
instance Data.Bits.FiniteBits a => Data.Bits.FiniteBits (Data.Functor.Identity.Identity a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Functor.Identity.Identity a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Functor.Identity.Identity a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Functor.Identity.Identity a)
instance Data.Bits.Bits a => Data.Bits.Bits (Data.Functor.Identity.Identity a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Functor.Identity.Identity a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Functor.Identity.Identity a)
instance Data.Foldable.Foldable Data.Functor.Identity.Identity
instance GHC.Base.Functor Data.Functor.Identity.Identity
instance GHC.Base.Applicative Data.Functor.Identity.Identity
instance GHC.Base.Monad Data.Functor.Identity.Identity
instance Control.Monad.Fix.MonadFix Data.Functor.Identity.Identity


-- | Basic arrow definitions, based on
--   
--   <ul>
--   <li><i>Generalising Monads to Arrows</i>, by John Hughes, <i>Science
--   of Computer Programming</i> 37, pp67-111, May 2000.</li>
--   </ul>
--   
--   plus a couple of definitions (<a>returnA</a> and <a>loop</a>) from
--   
--   <ul>
--   <li><i>A New Notation for Arrows</i>, by Ross Paterson, in <i>ICFP
--   2001</i>, Firenze, Italy, pp229-240.</li>
--   </ul>
--   
--   These papers and more information on arrows can be found at
--   <a>http://www.haskell.org/arrows/</a>.
module Control.Arrow

-- | The basic arrow class.
--   
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>arr</a> id = <a>id</a></pre></li>
--   <li><pre><a>arr</a> (f &gt;&gt;&gt; g) = <a>arr</a> f &gt;&gt;&gt;
--   <a>arr</a> g</pre></li>
--   <li><pre><a>first</a> (<a>arr</a> f) = <a>arr</a> (<a>first</a>
--   f)</pre></li>
--   <li><pre><a>first</a> (f &gt;&gt;&gt; g) = <a>first</a> f &gt;&gt;&gt;
--   <a>first</a> g</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> <a>fst</a> =
--   <a>arr</a> <a>fst</a> &gt;&gt;&gt; f</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> (<a>id</a> *** g) =
--   <a>arr</a> (<a>id</a> *** g) &gt;&gt;&gt; <a>first</a> f</pre></li>
--   <li><pre><a>first</a> (<a>first</a> f) &gt;&gt;&gt; <a>arr</a>
--   <tt>assoc</tt> = <a>arr</a> <tt>assoc</tt> &gt;&gt;&gt; <a>first</a>
--   f</pre></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assoc ((a,b),c) = (a,(b,c))
--   </pre>
--   
--   The other combinators have sensible default definitions, which may be
--   overridden for efficiency.
class Category a => Arrow a

-- | Lift a function to an arrow.
arr :: Arrow a => (b -> c) -> a b c

-- | Send the first component of the input through the argument arrow, and
--   copy the rest unchanged to the output.
first :: Arrow a => a b c -> a (b, d) (c, d)

-- | A mirror image of <a>first</a>.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
second :: Arrow a => a b c -> a (d, b) (d, c)

-- | Split the input between the two argument arrows and combine their
--   output. Note that this is in general not a functor.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
infixr 3 ***
infixr 3 &&&

-- | Kleisli arrows of a monad.
newtype Kleisli m a b
Kleisli :: (a -> m b) -> Kleisli m a b
[runKleisli] :: Kleisli m a b -> a -> m b

-- | The identity arrow, which plays the role of <a>return</a> in arrow
--   notation.
returnA :: Arrow a => a b b

-- | Precomposition with a pure function.
(^>>) :: Arrow a => (b -> c) -> a c d -> a b d
infixr 1 ^>>

-- | Postcomposition with a pure function.
(>>^) :: Arrow a => a b c -> (c -> d) -> a b d
infixr 1 >>^

-- | Left-to-right composition
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>

-- | Right-to-left composition
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
infixr 1 <<<

-- | Precomposition with a pure function (right-to-left variant).
(<<^) :: Arrow a => a c d -> (b -> c) -> a b d
infixr 1 <<^

-- | Postcomposition with a pure function (right-to-left variant).
(^<<) :: Arrow a => (c -> d) -> a b c -> a b d
infixr 1 ^<<
class Arrow a => ArrowZero a
zeroArrow :: ArrowZero a => a b c

-- | A monoid on arrows.
class ArrowZero a => ArrowPlus a

-- | An associative operation with identity <a>zeroArrow</a>.
(<+>) :: ArrowPlus a => a b c -> a b c -> a b c
infixr 5 <+>

-- | Choice, for arrows that support it. This class underlies the
--   <tt>if</tt> and <tt>case</tt> constructs in arrow notation.
--   
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>left</a> (<a>arr</a> f) = <a>arr</a> (<a>left</a>
--   f)</pre></li>
--   <li><pre><a>left</a> (f &gt;&gt;&gt; g) = <a>left</a> f &gt;&gt;&gt;
--   <a>left</a> g</pre></li>
--   <li><pre>f &gt;&gt;&gt; <a>arr</a> <a>Left</a> = <a>arr</a>
--   <a>Left</a> &gt;&gt;&gt; <a>left</a> f</pre></li>
--   <li><pre><a>left</a> f &gt;&gt;&gt; <a>arr</a> (<a>id</a> +++ g) =
--   <a>arr</a> (<a>id</a> +++ g) &gt;&gt;&gt; <a>left</a> f</pre></li>
--   <li><pre><a>left</a> (<a>left</a> f) &gt;&gt;&gt; <a>arr</a>
--   <tt>assocsum</tt> = <a>arr</a> <tt>assocsum</tt> &gt;&gt;&gt;
--   <a>left</a> f</pre></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assocsum (Left (Left x)) = Left x
--   assocsum (Left (Right y)) = Right (Left y)
--   assocsum (Right z) = Right (Right z)
--   </pre>
--   
--   The other combinators have sensible default definitions, which may be
--   overridden for efficiency.
class Arrow a => ArrowChoice a

-- | Feed marked inputs through the argument arrow, passing the rest
--   through unchanged to the output.
left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)

-- | A mirror image of <a>left</a>.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
right :: ArrowChoice a => a b c -> a (Either d b) (Either d c)

-- | Split the input between the two argument arrows, retagging and merging
--   their outputs. Note that this is in general not a functor.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')

-- | Fanin: Split the input between the two argument arrows and merge their
--   outputs.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
infixr 2 |||
infixr 2 +++

-- | Some arrows allow application of arrow inputs to other inputs.
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>first</a> (<a>arr</a> (\x -&gt; <a>arr</a> (\y -&gt;
--   (x,y)))) &gt;&gt;&gt; <a>app</a> = <a>id</a></pre></li>
--   <li><pre><a>first</a> (<a>arr</a> (g &gt;&gt;&gt;)) &gt;&gt;&gt;
--   <a>app</a> = <a>second</a> g &gt;&gt;&gt; <a>app</a></pre></li>
--   <li><pre><a>first</a> (<a>arr</a> (&gt;&gt;&gt; h)) &gt;&gt;&gt;
--   <a>app</a> = <a>app</a> &gt;&gt;&gt; h</pre></li>
--   </ul>
--   
--   Such arrows are equivalent to monads (see <a>ArrowMonad</a>).
class Arrow a => ArrowApply a
app :: ArrowApply a => a (a b c, b) c

-- | The <a>ArrowApply</a> class is equivalent to <a>Monad</a>: any monad
--   gives rise to a <a>Kleisli</a> arrow, and any instance of
--   <a>ArrowApply</a> defines a monad.
newtype ArrowMonad a b
ArrowMonad :: a () b -> ArrowMonad a b

-- | Any instance of <a>ArrowApply</a> can be made into an instance of
--   <a>ArrowChoice</a> by defining <a>left</a> = <a>leftApp</a>.
leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)

-- | The <a>loop</a> operator expresses computations in which an output
--   value is fed back as input, although the computation occurs only once.
--   It underlies the <tt>rec</tt> value recursion construct in arrow
--   notation. <a>loop</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i><i>extension</i></i> <tt><a>loop</a> (<a>arr</a> f) =
--   <a>arr</a> (\ b -&gt; <a>fst</a> (<a>fix</a> (\ (c,d) -&gt; f
--   (b,d))))</tt></li>
--   <li><i><i>left tightening</i></i> <tt><a>loop</a> (<a>first</a> h
--   &gt;&gt;&gt; f) = h &gt;&gt;&gt; <a>loop</a> f</tt></li>
--   <li><i><i>right tightening</i></i> <tt><a>loop</a> (f &gt;&gt;&gt;
--   <a>first</a> h) = <a>loop</a> f &gt;&gt;&gt; h</tt></li>
--   <li><i><i>sliding</i></i> <tt><a>loop</a> (f &gt;&gt;&gt; <a>arr</a>
--   (<a>id</a> *** k)) = <a>loop</a> (<a>arr</a> (<a>id</a> *** k)
--   &gt;&gt;&gt; f)</tt></li>
--   <li><i><i>vanishing</i></i> <tt><a>loop</a> (<a>loop</a> f) =
--   <a>loop</a> (<a>arr</a> unassoc &gt;&gt;&gt; f &gt;&gt;&gt; <a>arr</a>
--   assoc)</tt></li>
--   <li><i><i>superposing</i></i> <tt><a>second</a> (<a>loop</a> f) =
--   <a>loop</a> (<a>arr</a> assoc &gt;&gt;&gt; <a>second</a> f
--   &gt;&gt;&gt; <a>arr</a> unassoc)</tt></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assoc ((a,b),c) = (a,(b,c))
--   unassoc (a,(b,c)) = ((a,b),c)
--   </pre>
class Arrow a => ArrowLoop a
loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
instance Control.Arrow.ArrowLoop (->)
instance Control.Monad.Fix.MonadFix m => Control.Arrow.ArrowLoop (Control.Arrow.Kleisli m)
instance Control.Arrow.Arrow a => GHC.Base.Functor (Control.Arrow.ArrowMonad a)
instance Control.Arrow.Arrow a => GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
instance Control.Arrow.ArrowApply a => GHC.Base.Monad (Control.Arrow.ArrowMonad a)
instance Control.Arrow.ArrowPlus a => GHC.Base.Alternative (Control.Arrow.ArrowMonad a)
instance (Control.Arrow.ArrowApply a, Control.Arrow.ArrowPlus a) => GHC.Base.MonadPlus (Control.Arrow.ArrowMonad a)
instance Control.Arrow.ArrowApply (->)
instance GHC.Base.Monad m => Control.Arrow.ArrowApply (Control.Arrow.Kleisli m)
instance Control.Arrow.ArrowChoice (->)
instance GHC.Base.Monad m => Control.Arrow.ArrowChoice (Control.Arrow.Kleisli m)
instance GHC.Base.MonadPlus m => Control.Arrow.ArrowPlus (Control.Arrow.Kleisli m)
instance GHC.Base.MonadPlus m => Control.Arrow.ArrowZero (Control.Arrow.Kleisli m)
instance GHC.Base.Monad m => Control.Category.Category (Control.Arrow.Kleisli m)
instance GHC.Base.Monad m => Control.Arrow.Arrow (Control.Arrow.Kleisli m)
instance Control.Arrow.Arrow (->)


-- | This module describes a structure intermediate between a functor and a
--   monad (technically, a strong lax monoidal functor). Compared with
--   monads, this interface lacks the full power of the binding operation
--   <a>&gt;&gt;=</a>, but
--   
--   <ul>
--   <li>it has more instances.</li>
--   <li>it is sufficient for many uses, e.g. context-free parsing, or the
--   <a>Traversable</a> class.</li>
--   <li>instances can perform analysis of computations before they are
--   executed, and thus produce shared optimizations.</li>
--   </ul>
--   
--   This interface was introduced for parsers by Niklas Röjemo, because it
--   admits more sharing than the monadic interface. The names here are
--   mostly based on parsing work by Doaitse Swierstra.
--   
--   For more details, see <a>Applicative Programming with Effects</a>, by
--   Conor McBride and Ross Paterson.
module Control.Applicative

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <tt>&lt;$&gt;</tt> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i><i>identity</i></i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</pre></li>
--   <li><i><i>composition</i></i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i><i>homomorphism</i></i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i><i>interchange</i></i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative f

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <tt>&lt;$&gt;</tt> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative f

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | The <a>Const</a> functor.
newtype Const a b
Const :: a -> Const a b
[getConst] :: Const a b -> a
newtype WrappedMonad m a
WrapMonad :: m a -> WrappedMonad m a
[unwrapMonad] :: WrappedMonad m a -> m a
newtype WrappedArrow a b c
WrapArrow :: a b c -> WrappedArrow a b c
[unwrapArrow] :: WrappedArrow a b c -> a b c

-- | Lists, but with an <a>Applicative</a> functor based on zipping.
newtype ZipList a
ZipList :: [a] -> ZipList a
[getZipList] :: ZipList a -> [a]

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <tt>$</tt>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <tt>$</tt> is function application, <a>&lt;$&gt;</a> is
--   function application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | Lift a function to actions. This function may be used as a value for
--   <a>fmap</a> in a <a>Functor</a> instance.
liftA :: Applicative f => (a -> b) -> f a -> f b

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | One or none.
optional :: Alternative f => f a -> f (Maybe a)
instance GHC.Generics.Generic1 Control.Applicative.ZipList
instance GHC.Generics.Generic (Control.Applicative.ZipList a)
instance Data.Foldable.Foldable Control.Applicative.ZipList
instance GHC.Base.Functor Control.Applicative.ZipList
instance GHC.Read.Read a => GHC.Read.Read (Control.Applicative.ZipList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Control.Applicative.ZipList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Control.Applicative.ZipList a)
instance GHC.Show.Show a => GHC.Show.Show (Control.Applicative.ZipList a)
instance GHC.Generics.Generic1 (Control.Applicative.WrappedArrow a b)
instance GHC.Generics.Generic (Control.Applicative.WrappedArrow a b c)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Applicative.WrappedMonad m)
instance GHC.Generics.Generic1 (Control.Applicative.WrappedMonad m)
instance GHC.Generics.Generic (Control.Applicative.WrappedMonad m a)
instance GHC.Base.Applicative Control.Applicative.ZipList
instance GHC.Base.Alternative Control.Applicative.ZipList
instance Control.Arrow.Arrow a => GHC.Base.Functor (Control.Applicative.WrappedArrow a b)
instance Control.Arrow.Arrow a => GHC.Base.Applicative (Control.Applicative.WrappedArrow a b)
instance (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) => GHC.Base.Alternative (Control.Applicative.WrappedArrow a b)
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Applicative.WrappedMonad m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
instance GHC.Base.MonadPlus m => GHC.Base.Alternative (Control.Applicative.WrappedMonad m)


-- | Class of data structures that can be traversed from left to right,
--   performing an action on each element.
--   
--   See also
--   
--   <ul>
--   <li>"Applicative Programming with Effects", by Conor McBride and Ross
--   Paterson, <i>Journal of Functional Programming</i> 18:1 (2008) 1-13,
--   online at
--   <a>http://www.soi.city.ac.uk/~ross/papers/Applicative.html</a>.</li>
--   <li>"The Essence of the Iterator Pattern", by Jeremy Gibbons and Bruno
--   Oliveira, in <i>Mathematically-Structured Functional Programming</i>,
--   2006, online at
--   <a>http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/#iterator</a>.</li>
--   <li>"An Investigation of the Laws of Traversals", by Mauro Jaskelioff
--   and Ondrej Rypacek, in <i>Mathematically-Structured Functional
--   Programming</i>, 2012, online at
--   <a>http://arxiv.org/pdf/1202.2919</a>.</li>
--   </ul>
module Data.Traversable

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>traverse</a> f =
--   <a>traverse</a> (t . f)</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>traverse</a> Identity =
--   Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>traverse</a> (Compose .
--   <a>fmap</a> g . f) = Compose . <a>fmap</a> (<a>traverse</a> g) .
--   <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>sequenceA</a> =
--   <a>sequenceA</a> . <a>fmap</a> t</tt> for every applicative
--   transformation <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>sequenceA</a> . <a>fmap</a> Identity
--   = Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>sequenceA</a> . <a>fmap</a>
--   Compose = Compose . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <ul>
--   <li><pre>t (<a>pure</a> x) = <a>pure</a> x</pre></li>
--   <li><pre>t (x <a>&lt;*&gt;</a> y) = t x <a>&lt;*&gt;</a> t
--   y</pre></li>
--   </ul>
--   
--   and the identity functor <tt>Identity</tt> and composition of functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity a
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Identity where
--     pure x = Identity x
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure x = Compose (pure (pure x))
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable t

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | <a>for</a> is <a>traverse</a> with its arguments flipped. For a
--   version that ignores the results see <a>for_</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <tt>foldl</tt>; it applies a function to each element
--   of a structure, passing an accumulating parameter from left to right,
--   and returning a final value of this accumulator together with the new
--   structure.
mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <tt>foldr</tt>; it applies a function to each element
--   of a structure, passing an accumulating parameter from right to left,
--   and returning a final value of this accumulator together with the new
--   structure.
mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | This function may be used as a value for <a>fmap</a> in a
--   <a>Functor</a> instance, provided that <a>traverse</a> is defined.
--   (Using <a>fmapDefault</a> with a <a>Traversable</a> instance defined
--   only by <a>sequenceA</a> will result in infinite recursion.)
--   
--   <pre>
--   <a>fmapDefault</a> f ≡ <a>runIdentity</a> . <a>traverse</a> (<a>Identity</a> . f)
--   </pre>
fmapDefault :: forall t a b. Traversable t => (a -> b) -> t a -> t b

-- | This function may be used as a value for <a>foldMap</a> in a
--   <a>Foldable</a> instance.
--   
--   <pre>
--   <a>foldMapDefault</a> f ≡ <a>getConst</a> . <a>traverse</a> (<a>Const</a> . f)
--   </pre>
foldMapDefault :: forall t m a. (Traversable t, Monoid m) => (a -> m) -> t a -> m
instance Data.Traversable.Traversable Data.Functor.Identity.Identity
instance Data.Traversable.Traversable GHC.Generics.V1
instance Data.Traversable.Traversable GHC.Generics.Par1
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (GHC.Generics.Rec1 f)
instance Data.Traversable.Traversable (GHC.Generics.K1 i c)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (GHC.Generics.M1 i c f)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (f GHC.Generics.:+: g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (f GHC.Generics.:*: g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (f GHC.Generics.:.: g)
instance Data.Traversable.Traversable (GHC.Generics.URec (GHC.Ptr.Ptr ()))
instance Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Char)
instance Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Double)
instance Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Float)
instance Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Int)
instance Data.Traversable.Traversable (GHC.Generics.URec GHC.Types.Word)
instance Data.Traversable.Traversable Data.Ord.Down
instance Data.Traversable.Traversable GHC.Maybe.Maybe
instance Data.Traversable.Traversable []
instance Data.Traversable.Traversable GHC.Base.NonEmpty
instance Data.Traversable.Traversable (Data.Either.Either a)
instance Data.Traversable.Traversable ((,) a)
instance GHC.Arr.Ix i => Data.Traversable.Traversable (GHC.Arr.Array i)
instance Data.Traversable.Traversable Data.Proxy.Proxy
instance Data.Traversable.Traversable (Data.Functor.Const.Const m)
instance Data.Traversable.Traversable Data.Semigroup.Internal.Dual
instance Data.Traversable.Traversable Data.Semigroup.Internal.Sum
instance Data.Traversable.Traversable Data.Semigroup.Internal.Product
instance Data.Traversable.Traversable Data.Monoid.First
instance Data.Traversable.Traversable Data.Monoid.Last
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Data.Semigroup.Internal.Alt f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Data.Monoid.Ap f)
instance Data.Traversable.Traversable Control.Applicative.ZipList
instance Data.Traversable.Traversable GHC.Generics.U1


-- | Operations on lists.
module Data.List

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | Extract the first element of a list, which must be non-empty.
head :: [a] -> a

-- | Extract the last element of a list, which must be finite and
--   non-empty.
last :: [a] -> a

-- | Extract the elements after the head of a list, which must be
--   non-empty.
tail :: [a] -> [a]

-- | Return all the elements of a list except the last one. The list must
--   be non-empty.
init :: [a] -> [a]

-- | Decompose a list into its head and tail. If the list is empty, returns
--   <a>Nothing</a>. If the list is non-empty, returns <tt><a>Just</a> (x,
--   xs)</tt>, where <tt>x</tt> is the head of the list and <tt>xs</tt> its
--   tail.
uncons :: [a] -> Maybe (a, [a])

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | <a>map</a> <tt>f xs</tt> is the list obtained by applying <tt>f</tt>
--   to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | The <a>intersperse</a> function takes an element and a list and
--   `intersperses' that element between the elements of the list. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; intersperse ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
intersperse :: a -> [a] -> [a]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[10,11],[20],[],[30,31,32]]
--   [[10,20,30],[11,31],[32]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; subsequences "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: [a] -> [[a]]

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl'</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl'</a> instead of <a>foldl</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>z <tt>f</tt>
--   x1</tt> in the above example) before applying them to the operator
--   (e.g. to <tt>(<tt>f</tt> x2)</tt>). This results in a thunk chain
--   <tt>O(n)</tt> elements long, which then must be evaluated from the
--   outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <a>length</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A strict version of <a>foldl1</a>
foldl1' :: (a -> a -> a) -> [a] -> a

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t, Num a) => t a -> a

-- | The largest element of a non-empty structure.
maximum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
minimum :: forall a. (Foldable t, Ord a) => t a -> a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | A strictly accumulating version of <a>scanl</a>
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <tt>foldl</tt>; it applies a function to each element
--   of a structure, passing an accumulating parameter from left to right,
--   and returning a final value of this accumulator together with the new
--   structure.
mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <tt>foldr</tt>; it applies a function to each element
--   of a structure, passing an accumulating parameter from right to left,
--   and returning a final value of this accumulator together with the new
--   structure.
mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See 'iterate\''
--   for a strict variant of this function.
iterate :: (a -> a) -> a -> [a]

-- | 'iterate\'' is the strict version of <a>iterate</a>.
--   
--   It ensures that the result of each application of force to weak head
--   normal form before proceeding.
iterate' :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | The <a>dropWhileEnd</a> function drops the largest suffix of a list in
--   which the given predicate holds for all elements. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo\n"
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo bar"
--   "foo bar"
--   </pre>
--   
--   <pre>
--   dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined
--   </pre>
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | The <a>stripPrefix</a> function drops the given prefix from a list. It
--   returns <a>Nothing</a> if the list did not start with the prefix
--   given, or <a>Just</a> the list after the prefix, if it does.
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foobar"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foo"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoobaz"
--   Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result contains only equal elements. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Eq a => [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
inits :: [a] -> [[a]]

-- | The <a>tails</a> function returns all final segments of the argument,
--   longest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc","bc","c",""]
--   </pre>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
tails :: [a] -> [[a]]

-- | The <a>isPrefixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a prefix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. The second list must be
--   finite.
--   
--   <pre>
--   &gt;&gt;&gt; "ld!" `isSuffixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "World" `isSuffixOf` "Hello World!"
--   False
--   </pre>
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Haskell" "I really like Haskell."
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Ial" "I really like Haskell."
--   False
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSubsequenceOf</a> function takes two lists and returns
--   <a>True</a> if all the elements of the first list occur, in order, in
--   the second. The elements do not have to occur consecutively.
--   
--   <tt><a>isSubsequenceOf</a> x y</tt> is equivalent to <tt><a>elem</a> x
--   (<a>subsequences</a> y)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; isSubsequenceOf "GHC" "The Glorious Haskell Compiler"
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf ['a','d'..'z'] ['a'..'z']
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf [1..10] [10,9..0]
--   False
--   </pre>
isSubsequenceOf :: Eq a => [a] -> [a] -> Bool

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `elem`

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | <a>lookup</a> <tt>key assocs</tt> looks up a key in an association
--   list.
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
find :: Foldable t => (a -> Bool) -> t a -> Maybe a

-- | <a>filter</a>, applied to a predicate and a list, returns the list of
--   those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate a list and returns the
--   pair of lists of elements which do and do not satisfy the predicate,
--   respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partition (`elem` "aeiou") "Hello World!"
--   ("eoo","Hll Wrld!")
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 4 [0..]
--   Just 4
--   </pre>
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 'o' "Hello World"
--   [4,7]
--   </pre>
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; findIndex isSpace "Hello World!"
--   Just 5
--   </pre>
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (`elem` "aeiou") "Hello World!"
--   [1,4,7]
--   </pre>
findIndices :: (a -> Bool) -> [a] -> [Int]

-- | <a>zip</a> takes two lists and returns a list of corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums.
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | <i>O(n^2)</i>. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
--   
--   <pre>
--   &gt;&gt;&gt; nub [1,2,3,4,3,2,1,2,4,3,5]
--   [1,2,3,4,5]
--   </pre>
nub :: Eq a => [a] -> [a]

-- | <a>delete</a> <tt>x</tt> removes the first occurrence of <tt>x</tt>
--   from its list argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; delete 'a' "banana"
--   "bnana"
--   </pre>
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
delete :: Eq a => a -> [a] -> [a]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus
--   
--   <pre>
--   (xs ++ ys) \\ xs == ys.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello World!" \\ "ell W"
--   "Hoorld!"
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
(\\) :: Eq a => [a] -> [a] -> [a]
infix 5 \\

-- | The <a>union</a> function returns the list union of the two lists. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; "dog" `union` "cow"
--   "dogcw"
--   </pre>
--   
--   Duplicates, and elements of the first list, are removed from the the
--   second list, but if the first list contains duplicates, so will the
--   result. It is a special case of <a>unionBy</a>, which allows the
--   programmer to supply their own equality test.
union :: Eq a => [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] `intersect` [2,4,6,8]
--   [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,2,3,4] `intersect` [6,4,4,2]
--   [2,2,4]
--   </pre>
--   
--   It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. If the element is found
--   in both the first and the second list, the element from the first list
--   will be used.
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from from lowest to highest, keeping duplicates
--   in the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
sort :: Ord a => [a] -> [a]

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt>sortOn f</tt> is equivalent to <tt>sortBy (comparing
--   f)</tt>, but has the performance advantage of only evaluating
--   <tt>f</tt> once for each element in the input list. This is called the
--   decorate-sort-undecorate paradigm, or Schwartzian transform.
--   
--   Elements are arranged from from lowest to highest, keeping duplicates
--   in the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | The <a>insert</a> function takes an element and a list and inserts the
--   element into the list at the first position where it is less than or
--   equal to the next element. In particular, if the list is sorted before
--   the call, the result will also be sorted. It is a special case of
--   <a>insertBy</a>, which allows the programmer to supply their own
--   comparison function.
--   
--   <pre>
--   &gt;&gt;&gt; insert 4 [1,2,3,5,6,7]
--   [1,2,3,4,5,6,7]
--   </pre>
insert :: Ord a => a -> [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
--   [1,2,6]
--   </pre>
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | The <a>deleteBy</a> function behaves like <a>delete</a>, but takes a
--   user-supplied equality predicate.
--   
--   <pre>
--   &gt;&gt;&gt; deleteBy (&lt;=) 4 [1..10]
--   [1,2,3,5,6,7,8,9,10]
--   </pre>
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | The <a>deleteFirstsBy</a> function takes a predicate and two lists and
--   returns the first list with the first occurrence of each element of
--   the second list removed.
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>.
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | The non-overloaded version of <a>insert</a>.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The <a>genericLength</a> function is an overloaded version of
--   <a>length</a>. In particular, instead of returning an <a>Int</a>, it
--   returns any type which is an instance of <a>Num</a>. It is, however,
--   less efficient than <a>length</a>.
genericLength :: Num i => [a] -> i

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | The <a>genericIndex</a> function is an overloaded version of
--   <a>!!</a>, which accepts any <a>Integral</a> value as the index.
genericIndex :: Integral i => [a] -> i -> a

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]


-- | Functions for tracing and monitoring execution.
--   
--   These can be useful for investigating bugs or performance problems.
--   They should <i>not</i> be used in production code.
module Debug.Trace

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   "calling f with x = 123
--   123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: String -> a -> a

-- | Like <a>trace</a> but returns the message instead of a third value.
--   
--   <pre>
--   &gt;&gt;&gt; traceId "hello"
--   "hello
--   hello"
--   </pre>
traceId :: String -> String

-- | Like <a>trace</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   This makes it convenient for printing the values of interesting
--   variables or expressions inside a function. For example here we print
--   the value of the variables <tt>x</tt> and <tt>y</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let f x y = traceShow (x,y) (x + y) in f (1+2) 5
--   (3,5)
--   8
--   </pre>
traceShow :: Show a => a -> b -> b

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowId (1+2+3, "hello" ++ "world")
--   (6,"helloworld")
--   (6,"helloworld")
--   </pre>
traceShowId :: Show a => a -> a

-- | like <a>trace</a>, but additionally prints a call stack if one is
--   available.
--   
--   In the current GHC implementation, the call stack is only available if
--   the program was compiled with <tt>-prof</tt>; otherwise
--   <a>traceStack</a> behaves exactly like <a>trace</a>. Entries in the
--   call stack correspond to <tt>SCC</tt> annotations, so it is a good
--   idea to use <tt>-fprof-auto</tt> or <tt>-fprof-auto-calls</tt> to add
--   SCC annotations automatically.
traceStack :: String -> a -> a

-- | The <a>traceIO</a> function outputs the trace message from the IO
--   monad. This sequences the output with respect to other IO actions.
traceIO :: String -> IO ()

-- | Like <a>trace</a> but returning unit in an arbitrary
--   <a>Applicative</a> context. Allows for convenient use in do-notation.
--   
--   Note that the application of <a>traceM</a> is not an action in the
--   <a>Applicative</a> context, as <a>traceIO</a> is in the <a>IO</a>
--   type. While the fresh bindings in the following example will force the
--   <a>traceM</a> expressions to be reduced every time the
--   <tt>do</tt>-block is executed, <tt>traceM "not crashed"</tt> would
--   only be reduced once, and the message would only be printed once. If
--   your monad is in <tt>MonadIO</tt>, <tt>liftIO . traceIO</tt> may be a
--   better option.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceM ("x: " ++ show x)
--       y &lt;- pure 12
--       traceM ("y: " ++ show y)
--       pure (x*2 + y)
--   :}
--   x: 3
--   y: 12
--   Just 18
--   </pre>
traceM :: Applicative f => String -> f ()

-- | Like <a>traceM</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceShowM x
--       y &lt;- pure 12
--       traceShowM y
--       pure (x*2 + y)
--   :}
--   3
--   12
--   Just 18
--   </pre>
traceShowM :: (Show a, Applicative f) => a -> f ()


-- | <i>Deprecated: Use <a>traceIO</a></i>
putTraceMsg :: String -> IO ()

-- | The <a>traceEvent</a> function behaves like <a>trace</a> with the
--   difference that the message is emitted to the eventlog, if eventlog
--   profiling is available and enabled at runtime.
--   
--   It is suitable for use in pure code. In an IO context use
--   <a>traceEventIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceEvent</a>.
traceEvent :: String -> a -> a

-- | The <a>traceEventIO</a> function emits a message to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceEvent</a>, <a>traceEventIO</a> sequences the event
--   with respect to other IO actions.
traceEventIO :: String -> IO ()

-- | The <a>traceMarker</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime. The
--   <tt>String</tt> is the name of the marker. The name is just used in
--   the profiling tools to help you keep clear which marker is which.
--   
--   This function is suitable for use in pure code. In an IO context use
--   <a>traceMarkerIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceMarker</a>.
traceMarker :: String -> a -> a

-- | The <a>traceMarkerIO</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceMarker</a>, <a>traceMarkerIO</a> sequences the
--   event with respect to other IO actions.
traceMarkerIO :: String -> IO ()


-- | The <tt>String</tt> type and associated operations.
module Data.String

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String
instance Data.String.IsString a => Data.String.IsString (Data.Functor.Const.Const a b)
instance Data.String.IsString a => Data.String.IsString (Data.Functor.Identity.Identity a)
instance (a Data.Type.Equality.~ GHC.Types.Char) => Data.String.IsString [a]


-- | A general library for representation and manipulation of versions.
--   
--   Versioning schemes are many and varied, so the version representation
--   provided by this library is intended to be a compromise between
--   complete generality, where almost no common functionality could
--   reasonably be provided, and fixing a particular versioning scheme,
--   which would probably be too restrictive.
--   
--   So the approach taken here is to provide a representation which
--   subsumes many of the versioning schemes commonly in use, and we
--   provide implementations of <a>Eq</a>, <a>Ord</a> and conversion
--   to/from <a>String</a> which will be appropriate for some applications,
--   but not all.
module Data.Version

-- | A <a>Version</a> represents the version of a software entity.
--   
--   An instance of <a>Eq</a> is provided, which implements exact equality
--   modulo reordering of the tags in the <a>versionTags</a> field.
--   
--   An instance of <a>Ord</a> is also provided, which gives lexicographic
--   ordering on the <a>versionBranch</a> fields (i.e. 2.1 &gt; 2.0, 1.2.3
--   &gt; 1.2.2, etc.). This is expected to be sufficient for many uses,
--   but note that you may need to use a more specific ordering for your
--   versioning scheme. For example, some versioning schemes may include
--   pre-releases which have tags <tt>"pre1"</tt>, <tt>"pre2"</tt>, and so
--   on, and these would need to be taken into account when determining
--   ordering. In some cases, date ordering may be more appropriate, so the
--   application would have to look for <tt>date</tt> tags in the
--   <a>versionTags</a> field and compare those. The bottom line is, don't
--   always assume that <a>compare</a> and other <a>Ord</a> operations are
--   the right thing for every <a>Version</a>.
--   
--   Similarly, concrete representations of versions may differ. One
--   possible concrete representation is provided (see <a>showVersion</a>
--   and <a>parseVersion</a>), but depending on the application a different
--   concrete representation may be more appropriate.
data Version
Version :: [Int] -> [String] -> Version

-- | The numeric branch for this version. This reflects the fact that most
--   software versions are tree-structured; there is a main trunk which is
--   tagged with versions at various points (1,2,3...), and the first
--   branch off the trunk after version 3 is 3.1, the second branch off the
--   trunk after version 3 is 3.2, and so on. The tree can be branched
--   arbitrarily, just by adding more digits.
--   
--   We represent the branch as a list of <a>Int</a>, so version 3.2.1
--   becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of
--   <a>Ord</a> for <tt>[Int]</tt>) gives the natural ordering of branches.
[versionBranch] :: Version -> [Int]

-- | A version can be tagged with an arbitrary list of strings. The
--   interpretation of the list of tags is entirely dependent on the entity
--   that this version applies to.

-- | <i>Deprecated: See GHC ticket #2496</i>
[versionTags] :: Version -> [String]

-- | Provides one possible concrete representation for <a>Version</a>. For
--   a version with <a>versionBranch</a> <tt>= [1,2,3]</tt> and
--   <a>versionTags</a> <tt>= ["tag1","tag2"]</tt>, the output will be
--   <tt>1.2.3-tag1-tag2</tt>.
showVersion :: Version -> String

-- | A parser for versions in the format produced by <a>showVersion</a>.
parseVersion :: ReadP Version

-- | Construct tag-less <a>Version</a>
makeVersion :: [Int] -> Version
instance GHC.Generics.Generic Data.Version.Version
instance GHC.Show.Show Data.Version.Version
instance GHC.Read.Read Data.Version.Version
instance GHC.Classes.Eq Data.Version.Version
instance GHC.Classes.Ord Data.Version.Version


-- | The <a>Functor</a>, <a>Monad</a> and <a>MonadPlus</a> classes, with
--   some useful operations on monads.
module Control.Monad

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor f
fmap :: Functor f => (a -> b) -> f a -> f b

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>return</a> a <a>&gt;&gt;=</a> k = k a</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> <a>return</a> = m</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> (\x -&gt; k x <a>&gt;&gt;=</a> h) = (m
--   <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a> h</pre></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad m

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: forall a b. Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: forall a b. Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Fail with a message. This operation is not part of the mathematical
--   definition of a monad, but is invoked on pattern-match failure in a
--   <tt>do</tt> expression.
--   
--   As part of the MonadFail proposal (MFP), this function is moved to its
--   own class <tt>MonadFail</tt> (see <a>Control.Monad.Fail</a> for more
--   details). The definition here will be removed in a future release.
fail :: Monad m => String -> m a
infixl 1 >>=
infixl 1 >>

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus m

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   As of base 4.8.0.0, <a>forM_</a> is just <a>for_</a>, specialized to
--   <a>Monad</a>.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Left-to-right composition of Kleisli arrows.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
forever :: Applicative f => f a -> f b

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with
--   unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with unit, resulting in an <tt><tt>Either</tt>
--   <tt>Int</tt> '()'</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | The sum of a collection of actions, generalizing <a>concat</a>. As of
--   base 4.8.0.0, <a>msum</a> is just <a>asum</a>, specialized to
--   <a>MonadPlus</a>.
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | This generalizes the list-based <tt>filter</tt> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state-transforming monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>foldM</a> function is analogous to <tt>foldl</tt>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>n</tt> times,
--   gathering the results.
replicateM :: Applicative m => Int -> m a -> m [a]

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>


-- | The Prelude: a standard module. The Prelude is imported by default
--   into all Haskell modules unless either there is an explicit import
--   statement for it, or the NoImplicitPrelude extension is enabled.
module Prelude
data Bool
False :: Bool
True :: Bool

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <tt>error</tt>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <tt>show</tt> to a <tt>Maybe Int</tt>. If we have <tt>Just
--   n</tt>, we want to show the underlying <a>Int</a> <tt>n</tt>. But if
--   we have <a>Nothing</a>, we return the empty string instead of (for
--   example) "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <tt>length</tt> function (if we have a <a>String</a>) or the
--   "times-two" function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 <
infix 4 <=
infix 4 >=
infix 4 >

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | Invariant: <a>Jn#</a> and <a>Jp#</a> are used iff value doesn't fit in
--   <a>S#</a>
--   
--   Useful properties resulting from the invariants:
--   
--   <ul>
--   <li><pre>abs (<a>S#</a> _) &lt;= abs (<a>Jp#</a> _)</pre></li>
--   <li><pre>abs (<a>S#</a> _) &lt; abs (<a>Jn#</a> _)</pre></li>
--   </ul>
data Integer

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However, '(+)' and
--   '(*)' are customarily expected to define a ring and have the following
--   properties:
--   
--   <ul>
--   <li><i><b>Associativity of (+)</b></i> <tt>(x + y) + z</tt> = <tt>x +
--   (y + z)</tt></li>
--   <li><i><b>Commutativity of (+)</b></i> <tt>x + y</tt> = <tt>y +
--   x</tt></li>
--   <li><i><b><tt>fromInteger 0</tt> is the additive identity</b></i>
--   <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of (*)</b></i> <tt>(x * y) * z</tt> = <tt>x *
--   (y * z)</tt></li>
--   <li><i><b><tt>fromInteger 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of (*) with respect to (+)</b></i> <tt>a * (b
--   + c)</tt> = <tt>(a * b) + (a * c)</tt> and <tt>(b + c) * a</tt> =
--   <tt>(b * a) + (c * a)</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <tt>Rational</tt> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 +
infixl 6 -
infixl 7 *
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the 'div'/'mod'
--   and 'quot'/'rem' pairs, given suitable Euclidean functions <tt>f</tt>
--   and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   '(+)' and '(*)' are customarily expected to define a division ring and
--   have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class (Num a) => Fractional a

-- | fractional division
(/) :: Fractional a => a -> a -> a

-- | reciprocal fraction
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   '(+)', '(*)' and <a>exp</a> are customarily expected to define an
--   exponential field and have the following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = @exp a * exp b</li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class (Fractional a) => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><tt>uncurry</tt> <a>encodeFloat</a> (<a>decodeFloat</a> x) =
--   x</tt>. <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a
even :: Integral a => a -> Bool
odd :: Integral a => a -> Bool

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the associativity law:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</pre></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> <a>mempty</a> = x</pre></li>
--   <li><pre><a>mempty</a> <a>&lt;&gt;</a> x = x</pre></li>
--   <li><tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a> law)</li>
--   <li><pre><a>mconcat</a> = <a>foldr</a> '(&lt;&gt;)'
--   <a>mempty</a></pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <tt>Sum</tt> and <tt>Product</tt>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = '(&lt;&gt;)'</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
mconcat :: Monoid a => [a] -> a

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor f
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <tt>$</tt>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <tt>$</tt> is function application, <a>&lt;$&gt;</a> is
--   function application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <tt>&lt;$&gt;</tt> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i><i>identity</i></i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</pre></li>
--   <li><i><i>composition</i></i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i><i>homomorphism</i></i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i><i>interchange</i></i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative f

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>return</a> a <a>&gt;&gt;=</a> k = k a</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> <a>return</a> = m</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> (\x -&gt; k x <a>&gt;&gt;=</a> h) = (m
--   <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a> h</pre></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad m

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: forall a b. Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: forall a b. Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Fail with a message. This operation is not part of the mathematical
--   definition of a monad, but is invoked on pattern-match failure in a
--   <tt>do</tt> expression.
--   
--   As part of the MonadFail proposal (MFP), this function is moved to its
--   own class <tt>MonadFail</tt> (see <a>Control.Monad.Fail</a> for more
--   details). The definition here will be removed in a future release.
fail :: Monad m => String -> m a
infixl 1 >>=
infixl 1 >>

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable t

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl'</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl'</a> instead of <a>foldl</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>z <tt>f</tt>
--   x1</tt> in the above example) before applying them to the operator
--   (e.g. to <tt>(<tt>f</tt> x2)</tt>). This results in a thunk chain
--   <tt>O(n)</tt> elements long, which then must be evaluated from the
--   outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
maximum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
minimum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>traverse</a> f =
--   <a>traverse</a> (t . f)</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>traverse</a> Identity =
--   Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>traverse</a> (Compose .
--   <a>fmap</a> g . f) = Compose . <a>fmap</a> (<a>traverse</a> g) .
--   <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>sequenceA</a> =
--   <a>sequenceA</a> . <a>fmap</a> t</tt> for every applicative
--   transformation <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>sequenceA</a> . <a>fmap</a> Identity
--   = Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>sequenceA</a> . <a>fmap</a>
--   Compose = Compose . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <ul>
--   <li><pre>t (<a>pure</a> x) = <a>pure</a> x</pre></li>
--   <li><pre>t (x <a>&lt;*&gt;</a> y) = t x <a>&lt;*&gt;</a> t
--   y</pre></li>
--   </ul>
--   
--   and the identity functor <tt>Identity</tt> and composition of functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity a
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Identity where
--     pure x = Identity x
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure x = Compose (pure (pure x))
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable t

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>($)</tt> is levity-polymorphic in its result type, so
--   that foo $ True where foo :: Bool -&gt; Int# is well-typed
($) :: forall r a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep). forall (a :: TYPE r). HasCallStack => [Char] -> a

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: forall (r :: RuntimeRep). forall (a :: TYPE r). [Char] -> a

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep). forall (a :: TYPE r). HasCallStack => a

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: () => a -> b -> b

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall r a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | <a>map</a> <tt>f xs</tt> is the list obtained by applying <tt>f</tt>
--   to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | <a>filter</a>, applied to a predicate and a list, returns the list of
--   those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | Extract the first element of a list, which must be non-empty.
head :: [a] -> a

-- | Extract the last element of a list, which must be finite and
--   non-empty.
last :: [a] -> a

-- | Extract the elements after the head of a list, which must be
--   non-empty.
tail :: [a] -> [a]

-- | Return all the elements of a list except the last one. The list must
--   be non-empty.
init :: [a] -> [a]

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See 'iterate\''
--   for a strict variant of this function.
iterate :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | <a>lookup</a> <tt>key assocs</tt> looks up a key in an association
--   list.
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | <a>zip</a> takes two lists and returns a list of corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums.
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
data IO a

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOException</a> instead of returning a
--   result. For a more general type of exception, including also those
--   that arise in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | Construct an <a>IOException</a> value with a string describing the
--   error. The <a>fail</a> method of the <a>IO</a> instance of the
--   <a>Monad</a> class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError


-- | The representations of the types <a>TyCon</a> and <a>TypeRep</a>, and
--   the function <a>mkTyCon</a> which is used by derived instances of
--   <a>Typeable</a> to construct <a>TyCon</a>s.
--   
--   Be warned, these functions can be used to construct ill-kinded type
--   representations.
module Type.Reflection.Unsafe

-- | A concrete representation of a (monomorphic) type. <a>TypeRep</a>
--   supports reasonably efficient equality.
data TypeRep (a :: k)

-- | Construct a representation for a type application.
mkTrApp :: forall k1 k2 (a :: k1 -> k2) (b :: k1). TypeRep (a :: k1 -> k2) -> TypeRep (b :: k1) -> TypeRep (a b)

-- | Exquisitely unsafe.
mkTyCon :: String -> String -> String -> Int -> KindRep -> TyCon

-- | Observe the <a>Fingerprint</a> of a type representation
typeRepFingerprint :: TypeRep a -> Fingerprint
someTypeRepFingerprint :: SomeTypeRep -> Fingerprint

-- | The representation produced by GHC for conjuring up the kind of a
--   <tt>TypeRep</tt>. See Note [Representing TyCon kinds: KindRep] in
--   TcTypeable.
data KindRep
KindRepTyConApp :: TyCon -> [KindRep] -> KindRep
KindRepVar :: !KindBndr -> KindRep
KindRepApp :: KindRep -> KindRep -> KindRep
KindRepFun :: KindRep -> KindRep -> KindRep
KindRepTYPE :: !RuntimeRep -> KindRep
KindRepTypeLitS :: TypeLitSort -> Addr# -> KindRep
KindRepTypeLitD :: TypeLitSort -> [Char] -> KindRep
pattern KindRepTypeLit :: TypeLitSort -> String -> KindRep
data TypeLitSort
TypeLitSymbol :: TypeLitSort
TypeLitNat :: TypeLitSort
data TyCon

-- | Construct a representation for a type constructor applied at a
--   monomorphic kind.
--   
--   Note that this is unsafe as it allows you to construct ill-kinded
--   types.
mkTrCon :: forall k (a :: k). TyCon -> [SomeTypeRep] -> TypeRep a
tyConKindRep :: TyCon -> KindRep
tyConKindArgs :: TyCon -> Int
tyConFingerprint :: TyCon -> Fingerprint


-- | Optional instance of <a>Show</a> for functions:
--   
--   <pre>
--   instance Show (a -&gt; b) where
--      showsPrec _ _ = showString \"\&lt;function\&gt;\"
--   </pre>
module Text.Show.Functions
instance GHC.Show.Show (a -> b)


-- | A C <tt>printf(3)</tt>-like formatter. This version has been extended
--   by Bart Massey as per the recommendations of John Meacham and Simon
--   Marlow
--   &lt;<a>http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726</a>&gt;
--   to support extensible formatting for new datatypes. It has also been
--   extended to support almost all C <tt>printf(3)</tt> syntax.
module Text.Printf

-- | Format a variable number of arguments with the C-style formatting
--   string.
--   
--   <pre>
--   &gt;&gt;&gt; printf "%s, %d, %.4f" "hello" 123 pi
--   hello, 123, 3.1416
--   </pre>
--   
--   The return value is either <a>String</a> or <tt>(<a>IO</a> a)</tt>
--   (which should be <tt>(<a>IO</a> '()')</tt>, but Haskell's type system
--   makes this hard).
--   
--   The format string consists of ordinary characters and <i>conversion
--   specifications</i>, which specify how to format one of the arguments
--   to <a>printf</a> in the output string. A format specification is
--   introduced by the <tt>%</tt> character; this character can be
--   self-escaped into the format string using <tt>%%</tt>. A format
--   specification ends with a /format character/ that provides the primary
--   information about how to format the value. The rest of the conversion
--   specification is optional. In order, one may have flag characters, a
--   width specifier, a precision specifier, and type-specific modifier
--   characters.
--   
--   Unlike C <tt>printf(3)</tt>, the formatting of this <a>printf</a> is
--   driven by the argument type; formatting is type specific. The types
--   formatted by <a>printf</a> "out of the box" are:
--   
--   <ul>
--   <li><a>Integral</a> types, including <a>Char</a></li>
--   <li><a>String</a></li>
--   <li><a>RealFloat</a> types</li>
--   </ul>
--   
--   <a>printf</a> is also extensible to support other types: see below.
--   
--   A conversion specification begins with the character <tt>%</tt>,
--   followed by zero or more of the following flags:
--   
--   <pre>
--   -      left adjust (default is right adjust)
--   +      always use a sign (+ or -) for signed conversions
--   space  leading space for positive numbers in signed conversions
--   0      pad with zeros rather than spaces
--   #      use an \"alternate form\": see below
--   </pre>
--   
--   When both flags are given, <tt>-</tt> overrides <tt>0</tt> and
--   <tt>+</tt> overrides space. A negative width specifier in a <tt>*</tt>
--   conversion is treated as positive but implies the left adjust flag.
--   
--   The "alternate form" for unsigned radix conversions is as in C
--   <tt>printf(3)</tt>:
--   
--   <pre>
--   %o           prefix with a leading 0 if needed
--   %x           prefix with a leading 0x if nonzero
--   %X           prefix with a leading 0X if nonzero
--   %b           prefix with a leading 0b if nonzero
--   %[eEfFgG]    ensure that the number contains a decimal point
--   </pre>
--   
--   Any flags are followed optionally by a field width:
--   
--   <pre>
--   num    field width
--   *      as num, but taken from argument list
--   </pre>
--   
--   The field width is a minimum, not a maximum: it will be expanded as
--   needed to avoid mutilating a value.
--   
--   Any field width is followed optionally by a precision:
--   
--   <pre>
--   .num   precision
--   .      same as .0
--   .*     as num, but taken from argument list
--   </pre>
--   
--   Negative precision is taken as 0. The meaning of the precision depends
--   on the conversion type.
--   
--   <pre>
--   Integral    minimum number of digits to show
--   RealFloat   number of digits after the decimal point
--   String      maximum number of characters
--   </pre>
--   
--   The precision for Integral types is accomplished by zero-padding. If
--   both precision and zero-pad are given for an Integral field, the
--   zero-pad is ignored.
--   
--   Any precision is followed optionally for Integral types by a width
--   modifier; the only use of this modifier being to set the implicit size
--   of the operand for conversion of a negative operand to unsigned:
--   
--   <pre>
--   hh     Int8
--   h      Int16
--   l      Int32
--   ll     Int64
--   L      Int64
--   </pre>
--   
--   The specification ends with a format character:
--   
--   <pre>
--   c      character               Integral
--   d      decimal                 Integral
--   o      octal                   Integral
--   x      hexadecimal             Integral
--   X      hexadecimal             Integral
--   b      binary                  Integral
--   u      unsigned decimal        Integral
--   f      floating point          RealFloat
--   F      floating point          RealFloat
--   g      general format float    RealFloat
--   G      general format float    RealFloat
--   e      exponent format float   RealFloat
--   E      exponent format float   RealFloat
--   s      string                  String
--   v      default format          any type
--   </pre>
--   
--   The "%v" specifier is provided for all built-in types, and should be
--   provided for user-defined type formatters as well. It picks a "best"
--   representation for the given type. For the built-in types the "%v"
--   specifier is converted as follows:
--   
--   <pre>
--   c      Char
--   u      other unsigned Integral
--   d      other signed Integral
--   g      RealFloat
--   s      String
--   </pre>
--   
--   Mismatch between the argument types and the format string, as well as
--   any other syntactic or semantic errors in the format string, will
--   cause an exception to be thrown at runtime.
--   
--   Note that the formatting for <a>RealFloat</a> types is currently a bit
--   different from that of C <tt>printf(3)</tt>, conforming instead to
--   <a>showEFloat</a>, <a>showFFloat</a> and <a>showGFloat</a> (and their
--   alternate versions <a>showFFloatAlt</a> and <a>showGFloatAlt</a>).
--   This is hard to fix: the fixed versions would format in a
--   backward-incompatible way. In any case the Haskell behavior is
--   generally more sensible than the C behavior. A brief summary of some
--   key differences:
--   
--   <ul>
--   <li>Haskell <a>printf</a> never uses the default "6-digit" precision
--   used by C printf.</li>
--   <li>Haskell <a>printf</a> treats the "precision" specifier as
--   indicating the number of digits after the decimal point.</li>
--   <li>Haskell <a>printf</a> prints the exponent of e-format numbers
--   without a gratuitous plus sign, and with the minimum possible number
--   of digits.</li>
--   <li>Haskell <a>printf</a> will place a zero after a decimal point when
--   possible.</li>
--   </ul>
printf :: PrintfType r => String -> r

-- | Similar to <a>printf</a>, except that output is via the specified
--   <a>Handle</a>. The return type is restricted to <tt>(<a>IO</a>
--   a)</tt>.
hPrintf :: HPrintfType r => Handle -> String -> r

-- | Typeclass of <a>printf</a>-formattable values. The <a>formatArg</a>
--   method takes a value and a field format descriptor and either fails
--   due to a bad descriptor or produces a <a>ShowS</a> as the result. The
--   default <a>parseFormat</a> expects no modifiers: this is the normal
--   case. Minimal instance: <a>formatArg</a>.
class PrintfArg a

formatArg :: PrintfArg a => a -> FieldFormatter

parseFormat :: PrintfArg a => a -> ModifierParser

-- | This is the type of a field formatter reified over its argument.
type FieldFormatter = FieldFormat -> ShowS

-- | Description of field formatting for <a>formatArg</a>. See UNIX
--   <a>printf</a>(3) for a description of how field formatting works.
data FieldFormat
FieldFormat :: Maybe Int -> Maybe Int -> Maybe FormatAdjustment -> Maybe FormatSign -> Bool -> String -> Char -> FieldFormat

-- | Total width of the field.
[fmtWidth] :: FieldFormat -> Maybe Int

-- | Secondary field width specifier.
[fmtPrecision] :: FieldFormat -> Maybe Int

-- | Kind of filling or padding to be done.
[fmtAdjust] :: FieldFormat -> Maybe FormatAdjustment

-- | Whether to insist on a plus sign for positive numbers.
[fmtSign] :: FieldFormat -> Maybe FormatSign

-- | Indicates an "alternate format". See printf(3) for the details, which
--   vary by argument spec.
[fmtAlternate] :: FieldFormat -> Bool

-- | Characters that appeared immediately to the left of <a>fmtChar</a> in
--   the format and were accepted by the type's <a>parseFormat</a>.
--   Normally the empty string.
[fmtModifiers] :: FieldFormat -> String

-- | The format character <a>printf</a> was invoked with. <a>formatArg</a>
--   should fail unless this character matches the type. It is normal to
--   handle many different format characters for a single type.
[fmtChar] :: FieldFormat -> Char

-- | Whether to left-adjust or zero-pad a field. These are mutually
--   exclusive, with <a>LeftAdjust</a> taking precedence.
data FormatAdjustment
LeftAdjust :: FormatAdjustment
ZeroPad :: FormatAdjustment

-- | How to handle the sign of a numeric field. These are mutually
--   exclusive, with <a>SignPlus</a> taking precedence.
data FormatSign
SignPlus :: FormatSign
SignSpace :: FormatSign

-- | Substitute a 'v' format character with the given default format
--   character in the <a>FieldFormat</a>. A convenience for
--   user-implemented types, which should support "%v".
vFmt :: Char -> FieldFormat -> FieldFormat

-- | Type of a function that will parse modifier characters from the format
--   string.
type ModifierParser = String -> FormatParse

-- | The "format parser" walks over argument-type-specific modifier
--   characters to find the primary format character. This is the type of
--   its result.
data FormatParse
FormatParse :: String -> Char -> String -> FormatParse

-- | Any modifiers found.
[fpModifiers] :: FormatParse -> String

-- | Primary format character.
[fpChar] :: FormatParse -> Char

-- | Rest of the format string.
[fpRest] :: FormatParse -> String

-- | Formatter for <a>String</a> values.
formatString :: IsChar a => [a] -> FieldFormatter

-- | Formatter for <a>Char</a> values.
formatChar :: Char -> FieldFormatter

-- | Formatter for <a>Int</a> values.
formatInt :: (Integral a, Bounded a) => a -> FieldFormatter

-- | Formatter for <a>Integer</a> values.
formatInteger :: Integer -> FieldFormatter

-- | Formatter for <a>RealFloat</a> values.
formatRealFloat :: RealFloat a => a -> FieldFormatter

-- | Calls <a>perror</a> to indicate an unknown format letter for a given
--   type.
errorBadFormat :: Char -> a

-- | Calls <a>perror</a> to indicate that the format string ended early.
errorShortFormat :: a

-- | Calls <a>perror</a> to indicate that there is a missing argument in
--   the argument list.
errorMissingArgument :: a

-- | Calls <a>perror</a> to indicate that there is a type error or similar
--   in the given argument.
errorBadArgument :: a

-- | Raises an <a>error</a> with a printf-specific prefix on the message
--   string.
perror :: String -> a

-- | The <a>PrintfType</a> class provides the variable argument magic for
--   <a>printf</a>. Its implementation is intentionally not visible from
--   this module. If you attempt to pass an argument of a type which is not
--   an instance of this class to <a>printf</a> or <a>hPrintf</a>, then the
--   compiler will report it as a missing instance of <a>PrintfArg</a>.
class PrintfType t

-- | The <a>HPrintfType</a> class provides the variable argument magic for
--   <a>hPrintf</a>. Its implementation is intentionally not visible from
--   this module.
class HPrintfType t

-- | This class, with only the one instance, is used as a workaround for
--   the fact that <a>String</a>, as a concrete type, is not allowable as a
--   typeclass instance. <a>IsChar</a> is exported for
--   backward-compatibility.
class IsChar c

toChar :: IsChar c => c -> Char

fromChar :: IsChar c => Char -> c
instance Text.Printf.IsChar c => Text.Printf.PrintfType [c]
instance (a Data.Type.Equality.~ ()) => Text.Printf.PrintfType (GHC.Types.IO a)
instance (Text.Printf.PrintfArg a, Text.Printf.PrintfType r) => Text.Printf.PrintfType (a -> r)
instance (a Data.Type.Equality.~ ()) => Text.Printf.HPrintfType (GHC.Types.IO a)
instance (Text.Printf.PrintfArg a, Text.Printf.HPrintfType r) => Text.Printf.HPrintfType (a -> r)
instance Text.Printf.PrintfArg GHC.Types.Char
instance Text.Printf.IsChar c => Text.Printf.PrintfArg [c]
instance Text.Printf.PrintfArg GHC.Types.Int
instance Text.Printf.PrintfArg GHC.Int.Int8
instance Text.Printf.PrintfArg GHC.Int.Int16
instance Text.Printf.PrintfArg GHC.Int.Int32
instance Text.Printf.PrintfArg GHC.Int.Int64
instance Text.Printf.PrintfArg GHC.Types.Word
instance Text.Printf.PrintfArg GHC.Word.Word8
instance Text.Printf.PrintfArg GHC.Word.Word16
instance Text.Printf.PrintfArg GHC.Word.Word32
instance Text.Printf.PrintfArg GHC.Word.Word64
instance Text.Printf.PrintfArg GHC.Integer.Type.Integer
instance Text.Printf.PrintfArg GHC.Natural.Natural
instance Text.Printf.PrintfArg GHC.Types.Float
instance Text.Printf.PrintfArg GHC.Types.Double
instance Text.Printf.IsChar GHC.Types.Char


-- | In general terms, a weak pointer is a reference to an object that is
--   not followed by the garbage collector - that is, the existence of a
--   weak pointer to an object has no effect on the lifetime of that
--   object. A weak pointer can be de-referenced to find out whether the
--   object it refers to is still alive or not, and if so to return the
--   object itself.
--   
--   Weak pointers are particularly useful for caches and memo tables. To
--   build a memo table, you build a data structure mapping from the
--   function argument (the key) to its result (the value). When you apply
--   the function to a new argument you first check whether the key/value
--   pair is already in the memo table. The key point is that the memo
--   table itself should not keep the key and value alive. So the table
--   should contain a weak pointer to the key, not an ordinary pointer. The
--   pointer to the value must not be weak, because the only reference to
--   the value might indeed be from the memo table.
--   
--   So it looks as if the memo table will keep all its values alive for
--   ever. One way to solve this is to purge the table occasionally, by
--   deleting entries whose keys have died.
--   
--   The weak pointers in this library support another approach, called
--   <i>finalization</i>. When the key referred to by a weak pointer dies,
--   the storage manager arranges to run a programmer-specified finalizer.
--   In the case of memo tables, for example, the finalizer could remove
--   the key/value pair from the memo table.
--   
--   Another difficulty with the memo table is that the value of a
--   key/value pair might itself contain a pointer to the key. So the memo
--   table keeps the value alive, which keeps the key alive, even though
--   there may be no other references to the key so both should die. The
--   weak pointers in this library provide a slight generalisation of the
--   basic weak-pointer idea, in which each weak pointer actually contains
--   both a key and a value.
module System.Mem.Weak

-- | A weak pointer object with a key and a value. The value has type
--   <tt>v</tt>.
--   
--   A weak pointer expresses a relationship between two objects, the
--   <i>key</i> and the <i>value</i>: if the key is considered to be alive
--   by the garbage collector, then the value is also alive. A reference
--   from the value to the key does <i>not</i> keep the key alive.
--   
--   A weak pointer may also have a finalizer of type <tt>IO ()</tt>; if it
--   does, then the finalizer will be run at most once, at a time after the
--   key has become unreachable by the program ("dead"). The storage
--   manager attempts to run the finalizer(s) for an object soon after the
--   object dies, but promptness is not guaranteed.
--   
--   It is not guaranteed that a finalizer will eventually run, and no
--   attempt is made to run outstanding finalizers when the program exits.
--   Therefore finalizers should not be relied on to clean up resources -
--   other methods (eg. exception handlers) should be employed, possibly in
--   addition to finalizers.
--   
--   References from the finalizer to the key are treated in the same way
--   as references from the value to the key: they do not keep the key
--   alive. A finalizer may therefore ressurrect the key, perhaps by
--   storing it in the same data structure.
--   
--   The finalizer, and the relationship between the key and the value,
--   exist regardless of whether the program keeps a reference to the
--   <a>Weak</a> object or not.
--   
--   There may be multiple weak pointers with the same key. In this case,
--   the finalizers for each of these weak pointers will all be run in some
--   arbitrary order, or perhaps concurrently, when the key dies. If the
--   programmer specifies a finalizer that assumes it has the only
--   reference to an object (for example, a file that it wishes to close),
--   then the programmer must ensure that there is only one such finalizer.
--   
--   If there are no other threads to run, the runtime system will check
--   for runnable finalizers before declaring the system to be deadlocked.
--   
--   WARNING: weak pointers to ordinary non-primitive Haskell types are
--   particularly fragile, because the compiler is free to optimise away or
--   duplicate the underlying data structure. Therefore attempting to place
--   a finalizer on an ordinary Haskell type may well result in the
--   finalizer running earlier than you expected. This is not a problem for
--   caches and memo tables where early finalization is benign.
--   
--   Finalizers <i>can</i> be used reliably for types that are created
--   explicitly and have identity, such as <tt>IORef</tt> and
--   <tt>MVar</tt>. However, to place a finalizer on one of these types,
--   you should use the specific operation provided for that type, e.g.
--   <tt>mkWeakIORef</tt> and <tt>addMVarFinalizer</tt> respectively (the
--   non-uniformity is accidental). These operations attach the finalizer
--   to the primitive object inside the box (e.g. <tt>MutVar#</tt> in the
--   case of <tt>IORef</tt>), because attaching the finalizer to the box
--   itself fails when the outer box is optimised away by the compiler.
data Weak v

-- | Establishes a weak pointer to <tt>k</tt>, with value <tt>v</tt> and a
--   finalizer.
--   
--   This is the most general interface for building a weak pointer.
mkWeak :: k -> v -> Maybe (IO ()) -> IO (Weak v)

-- | Dereferences a weak pointer. If the key is still alive, then
--   <tt><a>Just</a> v</tt> is returned (where <tt>v</tt> is the
--   <i>value</i> in the weak pointer), otherwise <a>Nothing</a> is
--   returned.
--   
--   The return value of <a>deRefWeak</a> depends on when the garbage
--   collector runs, hence it is in the <a>IO</a> monad.
deRefWeak :: Weak v -> IO (Maybe v)

-- | Causes a the finalizer associated with a weak pointer to be run
--   immediately.
finalize :: Weak v -> IO ()

-- | A specialised version of <a>mkWeak</a>, where the key and the value
--   are the same object:
--   
--   <pre>
--   mkWeakPtr key finalizer = mkWeak key key finalizer
--   </pre>
mkWeakPtr :: k -> Maybe (IO ()) -> IO (Weak k)

-- | A specialised version of <a>mkWeakPtr</a>, where the <a>Weak</a>
--   object returned is simply thrown away (however the finalizer will be
--   remembered by the garbage collector, and will still be run when the
--   key becomes unreachable).
--   
--   Note: adding a finalizer to a <a>ForeignPtr</a> using
--   <a>addFinalizer</a> won't work; use the specialised version
--   <a>addForeignPtrFinalizer</a> instead. For discussion see the
--   <a>Weak</a> type. .
addFinalizer :: key -> IO () -> IO ()

-- | A specialised version of <a>mkWeak</a> where the value is actually a
--   pair of the key and value passed to <a>mkWeakPair</a>:
--   
--   <pre>
--   mkWeakPair key val finalizer = mkWeak key (key,val) finalizer
--   </pre>
--   
--   The advantage of this is that the key can be retrieved by
--   <a>deRefWeak</a> in addition to the value.
mkWeakPair :: k -> v -> Maybe (IO ()) -> IO (Weak (k, v))


-- | Memory-related system things.
module System.Mem

-- | Triggers an immediate major garbage collection.
performGC :: IO ()

-- | Triggers an immediate major garbage collection.
performMajorGC :: IO ()

-- | Triggers an immediate minor garbage collection.
performMinorGC :: IO ()

-- | Every thread has an allocation counter that tracks how much memory has
--   been allocated by the thread. The counter is initialized to zero, and
--   <a>setAllocationCounter</a> sets the current value. The allocation
--   counter counts *down*, so in the absence of a call to
--   <a>setAllocationCounter</a> its value is the negation of the number of
--   bytes of memory allocated by the thread.
--   
--   There are two things that you can do with this counter:
--   
--   <ul>
--   <li>Use it as a simple profiling mechanism, with
--   <a>getAllocationCounter</a>.</li>
--   <li>Use it as a resource limit. See <a>enableAllocationLimit</a>.</li>
--   </ul>
--   
--   Allocation accounting is accurate only to about 4Kbytes.
setAllocationCounter :: Int64 -> IO ()

-- | Return the current value of the allocation counter for the current
--   thread.
getAllocationCounter :: IO Int64

-- | Enables the allocation counter to be treated as a limit for the
--   current thread. When the allocation limit is enabled, if the
--   allocation counter counts down below zero, the thread will be sent the
--   <a>AllocationLimitExceeded</a> asynchronous exception. When this
--   happens, the counter is reinitialised (by default to 100K, but tunable
--   with the <tt>+RTS -xq</tt> option) so that it can handle the exception
--   and perform any necessary clean up. If it exhausts this additional
--   allowance, another <a>AllocationLimitExceeded</a> exception is sent,
--   and so forth. Like other asynchronous exceptions, the
--   <a>AllocationLimitExceeded</a> exception is deferred while the thread
--   is inside <a>mask</a> or an exception handler in <a>catch</a>.
--   
--   Note that memory allocation is unrelated to <i>live memory</i>, also
--   known as <i>heap residency</i>. A thread can allocate a large amount
--   of memory and retain anything between none and all of it. It is better
--   to think of the allocation limit as a limit on <i>CPU time</i>, rather
--   than a limit on memory.
--   
--   Compared to using timeouts, allocation limits don't count time spent
--   blocked or in foreign calls.
enableAllocationLimit :: IO ()

-- | Disable allocation limit processing for the current thread.
disableAllocationLimit :: IO ()


-- | Information about the characteristics of the host system lucky enough
--   to run your program.
module System.Info

-- | The operating system on which the program is running.
os :: String

-- | The machine architecture on which the program is running.
arch :: String

-- | The Haskell implementation with which the program was compiled or is
--   being interpreted.
compilerName :: String

-- | The version of <a>compilerName</a> with which the program was compiled
--   or is being interpreted.
compilerVersion :: Version


-- | Exiting the program.
module System.Exit

-- | Defines the exit codes that a program can return.
data ExitCode

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode

-- | Computation <a>exitWith</a> <tt>code</tt> throws <a>ExitCode</a>
--   <tt>code</tt>. Normally this terminates the program, returning
--   <tt>code</tt> to the program's caller.
--   
--   On program termination, the standard <a>Handle</a>s <a>stdout</a> and
--   <a>stderr</a> are flushed automatically; any other buffered
--   <a>Handle</a>s need to be flushed manually, otherwise the buffered
--   data will be discarded.
--   
--   A program that fails in any other way is treated as if it had called
--   <a>exitFailure</a>. A program that terminates successfully without
--   calling <a>exitWith</a> explicitly is treated as if it had called
--   <a>exitWith</a> <a>ExitSuccess</a>.
--   
--   As an <a>ExitCode</a> is not an <a>IOException</a>, <a>exitWith</a>
--   bypasses the error handling in the <a>IO</a> monad and cannot be
--   intercepted by <a>catch</a> from the <a>Prelude</a>. However it is a
--   <tt>SomeException</tt>, and can be caught using the functions of
--   <a>Control.Exception</a>. This means that cleanup computations added
--   with <a>bracket</a> (from <a>Control.Exception</a>) are also executed
--   properly on <a>exitWith</a>.
--   
--   Note: in GHC, <a>exitWith</a> should be called from the main program
--   thread in order to exit the process. When called from another thread,
--   <a>exitWith</a> will throw an <tt>ExitException</tt> as normal, but
--   the exception will not cause the process itself to exit.
exitWith :: ExitCode -> IO a

-- | The computation <a>exitFailure</a> is equivalent to <a>exitWith</a>
--   <tt>(</tt><a>ExitFailure</a> <i>exitfail</i><tt>)</tt>, where
--   <i>exitfail</i> is implementation-dependent.
exitFailure :: IO a

-- | The computation <a>exitSuccess</a> is equivalent to <a>exitWith</a>
--   <a>ExitSuccess</a>, It terminates the program successfully.
exitSuccess :: IO a

-- | Write given error message to <a>stderr</a> and terminate with
--   <a>exitFailure</a>.
die :: String -> IO a


-- | Miscellaneous information about the system environment.
module System.Environment

-- | Computation <a>getArgs</a> returns a list of the program's command
--   line arguments (not including the program name).
getArgs :: IO [String]

-- | Computation <a>getProgName</a> returns the name of the program as it
--   was invoked.
--   
--   However, this is hard-to-impossible to implement on some non-Unix
--   OSes, so instead, for maximum portability, we just return the leafname
--   of the program as invoked. Even then there are some differences
--   between platforms: on Windows, for example, a program invoked as foo
--   is probably really <tt>FOO.EXE</tt>, and that is what
--   <a>getProgName</a> will return.
getProgName :: IO String

-- | Returns the absolute pathname of the current executable.
--   
--   Note that for scripts and interactive sessions, this is the path to
--   the interpreter (e.g. ghci.)
--   
--   Since base 4.11.0.0, <a>getExecutablePath</a> resolves symlinks on
--   Windows. If an executable is launched through a symlink,
--   <a>getExecutablePath</a> returns the absolute path of the original
--   executable.
getExecutablePath :: IO FilePath

-- | Computation <a>getEnv</a> <tt>var</tt> returns the value of the
--   environment variable <tt>var</tt>. For the inverse, the <a>setEnv</a>
--   function can be used.
--   
--   This computation may fail with:
--   
--   <ul>
--   <li><a>isDoesNotExistError</a> if the environment variable does not
--   exist.</li>
--   </ul>
getEnv :: String -> IO String

-- | Return the value of the environment variable <tt>var</tt>, or
--   <tt>Nothing</tt> if there is no such value.
--   
--   For POSIX users, this is equivalent to <a>getEnv</a>.
lookupEnv :: String -> IO (Maybe String)

-- | <tt>setEnv name value</tt> sets the specified environment variable to
--   <tt>value</tt>.
--   
--   Early versions of this function operated under the mistaken belief
--   that setting an environment variable to the <i>empty string</i> on
--   Windows removes that environment variable from the environment. For
--   the sake of compatibility, it adopted that behavior on POSIX. In
--   particular
--   
--   <pre>
--   setEnv name ""
--   </pre>
--   
--   has the same effect as
--   
--   <pre>
--   <a>unsetEnv</a> name
--   </pre>
--   
--   If you'd like to be able to set environment variables to blank
--   strings, use <a>setEnv</a>.
--   
--   Throws <a>IOException</a> if <tt>name</tt> is the empty string or
--   contains an equals sign.
setEnv :: String -> String -> IO ()

-- | <tt>unsetEnv name</tt> removes the specified environment variable from
--   the environment of the current process.
--   
--   Throws <a>IOException</a> if <tt>name</tt> is the empty string or
--   contains an equals sign.
unsetEnv :: String -> IO ()

-- | <a>withArgs</a> <tt>args act</tt> - while executing action
--   <tt>act</tt>, have <a>getArgs</a> return <tt>args</tt>.
withArgs :: [String] -> IO a -> IO a

-- | <a>withProgName</a> <tt>name act</tt> - while executing action
--   <tt>act</tt>, have <a>getProgName</a> return <tt>name</tt>.
withProgName :: String -> IO a -> IO a

-- | <a>getEnvironment</a> retrieves the entire environment as a list of
--   <tt>(key,value)</tt> pairs.
--   
--   If an environment entry does not contain an <tt>'='</tt> character,
--   the <tt>key</tt> is the whole entry and the <tt>value</tt> is the
--   empty string.
getEnvironment :: IO [(String, String)]


-- | A setEnv implementation that allows blank environment variables.
--   Mimics the <a>Env</a> module from the <tt>unix</tt> package, but with
--   support for Windows too.
--   
--   The matrix of platforms that:
--   
--   <ul>
--   <li>support <tt>putenv(<a>FOO</a>)</tt> to unset environment
--   variables,</li>
--   <li>support <tt>putenv("FOO=")</tt> to unset environment variables or
--   set them to blank values,</li>
--   <li>support <tt>unsetenv</tt> to unset environment variables,</li>
--   <li>support <tt>setenv</tt> to set environment variables,</li>
--   <li>etc.</li>
--   </ul>
--   
--   is very complicated. Some platforms don't support unsetting of
--   environment variables at all.
module System.Environment.Blank

-- | Returns the absolute pathname of the current executable.
--   
--   Note that for scripts and interactive sessions, this is the path to
--   the interpreter (e.g. ghci.)
--   
--   Since base 4.11.0.0, <a>getExecutablePath</a> resolves symlinks on
--   Windows. If an executable is launched through a symlink,
--   <a>getExecutablePath</a> returns the absolute path of the original
--   executable.
getExecutablePath :: IO FilePath

-- | Computation <a>getArgs</a> returns a list of the program's command
--   line arguments (not including the program name).
getArgs :: IO [String]

-- | Computation <a>getProgName</a> returns the name of the program as it
--   was invoked.
--   
--   However, this is hard-to-impossible to implement on some non-Unix
--   OSes, so instead, for maximum portability, we just return the leafname
--   of the program as invoked. Even then there are some differences
--   between platforms: on Windows, for example, a program invoked as foo
--   is probably really <tt>FOO.EXE</tt>, and that is what
--   <a>getProgName</a> will return.
getProgName :: IO String

-- | <a>withArgs</a> <tt>args act</tt> - while executing action
--   <tt>act</tt>, have <a>getArgs</a> return <tt>args</tt>.
withArgs :: [String] -> IO a -> IO a

-- | <a>withProgName</a> <tt>name act</tt> - while executing action
--   <tt>act</tt>, have <a>getProgName</a> return <tt>name</tt>.
withProgName :: String -> IO a -> IO a

-- | <a>getEnvironment</a> retrieves the entire environment as a list of
--   <tt>(key,value)</tt> pairs.
--   
--   If an environment entry does not contain an <tt>'='</tt> character,
--   the <tt>key</tt> is the whole entry and the <tt>value</tt> is the
--   empty string.
getEnvironment :: IO [(String, String)]

-- | Similar to <a>lookupEnv</a>.
getEnv :: String -> IO (Maybe String)

-- | Get an environment value or a default value.
getEnvDefault :: String -> String -> IO String

-- | Like <a>setEnv</a>, but allows blank environment values and mimics the
--   function signature of <a>setEnv</a> from the <tt>unix</tt> package.
setEnv :: String -> String -> Bool -> IO ()

-- | Like <a>unsetEnv</a>, but allows for the removal of blank environment
--   variables. May throw an exception if the underlying platform doesn't
--   support unsetting of environment variables.
unsetEnv :: String -> IO ()


-- | This library provides facilities for parsing the command-line options
--   in a standalone program. It is essentially a Haskell port of the GNU
--   <tt>getopt</tt> library.
module System.Console.GetOpt

-- | Process the command-line, and return the list of values that matched
--   (and those that didn't). The arguments are:
--   
--   <ul>
--   <li>The order requirements (see <a>ArgOrder</a>)</li>
--   <li>The option descriptions (see <a>OptDescr</a>)</li>
--   <li>The actual command line arguments (presumably got from
--   <a>getArgs</a>).</li>
--   </ul>
--   
--   <a>getOpt</a> returns a triple consisting of the option arguments, a
--   list of non-options, and a list of error messages.
getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])

-- | This is almost the same as <a>getOpt</a>, but returns a quadruple
--   consisting of the option arguments, a list of non-options, a list of
--   unrecognized options, and a list of error messages.
getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])

-- | Return a string describing the usage of a command, derived from the
--   header (first argument) and the options described by the second
--   argument.
usageInfo :: String -> [OptDescr a] -> String

-- | What to do with options following non-options
data ArgOrder a

-- | no option processing after first non-option
RequireOrder :: ArgOrder a

-- | freely intersperse options and non-options
Permute :: ArgOrder a

-- | wrap non-options into options
ReturnInOrder :: (String -> a) -> ArgOrder a

-- | Each <a>OptDescr</a> describes a single option.
--   
--   The arguments to <a>Option</a> are:
--   
--   <ul>
--   <li>list of short option characters</li>
--   <li>list of long option strings (without "--")</li>
--   <li>argument descriptor</li>
--   <li>explanation of option for user</li>
--   </ul>
data OptDescr a
Option :: [Char] -> [String] -> ArgDescr a -> String -> OptDescr a

-- | Describes whether an option takes an argument or not, and if so how
--   the argument is injected into a value of type <tt>a</tt>.
data ArgDescr a

-- | no argument expected
NoArg :: a -> ArgDescr a

-- | option requires argument
ReqArg :: (String -> a) -> String -> ArgDescr a

-- | optional argument
OptArg :: (Maybe String -> a) -> String -> ArgDescr a
instance GHC.Base.Functor System.Console.GetOpt.OptDescr
instance GHC.Base.Functor System.Console.GetOpt.ArgDescr
instance GHC.Base.Functor System.Console.GetOpt.ArgOrder


-- | The standard CPUTime library.
module System.CPUTime

-- | Computation <a>getCPUTime</a> returns the number of picoseconds CPU
--   time used by the current program. The precision of this result is
--   implementation-dependent.
getCPUTime :: IO Integer

-- | The <a>cpuTimePrecision</a> constant is the smallest measurable
--   difference in CPU time that the implementation can record, and is
--   given as an integral number of picoseconds.
cpuTimePrecision :: Integer


-- | Stable names are a way of performing fast (O(1)), not-quite-exact
--   comparison between objects.
--   
--   Stable names solve the following problem: suppose you want to build a
--   hash table with Haskell objects as keys, but you want to use pointer
--   equality for comparison; maybe because the keys are large and hashing
--   would be slow, or perhaps because the keys are infinite in size. We
--   can't build a hash table using the address of the object as the key,
--   because objects get moved around by the garbage collector, meaning a
--   re-hash would be necessary after every garbage collection.
module GHC.StableName

-- | An abstract name for an object, that supports equality and hashing.
--   
--   Stable names have the following property:
--   
--   <ul>
--   <li>If <tt>sn1 :: StableName</tt> and <tt>sn2 :: StableName</tt> and
--   <tt>sn1 == sn2</tt> then <tt>sn1</tt> and <tt>sn2</tt> were created by
--   calls to <tt>makeStableName</tt> on the same object.</li>
--   </ul>
--   
--   The reverse is not necessarily true: if two stable names are not
--   equal, then the objects they name may still be equal. Note in
--   particular that <a>makeStableName</a> may return a different
--   <a>StableName</a> after an object is evaluated.
--   
--   Stable Names are similar to Stable Pointers
--   (<a>Foreign.StablePtr</a>), but differ in the following ways:
--   
--   <ul>
--   <li>There is no <tt>freeStableName</tt> operation, unlike
--   <a>Foreign.StablePtr</a>s. Stable names are reclaimed by the runtime
--   system when they are no longer needed.</li>
--   <li>There is no <tt>deRefStableName</tt> operation. You can't get back
--   from a stable name to the original Haskell object. The reason for this
--   is that the existence of a stable name for an object does not
--   guarantee the existence of the object itself; it can still be garbage
--   collected.</li>
--   </ul>
data StableName a
StableName :: StableName# a -> StableName a

-- | Makes a <a>StableName</a> for an arbitrary object. The object passed
--   as the first argument is not evaluated by <a>makeStableName</a>.
makeStableName :: a -> IO (StableName a)

-- | Convert a <a>StableName</a> to an <a>Int</a>. The <a>Int</a> returned
--   is not necessarily unique; several <a>StableName</a>s may map to the
--   same <a>Int</a> (in practice however, the chances of this are small,
--   so the result of <a>hashStableName</a> makes a good hash key).
hashStableName :: StableName a -> Int

-- | Equality on <a>StableName</a> that does not require that the types of
--   the arguments match.
eqStableName :: StableName a -> StableName b -> Bool
instance GHC.Classes.Eq (GHC.StableName.StableName a)


-- | Stable names are a way of performing fast (O(1)), not-quite-exact
--   comparison between objects.
--   
--   Stable names solve the following problem: suppose you want to build a
--   hash table with Haskell objects as keys, but you want to use pointer
--   equality for comparison; maybe because the keys are large and hashing
--   would be slow, or perhaps because the keys are infinite in size. We
--   can't build a hash table using the address of the object as the key,
--   because objects get moved around by the garbage collector, meaning a
--   re-hash would be necessary after every garbage collection.
module System.Mem.StableName

-- | An abstract name for an object, that supports equality and hashing.
--   
--   Stable names have the following property:
--   
--   <ul>
--   <li>If <tt>sn1 :: StableName</tt> and <tt>sn2 :: StableName</tt> and
--   <tt>sn1 == sn2</tt> then <tt>sn1</tt> and <tt>sn2</tt> were created by
--   calls to <tt>makeStableName</tt> on the same object.</li>
--   </ul>
--   
--   The reverse is not necessarily true: if two stable names are not
--   equal, then the objects they name may still be equal. Note in
--   particular that <a>makeStableName</a> may return a different
--   <a>StableName</a> after an object is evaluated.
--   
--   Stable Names are similar to Stable Pointers
--   (<a>Foreign.StablePtr</a>), but differ in the following ways:
--   
--   <ul>
--   <li>There is no <tt>freeStableName</tt> operation, unlike
--   <a>Foreign.StablePtr</a>s. Stable names are reclaimed by the runtime
--   system when they are no longer needed.</li>
--   <li>There is no <tt>deRefStableName</tt> operation. You can't get back
--   from a stable name to the original Haskell object. The reason for this
--   is that the existence of a stable name for an object does not
--   guarantee the existence of the object itself; it can still be garbage
--   collected.</li>
--   </ul>
data StableName a

-- | Makes a <a>StableName</a> for an arbitrary object. The object passed
--   as the first argument is not evaluated by <a>makeStableName</a>.
makeStableName :: a -> IO (StableName a)

-- | Convert a <a>StableName</a> to an <a>Int</a>. The <a>Int</a> returned
--   is not necessarily unique; several <a>StableName</a>s may map to the
--   same <a>Int</a> (in practice however, the chances of this are small,
--   so the result of <a>hashStableName</a> makes a good hash key).
hashStableName :: StableName a -> Int

-- | Equality on <a>StableName</a> that does not require that the types of
--   the arguments match.
eqStableName :: StableName a -> StableName b -> Bool


-- | GCC style response files.
module GHC.ResponseFile

-- | Like <a>getArgs</a>, but can also read arguments supplied via response
--   files.
--   
--   For example, consider a program <tt>foo</tt>:
--   
--   <pre>
--   main :: IO ()
--   main = do
--     args &lt;- getArgsWithResponseFiles
--     putStrLn (show args)
--   </pre>
--   
--   And a response file <tt>args.txt</tt>:
--   
--   <pre>
--   --one 1
--   --<tt>two</tt> 2
--   --"three" 3
--   </pre>
--   
--   Then the result of invoking <tt>foo</tt> with <tt>args.txt</tt> is:
--   
--   <pre>
--   &gt; ./foo @args.txt
--   ["--one","1","--two","2","--three","3"]
--   </pre>
getArgsWithResponseFiles :: IO [String]

-- | Given a string of concatenated strings, separate each by removing a
--   layer of <i>quoting</i> and/or <i>escaping</i> of certain characters.
--   
--   These characters are: any whitespace, single quote, double quote, and
--   the backslash character. The backslash character always escapes (i.e.,
--   passes through without further consideration) the character which
--   follows. Characters can also be escaped in blocks by quoting (i.e.,
--   surrounding the blocks with matching pairs of either single- or
--   double-quotes which are not themselves escaped).
--   
--   Any whitespace which appears outside of either of the quoting and
--   escaping mechanisms, is interpreted as having been added by this
--   special concatenation process to designate where the boundaries are
--   between the original, un-concatenated list of strings. These added
--   whitespace characters are removed from the output.
--   
--   <pre>
--   unescapeArgs "hello\\ \\\"world\\\"\n" == escapeArgs "hello \"world\""
--   </pre>
unescapeArgs :: String -> [String]

-- | Given a list of strings, concatenate them into a single string with
--   escaping of certain characters, and the addition of a newline between
--   each string. The escaping is done by adding a single backslash
--   character before any whitespace, single quote, double quote, or
--   backslash character, so this escaping character must be removed.
--   Unescaped whitespace (in this case, newline) is part of this
--   "transport" format to indicate the end of the previous string and the
--   start of a new string.
--   
--   While <a>unescapeArgs</a> allows using quoting (i.e., convenient
--   escaping of many characters) by having matching sets of single- or
--   double-quotes,<a>escapeArgs</a> does not use the quoting mechasnism,
--   and thus will always escape any whitespace, quotes, and backslashes.
--   
--   <pre>
--   unescapeArgs "hello\\ \\\"world\\\"\\n" == escapeArgs "hello \"world\""
--   </pre>
escapeArgs :: [String] -> String

-- | Arguments which look like '@foo' will be replaced with the contents of
--   file <tt>foo</tt>. A gcc-like syntax for response files arguments is
--   expected. This must re-constitute the argument list by doing an
--   inverse of the escaping mechanism done by the calling-program side.
--   
--   We quit if the file is not found or reading somehow fails. (A
--   convenience routine for haddock or possibly other clients)
expandResponse :: [String] -> IO [String]


-- | This module defines the <a>HasField</a> class used by the
--   <tt>OverloadedRecordFields</tt> extension. See the
--   &lt;<a>https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields</a>
--   wiki page&gt; for more details.
module GHC.Records

-- | Constraint representing the fact that the field <tt>x</tt> belongs to
--   the record type <tt>r</tt> and has field type <tt>a</tt>. This will be
--   solved automatically, but manual instances may be provided as well.
class HasField (x :: k) r a | x r -> a

-- | Selector function to extract the field from the record.
getField :: HasField x r a => r -> a


-- | This module defines the <a>IsLabel</a> class is used by the
--   <tt>OverloadedLabels</tt> extension. See the <a>wiki page</a> for more
--   details.
--   
--   When <tt>OverloadedLabels</tt> is enabled, if GHC sees an occurrence
--   of the overloaded label syntax <tt>#foo</tt>, it is replaced with
--   
--   <pre>
--   fromLabel @"foo" :: alpha
--   </pre>
--   
--   plus a wanted constraint <tt>IsLabel "foo" alpha</tt>.
--   
--   Note that if <tt>RebindableSyntax</tt> is enabled, the desugaring of
--   overloaded label syntax will make use of whatever <tt>fromLabel</tt>
--   is in scope.
module GHC.OverloadedLabels
class IsLabel (x :: Symbol) a
fromLabel :: IsLabel x a => a


-- | Target byte ordering.
module GHC.ByteOrder

-- | Byte ordering.
data ByteOrder

-- | most-significant-byte occurs in lowest address.
BigEndian :: ByteOrder

-- | least-significant-byte occurs in lowest address.
LittleEndian :: ByteOrder

-- | The byte ordering of the target machine.
targetByteOrder :: ByteOrder
instance GHC.Show.Show GHC.ByteOrder.ByteOrder
instance GHC.Read.Read GHC.ByteOrder.ByteOrder
instance GHC.Enum.Enum GHC.ByteOrder.ByteOrder
instance GHC.Enum.Bounded GHC.ByteOrder.ByteOrder
instance GHC.Classes.Ord GHC.ByteOrder.ByteOrder
instance GHC.Classes.Eq GHC.ByteOrder.ByteOrder


-- | An abstract interface to a unique symbol generator.
module Data.Unique

-- | An abstract unique object. Objects of type <a>Unique</a> may be
--   compared for equality and ordering and hashed into <a>Int</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do x &lt;- newUnique
--      print (x == x)
--      y &lt;- newUnique
--      print (x == y)
--   :}
--   True
--   False
--   </pre>
data Unique

-- | Creates a new object of type <a>Unique</a>. The value returned will
--   not compare equal to any other value of type <a>Unique</a> returned by
--   previous calls to <a>newUnique</a>. There is no limit on the number of
--   times <a>newUnique</a> may be called.
newUnique :: IO Unique

-- | Hashes a <a>Unique</a> into an <a>Int</a>. Two <a>Unique</a>s may hash
--   to the same value, although in practice this is unlikely. The
--   <a>Int</a> returned makes a good hash key.
hashUnique :: Unique -> Int
instance GHC.Classes.Ord Data.Unique.Unique
instance GHC.Classes.Eq Data.Unique.Unique


-- | Mutable references in the (strict) ST monad.
module Data.STRef

-- | a value of type <tt>STRef s a</tt> is a mutable variable in state
--   thread <tt>s</tt>, containing a value of type <tt>a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runST (do
--       ref &lt;- newSTRef "hello"
--       x &lt;- readSTRef ref
--       writeSTRef ref (x ++ "world")
--       readSTRef ref )
--   :}
--   "helloworld"
--   </pre>
data STRef s a

-- | Build a new <a>STRef</a> in the current state thread
newSTRef :: a -> ST s (STRef s a)

-- | Read the value of an <a>STRef</a>
readSTRef :: STRef s a -> ST s a

-- | Write a new value into an <a>STRef</a>
writeSTRef :: STRef s a -> a -> ST s ()

-- | Mutate the contents of an <a>STRef</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runST (do
--       ref &lt;- newSTRef ""
--       modifySTRef ref (const "world")
--       modifySTRef ref (++ "!")
--       modifySTRef ref ("Hello, " ++)
--       readSTRef ref )
--   :}
--   "Hello, world!"
--   </pre>
--   
--   Be warned that <a>modifySTRef</a> does not apply the function
--   strictly. This means if the program calls <a>modifySTRef</a> many
--   times, but seldomly uses the value, thunks will pile up in memory
--   resulting in a space leak. This is a common mistake made when using an
--   STRef as a counter. For example, the following will leak memory and
--   may produce a stack overflow:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad (replicateM_)
--   
--   &gt;&gt;&gt; :{
--   print (runST (do
--       ref &lt;- newSTRef 0
--       replicateM_ 1000 $ modifySTRef ref (+1)
--       readSTRef ref ))
--   :}
--   1000
--   </pre>
--   
--   To avoid this problem, use <a>modifySTRef'</a> instead.
modifySTRef :: STRef s a -> (a -> a) -> ST s ()

-- | Strict version of <a>modifySTRef</a>
modifySTRef' :: STRef s a -> (a -> a) -> ST s ()


-- | Mutable references in the (strict) ST monad (re-export of
--   <a>Data.STRef</a>)
module Data.STRef.Strict


-- | Standard functions on rational numbers
module Data.Ratio

-- | Rational numbers, with numerator and denominator of some
--   <a>Integral</a> type.
--   
--   Note that <a>Ratio</a>'s instances inherit the deficiencies from the
--   type parameter's. For example, <tt>Ratio Natural</tt>'s <a>Num</a>
--   instance has similar problems to <a>Natural</a>'s.
data Ratio a

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | Forms the ratio of two integral numbers.
(%) :: Integral a => a -> a -> Ratio a
infixl 7 %

-- | Extract the numerator of the ratio in reduced form: the numerator and
--   denominator have no common factor and the denominator is positive.
numerator :: Ratio a -> a

-- | Extract the denominator of the ratio in reduced form: the numerator
--   and denominator have no common factor and the denominator is positive.
denominator :: Ratio a -> a

-- | <a>approxRational</a>, applied to two real fractional numbers
--   <tt>x</tt> and <tt>epsilon</tt>, returns the simplest rational number
--   within <tt>epsilon</tt> of <tt>x</tt>. A rational number <tt>y</tt> is
--   said to be <i>simpler</i> than another <tt>y'</tt> if
--   
--   <ul>
--   <li><tt><a>abs</a> (<a>numerator</a> y) &lt;= <a>abs</a>
--   (<a>numerator</a> y')</tt>, and</li>
--   <li><tt><a>denominator</a> y &lt;= <a>denominator</a> y'</tt>.</li>
--   </ul>
--   
--   Any real interval contains a unique simplest rational; in particular,
--   note that <tt>0/1</tt> is the simplest rational of all.
approxRational :: RealFrac a => a -> a -> Rational


-- | Basic kinds
module Data.Kind

-- | The kind of types with values. For example <tt>Int :: Type</tt>.
type Type = Type

-- | The kind of constraints, like <tt>Show a</tt>
data Constraint


-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   type onto integers. It is used primarily for array indexing (see the
--   array package). <a>Ix</a> uses row-major order.
module Data.Ix

-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   a type onto integers. It is used primarily for array indexing (see the
--   array package).
--   
--   The first argument <tt>(l,u)</tt> of each of these operations is a
--   pair specifying the lower and upper bounds of a contiguous subrange of
--   values.
--   
--   An implementation is entitled to assume the following laws about these
--   operations:
--   
--   <ul>
--   <li><tt><a>inRange</a> (l,u) i == <a>elem</a> i (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   <li><tt><a>range</a> (l,u) <a>!!</a> <a>index</a> (l,u) i == i</tt>,
--   when <tt><a>inRange</a> (l,u) i</tt></li>
--   <li><tt><a>map</a> (<a>index</a> (l,u)) (<a>range</a> (l,u))) ==
--   [0..<a>rangeSize</a> (l,u)-1]</tt> <tt> </tt></li>
--   <li><tt><a>rangeSize</a> (l,u) == <a>length</a> (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   </ul>
class (Ord a) => Ix a

-- | The list of values in the subrange defined by a bounding pair.
range :: Ix a => (a, a) -> [a]

-- | The position of a subscript in the subrange.
index :: Ix a => (a, a) -> a -> Int

-- | Returns <a>True</a> the given subscript lies in the range defined the
--   bounding pair.
inRange :: Ix a => (a, a) -> a -> Bool

-- | The size of the subrange defined by a bounding pair.
rangeSize :: Ix a => (a, a) -> Int


-- | This library provides support for <i>strict</i> state threads, as
--   described in the PLDI '94 paper by John Launchbury and Simon Peyton
--   Jones <i>Lazy Functional State Threads</i>.
--   
--   Unsafe API.
module Control.Monad.ST.Unsafe

-- | <a>unsafeInterleaveST</a> allows an <a>ST</a> computation to be
--   deferred lazily. When passed a value of type <tt>ST a</tt>, the
--   <a>ST</a> computation will only be performed when the value of the
--   <tt>a</tt> is demanded.
unsafeInterleaveST :: ST s a -> ST s a

-- | <a>unsafeDupableInterleaveST</a> allows an <a>ST</a> computation to be
--   deferred lazily. When passed a value of type <tt>ST a</tt>, the
--   <a>ST</a> computation will only be performed when the value of the
--   <tt>a</tt> is demanded.
--   
--   The computation may be performed multiple times by different threads,
--   possibly at the same time. To prevent this, use
--   <a>unsafeInterleaveST</a> instead.
unsafeDupableInterleaveST :: ST s a -> ST s a

-- | Convert an <a>IO</a> action to an <a>ST</a> action. This relies on
--   <a>IO</a> and <a>ST</a> having the same representation modulo the
--   constraint on the type of the state.
unsafeIOToST :: IO a -> ST s a

-- | Convert an <a>ST</a> action to an <a>IO</a> action. This relies on
--   <a>IO</a> and <a>ST</a> having the same representation modulo the
--   constraint on the type of the state.
--   
--   For an example demonstrating why this is unsafe, see
--   <a>https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html</a>
unsafeSTToIO :: ST s a -> IO a


-- | This library provides support for <i>strict</i> state threads, as
--   described in the PLDI '94 paper by John Launchbury and Simon Peyton
--   Jones <i>Lazy Functional State Threads</i>.
--   
--   Safe API Only.

-- | <i>Deprecated: Safe is now the default, please use Control.Monad.ST
--   instead</i>
module Control.Monad.ST.Safe

-- | The strict state-transformer monad. A computation of type
--   <tt><a>ST</a> s a</tt> transforms an internal state indexed by
--   <tt>s</tt>, and returns a value of type <tt>a</tt>. The <tt>s</tt>
--   parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
data ST s a

-- | Return the value computed by a state transformer computation. The
--   <tt>forall</tt> ensures that the internal state used by the <a>ST</a>
--   computation is inaccessible to the rest of the program.
runST :: (forall s. ST s a) -> a

-- | Allow the result of a state transformer computation to be used
--   (lazily) inside the computation.
--   
--   Note that if <tt>f</tt> is strict, <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld :: Type

-- | Embed a strict state transformer in an <a>IO</a> action. The
--   <a>RealWorld</a> parameter indicates that the internal state used by
--   the <a>ST</a> computation is a special one supplied by the <a>IO</a>
--   monad, and thus distinct from those used by invocations of
--   <a>runST</a>.
stToIO :: ST RealWorld a -> IO a


-- | This library provides support for <i>strict</i> state threads, as
--   described in the PLDI '94 paper by John Launchbury and Simon Peyton
--   Jones <i>Lazy Functional State Threads</i>.
--   
--   References (variables) that can be used within the <tt>ST</tt> monad
--   are provided by <a>Data.STRef</a>, and arrays are provided by
--   <a>Data.Array.ST</a>.
module Control.Monad.ST

-- | The strict state-transformer monad. A computation of type
--   <tt><a>ST</a> s a</tt> transforms an internal state indexed by
--   <tt>s</tt>, and returns a value of type <tt>a</tt>. The <tt>s</tt>
--   parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
data ST s a

-- | Return the value computed by a state transformer computation. The
--   <tt>forall</tt> ensures that the internal state used by the <a>ST</a>
--   computation is inaccessible to the rest of the program.
runST :: (forall s. ST s a) -> a

-- | Allow the result of a state transformer computation to be used
--   (lazily) inside the computation.
--   
--   Note that if <tt>f</tt> is strict, <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld :: Type

-- | Embed a strict state transformer in an <a>IO</a> action. The
--   <a>RealWorld</a> parameter indicates that the internal state used by
--   the <a>ST</a> computation is a special one supplied by the <a>IO</a>
--   monad, and thus distinct from those used by invocations of
--   <a>runST</a>.
stToIO :: ST RealWorld a -> IO a


-- | The strict ST monad (re-export of <a>Control.Monad.ST</a>)
module Control.Monad.ST.Strict


-- | This module presents an identical interface to
--   <a>Control.Monad.ST</a>, except that the monad delays evaluation of
--   state operations until a value depending on them is required.
--   
--   Unsafe API.
module Control.Monad.ST.Lazy.Unsafe
unsafeInterleaveST :: ST s a -> ST s a
unsafeIOToST :: IO a -> ST s a


-- | This module presents an identical interface to
--   <a>Control.Monad.ST</a>, except that the monad delays evaluation of
--   state operations until a value depending on them is required.
--   
--   Safe API only.

-- | <i>Deprecated: Safe is now the default, please use
--   Control.Monad.ST.Lazy instead</i>
module Control.Monad.ST.Lazy.Safe

-- | The lazy state-transformer monad. A computation of type <tt><a>ST</a>
--   s a</tt> transforms an internal state indexed by <tt>s</tt>, and
--   returns a value of type <tt>a</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are not strict in
--   the state. For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= readSTRef _|_ &gt;&gt; return 2) = 2
--   </pre>
data ST s a

-- | Return the value computed by a state transformer computation. The
--   <tt>forall</tt> ensures that the internal state used by the <a>ST</a>
--   computation is inaccessible to the rest of the program.
runST :: (forall s. ST s a) -> a

-- | Allow the result of a state transformer computation to be used
--   (lazily) inside the computation. Note that if <tt>f</tt> is strict,
--   <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | Convert a strict <a>ST</a> computation into a lazy one. The strict
--   state thread passed to <a>strictToLazyST</a> is not performed until
--   the result of the lazy state thread it returns is demanded.
strictToLazyST :: ST s a -> ST s a

-- | Convert a lazy <a>ST</a> computation into a strict one.
lazyToStrictST :: ST s a -> ST s a

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld :: Type

-- | A monad transformer embedding lazy state transformers in the <a>IO</a>
--   monad. The <a>RealWorld</a> parameter indicates that the internal
--   state used by the <a>ST</a> computation is a special one supplied by
--   the <a>IO</a> monad, and thus distinct from those used by invocations
--   of <a>runST</a>.
stToIO :: ST RealWorld a -> IO a


-- | This module presents an identical interface to
--   <a>Control.Monad.ST</a>, except that the monad delays evaluation of
--   state operations until a value depending on them is required.
module Control.Monad.ST.Lazy

-- | The lazy state-transformer monad. A computation of type <tt><a>ST</a>
--   s a</tt> transforms an internal state indexed by <tt>s</tt>, and
--   returns a value of type <tt>a</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are not strict in
--   the state. For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= readSTRef _|_ &gt;&gt; return 2) = 2
--   </pre>
data ST s a

-- | Return the value computed by a state transformer computation. The
--   <tt>forall</tt> ensures that the internal state used by the <a>ST</a>
--   computation is inaccessible to the rest of the program.
runST :: (forall s. ST s a) -> a

-- | Allow the result of a state transformer computation to be used
--   (lazily) inside the computation. Note that if <tt>f</tt> is strict,
--   <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | Convert a strict <a>ST</a> computation into a lazy one. The strict
--   state thread passed to <a>strictToLazyST</a> is not performed until
--   the result of the lazy state thread it returns is demanded.
strictToLazyST :: ST s a -> ST s a

-- | Convert a lazy <a>ST</a> computation into a strict one.
lazyToStrictST :: ST s a -> ST s a

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld :: Type

-- | A monad transformer embedding lazy state transformers in the <a>IO</a>
--   monad. The <a>RealWorld</a> parameter indicates that the internal
--   state used by the <a>ST</a> computation is a special one supplied by
--   the <a>IO</a> monad, and thus distinct from those used by invocations
--   of <a>runST</a>.
stToIO :: ST RealWorld a -> IO a


-- | Mutable references in the lazy ST monad.
module Data.STRef.Lazy

-- | a value of type <tt>STRef s a</tt> is a mutable variable in state
--   thread <tt>s</tt>, containing a value of type <tt>a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runST (do
--       ref &lt;- newSTRef "hello"
--       x &lt;- readSTRef ref
--       writeSTRef ref (x ++ "world")
--       readSTRef ref )
--   :}
--   "helloworld"
--   </pre>
data STRef s a
newSTRef :: a -> ST s (STRef s a)
readSTRef :: STRef s a -> ST s a
writeSTRef :: STRef s a -> a -> ST s ()
modifySTRef :: STRef s a -> (a -> a) -> ST s ()


-- | <i>This module is DEPRECATED and will be removed in the future!</i>
--   
--   <a>Functor</a> and <a>Monad</a> instances for <tt>(-&gt;) r</tt> and
--   <a>Functor</a> instances for <tt>(,) a</tt> and <tt><a>Either</a>
--   a</tt>.

-- | <i>Deprecated: This module now contains no instances and will be
--   removed in the future</i>
module Control.Monad.Instances

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor f
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>return</a> a <a>&gt;&gt;=</a> k = k a</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> <a>return</a> = m</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> (\x -&gt; k x <a>&gt;&gt;=</a> h) = (m
--   <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a> h</pre></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad m

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: forall a b. Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: forall a b. Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Fail with a message. This operation is not part of the mathematical
--   definition of a monad, but is invoked on pattern-match failure in a
--   <tt>do</tt> expression.
--   
--   As part of the MonadFail proposal (MFP), this function is moved to its
--   own class <tt>MonadFail</tt> (see <a>Control.Monad.Fail</a> for more
--   details). The definition here will be removed in a future release.
fail :: Monad m => String -> m a
infixl 1 >>=
infixl 1 >>


-- | Class of monads based on <tt>IO</tt>.
module Control.Monad.IO.Class

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class (Monad m) => MonadIO m

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a
instance Control.Monad.IO.Class.MonadIO GHC.Types.IO


-- | This module provides access to internal garbage collection and memory
--   usage statistics. These statistics are not available unless a program
--   is run with the <tt>-T</tt> RTS flag.
--   
--   This module is GHC-only and should not be considered portable.
module GHC.Stats

-- | Statistics about runtime activity since the start of the program. This
--   is a mirror of the C <tt>struct RTSStats</tt> in <tt>RtsAPI.h</tt>
data RTSStats
RTSStats :: Word32 -> Word32 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> GCDetails -> RTSStats

-- | Total number of GCs
[gcs] :: RTSStats -> Word32

-- | Total number of major (oldest generation) GCs
[major_gcs] :: RTSStats -> Word32

-- | Total bytes allocated
[allocated_bytes] :: RTSStats -> Word64

-- | Maximum live data (including large objects + compact regions) in the
--   heap. Updated after a major GC.
[max_live_bytes] :: RTSStats -> Word64

-- | Maximum live data in large objects
[max_large_objects_bytes] :: RTSStats -> Word64

-- | Maximum live data in compact regions
[max_compact_bytes] :: RTSStats -> Word64

-- | Maximum slop
[max_slop_bytes] :: RTSStats -> Word64

-- | Maximum memory in use by the RTS
[max_mem_in_use_bytes] :: RTSStats -> Word64

-- | Sum of live bytes across all major GCs. Divided by major_gcs gives the
--   average live data over the lifetime of the program.
[cumulative_live_bytes] :: RTSStats -> Word64

-- | Sum of copied_bytes across all GCs
[copied_bytes] :: RTSStats -> Word64

-- | Sum of copied_bytes across all parallel GCs
[par_copied_bytes] :: RTSStats -> Word64

-- | Sum of par_max_copied_bytes across all parallel GCs. Deprecated.
[cumulative_par_max_copied_bytes] :: RTSStats -> Word64

-- | Sum of par_balanced_copied bytes across all parallel GCs
[cumulative_par_balanced_copied_bytes] :: RTSStats -> Word64

-- | Total CPU time used by the init phase @since 4.12.0.0
[init_cpu_ns] :: RTSStats -> RtsTime

-- | Total elapsed time used by the init phase @since 4.12.0.0
[init_elapsed_ns] :: RTSStats -> RtsTime

-- | Total CPU time used by the mutator
[mutator_cpu_ns] :: RTSStats -> RtsTime

-- | Total elapsed time used by the mutator
[mutator_elapsed_ns] :: RTSStats -> RtsTime

-- | Total CPU time used by the GC
[gc_cpu_ns] :: RTSStats -> RtsTime

-- | Total elapsed time used by the GC
[gc_elapsed_ns] :: RTSStats -> RtsTime

-- | Total CPU time (at the previous GC)
[cpu_ns] :: RTSStats -> RtsTime

-- | Total elapsed time (at the previous GC)
[elapsed_ns] :: RTSStats -> RtsTime

-- | Details about the most recent GC
[gc] :: RTSStats -> GCDetails

-- | Statistics about a single GC. This is a mirror of the C <tt>struct
--   GCDetails</tt> in <tt>RtsAPI.h</tt>, with the field prefixed with
--   <tt>gc_</tt> to avoid collisions with <a>RTSStats</a>.
data GCDetails
GCDetails :: Word32 -> Word32 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> RtsTime -> RtsTime -> RtsTime -> GCDetails

-- | The generation number of this GC
[gcdetails_gen] :: GCDetails -> Word32

-- | Number of threads used in this GC
[gcdetails_threads] :: GCDetails -> Word32

-- | Number of bytes allocated since the previous GC
[gcdetails_allocated_bytes] :: GCDetails -> Word64

-- | Total amount of live data in the heap (incliudes large + compact
--   data). Updated after every GC. Data in uncollected generations (in
--   minor GCs) are considered live.
[gcdetails_live_bytes] :: GCDetails -> Word64

-- | Total amount of live data in large objects
[gcdetails_large_objects_bytes] :: GCDetails -> Word64

-- | Total amount of live data in compact regions
[gcdetails_compact_bytes] :: GCDetails -> Word64

-- | Total amount of slop (wasted memory)
[gcdetails_slop_bytes] :: GCDetails -> Word64

-- | Total amount of memory in use by the RTS
[gcdetails_mem_in_use_bytes] :: GCDetails -> Word64

-- | Total amount of data copied during this GC
[gcdetails_copied_bytes] :: GCDetails -> Word64

-- | In parallel GC, the max amount of data copied by any one thread.
--   Deprecated.
[gcdetails_par_max_copied_bytes] :: GCDetails -> Word64

-- | In parallel GC, the amount of balanced data copied by all threads
[gcdetails_par_balanced_copied_bytes] :: GCDetails -> Word64

-- | The time elapsed during synchronisation before GC
[gcdetails_sync_elapsed_ns] :: GCDetails -> RtsTime

-- | The CPU time used during GC itself
[gcdetails_cpu_ns] :: GCDetails -> RtsTime

-- | The time elapsed during GC itself
[gcdetails_elapsed_ns] :: GCDetails -> RtsTime

-- | Time values from the RTS, using a fixed resolution of nanoseconds.
type RtsTime = Int64

-- | Get current runtime system statistics.
getRTSStats :: IO RTSStats

-- | Returns whether GC stats have been enabled (with <tt>+RTS -T</tt>, for
--   example).
getRTSStatsEnabled :: IO Bool
instance GHC.Show.Show GHC.Stats.RTSStats
instance GHC.Read.Read GHC.Stats.RTSStats
instance GHC.Show.Show GHC.Stats.GCDetails
instance GHC.Read.Read GHC.Stats.GCDetails


-- | Accessors to GHC RTS flags. Descriptions of flags can be seen in
--   <a>GHC User's Guide</a>, or by running RTS help message using <tt>+RTS
--   --help</tt>.
module GHC.RTS.Flags

-- | <tt><tt>Time</tt></tt> is defined as a <tt><tt>StgWord64</tt></tt> in
--   <tt>stg/Types.h</tt>
type RtsTime = Word64

-- | Parameters of the runtime system
data RTSFlags
RTSFlags :: GCFlags -> ConcFlags -> MiscFlags -> DebugFlags -> CCFlags -> ProfFlags -> TraceFlags -> TickyFlags -> ParFlags -> RTSFlags
[gcFlags] :: RTSFlags -> GCFlags
[concurrentFlags] :: RTSFlags -> ConcFlags
[miscFlags] :: RTSFlags -> MiscFlags
[debugFlags] :: RTSFlags -> DebugFlags
[costCentreFlags] :: RTSFlags -> CCFlags
[profilingFlags] :: RTSFlags -> ProfFlags
[traceFlags] :: RTSFlags -> TraceFlags
[tickyFlags] :: RTSFlags -> TickyFlags
[parFlags] :: RTSFlags -> ParFlags

-- | Should we produce a summary of the garbage collector statistics after
--   the program has exited?
data GiveGCStats
NoGCStats :: GiveGCStats
CollectGCStats :: GiveGCStats
OneLineGCStats :: GiveGCStats
SummaryGCStats :: GiveGCStats
VerboseGCStats :: GiveGCStats

-- | Parameters of the garbage collector.
data GCFlags
GCFlags :: Maybe FilePath -> GiveGCStats -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Bool -> Double -> Double -> Word32 -> Bool -> Bool -> Double -> Bool -> Bool -> RtsTime -> Bool -> Word -> Word -> Bool -> Word -> GCFlags
[statsFile] :: GCFlags -> Maybe FilePath
[giveStats] :: GCFlags -> GiveGCStats
[maxStkSize] :: GCFlags -> Word32
[initialStkSize] :: GCFlags -> Word32
[stkChunkSize] :: GCFlags -> Word32
[stkChunkBufferSize] :: GCFlags -> Word32
[maxHeapSize] :: GCFlags -> Word32
[minAllocAreaSize] :: GCFlags -> Word32
[largeAllocLim] :: GCFlags -> Word32
[nurseryChunkSize] :: GCFlags -> Word32
[minOldGenSize] :: GCFlags -> Word32
[heapSizeSuggestion] :: GCFlags -> Word32
[heapSizeSuggestionAuto] :: GCFlags -> Bool
[oldGenFactor] :: GCFlags -> Double
[pcFreeHeap] :: GCFlags -> Double
[generations] :: GCFlags -> Word32
[squeezeUpdFrames] :: GCFlags -> Bool

-- | True <a>=</a> "compact all the time"
[compact] :: GCFlags -> Bool
[compactThreshold] :: GCFlags -> Double

-- | use "mostly mark-sweep" instead of copying for the oldest generation
[sweep] :: GCFlags -> Bool
[ringBell] :: GCFlags -> Bool
[idleGCDelayTime] :: GCFlags -> RtsTime
[doIdleGC] :: GCFlags -> Bool

-- | address to ask the OS for memory
[heapBase] :: GCFlags -> Word
[allocLimitGrace] :: GCFlags -> Word
[numa] :: GCFlags -> Bool
[numaMask] :: GCFlags -> Word

-- | Parameters concerning context switching
data ConcFlags
ConcFlags :: RtsTime -> Int -> ConcFlags
[ctxtSwitchTime] :: ConcFlags -> RtsTime
[ctxtSwitchTicks] :: ConcFlags -> Int

-- | Miscellaneous parameters
data MiscFlags
MiscFlags :: RtsTime -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Word -> MiscFlags
[tickInterval] :: MiscFlags -> RtsTime
[installSignalHandlers] :: MiscFlags -> Bool
[installSEHHandlers] :: MiscFlags -> Bool
[generateCrashDumpFile] :: MiscFlags -> Bool
[generateStackTrace] :: MiscFlags -> Bool
[machineReadable] :: MiscFlags -> Bool
[internalCounters] :: MiscFlags -> Bool

-- | address to ask the OS for memory for the linker, 0 ==&gt; off
[linkerMemBase] :: MiscFlags -> Word

-- | Flags to control debugging output &amp; extra checking in various
--   subsystems.
data DebugFlags
DebugFlags :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> DebugFlags

-- | <tt>s</tt>
[scheduler] :: DebugFlags -> Bool

-- | <tt>i</tt>
[interpreter] :: DebugFlags -> Bool

-- | <tt>w</tt>
[weak] :: DebugFlags -> Bool

-- | <tt>G</tt>
[gccafs] :: DebugFlags -> Bool

-- | <tt>g</tt>
[gc] :: DebugFlags -> Bool

-- | <tt>b</tt>
[block_alloc] :: DebugFlags -> Bool

-- | <tt>S</tt>
[sanity] :: DebugFlags -> Bool

-- | <tt>t</tt>
[stable] :: DebugFlags -> Bool

-- | <tt>p</tt>
[prof] :: DebugFlags -> Bool

-- | <tt>l</tt> the object linker
[linker] :: DebugFlags -> Bool

-- | <tt>a</tt>
[apply] :: DebugFlags -> Bool

-- | <tt>m</tt>
[stm] :: DebugFlags -> Bool

-- | <tt>z</tt> stack squeezing &amp; lazy blackholing
[squeeze] :: DebugFlags -> Bool

-- | <tt>c</tt> coverage
[hpc] :: DebugFlags -> Bool

-- | <tt>r</tt>
[sparks] :: DebugFlags -> Bool

-- | Should the RTS produce a cost-center summary?
data DoCostCentres
CostCentresNone :: DoCostCentres
CostCentresSummary :: DoCostCentres
CostCentresVerbose :: DoCostCentres
CostCentresAll :: DoCostCentres
CostCentresJSON :: DoCostCentres

-- | Parameters pertaining to the cost-center profiler.
data CCFlags
CCFlags :: DoCostCentres -> Int -> Int -> CCFlags
[doCostCentres] :: CCFlags -> DoCostCentres
[profilerTicks] :: CCFlags -> Int
[msecsPerTick] :: CCFlags -> Int

-- | What sort of heap profile are we collecting?
data DoHeapProfile
NoHeapProfiling :: DoHeapProfile
HeapByCCS :: DoHeapProfile
HeapByMod :: DoHeapProfile
HeapByDescr :: DoHeapProfile
HeapByType :: DoHeapProfile
HeapByRetainer :: DoHeapProfile
HeapByLDV :: DoHeapProfile
HeapByClosureType :: DoHeapProfile

-- | Parameters of the cost-center profiler
data ProfFlags
ProfFlags :: DoHeapProfile -> RtsTime -> Word -> Bool -> Bool -> Word -> Word -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> ProfFlags
[doHeapProfile] :: ProfFlags -> DoHeapProfile

-- | time between samples
[heapProfileInterval] :: ProfFlags -> RtsTime

-- | ticks between samples (derived)
[heapProfileIntervalTicks] :: ProfFlags -> Word
[includeTSOs] :: ProfFlags -> Bool
[showCCSOnException] :: ProfFlags -> Bool
[maxRetainerSetSize] :: ProfFlags -> Word
[ccsLength] :: ProfFlags -> Word
[modSelector] :: ProfFlags -> Maybe String
[descrSelector] :: ProfFlags -> Maybe String
[typeSelector] :: ProfFlags -> Maybe String
[ccSelector] :: ProfFlags -> Maybe String
[ccsSelector] :: ProfFlags -> Maybe String
[retainerSelector] :: ProfFlags -> Maybe String
[bioSelector] :: ProfFlags -> Maybe String

-- | Is event tracing enabled?
data DoTrace

-- | no tracing
TraceNone :: DoTrace

-- | send tracing events to the event log
TraceEventLog :: DoTrace

-- | send tracing events to <tt>stderr</tt>
TraceStderr :: DoTrace

-- | Parameters pertaining to event tracing
data TraceFlags
TraceFlags :: DoTrace -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> TraceFlags
[tracing] :: TraceFlags -> DoTrace

-- | show timestamp in stderr output
[timestamp] :: TraceFlags -> Bool

-- | trace scheduler events
[traceScheduler] :: TraceFlags -> Bool

-- | trace GC events
[traceGc] :: TraceFlags -> Bool

-- | trace spark events by a sampled method
[sparksSampled] :: TraceFlags -> Bool

-- | trace spark events 100% accurately
[sparksFull] :: TraceFlags -> Bool

-- | trace user events (emitted from Haskell code)
[user] :: TraceFlags -> Bool

-- | Parameters pertaining to ticky-ticky profiler
data TickyFlags
TickyFlags :: Bool -> Maybe FilePath -> TickyFlags
[showTickyStats] :: TickyFlags -> Bool
[tickyFile] :: TickyFlags -> Maybe FilePath

-- | Parameters pertaining to parallelism
data ParFlags
ParFlags :: Word32 -> Bool -> Word32 -> Bool -> Word32 -> Bool -> Word32 -> Word32 -> Word32 -> Bool -> ParFlags
[nCapabilities] :: ParFlags -> Word32
[migrate] :: ParFlags -> Bool
[maxLocalSparks] :: ParFlags -> Word32
[parGcEnabled] :: ParFlags -> Bool
[parGcGen] :: ParFlags -> Word32
[parGcLoadBalancingEnabled] :: ParFlags -> Bool
[parGcLoadBalancingGen] :: ParFlags -> Word32
[parGcNoSyncWithIdle] :: ParFlags -> Word32
[parGcThreads] :: ParFlags -> Word32
[setAffinity] :: ParFlags -> Bool
getRTSFlags :: IO RTSFlags
getGCFlags :: IO GCFlags
getConcFlags :: IO ConcFlags
getMiscFlags :: IO MiscFlags
getDebugFlags :: IO DebugFlags
getCCFlags :: IO CCFlags
getProfFlags :: IO ProfFlags
getTraceFlags :: IO TraceFlags
getTickyFlags :: IO TickyFlags
getParFlags :: IO ParFlags
instance GHC.Show.Show GHC.RTS.Flags.RTSFlags
instance GHC.Show.Show GHC.RTS.Flags.ParFlags
instance GHC.Show.Show GHC.RTS.Flags.TickyFlags
instance GHC.Show.Show GHC.RTS.Flags.TraceFlags
instance GHC.Show.Show GHC.RTS.Flags.DoTrace
instance GHC.Show.Show GHC.RTS.Flags.ProfFlags
instance GHC.Show.Show GHC.RTS.Flags.DoHeapProfile
instance GHC.Show.Show GHC.RTS.Flags.CCFlags
instance GHC.Show.Show GHC.RTS.Flags.DoCostCentres
instance GHC.Show.Show GHC.RTS.Flags.DebugFlags
instance GHC.Show.Show GHC.RTS.Flags.MiscFlags
instance GHC.Show.Show GHC.RTS.Flags.ConcFlags
instance GHC.Show.Show GHC.RTS.Flags.GCFlags
instance GHC.Show.Show GHC.RTS.Flags.GiveGCStats
instance GHC.Enum.Enum GHC.RTS.Flags.DoTrace
instance GHC.Enum.Enum GHC.RTS.Flags.DoHeapProfile
instance GHC.Enum.Enum GHC.RTS.Flags.DoCostCentres
instance GHC.Enum.Enum GHC.RTS.Flags.GiveGCStats


-- | Internals of the <a>ExecutionStack</a> module
module GHC.ExecutionStack.Internal

-- | Location information about an address from a backtrace.
data Location
Location :: String -> String -> Maybe SrcLoc -> Location
[objectName] :: Location -> String
[functionName] :: Location -> String
[srcLoc] :: Location -> Maybe SrcLoc

-- | A location in the original program source.
data SrcLoc
SrcLoc :: String -> Int -> Int -> SrcLoc
[sourceFile] :: SrcLoc -> String
[sourceLine] :: SrcLoc -> Int
[sourceColumn] :: SrcLoc -> Int

-- | The state of the execution stack
data StackTrace

-- | List the frames of a stack trace.
stackFrames :: StackTrace -> Maybe [Location]

-- | How many stack frames in the given <a>StackTrace</a>
stackDepth :: StackTrace -> Int

-- | Get an execution stack.
collectStackTrace :: IO (Maybe StackTrace)

-- | Render a stacktrace as a string
showStackFrames :: [Location] -> ShowS

-- | Free the cached debug data.
invalidateDebugCache :: IO ()


-- | This is a module for efficient stack traces. This stack trace
--   implementation is considered low overhead. Basic usage looks like
--   this:
--   
--   <pre>
--   import GHC.ExecutionStack
--   
--   myFunction :: IO ()
--   myFunction = do
--        putStrLn =&lt;&lt; showStackTrace
--   </pre>
--   
--   Your GHC must have been built with <tt>libdw</tt> support for this to
--   work.
--   
--   <pre>
--   user@host:~$ ghc --info | grep libdw
--    ,("RTS expects libdw",<a>YES</a>)
--   </pre>
module GHC.ExecutionStack

-- | Location information about an address from a backtrace.
data Location
Location :: String -> String -> Maybe SrcLoc -> Location
[objectName] :: Location -> String
[functionName] :: Location -> String
[srcLoc] :: Location -> Maybe SrcLoc

-- | A location in the original program source.
data SrcLoc
SrcLoc :: String -> Int -> Int -> SrcLoc
[sourceFile] :: SrcLoc -> String
[sourceLine] :: SrcLoc -> Int
[sourceColumn] :: SrcLoc -> Int

-- | Get a trace of the current execution stack state.
--   
--   Returns <tt>Nothing</tt> if stack trace support isn't available on
--   host machine.
getStackTrace :: IO (Maybe [Location])

-- | Get a string representation of the current execution stack state.
showStackTrace :: IO (Maybe String)


-- | A <a>NonEmpty</a> list is one which always has at least one element,
--   but is otherwise identical to the traditional list type in complexity
--   and in terms of API. You will almost certainly want to import this
--   module <tt>qualified</tt>.
module Data.List.NonEmpty

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | Map a function over a <a>NonEmpty</a> stream.
map :: (a -> b) -> NonEmpty a -> NonEmpty b

-- | 'intersperse x xs' alternates elements of the list with copies of
--   <tt>x</tt>.
--   
--   <pre>
--   intersperse 0 (1 :| [2,3]) == 1 :| [0,2,0,3]
--   </pre>
intersperse :: a -> NonEmpty a -> NonEmpty a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a stream of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == z :| [z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: Foldable f => (b -> a -> b) -> b -> f a -> NonEmpty b

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: Foldable f => (a -> b -> b) -> b -> f a -> NonEmpty b

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == x1 :| [x1 `f` x2, x1 `f` (x2 `f` x3), ...]
--   </pre>
scanl1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a

-- | <a>transpose</a> for <a>NonEmpty</a>, behaves the same as
--   <a>transpose</a> The rows/columns need not be the same length, in
--   which case &gt; transpose . transpose /= id
transpose :: NonEmpty (NonEmpty a) -> NonEmpty (NonEmpty a)

-- | <a>sortBy</a> for <a>NonEmpty</a>, behaves the same as <a>sortBy</a>
sortBy :: (a -> a -> Ordering) -> NonEmpty a -> NonEmpty a

-- | <a>sortWith</a> for <a>NonEmpty</a>, behaves the same as:
--   
--   <pre>
--   sortBy . comparing
--   </pre>
sortWith :: Ord o => (a -> o) -> NonEmpty a -> NonEmpty a

-- | Number of elements in <a>NonEmpty</a> list.
length :: NonEmpty a -> Int

-- | Extract the first element of the stream.
head :: NonEmpty a -> a

-- | Extract the possibly-empty tail of the stream.
tail :: NonEmpty a -> [a]

-- | Extract the last element of the stream.
last :: NonEmpty a -> a

-- | Extract everything except the last element of the stream.
init :: NonEmpty a -> [a]

-- | Prepend an element to the stream.
(<|) :: a -> NonEmpty a -> NonEmpty a
infixr 5 <|

-- | Synonym for <a>&lt;|</a>.
cons :: a -> NonEmpty a -> NonEmpty a

-- | <a>uncons</a> produces the first element of the stream, and a stream
--   of the remaining elements, if any.
uncons :: NonEmpty a -> (a, Maybe (NonEmpty a))

-- | The <a>unfoldr</a> function is analogous to <a>Data.List</a>'s
--   <a>unfoldr</a> operation.
unfoldr :: (a -> (b, Maybe a)) -> a -> NonEmpty b

-- | Sort a stream.
sort :: Ord a => NonEmpty a -> NonEmpty a

-- | <a>reverse</a> a finite NonEmpty stream.
reverse :: NonEmpty a -> NonEmpty a

-- | The <a>inits</a> function takes a stream <tt>xs</tt> and returns all
--   the finite prefixes of <tt>xs</tt>.
inits :: Foldable f => f a -> NonEmpty [a]

-- | The <a>tails</a> function takes a stream <tt>xs</tt> and returns all
--   the suffixes of <tt>xs</tt>.
tails :: Foldable f => f a -> NonEmpty [a]

-- | <tt><a>iterate</a> f x</tt> produces the infinite sequence of repeated
--   applications of <tt>f</tt> to <tt>x</tt>.
--   
--   <pre>
--   iterate f x = x :| [f x, f (f x), ..]
--   </pre>
iterate :: (a -> a) -> a -> NonEmpty a

-- | <tt><a>repeat</a> x</tt> returns a constant stream, where all elements
--   are equal to <tt>x</tt>.
repeat :: a -> NonEmpty a

-- | <tt><a>cycle</a> xs</tt> returns the infinite repetition of
--   <tt>xs</tt>:
--   
--   <pre>
--   cycle (1 :| [2,3]) = 1 :| [2,3,1,2,3,...]
--   </pre>
cycle :: NonEmpty a -> NonEmpty a

-- | <a>unfold</a> produces a new stream by repeatedly applying the
--   unfolding function to the seed value to produce an element of type
--   <tt>b</tt> and a new seed value. When the unfolding function returns
--   <a>Nothing</a> instead of a new seed value, the stream ends.

-- | <i>Deprecated: Use unfoldr</i>
unfold :: (a -> (b, Maybe a)) -> a -> NonEmpty b

-- | <tt><a>insert</a> x xs</tt> inserts <tt>x</tt> into the last position
--   in <tt>xs</tt> where it is still less than or equal to the next
--   element. In particular, if the list is sorted beforehand, the result
--   will also be sorted.
insert :: (Foldable f, Ord a) => a -> f a -> NonEmpty a

-- | <tt><a>some1</a> x</tt> sequences <tt>x</tt> one or more times.
some1 :: Alternative f => f a -> f (NonEmpty a)

-- | <tt><a>take</a> n xs</tt> returns the first <tt>n</tt> elements of
--   <tt>xs</tt>.
take :: Int -> NonEmpty a -> [a]

-- | <tt><a>drop</a> n xs</tt> drops the first <tt>n</tt> elements off the
--   front of the sequence <tt>xs</tt>.
drop :: Int -> NonEmpty a -> [a]

-- | <tt><a>splitAt</a> n xs</tt> returns a pair consisting of the prefix
--   of <tt>xs</tt> of length <tt>n</tt> and the remaining stream
--   immediately following this prefix.
--   
--   <pre>
--   'splitAt' n xs == ('take' n xs, 'drop' n xs)
--   xs == ys ++ zs where (ys, zs) = 'splitAt' n xs
--   </pre>
splitAt :: Int -> NonEmpty a -> ([a], [a])

-- | <tt><a>takeWhile</a> p xs</tt> returns the longest prefix of the
--   stream <tt>xs</tt> for which the predicate <tt>p</tt> holds.
takeWhile :: (a -> Bool) -> NonEmpty a -> [a]

-- | <tt><a>dropWhile</a> p xs</tt> returns the suffix remaining after
--   <tt><a>takeWhile</a> p xs</tt>.
dropWhile :: (a -> Bool) -> NonEmpty a -> [a]

-- | <tt><a>span</a> p xs</tt> returns the longest prefix of <tt>xs</tt>
--   that satisfies <tt>p</tt>, together with the remainder of the stream.
--   
--   <pre>
--   'span' p xs == ('takeWhile' p xs, 'dropWhile' p xs)
--   xs == ys ++ zs where (ys, zs) = 'span' p xs
--   </pre>
span :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | The <tt><a>break</a> p</tt> function is equivalent to <tt><a>span</a>
--   (not . p)</tt>.
break :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | <tt><a>filter</a> p xs</tt> removes any elements from <tt>xs</tt> that
--   do not satisfy <tt>p</tt>.
filter :: (a -> Bool) -> NonEmpty a -> [a]

-- | The <a>partition</a> function takes a predicate <tt>p</tt> and a
--   stream <tt>xs</tt>, and returns a pair of lists. The first list
--   corresponds to the elements of <tt>xs</tt> for which <tt>p</tt> holds;
--   the second corresponds to the elements of <tt>xs</tt> for which
--   <tt>p</tt> does not hold.
--   
--   <pre>
--   'partition' p xs = ('filter' p xs, 'filter' (not . p) xs)
--   </pre>
partition :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | The <a>group</a> function takes a stream and returns a list of streams
--   such that flattening the resulting list is equal to the argument.
--   Moreover, each stream in the resulting list contains only equal
--   elements. For example, in list notation:
--   
--   <pre>
--   'group' $ 'cycle' "Mississippi"
--     = "M" : "i" : "ss" : "i" : "ss" : "i" : "pp" : "i" : "M" : "i" : ...
--   </pre>
group :: (Foldable f, Eq a) => f a -> [NonEmpty a]

-- | <a>groupBy</a> operates like <a>group</a>, but uses the provided
--   equality predicate instead of <a>==</a>.
groupBy :: Foldable f => (a -> a -> Bool) -> f a -> [NonEmpty a]

-- | <a>groupWith</a> operates like <a>group</a>, but uses the provided
--   projection when comparing for equality
groupWith :: (Foldable f, Eq b) => (a -> b) -> f a -> [NonEmpty a]

-- | <a>groupAllWith</a> operates like <a>groupWith</a>, but sorts the list
--   first so that each equivalence class has, at most, one list in the
--   output
groupAllWith :: Ord b => (a -> b) -> [a] -> [NonEmpty a]

-- | <a>group1</a> operates like <a>group</a>, but uses the knowledge that
--   its input is non-empty to produce guaranteed non-empty output.
group1 :: Eq a => NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupBy1</a> is to <a>group1</a> as <a>groupBy</a> is to
--   <a>group</a>.
groupBy1 :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupWith1</a> is to <a>group1</a> as <a>groupWith</a> is to
--   <a>group</a>
groupWith1 :: Eq b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupAllWith1</a> is to <a>groupWith1</a> as <a>groupAllWith</a> is
--   to <a>groupWith</a>
groupAllWith1 :: Ord b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | The <tt>isPrefix</tt> function returns <tt>True</tt> if the first
--   argument is a prefix of the second.
isPrefixOf :: Eq a => [a] -> NonEmpty a -> Bool

-- | The <a>nub</a> function removes duplicate elements from a list. In
--   particular, it keeps only the first occurrence of each element. (The
--   name <a>nub</a> means 'essence'.) It is a special case of
--   <a>nubBy</a>, which allows the programmer to supply their own
--   inequality test.
nub :: Eq a => NonEmpty a -> NonEmpty a

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
nubBy :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty a

-- | <tt>xs !! n</tt> returns the element of the stream <tt>xs</tt> at
--   index <tt>n</tt>. Note that the head of the stream has index 0.
--   
--   <i>Beware</i>: a negative or out-of-bounds index will cause an error.
(!!) :: NonEmpty a -> Int -> a
infixl 9 !!

-- | The <a>zip</a> function takes two streams and returns a stream of
--   corresponding pairs.
zip :: NonEmpty a -> NonEmpty b -> NonEmpty (a, b)

-- | The <a>zipWith</a> function generalizes <a>zip</a>. Rather than
--   tupling the elements, the elements are combined using the function
--   passed as the first argument.
zipWith :: (a -> b -> c) -> NonEmpty a -> NonEmpty b -> NonEmpty c

-- | The <a>unzip</a> function is the inverse of the <a>zip</a> function.
unzip :: Functor f => f (a, b) -> (f a, f b)

-- | Converts a normal list to a <a>NonEmpty</a> stream.
--   
--   Raises an error if given an empty list.
fromList :: [a] -> NonEmpty a

-- | Convert a stream to a normal list efficiently.
toList :: NonEmpty a -> [a]

-- | <a>nonEmpty</a> efficiently turns a normal list into a <a>NonEmpty</a>
--   stream, producing <a>Nothing</a> if the input is empty.
nonEmpty :: [a] -> Maybe (NonEmpty a)

-- | Compute n-ary logic exclusive OR operation on <a>NonEmpty</a> list.
xor :: NonEmpty Bool -> Bool


-- | Monadic zipping (used for monad comprehensions)
module Control.Monad.Zip

-- | <a>MonadZip</a> type class. Minimal definition: <a>mzip</a> or
--   <a>mzipWith</a>
--   
--   Instances should satisfy the laws:
--   
--   <ul>
--   <li>Naturality :</li>
--   </ul>
--   
--   <pre>
--   liftM (f *** g) (mzip ma mb) = mzip (liftM f ma) (liftM g mb)
--   </pre>
--   
--   <ul>
--   <li>Information Preservation:</li>
--   </ul>
--   
--   <pre>
--   liftM (const ()) ma = liftM (const ()) mb
--   ==&gt;
--   munzip (mzip ma mb) = (ma, mb)
--   </pre>
class Monad m => MonadZip m
mzip :: MonadZip m => m a -> m b -> m (a, b)
mzipWith :: MonadZip m => (a -> b -> c) -> m a -> m b -> m c
munzip :: MonadZip m => m (a, b) -> (m a, m b)
instance Control.Monad.Zip.MonadZip []
instance Control.Monad.Zip.MonadZip GHC.Base.NonEmpty
instance Control.Monad.Zip.MonadZip Data.Functor.Identity.Identity
instance Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Dual
instance Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Sum
instance Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Product
instance Control.Monad.Zip.MonadZip GHC.Maybe.Maybe
instance Control.Monad.Zip.MonadZip Data.Monoid.First
instance Control.Monad.Zip.MonadZip Data.Monoid.Last
instance Control.Monad.Zip.MonadZip f => Control.Monad.Zip.MonadZip (Data.Semigroup.Internal.Alt f)
instance Control.Monad.Zip.MonadZip Data.Proxy.Proxy
instance Control.Monad.Zip.MonadZip GHC.Generics.U1
instance Control.Monad.Zip.MonadZip GHC.Generics.Par1
instance Control.Monad.Zip.MonadZip f => Control.Monad.Zip.MonadZip (GHC.Generics.Rec1 f)
instance Control.Monad.Zip.MonadZip f => Control.Monad.Zip.MonadZip (GHC.Generics.M1 i c f)
instance (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) => Control.Monad.Zip.MonadZip (f GHC.Generics.:*: g)
instance Control.Monad.Zip.MonadZip Data.Ord.Down


-- | Liftings of the Prelude classes <a>Eq</a>, <a>Ord</a>, <a>Read</a> and
--   <a>Show</a> to unary and binary type constructors.
--   
--   These classes are needed to express the constraints on arguments of
--   transformers in portable Haskell. Thus for a new transformer
--   <tt>T</tt>, one might write instances like
--   
--   <pre>
--   instance (Eq1 f) =&gt; Eq1 (T f) where ...
--   instance (Ord1 f) =&gt; Ord1 (T f) where ...
--   instance (Read1 f) =&gt; Read1 (T f) where ...
--   instance (Show1 f) =&gt; Show1 (T f) where ...
--   </pre>
--   
--   If these instances can be defined, defining instances of the base
--   classes is mechanical:
--   
--   <pre>
--   instance (Eq1 f, Eq a) =&gt; Eq (T f a) where (==) = eq1
--   instance (Ord1 f, Ord a) =&gt; Ord (T f a) where compare = compare1
--   instance (Read1 f, Read a) =&gt; Read (T f a) where
--     readPrec     = readPrec1
--     readListPrec = readListPrecDefault
--   instance (Show1 f, Show a) =&gt; Show (T f a) where showsPrec = showsPrec1
--   </pre>
module Data.Functor.Classes

-- | Lifting of the <a>Eq</a> class to unary type constructors.
class Eq1 f

-- | Lift an equality test through the type constructor.
--   
--   The function will usually be applied to an equality function, but the
--   more general type ensures that the implementation uses it to compare
--   elements of the first container with elements of the second.
liftEq :: Eq1 f => (a -> b -> Bool) -> f a -> f b -> Bool

-- | Lift the standard <tt>(<a>==</a>)</tt> function through the type
--   constructor.
eq1 :: (Eq1 f, Eq a) => f a -> f a -> Bool

-- | Lifting of the <a>Ord</a> class to unary type constructors.
class (Eq1 f) => Ord1 f

-- | Lift a <a>compare</a> function through the type constructor.
--   
--   The function will usually be applied to a comparison function, but the
--   more general type ensures that the implementation uses it to compare
--   elements of the first container with elements of the second.
liftCompare :: Ord1 f => (a -> b -> Ordering) -> f a -> f b -> Ordering

-- | Lift the standard <a>compare</a> function through the type
--   constructor.
compare1 :: (Ord1 f, Ord a) => f a -> f a -> Ordering

-- | Lifting of the <a>Read</a> class to unary type constructors.
--   
--   Both <a>liftReadsPrec</a> and <a>liftReadPrec</a> exist to match the
--   interface provided in the <a>Read</a> type class, but it is
--   recommended to implement <a>Read1</a> instances using
--   <a>liftReadPrec</a> as opposed to <a>liftReadsPrec</a>, since the
--   former is more efficient than the latter. For example:
--   
--   <pre>
--   instance <a>Read1</a> T where
--     <a>liftReadPrec</a>     = ...
--     <a>liftReadListPrec</a> = <a>liftReadListPrecDefault</a>
--   </pre>
--   
--   For more information, refer to the documentation for the <a>Read</a>
--   class.
class Read1 f

-- | <a>readsPrec</a> function for an application of the type constructor
--   based on <a>readsPrec</a> and <a>readList</a> functions for the
--   argument type.
liftReadsPrec :: Read1 f => (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (f a)

-- | <a>readList</a> function for an application of the type constructor
--   based on <a>readsPrec</a> and <a>readList</a> functions for the
--   argument type. The default implementation using standard list syntax
--   is correct for most types.
liftReadList :: Read1 f => (Int -> ReadS a) -> ReadS [a] -> ReadS [f a]

-- | <a>readPrec</a> function for an application of the type constructor
--   based on <a>readPrec</a> and <a>readListPrec</a> functions for the
--   argument type.
liftReadPrec :: Read1 f => ReadPrec a -> ReadPrec [a] -> ReadPrec (f a)

-- | <a>readListPrec</a> function for an application of the type
--   constructor based on <a>readPrec</a> and <a>readListPrec</a> functions
--   for the argument type.
--   
--   The default definition uses <a>liftReadList</a>. Instances that define
--   <a>liftReadPrec</a> should also define <a>liftReadListPrec</a> as
--   <a>liftReadListPrecDefault</a>.
liftReadListPrec :: Read1 f => ReadPrec a -> ReadPrec [a] -> ReadPrec [f a]

-- | Lift the standard <a>readsPrec</a> and <a>readList</a> functions
--   through the type constructor.
readsPrec1 :: (Read1 f, Read a) => Int -> ReadS (f a)

-- | Lift the standard <a>readPrec</a> and <a>readListPrec</a> functions
--   through the type constructor.
readPrec1 :: (Read1 f, Read a) => ReadPrec (f a)

-- | A possible replacement definition for the <a>liftReadList</a> method.
--   This is only needed for <a>Read1</a> instances where
--   <a>liftReadListPrec</a> isn't defined as
--   <a>liftReadListPrecDefault</a>.
liftReadListDefault :: Read1 f => (Int -> ReadS a) -> ReadS [a] -> ReadS [f a]

-- | A possible replacement definition for the <a>liftReadListPrec</a>
--   method, defined using <a>liftReadPrec</a>.
liftReadListPrecDefault :: Read1 f => ReadPrec a -> ReadPrec [a] -> ReadPrec [f a]

-- | Lifting of the <a>Show</a> class to unary type constructors.
class Show1 f

-- | <a>showsPrec</a> function for an application of the type constructor
--   based on <a>showsPrec</a> and <a>showList</a> functions for the
--   argument type.
liftShowsPrec :: Show1 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> f a -> ShowS

-- | <a>showList</a> function for an application of the type constructor
--   based on <a>showsPrec</a> and <a>showList</a> functions for the
--   argument type. The default implementation using standard list syntax
--   is correct for most types.
liftShowList :: Show1 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> [f a] -> ShowS

-- | Lift the standard <a>showsPrec</a> and <a>showList</a> functions
--   through the type constructor.
showsPrec1 :: (Show1 f, Show a) => Int -> f a -> ShowS

-- | Lifting of the <a>Eq</a> class to binary type constructors.
class Eq2 f

-- | Lift equality tests through the type constructor.
--   
--   The function will usually be applied to equality functions, but the
--   more general type ensures that the implementation uses them to compare
--   elements of the first container with elements of the second.
liftEq2 :: Eq2 f => (a -> b -> Bool) -> (c -> d -> Bool) -> f a c -> f b d -> Bool

-- | Lift the standard <tt>(<a>==</a>)</tt> function through the type
--   constructor.
eq2 :: (Eq2 f, Eq a, Eq b) => f a b -> f a b -> Bool

-- | Lifting of the <a>Ord</a> class to binary type constructors.
class (Eq2 f) => Ord2 f

-- | Lift <a>compare</a> functions through the type constructor.
--   
--   The function will usually be applied to comparison functions, but the
--   more general type ensures that the implementation uses them to compare
--   elements of the first container with elements of the second.
liftCompare2 :: Ord2 f => (a -> b -> Ordering) -> (c -> d -> Ordering) -> f a c -> f b d -> Ordering

-- | Lift the standard <a>compare</a> function through the type
--   constructor.
compare2 :: (Ord2 f, Ord a, Ord b) => f a b -> f a b -> Ordering

-- | Lifting of the <a>Read</a> class to binary type constructors.
--   
--   Both <a>liftReadsPrec2</a> and <a>liftReadPrec2</a> exist to match the
--   interface provided in the <a>Read</a> type class, but it is
--   recommended to implement <a>Read2</a> instances using
--   <a>liftReadPrec2</a> as opposed to <a>liftReadsPrec2</a>, since the
--   former is more efficient than the latter. For example:
--   
--   <pre>
--   instance <a>Read2</a> T where
--     <a>liftReadPrec2</a>     = ...
--     <a>liftReadListPrec2</a> = <a>liftReadListPrec2Default</a>
--   </pre>
--   
--   For more information, refer to the documentation for the <a>Read</a>
--   class. @since 4.9.0.0
class Read2 f

-- | <a>readsPrec</a> function for an application of the type constructor
--   based on <a>readsPrec</a> and <a>readList</a> functions for the
--   argument types.
liftReadsPrec2 :: Read2 f => (Int -> ReadS a) -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> Int -> ReadS (f a b)

-- | <a>readList</a> function for an application of the type constructor
--   based on <a>readsPrec</a> and <a>readList</a> functions for the
--   argument types. The default implementation using standard list syntax
--   is correct for most types.
liftReadList2 :: Read2 f => (Int -> ReadS a) -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> ReadS [f a b]

-- | <a>readPrec</a> function for an application of the type constructor
--   based on <a>readPrec</a> and <a>readListPrec</a> functions for the
--   argument types.
liftReadPrec2 :: Read2 f => ReadPrec a -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec (f a b)

-- | <a>readListPrec</a> function for an application of the type
--   constructor based on <a>readPrec</a> and <a>readListPrec</a> functions
--   for the argument types.
--   
--   The default definition uses <a>liftReadList2</a>. Instances that
--   define <a>liftReadPrec2</a> should also define
--   <a>liftReadListPrec2</a> as <a>liftReadListPrec2Default</a>.
liftReadListPrec2 :: Read2 f => ReadPrec a -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec [f a b]

-- | Lift the standard <a>readsPrec</a> function through the type
--   constructor.
readsPrec2 :: (Read2 f, Read a, Read b) => Int -> ReadS (f a b)

-- | Lift the standard <a>readPrec</a> function through the type
--   constructor.
readPrec2 :: (Read2 f, Read a, Read b) => ReadPrec (f a b)

-- | A possible replacement definition for the <a>liftReadList2</a> method.
--   This is only needed for <a>Read2</a> instances where
--   <a>liftReadListPrec2</a> isn't defined as
--   <a>liftReadListPrec2Default</a>.
liftReadList2Default :: Read2 f => (Int -> ReadS a) -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> ReadS [f a b]

-- | A possible replacement definition for the <a>liftReadListPrec2</a>
--   method, defined using <a>liftReadPrec2</a>.
liftReadListPrec2Default :: Read2 f => ReadPrec a -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec [f a b]

-- | Lifting of the <a>Show</a> class to binary type constructors.
class Show2 f

-- | <a>showsPrec</a> function for an application of the type constructor
--   based on <a>showsPrec</a> and <a>showList</a> functions for the
--   argument types.
liftShowsPrec2 :: Show2 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> (Int -> b -> ShowS) -> ([b] -> ShowS) -> Int -> f a b -> ShowS

-- | <a>showList</a> function for an application of the type constructor
--   based on <a>showsPrec</a> and <a>showList</a> functions for the
--   argument types. The default implementation using standard list syntax
--   is correct for most types.
liftShowList2 :: Show2 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> (Int -> b -> ShowS) -> ([b] -> ShowS) -> [f a b] -> ShowS

-- | Lift the standard <a>showsPrec</a> function through the type
--   constructor.
showsPrec2 :: (Show2 f, Show a, Show b) => Int -> f a b -> ShowS

-- | <tt><a>readsData</a> p d</tt> is a parser for datatypes where each
--   alternative begins with a data constructor. It parses the constructor
--   and passes it to <tt>p</tt>. Parsers for various constructors can be
--   constructed with <a>readsUnary</a>, <a>readsUnary1</a> and
--   <a>readsBinary1</a>, and combined with <tt>mappend</tt> from the
--   <tt>Monoid</tt> class.
readsData :: (String -> ReadS a) -> Int -> ReadS a

-- | <tt><a>readData</a> p</tt> is a parser for datatypes where each
--   alternative begins with a data constructor. It parses the constructor
--   and passes it to <tt>p</tt>. Parsers for various constructors can be
--   constructed with <a>readUnaryWith</a> and <a>readBinaryWith</a>, and
--   combined with '(<a>|</a>)' from the <a>Alternative</a> class.
readData :: ReadPrec a -> ReadPrec a

-- | <tt><a>readsUnaryWith</a> rp n c n'</tt> matches the name of a unary
--   data constructor and then parses its argument using <tt>rp</tt>.
readsUnaryWith :: (Int -> ReadS a) -> String -> (a -> t) -> String -> ReadS t

-- | <tt><a>readUnaryWith</a> rp n c'</tt> matches the name of a unary data
--   constructor and then parses its argument using <tt>rp</tt>.
readUnaryWith :: ReadPrec a -> String -> (a -> t) -> ReadPrec t

-- | <tt><a>readsBinaryWith</a> rp1 rp2 n c n'</tt> matches the name of a
--   binary data constructor and then parses its arguments using
--   <tt>rp1</tt> and <tt>rp2</tt> respectively.
readsBinaryWith :: (Int -> ReadS a) -> (Int -> ReadS b) -> String -> (a -> b -> t) -> String -> ReadS t

-- | <tt><a>readBinaryWith</a> rp1 rp2 n c'</tt> matches the name of a
--   binary data constructor and then parses its arguments using
--   <tt>rp1</tt> and <tt>rp2</tt> respectively.
readBinaryWith :: ReadPrec a -> ReadPrec b -> String -> (a -> b -> t) -> ReadPrec t

-- | <tt><a>showsUnaryWith</a> sp n d x</tt> produces the string
--   representation of a unary data constructor with name <tt>n</tt> and
--   argument <tt>x</tt>, in precedence context <tt>d</tt>.
showsUnaryWith :: (Int -> a -> ShowS) -> String -> Int -> a -> ShowS

-- | <tt><a>showsBinaryWith</a> sp1 sp2 n d x y</tt> produces the string
--   representation of a binary data constructor with name <tt>n</tt> and
--   arguments <tt>x</tt> and <tt>y</tt>, in precedence context <tt>d</tt>.
showsBinaryWith :: (Int -> a -> ShowS) -> (Int -> b -> ShowS) -> String -> Int -> a -> b -> ShowS

-- | <tt><a>readsUnary</a> n c n'</tt> matches the name of a unary data
--   constructor and then parses its argument using <a>readsPrec</a>.

-- | <i>Deprecated: Use readsUnaryWith to define liftReadsPrec</i>
readsUnary :: Read a => String -> (a -> t) -> String -> ReadS t

-- | <tt><a>readsUnary1</a> n c n'</tt> matches the name of a unary data
--   constructor and then parses its argument using <a>readsPrec1</a>.

-- | <i>Deprecated: Use readsUnaryWith to define liftReadsPrec</i>
readsUnary1 :: (Read1 f, Read a) => String -> (f a -> t) -> String -> ReadS t

-- | <tt><a>readsBinary1</a> n c n'</tt> matches the name of a binary data
--   constructor and then parses its arguments using <a>readsPrec1</a>.

-- | <i>Deprecated: Use readsBinaryWith to define liftReadsPrec</i>
readsBinary1 :: (Read1 f, Read1 g, Read a) => String -> (f a -> g a -> t) -> String -> ReadS t

-- | <tt><a>showsUnary</a> n d x</tt> produces the string representation of
--   a unary data constructor with name <tt>n</tt> and argument <tt>x</tt>,
--   in precedence context <tt>d</tt>.

-- | <i>Deprecated: Use showsUnaryWith to define liftShowsPrec</i>
showsUnary :: Show a => String -> Int -> a -> ShowS

-- | <tt><a>showsUnary1</a> n d x</tt> produces the string representation
--   of a unary data constructor with name <tt>n</tt> and argument
--   <tt>x</tt>, in precedence context <tt>d</tt>.

-- | <i>Deprecated: Use showsUnaryWith to define liftShowsPrec</i>
showsUnary1 :: (Show1 f, Show a) => String -> Int -> f a -> ShowS

-- | <tt><a>showsBinary1</a> n d x y</tt> produces the string
--   representation of a binary data constructor with name <tt>n</tt> and
--   arguments <tt>x</tt> and <tt>y</tt>, in precedence context <tt>d</tt>.

-- | <i>Deprecated: Use showsBinaryWith to define liftShowsPrec</i>
showsBinary1 :: (Show1 f, Show1 g, Show a) => String -> Int -> f a -> g a -> ShowS
instance Data.Functor.Classes.Show2 (,)
instance GHC.Show.Show a => Data.Functor.Classes.Show1 ((,) a)
instance Data.Functor.Classes.Show2 Data.Either.Either
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.Either.Either a)
instance Data.Functor.Classes.Show2 Data.Functor.Const.Const
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.Functor.Const.Const a)
instance Data.Functor.Classes.Read2 (,)
instance GHC.Read.Read a => Data.Functor.Classes.Read1 ((,) a)
instance Data.Functor.Classes.Read2 Data.Either.Either
instance GHC.Read.Read a => Data.Functor.Classes.Read1 (Data.Either.Either a)
instance Data.Functor.Classes.Read2 Data.Functor.Const.Const
instance GHC.Read.Read a => Data.Functor.Classes.Read1 (Data.Functor.Const.Const a)
instance Data.Functor.Classes.Ord2 (,)
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 ((,) a)
instance Data.Functor.Classes.Ord2 Data.Either.Either
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.Either.Either a)
instance Data.Functor.Classes.Ord2 Data.Functor.Const.Const
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.Functor.Const.Const a)
instance Data.Functor.Classes.Eq2 (,)
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 ((,) a)
instance Data.Functor.Classes.Eq2 Data.Either.Either
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.Either.Either a)
instance Data.Functor.Classes.Eq2 Data.Functor.Const.Const
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.Functor.Const.Const a)
instance Data.Functor.Classes.Show1 GHC.Maybe.Maybe
instance Data.Functor.Classes.Show1 []
instance Data.Functor.Classes.Show1 GHC.Base.NonEmpty
instance Data.Functor.Classes.Show1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Show1 Data.Proxy.Proxy
instance Data.Functor.Classes.Show1 Data.Ord.Down
instance Data.Functor.Classes.Read1 GHC.Maybe.Maybe
instance Data.Functor.Classes.Read1 []
instance Data.Functor.Classes.Read1 GHC.Base.NonEmpty
instance Data.Functor.Classes.Read1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Read1 Data.Proxy.Proxy
instance Data.Functor.Classes.Read1 Data.Ord.Down
instance Data.Functor.Classes.Ord1 GHC.Maybe.Maybe
instance Data.Functor.Classes.Ord1 []
instance Data.Functor.Classes.Ord1 GHC.Base.NonEmpty
instance Data.Functor.Classes.Ord1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Ord1 Data.Proxy.Proxy
instance Data.Functor.Classes.Ord1 Data.Ord.Down
instance Data.Functor.Classes.Eq1 GHC.Maybe.Maybe
instance Data.Functor.Classes.Eq1 []
instance Data.Functor.Classes.Eq1 GHC.Base.NonEmpty
instance Data.Functor.Classes.Eq1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Eq1 Data.Proxy.Proxy
instance Data.Functor.Classes.Eq1 Data.Ord.Down


module Data.Bifunctor

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
class Bifunctor p

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c
instance Data.Bifunctor.Bifunctor (,)
instance Data.Bifunctor.Bifunctor ((,,) x1)
instance Data.Bifunctor.Bifunctor ((,,,) x1 x2)
instance Data.Bifunctor.Bifunctor ((,,,,) x1 x2 x3)
instance Data.Bifunctor.Bifunctor ((,,,,,) x1 x2 x3 x4)
instance Data.Bifunctor.Bifunctor ((,,,,,,) x1 x2 x3 x4 x5)
instance Data.Bifunctor.Bifunctor Data.Either.Either
instance Data.Bifunctor.Bifunctor Data.Functor.Const.Const
instance Data.Bifunctor.Bifunctor (GHC.Generics.K1 i)


module Data.Bifoldable

-- | <a>Bifoldable</a> identifies foldable structures with two different
--   varieties of elements (as opposed to <a>Foldable</a>, which has one
--   variety of element). Common examples are <a>Either</a> and '(,)':
--   
--   <pre>
--   instance Bifoldable Either where
--     bifoldMap f _ (Left  a) = f a
--     bifoldMap _ g (Right b) = g b
--   
--   instance Bifoldable (,) where
--     bifoldr f g z (a, b) = f a (g b z)
--   </pre>
--   
--   A minimal <a>Bifoldable</a> definition consists of either
--   <a>bifoldMap</a> or <a>bifoldr</a>. When defining more than this
--   minimal set, one should ensure that the following identities hold:
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   <a>bifoldMap</a> f g ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   <a>bifoldr</a> f g z t ≡ <a>appEndo</a> (<a>bifoldMap</a> (Endo . f) (Endo . g) t) z
--   </pre>
--   
--   If the type is also a <tt>Bifunctor</tt> instance, it should satisfy:
--   
--   <pre>
--   'bifoldMap' f g ≡ 'bifold' . 'bimap' f g
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   'bifoldMap' f g . 'bimap' h i ≡ 'bifoldMap' (f . h) (g . i)
--   </pre>
class Bifoldable p

-- | Combines the elements of a structure using a monoid.
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   </pre>
bifold :: (Bifoldable p, Monoid m) => p m m -> m

-- | Combines the elements of a structure, given ways of mapping them to a
--   common monoid.
--   
--   <pre>
--   <a>bifoldMap</a> f g
--        ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   </pre>
bifoldMap :: (Bifoldable p, Monoid m) => (a -> m) -> (b -> m) -> p a b -> m

-- | Combines the elements of a structure in a right associative manner.
--   Given a hypothetical function <tt>toEitherList :: p a b -&gt; [Either
--   a b]</tt> yielding a list of all elements of a structure in order, the
--   following would hold:
--   
--   <pre>
--   <a>bifoldr</a> f g z ≡ <a>foldr</a> (<a>either</a> f g) z . toEitherList
--   </pre>
bifoldr :: Bifoldable p => (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c

-- | Combines the elements of a structure in a left associative manner.
--   Given a hypothetical function <tt>toEitherList :: p a b -&gt; [Either
--   a b]</tt> yielding a list of all elements of a structure in order, the
--   following would hold:
--   
--   <pre>
--   <a>bifoldl</a> f g z
--        ≡ <a>foldl</a> (acc -&gt; <a>either</a> (f acc) (g acc)) z . toEitherList
--   </pre>
--   
--   Note that if you want an efficient left-fold, you probably want to use
--   <a>bifoldl'</a> instead of <a>bifoldl</a>. The reason is that the
--   latter does not force the "inner" results, resulting in a thunk chain
--   which then must be evaluated from the outside-in.
bifoldl :: Bifoldable p => (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c

-- | As <a>bifoldr</a>, but strict in the result of the reduction functions
--   at each step.
bifoldr' :: Bifoldable t => (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c

-- | A variant of <a>bifoldr</a> that has no base case, and thus may only
--   be applied to non-empty structures.
bifoldr1 :: Bifoldable t => (a -> a -> a) -> t a a -> a

-- | Right associative monadic bifold over a structure.
bifoldrM :: (Bifoldable t, Monad m) => (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c

-- | As <a>bifoldl</a>, but strict in the result of the reduction functions
--   at each step.
--   
--   This ensures that each step of the bifold is forced to weak head
--   normal form before being applied, avoiding the collection of thunks
--   that would otherwise occur. This is often what you want to strictly
--   reduce a finite structure to a single, monolithic result (e.g.,
--   <a>bilength</a>).
bifoldl' :: Bifoldable t => (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a

-- | A variant of <a>bifoldl</a> that has no base case, and thus may only
--   be applied to non-empty structures.
bifoldl1 :: Bifoldable t => (a -> a -> a) -> t a a -> a

-- | Left associative monadic bifold over a structure.
bifoldlM :: (Bifoldable t, Monad m) => (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a

-- | Map each element of a structure using one of two actions, evaluate
--   these actions from left to right, and ignore the results. For a
--   version that doesn't ignore the results, see <a>bitraverse</a>.
bitraverse_ :: (Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()

-- | As <a>bitraverse_</a>, but with the structure as the primary argument.
--   For a version that doesn't ignore the results, see <a>bifor</a>.
--   
--   <pre>
--   &gt;&gt;&gt; &gt; bifor_ ('a', "bc") print (print . reverse)
--   'a'
--   "cb"
--   </pre>
bifor_ :: (Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()

-- | Alias for <a>bitraverse_</a>.
bimapM_ :: (Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()

-- | Alias for <a>bifor_</a>.
biforM_ :: (Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()

-- | Alias for <a>biasum</a>.
bimsum :: (Bifoldable t, Alternative f) => t (f a) (f a) -> f a

-- | Alias for <a>bisequence_</a>.
bisequenceA_ :: (Bifoldable t, Applicative f) => t (f a) (f b) -> f ()

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results, see
--   <a>bisequence</a>.
bisequence_ :: (Bifoldable t, Applicative f) => t (f a) (f b) -> f ()

-- | The sum of a collection of actions, generalizing <a>biconcat</a>.
biasum :: (Bifoldable t, Alternative f) => t (f a) (f a) -> f a

-- | Collects the list of elements of a structure, from left to right.
biList :: Bifoldable t => t a a -> [a]

-- | Test whether the structure is empty.
binull :: Bifoldable t => t a b -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>.
bilength :: Bifoldable t => t a b -> Int

-- | Does the element occur in the structure?
bielem :: (Bifoldable t, Eq a) => a -> t a a -> Bool

-- | The largest element of a non-empty structure.
bimaximum :: forall t a. (Bifoldable t, Ord a) => t a a -> a

-- | The least element of a non-empty structure.
biminimum :: forall t a. (Bifoldable t, Ord a) => t a a -> a

-- | The <a>bisum</a> function computes the sum of the numbers of a
--   structure.
bisum :: (Bifoldable t, Num a) => t a a -> a

-- | The <a>biproduct</a> function computes the product of the numbers of a
--   structure.
biproduct :: (Bifoldable t, Num a) => t a a -> a

-- | Reduces a structure of lists to the concatenation of those lists.
biconcat :: Bifoldable t => t [a] [a] -> [a]

-- | Given a means of mapping the elements of a structure to lists,
--   computes the concatenation of all such lists in order.
biconcatMap :: Bifoldable t => (a -> [c]) -> (b -> [c]) -> t a b -> [c]

-- | <a>biand</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
biand :: Bifoldable t => t Bool Bool -> Bool

-- | <a>bior</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
bior :: Bifoldable t => t Bool Bool -> Bool

-- | Determines whether any element of the structure satisfies its
--   appropriate predicate argument.
biany :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool

-- | Determines whether all elements of the structure satisfy their
--   appropriate predicate argument.
biall :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
bimaximumBy :: Bifoldable t => (a -> a -> Ordering) -> t a a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
biminimumBy :: Bifoldable t => (a -> a -> Ordering) -> t a a -> a

-- | <a>binotElem</a> is the negation of <a>bielem</a>.
binotElem :: (Bifoldable t, Eq a) => a -> t a a -> Bool

-- | The <a>bifind</a> function takes a predicate and a structure and
--   returns the leftmost element of the structure matching the predicate,
--   or <a>Nothing</a> if there is no such element.
bifind :: Bifoldable t => (a -> Bool) -> t a a -> Maybe a
instance Data.Bifoldable.Bifoldable (,)
instance Data.Bifoldable.Bifoldable Data.Functor.Const.Const
instance Data.Bifoldable.Bifoldable (GHC.Generics.K1 i)
instance Data.Bifoldable.Bifoldable ((,,) x)
instance Data.Bifoldable.Bifoldable ((,,,) x y)
instance Data.Bifoldable.Bifoldable ((,,,,) x y z)
instance Data.Bifoldable.Bifoldable ((,,,,,) x y z w)
instance Data.Bifoldable.Bifoldable ((,,,,,,) x y z w v)
instance Data.Bifoldable.Bifoldable Data.Either.Either


module Data.Bitraversable

-- | <a>Bitraversable</a> identifies bifunctorial data structures whose
--   elements can be traversed in order, performing <a>Applicative</a> or
--   <a>Monad</a> actions at each element, and collecting a result
--   structure with the same shape.
--   
--   As opposed to <a>Traversable</a> data structures, which have one
--   variety of element on which an action can be performed,
--   <a>Bitraversable</a> data structures have two such varieties of
--   elements.
--   
--   A definition of <a>bitraverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt><a>bitraverse</a> (t . f) (t . g) ≡ t
--   . <a>bitraverse</a> f g</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>bitraverse</a> <a>Identity</a>
--   <a>Identity</a> ≡ <a>Identity</a></tt></li>
--   <li><i><i>composition</i></i> <tt><tt>Compose</tt> . <a>fmap</a>
--   (<a>bitraverse</a> g1 g2) . <a>bitraverse</a> f1 f2 ≡ <a>traverse</a>
--   (<tt>Compose</tt> . <a>fmap</a> g1 . f1) (<tt>Compose</tt> .
--   <a>fmap</a> g2 . f2)</tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (<a>Applicative</a> f, <a>Applicative</a> g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations:
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <a>Identity</a> and composition functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity { runIdentity :: a }
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Identity where
--     pure = Identity
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure = Compose . pure . pure
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   Some simple examples are <a>Either</a> and '(,)':
--   
--   <pre>
--   instance Bitraversable Either where
--     bitraverse f _ (Left x) = Left &lt;$&gt; f x
--     bitraverse _ g (Right y) = Right &lt;$&gt; g y
--   
--   instance Bitraversable (,) where
--     bitraverse f g (x, y) = (,) &lt;$&gt; f x &lt;*&gt; g y
--   </pre>
--   
--   <a>Bitraversable</a> relates to its superclasses in the following
--   ways:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>runIdentity</a> . <a>bitraverse</a> (<a>Identity</a> . f) (<a>Identity</a> . g)
--   <a>bifoldMap</a> f g = <a>getConst</a> . <a>bitraverse</a> (<a>Const</a> . f) (<a>Const</a> . g)
--   </pre>
--   
--   These are available as <a>bimapDefault</a> and <a>bifoldMapDefault</a>
--   respectively.
class (Bifunctor t, Bifoldable t) => Bitraversable t

-- | Evaluates the relevant functions at each element in the structure,
--   running the action, and builds a new structure with the same shape,
--   using the results produced from sequencing the actions.
--   
--   <pre>
--   <a>bitraverse</a> f g ≡ <a>bisequenceA</a> . <a>bimap</a> f g
--   </pre>
--   
--   For a version that ignores the results, see <a>bitraverse_</a>.
bitraverse :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)

-- | Alias for <a>bisequence</a>.
bisequenceA :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)

-- | Sequences all the actions in a structure, building a new structure
--   with the same shape using the results of the actions. For a version
--   that ignores the results, see <a>bisequence_</a>.
--   
--   <pre>
--   <a>bisequence</a> ≡ <a>bitraverse</a> <a>id</a> <a>id</a>
--   </pre>
bisequence :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)

-- | Alias for <a>bitraverse</a>.
bimapM :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)

-- | <a>bifor</a> is <a>bitraverse</a> with the structure as the first
--   argument. For a version that ignores the results, see <a>bifor_</a>.
bifor :: (Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)

-- | Alias for <a>bifor</a>.
biforM :: (Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)

-- | The <a>bimapAccumL</a> function behaves like a combination of
--   <a>bimap</a> and <a>bifoldl</a>; it traverses a structure from left to
--   right, threading a state of type <tt>a</tt> and using the given
--   actions to compute new elements for the structure.
bimapAccumL :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)

-- | The <a>bimapAccumR</a> function behaves like a combination of
--   <a>bimap</a> and <a>bifoldl</a>; it traverses a structure from right
--   to left, threading a state of type <tt>a</tt> and using the given
--   actions to compute new elements for the structure.
bimapAccumR :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)

-- | A default definition of <a>bimap</a> in terms of the
--   <a>Bitraversable</a> operations.
--   
--   <pre>
--   <a>bimapDefault</a> f g ≡
--        <a>runIdentity</a> . <a>bitraverse</a> (<a>Identity</a> . f) (<a>Identity</a> . g)
--   </pre>
bimapDefault :: forall t a b c d. Bitraversable t => (a -> b) -> (c -> d) -> t a c -> t b d

-- | A default definition of <a>bifoldMap</a> in terms of the
--   <a>Bitraversable</a> operations.
--   
--   <pre>
--   <a>bifoldMapDefault</a> f g ≡
--       <a>getConst</a> . <a>bitraverse</a> (<a>Const</a> . f) (<a>Const</a> . g)
--   </pre>
bifoldMapDefault :: forall t m a b. (Bitraversable t, Monoid m) => (a -> m) -> (b -> m) -> t a b -> m
instance Data.Bitraversable.Bitraversable (,)
instance Data.Bitraversable.Bitraversable ((,,) x)
instance Data.Bitraversable.Bitraversable ((,,,) x y)
instance Data.Bitraversable.Bitraversable ((,,,,) x y z)
instance Data.Bitraversable.Bitraversable ((,,,,,) x y z w)
instance Data.Bitraversable.Bitraversable ((,,,,,,) x y z w v)
instance Data.Bitraversable.Bitraversable Data.Either.Either
instance Data.Bitraversable.Bitraversable Data.Functor.Const.Const
instance Data.Bitraversable.Bitraversable (GHC.Generics.K1 i)


-- | This module provides scalable event notification for file descriptors
--   and timeouts.
--   
--   This module should be considered GHC internal.
--   
--   <ul>
--   
--   <li>---------------------------------------------------------------------------</li>
--   </ul>
module GHC.Event

-- | The event manager state.
data EventManager

-- | The event manager state.
data TimerManager

-- | Retrieve the system event manager for the capability on which the
--   calling thread is running.
--   
--   This function always returns <a>Just</a> the current thread's event
--   manager when using the threaded RTS and <a>Nothing</a> otherwise.
getSystemEventManager :: IO (Maybe EventManager)

-- | Create a new event manager.
new :: IO EventManager
getSystemTimerManager :: IO TimerManager

-- | An I/O event.
data Event

-- | Data is available to be read.
evtRead :: Event

-- | The file descriptor is ready to accept a write.
evtWrite :: Event

-- | Callback invoked on I/O events.
type IOCallback = FdKey -> Event -> IO ()

-- | A file descriptor registration cookie.
data FdKey

-- | The lifetime of an event registration.
data Lifetime

-- | the registration will be active for only one event
OneShot :: Lifetime

-- | the registration will trigger multiple times
MultiShot :: Lifetime

-- | <tt>registerFd mgr cb fd evs lt</tt> registers interest in the events
--   <tt>evs</tt> on the file descriptor <tt>fd</tt> for lifetime
--   <tt>lt</tt>. <tt>cb</tt> is called for each event that occurs. Returns
--   a cookie that can be handed to <a>unregisterFd</a>.
registerFd :: EventManager -> IOCallback -> Fd -> Event -> Lifetime -> IO FdKey

-- | Drop a previous file descriptor registration.
unregisterFd :: EventManager -> FdKey -> IO ()

-- | Drop a previous file descriptor registration, without waking the event
--   manager thread. The return value indicates whether the event manager
--   ought to be woken.
unregisterFd_ :: EventManager -> FdKey -> IO Bool

-- | Close a file descriptor in a race-safe way.
closeFd :: EventManager -> (Fd -> IO ()) -> Fd -> IO ()

-- | Callback invoked on timeout events.
type TimeoutCallback = IO ()

-- | A timeout registration cookie.
data TimeoutKey

-- | Register a timeout in the given number of microseconds. The returned
--   <a>TimeoutKey</a> can be used to later unregister or update the
--   timeout. The timeout is automatically unregistered after the given
--   time has passed.
registerTimeout :: TimerManager -> Int -> TimeoutCallback -> IO TimeoutKey

-- | Update an active timeout to fire in the given number of microseconds.
updateTimeout :: TimerManager -> TimeoutKey -> Int -> IO ()

-- | Unregister an active timeout.
unregisterTimeout :: TimerManager -> TimeoutKey -> IO ()


-- | Basic concurrency stuff.
module GHC.Conc

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
data ThreadId
ThreadId :: ThreadId# -> ThreadId

-- | Creates a new thread to run the <a>IO</a> computation passed as the
--   first argument, and returns the <a>ThreadId</a> of the newly created
--   thread.
--   
--   The new thread will be a lightweight, <i>unbound</i> thread. Foreign
--   calls made by this thread are not guaranteed to be made by any
--   particular OS thread; if you need foreign calls to be made by a
--   particular OS thread, then use <a>forkOS</a> instead.
--   
--   The new thread inherits the <i>masked</i> state of the parent (see
--   <a>mask</a>).
--   
--   The newly created thread has an exception handler that discards the
--   exceptions <a>BlockedIndefinitelyOnMVar</a>,
--   <a>BlockedIndefinitelyOnSTM</a>, and <a>ThreadKilled</a>, and passes
--   all other exceptions to the uncaught exception handler.
forkIO :: IO () -> IO ThreadId

-- | Like <a>forkIO</a>, but the child thread is passed a function that can
--   be used to unmask asynchronous exceptions. This function is typically
--   used in the following way
--   
--   <pre>
--   ... mask_ $ forkIOWithUnmask $ \unmask -&gt;
--                  catch (unmask ...) handler
--   </pre>
--   
--   so that the exception handler in the child thread is established with
--   asynchronous exceptions masked, meanwhile the main body of the child
--   thread is executed in the unmasked state.
--   
--   Note that the unmask function passed to the child thread should only
--   be used in that thread; the behaviour is undefined if it is invoked in
--   a different thread.
forkIOWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Like <a>forkIO</a>, but lets you specify on which capability the
--   thread should run. Unlike a <a>forkIO</a> thread, a thread created by
--   <a>forkOn</a> will stay on the same capability for its entire lifetime
--   (<a>forkIO</a> threads can migrate between capabilities according to
--   the scheduling policy). <a>forkOn</a> is useful for overriding the
--   scheduling policy when you know in advance how best to distribute the
--   threads.
--   
--   The <a>Int</a> argument specifies a <i>capability number</i> (see
--   <a>getNumCapabilities</a>). Typically capabilities correspond to
--   physical processors, but the exact behaviour is
--   implementation-dependent. The value passed to <a>forkOn</a> is
--   interpreted modulo the total number of capabilities as returned by
--   <a>getNumCapabilities</a>.
--   
--   GHC note: the number of capabilities is specified by the <tt>+RTS
--   -N</tt> option when the program is started. Capabilities can be fixed
--   to actual processor cores with <tt>+RTS -qa</tt> if the underlying
--   operating system supports that, although in practice this is usually
--   unnecessary (and may actually degrade performance in some cases -
--   experimentation is recommended).
forkOn :: Int -> IO () -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is pinned to the
--   given CPU, as with <a>forkOn</a>.
forkOnWithUnmask :: Int -> ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | the value passed to the <tt>+RTS -N</tt> flag. This is the number of
--   Haskell threads that can run truly simultaneously at any given time,
--   and is typically set to the number of physical processor cores on the
--   machine.
--   
--   Strictly speaking it is better to use <a>getNumCapabilities</a>,
--   because the number of capabilities might vary at runtime.
numCapabilities :: Int

-- | Returns the number of Haskell threads that can run truly
--   simultaneously (on separate physical processors) at any given time. To
--   change this value, use <a>setNumCapabilities</a>.
getNumCapabilities :: IO Int

-- | Set the number of Haskell threads that can run truly simultaneously
--   (on separate physical processors) at any given time. The number passed
--   to <a>forkOn</a> is interpreted modulo this value. The initial value
--   is given by the <tt>+RTS -N</tt> runtime flag.
--   
--   This is also the number of threads that will participate in parallel
--   garbage collection. It is strongly recommended that the number of
--   capabilities is not set larger than the number of physical processor
--   cores, and it may often be beneficial to leave one or more cores free
--   to avoid contention with other processes in the machine.
setNumCapabilities :: Int -> IO ()

-- | Returns the number of CPUs that the machine has
getNumProcessors :: IO Int

-- | Returns the number of sparks currently in the local spark pool
numSparks :: IO Int
childHandler :: SomeException -> IO ()

-- | Returns the <a>ThreadId</a> of the calling thread (GHC only).
myThreadId :: IO ThreadId

-- | <a>killThread</a> raises the <a>ThreadKilled</a> exception in the
--   given thread (GHC only).
--   
--   <pre>
--   killThread tid = throwTo tid ThreadKilled
--   </pre>
killThread :: ThreadId -> IO ()

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()
par :: a -> b -> b
infixr 0 `par`
pseq :: a -> b -> b
infixr 0 `pseq`

-- | Internal function used by the RTS to run sparks.
runSparks :: IO ()

-- | The <a>yield</a> action allows (forces, in a co-operative multitasking
--   implementation) a context-switch to any other currently runnable
--   threads (if any), and is occasionally useful when implementing
--   concurrency abstractions.
yield :: IO ()

-- | <a>labelThread</a> stores a string as identifier for this thread if
--   you built a RTS with debugging support. This identifier will be used
--   in the debugging output to make distinction of different threads
--   easier (otherwise you only have the thread state object's address in
--   the heap).
--   
--   Other applications like the graphical Concurrent Haskell Debugger
--   (<a>http://www.informatik.uni-kiel.de/~fhu/chd/</a>) may choose to
--   overload <a>labelThread</a> for their purposes as well.
labelThread :: ThreadId -> String -> IO ()

-- | Make a weak pointer to a <a>ThreadId</a>. It can be important to do
--   this if you want to hold a reference to a <a>ThreadId</a> while still
--   allowing the thread to receive the <tt>BlockedIndefinitely</tt> family
--   of exceptions (e.g. <a>BlockedIndefinitelyOnMVar</a>). Holding a
--   normal <a>ThreadId</a> reference will prevent the delivery of
--   <tt>BlockedIndefinitely</tt> exceptions because the reference could be
--   used as the target of <a>throwTo</a> at any time, which would unblock
--   the thread.
--   
--   Holding a <tt>Weak ThreadId</tt>, on the other hand, will not prevent
--   the thread from receiving <tt>BlockedIndefinitely</tt> exceptions. It
--   is still possible to throw an exception to a <tt>Weak ThreadId</tt>,
--   but the caller must use <tt>deRefWeak</tt> first to determine whether
--   the thread still exists.
mkWeakThreadId :: ThreadId -> IO (Weak ThreadId)

-- | The current status of a thread
data ThreadStatus

-- | the thread is currently runnable or running
ThreadRunning :: ThreadStatus

-- | the thread has finished
ThreadFinished :: ThreadStatus

-- | the thread is blocked on some resource
ThreadBlocked :: BlockReason -> ThreadStatus

-- | the thread received an uncaught exception
ThreadDied :: ThreadStatus
data BlockReason

-- | blocked on <a>MVar</a>
BlockedOnMVar :: BlockReason

-- | blocked on a computation in progress by another thread
BlockedOnBlackHole :: BlockReason

-- | blocked in <a>throwTo</a>
BlockedOnException :: BlockReason

-- | blocked in <a>retry</a> in an STM transaction
BlockedOnSTM :: BlockReason

-- | currently in a foreign call
BlockedOnForeignCall :: BlockReason

-- | blocked on some other resource. Without <tt>-threaded</tt>, I/O and
--   <tt>threadDelay</tt> show up as <a>BlockedOnOther</a>, with
--   <tt>-threaded</tt> they show up as <a>BlockedOnMVar</a>.
BlockedOnOther :: BlockReason
threadStatus :: ThreadId -> IO ThreadStatus

-- | Returns the number of the capability on which the thread is currently
--   running, and a boolean indicating whether the thread is locked to that
--   capability or not. A thread is locked to a capability if it was
--   created with <tt>forkOn</tt>.
threadCapability :: ThreadId -> IO (Int, Bool)

-- | Make a StablePtr that can be passed to the C function
--   <tt>hs_try_putmvar()</tt>. The RTS wants a <a>StablePtr</a> to the
--   underlying <a>MVar#</a>, but a <a>StablePtr#</a> can only refer to
--   lifted types, so we have to cheat by coercing.
newStablePtrPrimMVar :: MVar () -> IO (StablePtr PrimMVar)
data PrimMVar

-- | Suspends the current thread for a given number of microseconds (GHC
--   only).
--   
--   There is no guarantee that the thread will be rescheduled promptly
--   when the delay has expired, but the thread will never continue to run
--   <i>earlier</i> than specified.
threadDelay :: Int -> IO ()

-- | Switch the value of returned <a>TVar</a> from initial value
--   <a>False</a> to <a>True</a> after a given number of microseconds. The
--   caveats associated with <a>threadDelay</a> also apply.
registerDelay :: Int -> IO (TVar Bool)

-- | Block the current thread until data is available to read on the given
--   file descriptor (GHC only).
--   
--   This will throw an <tt>IOError</tt> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitRead</a>, use <a>closeFdWith</a>.
threadWaitRead :: Fd -> IO ()

-- | Block the current thread until data can be written to the given file
--   descriptor (GHC only).
--   
--   This will throw an <tt>IOError</tt> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitWrite</a>, use <a>closeFdWith</a>.
threadWaitWrite :: Fd -> IO ()

-- | Returns an STM action that can be used to wait for data to read from a
--   file descriptor. The second returned value is an IO action that can be
--   used to deregister interest in the file descriptor.
threadWaitReadSTM :: Fd -> IO (STM (), IO ())

-- | Returns an STM action that can be used to wait until data can be
--   written to a file descriptor. The second returned value is an IO
--   action that can be used to deregister interest in the file descriptor.
threadWaitWriteSTM :: Fd -> IO (STM (), IO ())

-- | Close a file descriptor in a concurrency-safe way (GHC only). If you
--   are using <a>threadWaitRead</a> or <a>threadWaitWrite</a> to perform
--   blocking I/O, you <i>must</i> use this function to close file
--   descriptors, or blocked threads may not be woken.
--   
--   Any threads that are blocked on the file descriptor via
--   <a>threadWaitRead</a> or <a>threadWaitWrite</a> will be unblocked by
--   having IO exceptions thrown.
closeFdWith :: (Fd -> IO ()) -> Fd -> IO ()

-- | Every thread has an allocation counter that tracks how much memory has
--   been allocated by the thread. The counter is initialized to zero, and
--   <a>setAllocationCounter</a> sets the current value. The allocation
--   counter counts *down*, so in the absence of a call to
--   <a>setAllocationCounter</a> its value is the negation of the number of
--   bytes of memory allocated by the thread.
--   
--   There are two things that you can do with this counter:
--   
--   <ul>
--   <li>Use it as a simple profiling mechanism, with
--   <a>getAllocationCounter</a>.</li>
--   <li>Use it as a resource limit. See <a>enableAllocationLimit</a>.</li>
--   </ul>
--   
--   Allocation accounting is accurate only to about 4Kbytes.
setAllocationCounter :: Int64 -> IO ()

-- | Return the current value of the allocation counter for the current
--   thread.
getAllocationCounter :: IO Int64

-- | Enables the allocation counter to be treated as a limit for the
--   current thread. When the allocation limit is enabled, if the
--   allocation counter counts down below zero, the thread will be sent the
--   <a>AllocationLimitExceeded</a> asynchronous exception. When this
--   happens, the counter is reinitialised (by default to 100K, but tunable
--   with the <tt>+RTS -xq</tt> option) so that it can handle the exception
--   and perform any necessary clean up. If it exhausts this additional
--   allowance, another <a>AllocationLimitExceeded</a> exception is sent,
--   and so forth. Like other asynchronous exceptions, the
--   <a>AllocationLimitExceeded</a> exception is deferred while the thread
--   is inside <a>mask</a> or an exception handler in <a>catch</a>.
--   
--   Note that memory allocation is unrelated to <i>live memory</i>, also
--   known as <i>heap residency</i>. A thread can allocate a large amount
--   of memory and retain anything between none and all of it. It is better
--   to think of the allocation limit as a limit on <i>CPU time</i>, rather
--   than a limit on memory.
--   
--   Compared to using timeouts, allocation limits don't count time spent
--   blocked or in foreign calls.
enableAllocationLimit :: IO ()

-- | Disable allocation limit processing for the current thread.
disableAllocationLimit :: IO ()

-- | A monad supporting atomic memory transactions.
newtype STM a
STM :: (State# RealWorld -> (# State# RealWorld, a #)) -> STM a

-- | Perform a series of STM actions atomically.
--   
--   Using <a>atomically</a> inside an <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a> subverts some of guarantees that STM
--   provides. It makes it possible to run a transaction inside of another
--   transaction, depending on when the thunk is evaluated. If a nested
--   transaction is attempted, an exception is thrown by the runtime. It is
--   possible to safely use <a>atomically</a> inside <a>unsafePerformIO</a>
--   or <a>unsafeInterleaveIO</a>, but the typechecker does not rule out
--   programs that may attempt nested transactions, meaning that the
--   programmer must take special care to prevent these.
--   
--   However, there are functions for creating transactional variables that
--   can always be safely called in <a>unsafePerformIO</a>. See:
--   <a>newTVarIO</a>, <tt>newTChanIO</tt>, <tt>newBroadcastTChanIO</tt>,
--   <tt>newTQueueIO</tt>, <tt>newTBQueueIO</tt>, and <tt>newTMVarIO</tt>.
--   
--   Using <a>unsafePerformIO</a> inside of <a>atomically</a> is also
--   dangerous but for different reasons. See <a>unsafeIOToSTM</a> for more
--   on this.
atomically :: STM a -> IO a

-- | Retry execution of the current memory transaction because it has seen
--   values in <a>TVar</a>s which mean that it should not continue (e.g.
--   the <a>TVar</a>s represent a shared buffer that is now empty). The
--   implementation may block the thread until one of the <a>TVar</a>s that
--   it has read from has been updated. (GHC only)
retry :: STM a

-- | Compose two alternative STM actions (GHC only).
--   
--   If the first action completes without retrying then it forms the
--   result of the <a>orElse</a>. Otherwise, if the first action retries,
--   then the second action is tried in its place. If both actions retry
--   then the <a>orElse</a> as a whole retries.
orElse :: STM a -> STM a -> STM a

-- | A variant of <a>throw</a> that can only be used within the <a>STM</a>
--   monad.
--   
--   Throwing an exception in <tt>STM</tt> aborts the transaction and
--   propagates the exception.
--   
--   Although <a>throwSTM</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e    `seq` x  ===&gt; throw e
--   throwSTM e `seq` x  ===&gt; x
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwSTM</a> will only cause
--   an exception to be raised when it is used within the <a>STM</a> monad.
--   The <a>throwSTM</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>STM</a> monad because
--   it guarantees ordering with respect to other <a>STM</a> operations,
--   whereas <a>throw</a> does not.
throwSTM :: Exception e => e -> STM a

-- | Exception handling within STM actions.
catchSTM :: Exception e => STM a -> (e -> STM a) -> STM a

-- | Shared memory locations that support atomic memory transactions.
data TVar a
TVar :: TVar# RealWorld a -> TVar a

-- | Create a new <a>TVar</a> holding a value supplied
newTVar :: a -> STM (TVar a)

-- | <tt>IO</tt> version of <a>newTVar</a>. This is useful for creating
--   top-level <a>TVar</a>s using <a>unsafePerformIO</a>, because using
--   <a>atomically</a> inside <a>unsafePerformIO</a> isn't possible.
newTVarIO :: a -> IO (TVar a)

-- | Return the current value stored in a <a>TVar</a>.
readTVar :: TVar a -> STM a

-- | Return the current value stored in a <a>TVar</a>. This is equivalent
--   to
--   
--   <pre>
--   readTVarIO = atomically . readTVar
--   </pre>
--   
--   but works much faster, because it doesn't perform a complete
--   transaction, it just reads the current value of the <a>TVar</a>.
readTVarIO :: TVar a -> IO a

-- | Write the supplied value into a <a>TVar</a>.
writeTVar :: TVar a -> a -> STM ()

-- | Unsafely performs IO in the STM monad. Beware: this is a highly
--   dangerous thing to do.
--   
--   <ul>
--   <li>The STM implementation will often run transactions multiple times,
--   so you need to be prepared for this if your IO has any side
--   effects.</li>
--   <li>The STM implementation will abort transactions that are known to
--   be invalid and need to be restarted. This may happen in the middle of
--   <a>unsafeIOToSTM</a>, so make sure you don't acquire any resources
--   that need releasing (exception handlers are ignored when aborting the
--   transaction). That includes doing any IO using Handles, for example.
--   Getting this wrong will probably lead to random deadlocks.</li>
--   <li>The transaction may have seen an inconsistent view of memory when
--   the IO runs. Invariants that you expect to be true throughout your
--   program may not be true inside a transaction, due to the way
--   transactions are implemented. Normally this wouldn't be visible to the
--   programmer, but using <a>unsafeIOToSTM</a> can expose it.</li>
--   </ul>
unsafeIOToSTM :: IO a -> STM a

-- | Provide an <a>IO</a> action with the current value of an <a>MVar</a>.
--   The <a>MVar</a> will be empty for the duration that the action is
--   running.
withMVar :: MVar a -> (a -> IO b) -> IO b
type Signal = CInt
type HandlerFun = ForeignPtr Word8 -> IO ()
setHandler :: Signal -> Maybe (HandlerFun, Dynamic) -> IO (Maybe (HandlerFun, Dynamic))
runHandlers :: ForeignPtr Word8 -> Signal -> IO ()
ensureIOManagerIsRunning :: IO ()
ioManagerCapabilitiesChanged :: IO ()
setUncaughtExceptionHandler :: (SomeException -> IO ()) -> IO ()
getUncaughtExceptionHandler :: IO (SomeException -> IO ())
reportError :: SomeException -> IO ()
reportStackOverflow :: IO ()
reportHeapOverflow :: IO ()


-- | Quantity semaphores in which each thread may wait for an arbitrary
--   "amount".
module Control.Concurrent.QSemN

-- | <a>QSemN</a> is a quantity semaphore in which the resource is acquired
--   and released in units of one. It provides guaranteed FIFO ordering for
--   satisfying blocked <a>waitQSemN</a> calls.
--   
--   The pattern
--   
--   <pre>
--   bracket_ (waitQSemN n) (signalQSemN n) (...)
--   </pre>
--   
--   is safe; it never loses any of the resource.
data QSemN

-- | Build a new <a>QSemN</a> with a supplied initial quantity. The initial
--   quantity must be at least 0.
newQSemN :: Int -> IO QSemN

-- | Wait for the specified quantity to become available
waitQSemN :: QSemN -> Int -> IO ()

-- | Signal that a given quantity is now available from the <a>QSemN</a>.
signalQSemN :: QSemN -> Int -> IO ()


-- | Simple quantity semaphores.
module Control.Concurrent.QSem

-- | <a>QSem</a> is a quantity semaphore in which the resource is acquired
--   and released in units of one. It provides guaranteed FIFO ordering for
--   satisfying blocked <a>waitQSem</a> calls.
--   
--   The pattern
--   
--   <pre>
--   bracket_ waitQSem signalQSem (...)
--   </pre>
--   
--   is safe; it never loses a unit of the resource.
data QSem

-- | Build a new <a>QSem</a> with a supplied initial quantity. The initial
--   quantity must be at least 0.
newQSem :: Int -> IO QSem

-- | Wait for a unit to become available
waitQSem :: QSem -> IO ()

-- | Signal that a unit of the <a>QSem</a> is available
signalQSem :: QSem -> IO ()


-- | Unbounded channels.
--   
--   The channels are implemented with <tt>MVar</tt>s and therefore inherit
--   all the caveats that apply to <tt>MVar</tt>s (possibility of races,
--   deadlocks etc). The stm (software transactional memory) library has a
--   more robust implementation of channels called <tt>TChan</tt>s.
module Control.Concurrent.Chan

-- | <a>Chan</a> is an abstract type representing an unbounded FIFO
--   channel.
data Chan a

-- | Build and returns a new instance of <a>Chan</a>.
newChan :: IO (Chan a)

-- | Write a value to a <a>Chan</a>.
writeChan :: Chan a -> a -> IO ()

-- | Read the next value from the <a>Chan</a>. Blocks when the channel is
--   empty. Since the read end of a channel is an <a>MVar</a>, this
--   operation inherits fairness guarantees of <a>MVar</a>s (e.g. threads
--   blocked in this operation are woken up in FIFO order).
--   
--   Throws <tt>BlockedIndefinitelyOnMVar</tt> when the channel is empty
--   and no other thread holds a reference to the channel.
readChan :: Chan a -> IO a

-- | Duplicate a <a>Chan</a>: the duplicate channel begins empty, but data
--   written to either channel from then on will be available from both.
--   Hence this creates a kind of broadcast channel, where data written by
--   anyone is seen by everyone else.
--   
--   (Note that a duplicated channel is not equal to its original. So:
--   <tt>fmap (c /=) $ dupChan c</tt> returns <tt>True</tt> for all
--   <tt>c</tt>.)
dupChan :: Chan a -> IO (Chan a)

-- | Return a lazy list representing the contents of the supplied
--   <a>Chan</a>, much like <a>hGetContents</a>.
getChanContents :: Chan a -> IO [a]

-- | Write an entire list of items to a <a>Chan</a>.
writeList2Chan :: Chan a -> [a] -> IO ()
instance GHC.Classes.Eq (Control.Concurrent.Chan.Chan a)


-- | A common interface to a collection of useful concurrency abstractions.
module Control.Concurrent

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
data ThreadId

-- | Returns the <a>ThreadId</a> of the calling thread (GHC only).
myThreadId :: IO ThreadId

-- | Creates a new thread to run the <a>IO</a> computation passed as the
--   first argument, and returns the <a>ThreadId</a> of the newly created
--   thread.
--   
--   The new thread will be a lightweight, <i>unbound</i> thread. Foreign
--   calls made by this thread are not guaranteed to be made by any
--   particular OS thread; if you need foreign calls to be made by a
--   particular OS thread, then use <a>forkOS</a> instead.
--   
--   The new thread inherits the <i>masked</i> state of the parent (see
--   <a>mask</a>).
--   
--   The newly created thread has an exception handler that discards the
--   exceptions <a>BlockedIndefinitelyOnMVar</a>,
--   <a>BlockedIndefinitelyOnSTM</a>, and <a>ThreadKilled</a>, and passes
--   all other exceptions to the uncaught exception handler.
forkIO :: IO () -> IO ThreadId

-- | Fork a thread and call the supplied function when the thread is about
--   to terminate, with an exception or a returned value. The function is
--   called with asynchronous exceptions masked.
--   
--   <pre>
--   forkFinally action and_then =
--     mask $ \restore -&gt;
--       forkIO $ try (restore action) &gt;&gt;= and_then
--   </pre>
--   
--   This function is useful for informing the parent when a child
--   terminates, for example.
forkFinally :: IO a -> (Either SomeException a -> IO ()) -> IO ThreadId

-- | Like <a>forkIO</a>, but the child thread is passed a function that can
--   be used to unmask asynchronous exceptions. This function is typically
--   used in the following way
--   
--   <pre>
--   ... mask_ $ forkIOWithUnmask $ \unmask -&gt;
--                  catch (unmask ...) handler
--   </pre>
--   
--   so that the exception handler in the child thread is established with
--   asynchronous exceptions masked, meanwhile the main body of the child
--   thread is executed in the unmasked state.
--   
--   Note that the unmask function passed to the child thread should only
--   be used in that thread; the behaviour is undefined if it is invoked in
--   a different thread.
forkIOWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | <a>killThread</a> raises the <a>ThreadKilled</a> exception in the
--   given thread (GHC only).
--   
--   <pre>
--   killThread tid = throwTo tid ThreadKilled
--   </pre>
killThread :: ThreadId -> IO ()

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | Like <a>forkIO</a>, but lets you specify on which capability the
--   thread should run. Unlike a <a>forkIO</a> thread, a thread created by
--   <a>forkOn</a> will stay on the same capability for its entire lifetime
--   (<a>forkIO</a> threads can migrate between capabilities according to
--   the scheduling policy). <a>forkOn</a> is useful for overriding the
--   scheduling policy when you know in advance how best to distribute the
--   threads.
--   
--   The <a>Int</a> argument specifies a <i>capability number</i> (see
--   <a>getNumCapabilities</a>). Typically capabilities correspond to
--   physical processors, but the exact behaviour is
--   implementation-dependent. The value passed to <a>forkOn</a> is
--   interpreted modulo the total number of capabilities as returned by
--   <a>getNumCapabilities</a>.
--   
--   GHC note: the number of capabilities is specified by the <tt>+RTS
--   -N</tt> option when the program is started. Capabilities can be fixed
--   to actual processor cores with <tt>+RTS -qa</tt> if the underlying
--   operating system supports that, although in practice this is usually
--   unnecessary (and may actually degrade performance in some cases -
--   experimentation is recommended).
forkOn :: Int -> IO () -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is pinned to the
--   given CPU, as with <a>forkOn</a>.
forkOnWithUnmask :: Int -> ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Returns the number of Haskell threads that can run truly
--   simultaneously (on separate physical processors) at any given time. To
--   change this value, use <a>setNumCapabilities</a>.
getNumCapabilities :: IO Int

-- | Set the number of Haskell threads that can run truly simultaneously
--   (on separate physical processors) at any given time. The number passed
--   to <a>forkOn</a> is interpreted modulo this value. The initial value
--   is given by the <tt>+RTS -N</tt> runtime flag.
--   
--   This is also the number of threads that will participate in parallel
--   garbage collection. It is strongly recommended that the number of
--   capabilities is not set larger than the number of physical processor
--   cores, and it may often be beneficial to leave one or more cores free
--   to avoid contention with other processes in the machine.
setNumCapabilities :: Int -> IO ()

-- | Returns the number of the capability on which the thread is currently
--   running, and a boolean indicating whether the thread is locked to that
--   capability or not. A thread is locked to a capability if it was
--   created with <tt>forkOn</tt>.
threadCapability :: ThreadId -> IO (Int, Bool)

-- | The <a>yield</a> action allows (forces, in a co-operative multitasking
--   implementation) a context-switch to any other currently runnable
--   threads (if any), and is occasionally useful when implementing
--   concurrency abstractions.
yield :: IO ()

-- | Suspends the current thread for a given number of microseconds (GHC
--   only).
--   
--   There is no guarantee that the thread will be rescheduled promptly
--   when the delay has expired, but the thread will never continue to run
--   <i>earlier</i> than specified.
threadDelay :: Int -> IO ()

-- | Block the current thread until data is available to read on the given
--   file descriptor (GHC only).
--   
--   This will throw an <a>IOError</a> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitRead</a>, use <a>closeFdWith</a>.
threadWaitRead :: Fd -> IO ()

-- | Block the current thread until data can be written to the given file
--   descriptor (GHC only).
--   
--   This will throw an <a>IOError</a> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitWrite</a>, use <a>closeFdWith</a>.
threadWaitWrite :: Fd -> IO ()

-- | Returns an STM action that can be used to wait for data to read from a
--   file descriptor. The second returned value is an IO action that can be
--   used to deregister interest in the file descriptor.
threadWaitReadSTM :: Fd -> IO (STM (), IO ())

-- | Returns an STM action that can be used to wait until data can be
--   written to a file descriptor. The second returned value is an IO
--   action that can be used to deregister interest in the file descriptor.
threadWaitWriteSTM :: Fd -> IO (STM (), IO ())

-- | <a>True</a> if bound threads are supported. If
--   <tt>rtsSupportsBoundThreads</tt> is <a>False</a>,
--   <a>isCurrentThreadBound</a> will always return <a>False</a> and both
--   <a>forkOS</a> and <a>runInBoundThread</a> will fail.
rtsSupportsBoundThreads :: Bool

-- | Like <a>forkIO</a>, this sparks off a new thread to run the <a>IO</a>
--   computation passed as the first argument, and returns the
--   <a>ThreadId</a> of the newly created thread.
--   
--   However, <a>forkOS</a> creates a <i>bound</i> thread, which is
--   necessary if you need to call foreign (non-Haskell) libraries that
--   make use of thread-local state, such as OpenGL (see
--   <a>Control.Concurrent#boundthreads</a>).
--   
--   Using <a>forkOS</a> instead of <a>forkIO</a> makes no difference at
--   all to the scheduling behaviour of the Haskell runtime system. It is a
--   common misconception that you need to use <a>forkOS</a> instead of
--   <a>forkIO</a> to avoid blocking all the Haskell threads when making a
--   foreign call; this isn't the case. To allow foreign calls to be made
--   without blocking all the Haskell threads (with GHC), it is only
--   necessary to use the <tt>-threaded</tt> option when linking your
--   program, and to make sure the foreign import is not marked
--   <tt>unsafe</tt>.
forkOS :: IO () -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is a bound thread,
--   as with <a>forkOS</a>.
forkOSWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Returns <a>True</a> if the calling thread is <i>bound</i>, that is, if
--   it is safe to use foreign libraries that rely on thread-local state
--   from the calling thread.
isCurrentThreadBound :: IO Bool

-- | Run the <a>IO</a> computation passed as the first argument. If the
--   calling thread is not <i>bound</i>, a bound thread is created
--   temporarily. <tt>runInBoundThread</tt> doesn't finish until the
--   <a>IO</a> computation finishes.
--   
--   You can wrap a series of foreign function calls that rely on
--   thread-local state with <tt>runInBoundThread</tt> so that you can use
--   them without knowing whether the current thread is <i>bound</i>.
runInBoundThread :: IO a -> IO a

-- | Run the <a>IO</a> computation passed as the first argument. If the
--   calling thread is <i>bound</i>, an unbound thread is created
--   temporarily using <a>forkIO</a>. <tt>runInBoundThread</tt> doesn't
--   finish until the <a>IO</a> computation finishes.
--   
--   Use this function <i>only</i> in the rare case that you have actually
--   observed a performance loss due to the use of bound threads. A program
--   that doesn't need its main thread to be bound and makes <i>heavy</i>
--   use of concurrency (e.g. a web server), might want to wrap its
--   <tt>main</tt> action in <tt>runInUnboundThread</tt>.
--   
--   Note that exceptions which are thrown to the current thread are thrown
--   in turn to the thread that is executing the given computation. This
--   ensures there's always a way of killing the forked thread.
runInUnboundThread :: IO a -> IO a

-- | Make a weak pointer to a <a>ThreadId</a>. It can be important to do
--   this if you want to hold a reference to a <a>ThreadId</a> while still
--   allowing the thread to receive the <tt>BlockedIndefinitely</tt> family
--   of exceptions (e.g. <a>BlockedIndefinitelyOnMVar</a>). Holding a
--   normal <a>ThreadId</a> reference will prevent the delivery of
--   <tt>BlockedIndefinitely</tt> exceptions because the reference could be
--   used as the target of <a>throwTo</a> at any time, which would unblock
--   the thread.
--   
--   Holding a <tt>Weak ThreadId</tt>, on the other hand, will not prevent
--   the thread from receiving <tt>BlockedIndefinitely</tt> exceptions. It
--   is still possible to throw an exception to a <tt>Weak ThreadId</tt>,
--   but the caller must use <tt>deRefWeak</tt> first to determine whether
--   the thread still exists.
mkWeakThreadId :: ThreadId -> IO (Weak ThreadId)


-- | Attach a timeout event to arbitrary <a>IO</a> computations.
module System.Timeout

-- | Wrap an <a>IO</a> computation to time out and return <tt>Nothing</tt>
--   in case no result is available within <tt>n</tt> microseconds
--   (<tt>1/10^6</tt> seconds). In case a result is available before the
--   timeout expires, <tt>Just a</tt> is returned. A negative timeout
--   interval means "wait indefinitely". When specifying long timeouts, be
--   careful not to exceed <tt>maxBound :: Int</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; timeout 1000000 (threadDelay 1000 *&gt; pure "finished on time")
--   Just "finished on time"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timeout 10000 (threadDelay 100000 *&gt; pure "finished on time")
--   Nothing
--   </pre>
--   
--   The design of this combinator was guided by the objective that
--   <tt>timeout n f</tt> should behave exactly the same as <tt>f</tt> as
--   long as <tt>f</tt> doesn't time out. This means that <tt>f</tt> has
--   the same <a>myThreadId</a> it would have without the timeout wrapper.
--   Any exceptions <tt>f</tt> might throw cancel the timeout and propagate
--   further up. It also possible for <tt>f</tt> to receive exceptions
--   thrown to it by another thread.
--   
--   A tricky implementation detail is the question of how to abort an
--   <tt>IO</tt> computation. This combinator relies on asynchronous
--   exceptions internally. The technique works very well for computations
--   executing inside of the Haskell runtime system, but it doesn't work at
--   all for non-Haskell code. Foreign function calls, for example, cannot
--   be timed out with this combinator simply because an arbitrary C
--   function cannot receive asynchronous exceptions. When <tt>timeout</tt>
--   is used to wrap an FFI call that blocks, no timeout event can be
--   delivered until the FFI call returns, which pretty much negates the
--   purpose of the combinator. In practice, however, this limitation is
--   less severe than it may sound. Standard I/O functions like
--   <a>hGetBuf</a>, <a>hPutBuf</a>, Network.Socket.accept, or
--   <a>hWaitForInput</a> appear to be blocking, but they really don't
--   because the runtime system uses scheduling mechanisms like
--   <tt>select(2)</tt> to perform asynchronous I/O, so it is possible to
--   interrupt standard socket I/O or file I/O using this combinator.
timeout :: Int -> IO a -> IO (Maybe a)
instance GHC.Classes.Eq System.Timeout.Timeout
instance GHC.Show.Show System.Timeout.Timeout
instance GHC.Exception.Type.Exception System.Timeout.Timeout


-- | "Scrap your boilerplate" --- Generic programming in Haskell. See
--   <a>http://www.haskell.org/haskellwiki/Research_papers/Generics#Scrap_your_boilerplate.21</a>.
--   This module provides the <a>Data</a> class with its primitives for
--   generic programming, along with instances for many datatypes. It
--   corresponds to a merge between the previous
--   <a>Data.Generics.Basics</a> and almost all of
--   <a>Data.Generics.Instances</a>. The instances that are not present in
--   this module were moved to the <tt>Data.Generics.Instances</tt> module
--   in the <tt>syb</tt> package.
--   
--   For more information, please visit the new SYB wiki:
--   <a>http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB</a>.
module Data.Data

-- | The <a>Data</a> class comprehends a fundamental primitive
--   <a>gfoldl</a> for folding over constructor applications, say terms.
--   This primitive can be instantiated in several ways to map over the
--   immediate subterms of a term; see the <tt>gmap</tt> combinators later
--   in this class. Indeed, a generic programmer does not necessarily need
--   to use the ingenious gfoldl primitive but rather the intuitive
--   <tt>gmap</tt> combinators. The <a>gfoldl</a> primitive is completed by
--   means to query top-level constructors, to turn constructor
--   representations into proper terms, and to list all possible datatype
--   constructors. This completion allows us to serve generic programming
--   scenarios like read, show, equality, term generation.
--   
--   The combinators <a>gmapT</a>, <a>gmapQ</a>, <a>gmapM</a>, etc are all
--   provided with default definitions in terms of <a>gfoldl</a>, leaving
--   open the opportunity to provide datatype-specific definitions. (The
--   inclusion of the <tt>gmap</tt> combinators as members of class
--   <a>Data</a> allows the programmer or the compiler to derive
--   specialised, and maybe more efficient code per datatype. <i>Note</i>:
--   <a>gfoldl</a> is more higher-order than the <tt>gmap</tt> combinators.
--   This is subject to ongoing benchmarking experiments. It might turn out
--   that the <tt>gmap</tt> combinators will be moved out of the class
--   <a>Data</a>.)
--   
--   Conceptually, the definition of the <tt>gmap</tt> combinators in terms
--   of the primitive <a>gfoldl</a> requires the identification of the
--   <a>gfoldl</a> function arguments. Technically, we also need to
--   identify the type constructor <tt>c</tt> for the construction of the
--   result type from the folded term type.
--   
--   In the definition of <tt>gmapQ</tt><i>x</i> combinators, we use
--   phantom type constructors for the <tt>c</tt> in the type of
--   <a>gfoldl</a> because the result type of a query does not involve the
--   (polymorphic) type of the term argument. In the definition of
--   <a>gmapQl</a> we simply use the plain constant type constructor
--   because <a>gfoldl</a> is left-associative anyway and so it is readily
--   suited to fold a left-associative binary operation over the immediate
--   subterms. In the definition of gmapQr, extra effort is needed. We use
--   a higher-order accumulation trick to mediate between left-associative
--   constructor application vs. right-associative binary operation (e.g.,
--   <tt>(:)</tt>). When the query is meant to compute a value of type
--   <tt>r</tt>, then the result type withing generic folding is <tt>r
--   -&gt; r</tt>. So the result of folding is a function to which we
--   finally pass the right unit.
--   
--   With the <tt>-XDeriveDataTypeable</tt> option, GHC can generate
--   instances of the <a>Data</a> class automatically. For example, given
--   the declaration
--   
--   <pre>
--   data T a b = C1 a b | C2 deriving (Typeable, Data)
--   </pre>
--   
--   GHC will generate an instance that is equivalent to
--   
--   <pre>
--   instance (Data a, Data b) =&gt; Data (T a b) where
--       gfoldl k z (C1 a b) = z C1 `k` a `k` b
--       gfoldl k z C2       = z C2
--   
--       gunfold k z c = case constrIndex c of
--                           1 -&gt; k (k (z C1))
--                           2 -&gt; z C2
--   
--       toConstr (C1 _ _) = con_C1
--       toConstr C2       = con_C2
--   
--       dataTypeOf _ = ty_T
--   
--   con_C1 = mkConstr ty_T "C1" [] Prefix
--   con_C2 = mkConstr ty_T "C2" [] Prefix
--   ty_T   = mkDataType "Module.T" [con_C1, con_C2]
--   </pre>
--   
--   This is suitable for datatypes that are exported transparently.
class Typeable a => Data a

-- | Left-associative fold operation for constructor applications.
--   
--   The type of <a>gfoldl</a> is a headache, but operationally it is a
--   simple generalisation of a list fold.
--   
--   The default definition for <a>gfoldl</a> is <tt><a>const</a>
--   <a>id</a></tt>, which is suitable for abstract datatypes with no
--   substructures.
gfoldl :: Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a

-- | Unfolding constructor applications
gunfold :: Data a => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a

-- | Obtaining the constructor from a given datum. For proper terms, this
--   is meant to be the top-level constructor. Primitive datatypes are here
--   viewed as potentially infinite sets of values (i.e., constructors).
toConstr :: Data a => a -> Constr

-- | The outer type constructor of the type
dataTypeOf :: Data a => a -> DataType

-- | Mediate types and unary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, ...) =&gt; Data (T a)
--   </pre>
--   
--   <a>dataCast1</a> should be defined as <a>gcast1</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast1 :: (Data a, Typeable t) => (forall d. Data d => c (t d)) -> Maybe (c a)

-- | Mediate types and binary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, Data b, ...) =&gt; Data (T a b)
--   </pre>
--   
--   <a>dataCast2</a> should be defined as <a>gcast2</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast2 :: (Data a, Typeable t) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)

-- | A generic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to an identity datatype constructor, using
--   the isomorphism pair as injection and projection.
gmapT :: Data a => (forall b. Data b => b -> b) -> a -> a

-- | A generic query with a left-associative binary operator
gmapQl :: forall r r'. Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query with a right-associative binary operator
gmapQr :: forall r r'. Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query that processes the immediate subterms and returns a
--   list of results. The list is given in the same order as originally
--   specified in the declaration of the data constructors.
gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]

-- | A generic query that processes one child by index (zero-based)
gmapQi :: forall u. Data a => Int -> (forall d. Data d => d -> u) -> a -> u

-- | A generic monadic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to the monad datatype constructor, defining
--   injection and projection using <a>return</a> and <a>&gt;&gt;=</a>.
gmapM :: forall m. (Data a, Monad m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of at least one immediate subterm does not fail
gmapMp :: forall m. (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of one immediate subterm with success
gmapMo :: forall m. (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Representation of datatypes. A package of constructor representations
--   with names of type and module.
data DataType

-- | Constructs an algebraic datatype
mkDataType :: String -> [Constr] -> DataType

-- | Constructs the <a>Int</a> type
mkIntType :: String -> DataType

-- | Constructs the <a>Float</a> type
mkFloatType :: String -> DataType

-- | Constructs the <a>Char</a> type
mkCharType :: String -> DataType

-- | Constructs a non-representation for a non-representable type
mkNoRepType :: String -> DataType

-- | Gets the type constructor including the module
dataTypeName :: DataType -> String

-- | Public representation of datatypes
data DataRep
AlgRep :: [Constr] -> DataRep
IntRep :: DataRep
FloatRep :: DataRep
CharRep :: DataRep
NoRep :: DataRep

-- | Gets the public presentation of a datatype
dataTypeRep :: DataType -> DataRep

-- | Look up a constructor by its representation
repConstr :: DataType -> ConstrRep -> Constr

-- | Test for an algebraic type
isAlgType :: DataType -> Bool

-- | Gets the constructors of an algebraic datatype
dataTypeConstrs :: DataType -> [Constr]

-- | Gets the constructor for an index (algebraic datatypes only)
indexConstr :: DataType -> ConIndex -> Constr

-- | Gets the maximum constructor index of an algebraic datatype
maxConstrIndex :: DataType -> ConIndex

-- | Test for a non-representable type
isNorepType :: DataType -> Bool

-- | Representation of constructors. Note that equality on constructors
--   with different types may not work -- i.e. the constructors for
--   <a>False</a> and <a>Nothing</a> may compare equal.
data Constr

-- | Unique index for datatype constructors, counting from 1 in the order
--   they are given in the program text.
type ConIndex = Int

-- | Fixity of constructors
data Fixity
Prefix :: Fixity
Infix :: Fixity

-- | Constructs a constructor
mkConstr :: DataType -> String -> [String] -> Fixity -> Constr
mkIntegralConstr :: (Integral a, Show a) => DataType -> a -> Constr
mkRealConstr :: (Real a, Show a) => DataType -> a -> Constr

-- | Makes a constructor for <a>Char</a>.
mkCharConstr :: DataType -> Char -> Constr

-- | Gets the datatype of a constructor
constrType :: Constr -> DataType

-- | Public representation of constructors
data ConstrRep
AlgConstr :: ConIndex -> ConstrRep
IntConstr :: Integer -> ConstrRep
FloatConstr :: Rational -> ConstrRep
CharConstr :: Char -> ConstrRep

-- | Gets the public presentation of constructors
constrRep :: Constr -> ConstrRep

-- | Gets the field labels of a constructor. The list of labels is returned
--   in the same order as they were given in the original constructor
--   declaration.
constrFields :: Constr -> [String]

-- | Gets the fixity of a constructor
constrFixity :: Constr -> Fixity

-- | Gets the index of a constructor (algebraic datatypes only)
constrIndex :: Constr -> ConIndex

-- | Gets the string for a constructor
showConstr :: Constr -> String

-- | Lookup a constructor via a string
readConstr :: DataType -> String -> Maybe Constr

-- | Gets the unqualified type constructor: drop *.*.*... before name
tyconUQname :: String -> String

-- | Gets the module of a type constructor: take *.*.*... before name
tyconModule :: String -> String

-- | Build a term skeleton
fromConstr :: Data a => Constr -> a

-- | Build a term and use a generic function for subterms
fromConstrB :: Data a => (forall d. Data d => d) -> Constr -> a

-- | Monadic variation on <a>fromConstrB</a>
fromConstrM :: forall m a. (Monad m, Data a) => (forall d. Data d => m d) -> Constr -> m a
instance GHC.Show.Show Data.Data.DataRep
instance GHC.Classes.Eq Data.Data.DataRep
instance GHC.Show.Show Data.Data.DataType
instance GHC.Show.Show Data.Data.Fixity
instance GHC.Classes.Eq Data.Data.Fixity
instance GHC.Show.Show Data.Data.ConstrRep
instance GHC.Classes.Eq Data.Data.ConstrRep
instance Data.Data.Data GHC.Types.Bool
instance Data.Data.Data a => Data.Data.Data (GHC.Base.NonEmpty a)
instance Data.Data.Data a => Data.Data.Data (GHC.Maybe.Maybe a)
instance Data.Data.Data GHC.Types.Ordering
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Either.Either a b)
instance Data.Data.Data ()
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (a, b)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c) => Data.Data.Data (a, b, c)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d) => Data.Data.Data (a, b, c, d)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e) => Data.Data.Data (a, b, c, d, e)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e, Data.Data.Data f) => Data.Data.Data (a, b, c, d, e, f)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e, Data.Data.Data f, Data.Data.Data g) => Data.Data.Data (a, b, c, d, e, f, g)
instance Data.Data.Data Foreign.Ptr.IntPtr
instance Data.Data.Data Foreign.Ptr.WordPtr
instance Data.Data.Data t => Data.Data.Data (Data.Proxy.Proxy t)
instance (a Data.Type.Equality.~ b, Data.Data.Data a) => Data.Data.Data (a Data.Type.Equality.:~: b)
instance forall i j (a :: i) (b :: j). (Data.Typeable.Internal.Typeable i, Data.Typeable.Internal.Typeable j, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, a GHC.Types.~~ b) => Data.Data.Data (a Data.Type.Equality.:~~: b)
instance (GHC.Types.Coercible a b, Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Type.Coercion.Coercion a b)
instance Data.Data.Data a => Data.Data.Data (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). (Data.Typeable.Internal.Typeable k, Data.Data.Data a, Data.Typeable.Internal.Typeable b) => Data.Data.Data (Data.Functor.Const.Const a b)
instance Data.Data.Data Data.Version.Version
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Internal.Dual a)
instance Data.Data.Data Data.Semigroup.Internal.All
instance Data.Data.Data Data.Semigroup.Internal.Any
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Internal.Sum a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Internal.Product a)
instance Data.Data.Data a => Data.Data.Data (Data.Monoid.First a)
instance Data.Data.Data a => Data.Data.Data (Data.Monoid.Last a)
instance (Data.Data.Data (f a), Data.Data.Data a, Data.Typeable.Internal.Typeable f) => Data.Data.Data (Data.Semigroup.Internal.Alt f a)
instance (Data.Data.Data (f a), Data.Data.Data a, Data.Typeable.Internal.Typeable f) => Data.Data.Data (Data.Monoid.Ap f a)
instance Data.Data.Data p => Data.Data.Data (GHC.Generics.U1 p)
instance Data.Data.Data p => Data.Data.Data (GHC.Generics.Par1 p)
instance (Data.Data.Data (f p), Data.Typeable.Internal.Typeable f, Data.Data.Data p) => Data.Data.Data (GHC.Generics.Rec1 f p)
instance (Data.Typeable.Internal.Typeable i, Data.Data.Data p, Data.Data.Data c) => Data.Data.Data (GHC.Generics.K1 i c p)
instance (Data.Data.Data p, Data.Data.Data (f p), Data.Typeable.Internal.Typeable c, Data.Typeable.Internal.Typeable i, Data.Typeable.Internal.Typeable f) => Data.Data.Data (GHC.Generics.M1 i c f p)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Data.Data p, Data.Data.Data (f p), Data.Data.Data (g p)) => Data.Data.Data ((GHC.Generics.:+:) f g p)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Data.Data p, Data.Data.Data (f (g p))) => Data.Data.Data ((GHC.Generics.:.:) f g p)
instance Data.Data.Data p => Data.Data.Data (GHC.Generics.V1 p)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Data.Data p, Data.Data.Data (f p), Data.Data.Data (g p)) => Data.Data.Data ((GHC.Generics.:*:) f g p)
instance Data.Data.Data GHC.Generics.Fixity
instance Data.Data.Data GHC.Generics.Associativity
instance Data.Data.Data GHC.Generics.SourceUnpackedness
instance Data.Data.Data GHC.Generics.SourceStrictness
instance Data.Data.Data GHC.Generics.DecidedStrictness
instance Data.Data.Data a => Data.Data.Data (Data.Ord.Down a)
instance Data.Data.Data GHC.Types.Char
instance Data.Data.Data GHC.Types.Float
instance Data.Data.Data GHC.Types.Double
instance Data.Data.Data GHC.Types.Int
instance Data.Data.Data GHC.Integer.Type.Integer
instance Data.Data.Data GHC.Natural.Natural
instance Data.Data.Data GHC.Int.Int8
instance Data.Data.Data GHC.Int.Int16
instance Data.Data.Data GHC.Int.Int32
instance Data.Data.Data GHC.Int.Int64
instance Data.Data.Data GHC.Types.Word
instance Data.Data.Data GHC.Word.Word8
instance Data.Data.Data GHC.Word.Word16
instance Data.Data.Data GHC.Word.Word32
instance Data.Data.Data GHC.Word.Word64
instance (Data.Data.Data a, GHC.Real.Integral a) => Data.Data.Data (GHC.Real.Ratio a)
instance Data.Data.Data a => Data.Data.Data [a]
instance Data.Data.Data a => Data.Data.Data (GHC.Ptr.Ptr a)
instance Data.Data.Data a => Data.Data.Data (GHC.ForeignPtr.ForeignPtr a)
instance (Data.Data.Data a, Data.Data.Data b, GHC.Arr.Ix a) => Data.Data.Data (GHC.Arr.Array a b)
instance GHC.Show.Show Data.Data.Constr
instance GHC.Classes.Eq Data.Data.Constr


-- | GHC Extensions: this is the Approved Way to get at GHC-specific
--   extensions.
--   
--   Note: no other base module should import this module.
module GHC.Exts

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int
I# :: Int# -> Int

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word
W# :: Word# -> Word

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float
F# :: Float# -> Float

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double
D# :: Double# -> Double

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char
C# :: Char# -> Char

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data Ptr a
Ptr :: Addr# -> Ptr a

-- | A value of type <tt><a>FunPtr</a> a</tt> is a pointer to a function
--   callable from foreign code. The type <tt>a</tt> will normally be a
--   <i>foreign type</i>, a function type with zero or more arguments where
--   
--   <ul>
--   <li>the argument types are <i>marshallable foreign types</i>, i.e.
--   <a>Char</a>, <a>Int</a>, <a>Double</a>, <a>Float</a>, <a>Bool</a>,
--   <a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>, <a>Word8</a>,
--   <a>Word16</a>, <a>Word32</a>, <a>Word64</a>, <tt><a>Ptr</a> a</tt>,
--   <tt><a>FunPtr</a> a</tt>, <tt><a>StablePtr</a> a</tt> or a renaming of
--   any of these using <tt>newtype</tt>.</li>
--   <li>the return type is either a marshallable foreign type or has the
--   form <tt><a>IO</a> t</tt> where <tt>t</tt> is a marshallable foreign
--   type or <tt>()</tt>.</li>
--   </ul>
--   
--   A value of type <tt><a>FunPtr</a> a</tt> may be a pointer to a foreign
--   function, either returned by another foreign function or imported with
--   a a static address import like
--   
--   <pre>
--   foreign import ccall "stdlib.h &amp;free"
--     p_free :: FunPtr (Ptr a -&gt; IO ())
--   </pre>
--   
--   or a pointer to a Haskell function created using a <i>wrapper</i> stub
--   declared to produce a <a>FunPtr</a> of the correct type. For example:
--   
--   <pre>
--   type Compare = Int -&gt; Int -&gt; Bool
--   foreign import ccall "wrapper"
--     mkCompare :: Compare -&gt; IO (FunPtr Compare)
--   </pre>
--   
--   Calls to wrapper stubs like <tt>mkCompare</tt> allocate storage, which
--   should be released with <a>freeHaskellFunPtr</a> when no longer
--   required.
--   
--   To convert <a>FunPtr</a> values to corresponding Haskell functions,
--   one can define a <i>dynamic</i> stub for the specific foreign type,
--   e.g.
--   
--   <pre>
--   type IntFunction = CInt -&gt; IO ()
--   foreign import ccall "dynamic"
--     mkFun :: FunPtr IntFunction -&gt; IntFunction
--   </pre>
data FunPtr a
FunPtr :: Addr# -> FunPtr a
maxTupleSize :: Int

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: () => a -> b -> b
realWorld# :: State# RealWorld
void# :: Void#

-- | The function <tt>unsafeCoerce#</tt> allows you to side-step the
--   typechecker entirely. That is, it allows you to coerce any type into
--   any other type. If you use this function, you had better get it right,
--   otherwise segmentation faults await. It is generally used when you
--   want to write a program that you know is well-typed, but where
--   Haskell's type system is not expressive enough to prove that it is
--   well typed.
--   
--   The following uses of <tt>unsafeCoerce#</tt> are supposed to work
--   (i.e. not lead to spurious compile-time or run-time crashes):
--   
--   <ul>
--   <li>Casting any lifted type to <tt>Any</tt></li>
--   <li>Casting <tt>Any</tt> back to the real type</li>
--   <li>Casting an unboxed type to another unboxed type of the same size.
--   (Casting between floating-point and integral types does not work. See
--   the <tt>GHC.Float</tt> module for functions to do work.)</li>
--   <li>Casting between two types that have the same runtime
--   representation. One case is when the two types differ only in
--   "phantom" type parameters, for example <tt>Ptr Int</tt> to <tt>Ptr
--   Float</tt>, or <tt>[Int]</tt> to <tt>[Float]</tt> when the list is
--   known to be empty. Also, a <tt>newtype</tt> of a type <tt>T</tt> has
--   the same representation at runtime as <tt>T</tt>.</li>
--   </ul>
--   
--   Other uses of <tt>unsafeCoerce#</tt> are undefined. In particular, you
--   should not use <tt>unsafeCoerce#</tt> to cast a T to an algebraic data
--   type D, unless T is also an algebraic data type. For example, do not
--   cast <tt>Int-&gt;Int</tt> to <tt>Bool</tt>, even if you later cast
--   that <tt>Bool</tt> back to <tt>Int-&gt;Int</tt> before applying it.
--   The reasons have to do with GHC's internal representation details (for
--   the cognoscenti, data values can be entered but function closures
--   cannot). If you want a safe type to cast things to, use <tt>Any</tt>,
--   which is not an algebraic data type.
unsafeCoerce# :: () => a -> b

-- | The null address.
nullAddr# :: Addr#
magicDict :: () => a

-- | Witness for an unboxed <tt>Proxy#</tt> value, which has no runtime
--   representation.
proxy# :: () => Proxy# a

-- | An arbitrary machine address assumed to point outside the
--   garbage-collected heap.
data Addr# :: TYPE AddrRep
data Array# (a :: Type) :: Type -> TYPE UnliftedRep
data ByteArray# :: TYPE UnliftedRep
data Char# :: TYPE WordRep
data Double# :: TYPE DoubleRep
data Float# :: TYPE FloatRep
data Int# :: TYPE IntRep
data Int32# :: TYPE IntRep
data Int64# :: TYPE Int64Rep
data Weak# (a :: Type) :: Type -> TYPE UnliftedRep
data MutableArray# (a :: Type) (b :: Type) :: Type -> Type -> TYPE UnliftedRep
data MutableByteArray# (a :: Type) :: Type -> TYPE UnliftedRep

-- | A shared mutable variable (<i>not</i> the same as a
--   <tt>MutVar#</tt>!). (Note: in a non-concurrent implementation,
--   <tt>(MVar# a)</tt> can be represented by <tt>(MutVar# (Maybe
--   a))</tt>.)
data MVar# (a :: Type) (b :: Type) :: Type -> Type -> TYPE UnliftedRep

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld :: Type
data StablePtr# (a :: Type) :: Type -> TYPE AddrRep
data ArrayArray# :: TYPE UnliftedRep
data MutableArrayArray# (a :: Type) :: Type -> TYPE UnliftedRep

-- | <tt>State#</tt> is the primitive, unlifted type of states. It has one
--   type parameter, thus <tt>State# RealWorld</tt>, or <tt>State# s</tt>,
--   where s is a type variable. The only purpose of the type parameter is
--   to keep different state threads separate. It is represented by nothing
--   at all.
data State# (a :: Type) :: Type -> TYPE TupleRep ([] :: [RuntimeRep])
data StableName# (a :: Type) :: Type -> TYPE UnliftedRep

-- | A <tt>MutVar#</tt> behaves like a single-element mutable array.
data MutVar# (a :: Type) (b :: Type) :: Type -> Type -> TYPE UnliftedRep
data Void# :: TYPE TupleRep ([] :: [RuntimeRep])
data Word# :: TYPE WordRep
data Word32# :: TYPE WordRep
data Word64# :: TYPE Word64Rep

-- | (In a non-concurrent implementation, this can be a singleton type,
--   whose (unique) value is returned by <tt>myThreadId#</tt>. The other
--   operations can be omitted.)
data ThreadId# :: TYPE UnliftedRep

-- | Primitive bytecode type.
data BCO# :: TYPE UnliftedRep
data TVar# (a :: Type) (b :: Type) :: Type -> Type -> TYPE UnliftedRep
data Compact# :: TYPE UnliftedRep

-- | The type constructor <tt>Proxy#</tt> is used to bear witness to some
--   type variable. It's used when you want to pass around proxy values for
--   doing things like modelling type applications. A <tt>Proxy#</tt> is
--   not only unboxed, it also has a polymorphic kind, and has no runtime
--   representation, being totally free.
data Proxy# :: forall k0. () => k0 -> TYPE TupleRep ([] :: [RuntimeRep])
data SmallArray# (a :: Type) :: Type -> TYPE UnliftedRep
data SmallMutableArray# (a :: Type) (b :: Type) :: Type -> Type -> TYPE UnliftedRep
data Int8X16# :: TYPE VecRep Vec16 Int8ElemRep
data Int16X8# :: TYPE VecRep Vec8 Int16ElemRep
data Int32X4# :: TYPE VecRep Vec4 Int32ElemRep
data Int64X2# :: TYPE VecRep Vec2 Int64ElemRep
data Int8X32# :: TYPE VecRep Vec32 Int8ElemRep
data Int16X16# :: TYPE VecRep Vec16 Int16ElemRep
data Int32X8# :: TYPE VecRep Vec8 Int32ElemRep
data Int64X4# :: TYPE VecRep Vec4 Int64ElemRep
data Int8X64# :: TYPE VecRep Vec64 Int8ElemRep
data Int16X32# :: TYPE VecRep Vec32 Int16ElemRep
data Int32X16# :: TYPE VecRep Vec16 Int32ElemRep
data Int64X8# :: TYPE VecRep Vec8 Int64ElemRep
data Word8X16# :: TYPE VecRep Vec16 Word8ElemRep
data Word16X8# :: TYPE VecRep Vec8 Word16ElemRep
data Word32X4# :: TYPE VecRep Vec4 Word32ElemRep
data Word64X2# :: TYPE VecRep Vec2 Word64ElemRep
data Word8X32# :: TYPE VecRep Vec32 Word8ElemRep
data Word16X16# :: TYPE VecRep Vec16 Word16ElemRep
data Word32X8# :: TYPE VecRep Vec8 Word32ElemRep
data Word64X4# :: TYPE VecRep Vec4 Word64ElemRep
data Word8X64# :: TYPE VecRep Vec64 Word8ElemRep
data Word16X32# :: TYPE VecRep Vec32 Word16ElemRep
data Word32X16# :: TYPE VecRep Vec16 Word32ElemRep
data Word64X8# :: TYPE VecRep Vec8 Word64ElemRep
data FloatX4# :: TYPE VecRep Vec4 FloatElemRep
data DoubleX2# :: TYPE VecRep Vec2 DoubleElemRep
data FloatX8# :: TYPE VecRep Vec8 FloatElemRep
data DoubleX4# :: TYPE VecRep Vec4 DoubleElemRep
data FloatX16# :: TYPE VecRep Vec16 FloatElemRep
data DoubleX8# :: TYPE VecRep Vec8 DoubleElemRep
gtChar# :: Char# -> Char# -> Int#
geChar# :: Char# -> Char# -> Int#
eqChar# :: Char# -> Char# -> Int#
neChar# :: Char# -> Char# -> Int#
ltChar# :: Char# -> Char# -> Int#
leChar# :: Char# -> Char# -> Int#
ord# :: Char# -> Int#
(+#) :: Int# -> Int# -> Int#
infixl 6 +#
(-#) :: Int# -> Int# -> Int#
infixl 6 -#

-- | Low word of signed integer multiply.
(*#) :: Int# -> Int# -> Int#
infixl 7 *#

-- | Return non-zero if there is any possibility that the upper word of a
--   signed integer multiply might contain useful information. Return zero
--   only if you are completely sure that no overflow can occur. On a
--   32-bit platform, the recommended implementation is to do a 32 x 32
--   -&gt; 64 signed multiply, and subtract result[63:32] from (result[31]
--   &gt;&gt;signed 31). If this is zero, meaning that the upper word is
--   merely a sign extension of the lower one, no overflow can occur.
--   
--   On a 64-bit platform it is not always possible to acquire the top 64
--   bits of the result. Therefore, a recommended implementation is to take
--   the absolute value of both operands, and return 0 iff bits[63:31] of
--   them are zero, since that means that their magnitudes fit within 31
--   bits, so the magnitude of the product must fit into 62 bits.
--   
--   If in doubt, return non-zero, but do make an effort to create the
--   correct answer for small args, since otherwise the performance of
--   <tt>(*) :: Integer -&gt; Integer -&gt; Integer</tt> will be poor.
mulIntMayOflo# :: Int# -> Int# -> Int#

-- | Rounds towards zero. The behavior is undefined if the second argument
--   is zero.
quotInt# :: Int# -> Int# -> Int#

-- | Satisfies <tt>(quotInt# x y) *# y +# (remInt# x y) == x</tt>. The
--   behavior is undefined if the second argument is zero.
remInt# :: Int# -> Int# -> Int#

-- | Rounds towards zero.
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
andI# :: Int# -> Int# -> Int#
orI# :: Int# -> Int# -> Int#
xorI# :: Int# -> Int# -> Int#
notI# :: Int# -> Int#
negateInt# :: Int# -> Int#

-- | Add signed integers reporting overflow. First member of result is the
--   sum truncated to an <tt>Int#</tt>; second member is zero if the true
--   sum fits in an <tt>Int#</tt>, nonzero if overflow occurred (the sum is
--   either too large or too small to fit in an <tt>Int#</tt>).
addIntC# :: Int# -> Int# -> (# Int#, Int# #)

-- | Subtract signed integers reporting overflow. First member of result is
--   the difference truncated to an <tt>Int#</tt>; second member is zero if
--   the true difference fits in an <tt>Int#</tt>, nonzero if overflow
--   occurred (the difference is either too large or too small to fit in an
--   <tt>Int#</tt>).
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
(>#) :: Int# -> Int# -> Int#
infix 4 >#
(>=#) :: Int# -> Int# -> Int#
infix 4 >=#
(==#) :: Int# -> Int# -> Int#
infix 4 ==#
(/=#) :: Int# -> Int# -> Int#
infix 4 /=#
(<#) :: Int# -> Int# -> Int#
infix 4 <#
(<=#) :: Int# -> Int# -> Int#
infix 4 <=#
chr# :: Int# -> Char#
int2Word# :: Int# -> Word#
int2Float# :: Int# -> Float#
int2Double# :: Int# -> Double#
word2Float# :: Word# -> Float#
word2Double# :: Word# -> Double#

-- | Shift left. Result undefined if shift amount is not in the range 0 to
--   word size - 1 inclusive.
uncheckedIShiftL# :: Int# -> Int# -> Int#

-- | Shift right arithmetic. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRA# :: Int# -> Int# -> Int#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRL# :: Int# -> Int# -> Int#
plusWord# :: Word# -> Word# -> Word#

-- | Add unsigned integers reporting overflow. The first element of the
--   pair is the result. The second element is the carry flag, which is
--   nonzero on overflow. See also <tt>plusWord2#</tt>.
addWordC# :: Word# -> Word# -> (# Word#, Int# #)

-- | Subtract unsigned integers reporting overflow. The first element of
--   the pair is the result. The second element is the carry flag, which is
--   nonzero on overflow.
subWordC# :: Word# -> Word# -> (# Word#, Int# #)

-- | Add unsigned integers, with the high part (carry) in the first
--   component of the returned pair and the low part in the second
--   component of the pair. See also <tt>addWordC#</tt>.
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
minusWord# :: Word# -> Word# -> Word#
timesWord# :: Word# -> Word# -> Word#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
quotWord# :: Word# -> Word# -> Word#
remWord# :: Word# -> Word# -> Word#
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
and# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
xor# :: Word# -> Word# -> Word#
not# :: Word# -> Word#

-- | Shift left logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftL# :: Word# -> Int# -> Word#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftRL# :: Word# -> Int# -> Word#
word2Int# :: Word# -> Int#
gtWord# :: Word# -> Word# -> Int#
geWord# :: Word# -> Word# -> Int#
eqWord# :: Word# -> Word# -> Int#
neWord# :: Word# -> Word# -> Int#
ltWord# :: Word# -> Word# -> Int#
leWord# :: Word# -> Word# -> Int#

-- | Count the number of set bits in the lower 8 bits of a word.
popCnt8# :: Word# -> Word#

-- | Count the number of set bits in the lower 16 bits of a word.
popCnt16# :: Word# -> Word#

-- | Count the number of set bits in the lower 32 bits of a word.
popCnt32# :: Word# -> Word#

-- | Count the number of set bits in a 64-bit word.
popCnt64# :: Word# -> Word#

-- | Count the number of set bits in a word.
popCnt# :: Word# -> Word#

-- | Deposit bits to lower 8 bits of a word at locations specified by a
--   mask.
pdep8# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 16 bits of a word at locations specified by a
--   mask.
pdep16# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 32 bits of a word at locations specified by a
--   mask.
pdep32# :: Word# -> Word# -> Word#

-- | Deposit bits to a word at locations specified by a mask.
pdep64# :: Word# -> Word# -> Word#

-- | Deposit bits to a word at locations specified by a mask.
pdep# :: Word# -> Word# -> Word#

-- | Extract bits from lower 8 bits of a word at locations specified by a
--   mask.
pext8# :: Word# -> Word# -> Word#

-- | Extract bits from lower 16 bits of a word at locations specified by a
--   mask.
pext16# :: Word# -> Word# -> Word#

-- | Extract bits from lower 32 bits of a word at locations specified by a
--   mask.
pext32# :: Word# -> Word# -> Word#

-- | Extract bits from a word at locations specified by a mask.
pext64# :: Word# -> Word# -> Word#

-- | Extract bits from a word at locations specified by a mask.
pext# :: Word# -> Word# -> Word#

-- | Count leading zeros in the lower 8 bits of a word.
clz8# :: Word# -> Word#

-- | Count leading zeros in the lower 16 bits of a word.
clz16# :: Word# -> Word#

-- | Count leading zeros in the lower 32 bits of a word.
clz32# :: Word# -> Word#

-- | Count leading zeros in a 64-bit word.
clz64# :: Word# -> Word#

-- | Count leading zeros in a word.
clz# :: Word# -> Word#

-- | Count trailing zeros in the lower 8 bits of a word.
ctz8# :: Word# -> Word#

-- | Count trailing zeros in the lower 16 bits of a word.
ctz16# :: Word# -> Word#

-- | Count trailing zeros in the lower 32 bits of a word.
ctz32# :: Word# -> Word#

-- | Count trailing zeros in a 64-bit word.
ctz64# :: Word# -> Word#

-- | Count trailing zeros in a word.
ctz# :: Word# -> Word#

-- | Swap bytes in the lower 16 bits of a word. The higher bytes are
--   undefined.
byteSwap16# :: Word# -> Word#

-- | Swap bytes in the lower 32 bits of a word. The higher bytes are
--   undefined.
byteSwap32# :: Word# -> Word#

-- | Swap bytes in a 64 bits of a word.
byteSwap64# :: Word# -> Word#

-- | Swap bytes in a word.
byteSwap# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow32Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow32Word# :: Word# -> Word#
(>##) :: Double# -> Double# -> Int#
infix 4 >##
(>=##) :: Double# -> Double# -> Int#
infix 4 >=##
(==##) :: Double# -> Double# -> Int#
infix 4 ==##
(/=##) :: Double# -> Double# -> Int#
infix 4 /=##
(<##) :: Double# -> Double# -> Int#
infix 4 <##
(<=##) :: Double# -> Double# -> Int#
infix 4 <=##
(+##) :: Double# -> Double# -> Double#
infixl 6 +##
(-##) :: Double# -> Double# -> Double#
infixl 6 -##
(*##) :: Double# -> Double# -> Double#
infixl 7 *##
(/##) :: Double# -> Double# -> Double#
infixl 7 /##
negateDouble# :: Double# -> Double#
fabsDouble# :: Double# -> Double#

-- | Truncates a <tt>Double#</tt> value to the nearest <tt>Int#</tt>.
--   Results are undefined if the truncation if truncation yields a value
--   outside the range of <tt>Int#</tt>.
double2Int# :: Double# -> Int#
double2Float# :: Double# -> Float#
expDouble# :: Double# -> Double#
logDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#
asinDouble# :: Double# -> Double#
acosDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#

-- | Exponentiation.
(**##) :: Double# -> Double# -> Double#

-- | Convert to integer. First component of the result is -1 or 1,
--   indicating the sign of the mantissa. The next two are the high and low
--   32 bits of the mantissa respectively, and the last is the exponent.
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)

-- | Decode <tt>Double#</tt> into mantissa and base-2 exponent.
decodeDouble_Int64# :: Double# -> (# Int#, Int# #)
gtFloat# :: Float# -> Float# -> Int#
geFloat# :: Float# -> Float# -> Int#
eqFloat# :: Float# -> Float# -> Int#
neFloat# :: Float# -> Float# -> Int#
ltFloat# :: Float# -> Float# -> Int#
leFloat# :: Float# -> Float# -> Int#
plusFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#
divideFloat# :: Float# -> Float# -> Float#
negateFloat# :: Float# -> Float#
fabsFloat# :: Float# -> Float#

-- | Truncates a <tt>Float#</tt> value to the nearest <tt>Int#</tt>.
--   Results are undefined if the truncation if truncation yields a value
--   outside the range of <tt>Int#</tt>.
float2Int# :: Float# -> Int#
expFloat# :: Float# -> Float#
logFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#
asinFloat# :: Float# -> Float#
acosFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
powerFloat# :: Float# -> Float# -> Float#
float2Double# :: Float# -> Double#

-- | Convert to integers. First <tt>Int#</tt> in result is the mantissa;
--   second is the exponent.
decodeFloat_Int# :: Float# -> (# Int#, Int# #)

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newArray# :: () => Int# -> a -> State# d -> (# State# d, MutableArray# d a #)
sameMutableArray# :: () => MutableArray# d a -> MutableArray# d a -> Int#

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
readArray# :: () => MutableArray# d a -> Int# -> State# d -> (# State# d, a #)

-- | Write to specified index of mutable array.
writeArray# :: () => MutableArray# d a -> Int# -> a -> State# d -> State# d

-- | Return the number of elements in the array.
sizeofArray# :: () => Array# a -> Int#

-- | Return the number of elements in the array.
sizeofMutableArray# :: () => MutableArray# d a -> Int#

-- | Read from the specified index of an immutable array. The result is
--   packaged into an unboxed unary tuple; the result itself is not yet
--   evaluated. Pattern matching on the tuple forces the indexing of the
--   array to happen but does not evaluate the element itself. Evaluating
--   the thunk prevents additional thunks from building up on the heap.
--   Avoiding these thunks, in turn, reduces references to the argument
--   array, allowing it to be garbage collected more promptly.
indexArray# :: () => Array# a -> Int# -> (# a #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeArray# :: () => MutableArray# d a -> State# d -> (# State# d, Array# a #)

-- | Make an immutable array mutable, without copying.
unsafeThawArray# :: () => Array# a -> State# d -> (# State# d, MutableArray# d a #)

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
copyArray# :: () => Array# a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. In the case where the source and destination are the
--   same array the source and destination regions may overlap.
copyMutableArray# :: () => MutableArray# d a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
cloneArray# :: () => Array# a -> Int# -> Int# -> Array# a

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
cloneMutableArray# :: () => MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
freezeArray# :: () => MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, Array# a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
thawArray# :: () => Array# a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)

-- | Unsafe, machine-level atomic compare and swap on an element within an
--   Array.
casArray# :: () => MutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newSmallArray# :: () => Int# -> a -> State# d -> (# State# d, SmallMutableArray# d a #)
sameSmallMutableArray# :: () => SmallMutableArray# d a -> SmallMutableArray# d a -> Int#

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
readSmallArray# :: () => SmallMutableArray# d a -> Int# -> State# d -> (# State# d, a #)

-- | Write to specified index of mutable array.
writeSmallArray# :: () => SmallMutableArray# d a -> Int# -> a -> State# d -> State# d

-- | Return the number of elements in the array.
sizeofSmallArray# :: () => SmallArray# a -> Int#

-- | Return the number of elements in the array.
sizeofSmallMutableArray# :: () => SmallMutableArray# d a -> Int#

-- | Read from specified index of immutable array. Result is packaged into
--   an unboxed singleton; the result itself is not yet evaluated.
indexSmallArray# :: () => SmallArray# a -> Int# -> (# a #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeSmallArray# :: () => SmallMutableArray# d a -> State# d -> (# State# d, SmallArray# a #)

-- | Make an immutable array mutable, without copying.
unsafeThawSmallArray# :: () => SmallArray# a -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
copySmallArray# :: () => SmallArray# a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. The source and destination arrays can refer to the same array.
--   Both arrays must fully contain the specified ranges, but this is not
--   checked. The regions are allowed to overlap, although this is only
--   possible when the same array is provided as both the source and the
--   destination.
copySmallMutableArray# :: () => SmallMutableArray# d a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
cloneSmallArray# :: () => SmallArray# a -> Int# -> Int# -> SmallArray# a

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
cloneSmallMutableArray# :: () => SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
freezeSmallArray# :: () => SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallArray# a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
thawSmallArray# :: () => SmallArray# a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Unsafe, machine-level atomic compare and swap on an element within an
--   array.
casSmallArray# :: () => SmallMutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)

-- | Create a new mutable byte array of specified size (in bytes), in the
--   specified state thread.
newByteArray# :: () => Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Create a mutable byte array that the GC guarantees not to move.
newPinnedByteArray# :: () => Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Create a mutable byte array, aligned by the specified amount, that the
--   GC guarantees not to move.
newAlignedPinnedByteArray# :: () => Int# -> Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Determine whether a <tt>MutableByteArray#</tt> is guaranteed not to
--   move during GC.
isMutableByteArrayPinned# :: () => MutableByteArray# d -> Int#

-- | Determine whether a <tt>ByteArray#</tt> is guaranteed not to move
--   during GC.
isByteArrayPinned# :: ByteArray# -> Int#

-- | Intended for use with pinned arrays; otherwise very unsafe!
byteArrayContents# :: ByteArray# -> Addr#
sameMutableByteArray# :: () => MutableByteArray# d -> MutableByteArray# d -> Int#

-- | Shrink mutable byte array to new specified size (in bytes), in the
--   specified state thread. The new size argument must be less than or
--   equal to the current size as reported by <tt>sizeofMutableArray#</tt>.
shrinkMutableByteArray# :: () => MutableByteArray# d -> Int# -> State# d -> State# d

-- | Resize (unpinned) mutable byte array to new specified size (in bytes).
--   The returned <tt>MutableByteArray#</tt> is either the original
--   <tt>MutableByteArray#</tt> resized in-place or, if not possible, a
--   newly allocated (unpinned) <tt>MutableByteArray#</tt> (with the
--   original content copied over).
--   
--   To avoid undefined behaviour, the original <tt>MutableByteArray#</tt>
--   shall not be accessed anymore after a <tt>resizeMutableByteArray#</tt>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <tt>MutableByteArray#</tt> in case a new <tt>MutableByteArray#</tt>
--   had to be allocated.
resizeMutableByteArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Make a mutable byte array immutable, without copying.
unsafeFreezeByteArray# :: () => MutableByteArray# d -> State# d -> (# State# d, ByteArray# #)

-- | Return the size of the array in bytes.
sizeofByteArray# :: ByteArray# -> Int#

-- | Return the size of the array in bytes. Note that this is deprecated as
--   it is unsafe in the presence of concurrent resize operations on the
--   same byte array. See <tt>getSizeofMutableByteArray</tt>.
sizeofMutableByteArray# :: () => MutableByteArray# d -> Int#

-- | Return the number of elements in the array.
getSizeofMutableByteArray# :: () => MutableByteArray# d -> State# d -> (# State# d, Int# #)

-- | Read 8-bit character; offset in bytes.
indexCharArray# :: ByteArray# -> Int# -> Char#

-- | Read 31-bit character; offset in 4-byte words.
indexWideCharArray# :: ByteArray# -> Int# -> Char#
indexIntArray# :: ByteArray# -> Int# -> Int#
indexWordArray# :: ByteArray# -> Int# -> Word#
indexAddrArray# :: ByteArray# -> Int# -> Addr#
indexFloatArray# :: ByteArray# -> Int# -> Float#
indexDoubleArray# :: ByteArray# -> Int# -> Double#
indexStablePtrArray# :: () => ByteArray# -> Int# -> StablePtr# a

-- | Read 8-bit integer; offset in bytes.
indexInt8Array# :: ByteArray# -> Int# -> Int#

-- | Read 16-bit integer; offset in 16-bit words.
indexInt16Array# :: ByteArray# -> Int# -> Int#

-- | Read 32-bit integer; offset in 32-bit words.
indexInt32Array# :: ByteArray# -> Int# -> Int#

-- | Read 64-bit integer; offset in 64-bit words.
indexInt64Array# :: ByteArray# -> Int# -> Int#

-- | Read 8-bit word; offset in bytes.
indexWord8Array# :: ByteArray# -> Int# -> Word#

-- | Read 16-bit word; offset in 16-bit words.
indexWord16Array# :: ByteArray# -> Int# -> Word#

-- | Read 32-bit word; offset in 32-bit words.
indexWord32Array# :: ByteArray# -> Int# -> Word#

-- | Read 64-bit word; offset in 64-bit words.
indexWord64Array# :: ByteArray# -> Int# -> Word#

-- | Read 8-bit character; offset in bytes.
indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#

-- | Read 31-bit character; offset in bytes.
indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#

-- | Read address; offset in bytes.
indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#

-- | Read float; offset in bytes.
indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#

-- | Read double; offset in bytes.
indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#

-- | Read stable pointer; offset in bytes.
indexWord8ArrayAsStablePtr# :: () => ByteArray# -> Int# -> StablePtr# a

-- | Read 16-bit int; offset in bytes.
indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int#

-- | Read 32-bit int; offset in bytes.
indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int#

-- | Read 64-bit int; offset in bytes.
indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int#

-- | Read int; offset in bytes.
indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#

-- | Read 16-bit word; offset in bytes.
indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word#

-- | Read 32-bit word; offset in bytes.
indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word#

-- | Read 64-bit word; offset in bytes.
indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word#

-- | Read word; offset in bytes.
indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#

-- | Read 8-bit character; offset in bytes.
readCharArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read 31-bit character; offset in 4-byte words.
readWideCharArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read integer; offset in words.
readIntArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)

-- | Read word; offset in words.
readWordArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readAddrArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)
readFloatArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)
readDoubleArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)
readStablePtrArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)
readInt8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readInt16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readInt32Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readInt64Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readWord8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readWord16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readWord32Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readWord64Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readWord8ArrayAsChar# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
readWord8ArrayAsWideChar# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
readWord8ArrayAsAddr# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)
readWord8ArrayAsFloat# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)
readWord8ArrayAsDouble# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)
readWord8ArrayAsStablePtr# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)
readWord8ArrayAsInt16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readWord8ArrayAsInt32# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readWord8ArrayAsInt64# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readWord8ArrayAsInt# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
readWord8ArrayAsWord16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readWord8ArrayAsWord32# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readWord8ArrayAsWord64# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
readWord8ArrayAsWord# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)

-- | Write 8-bit character; offset in bytes.
writeCharArray# :: () => MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write 31-bit character; offset in 4-byte words.
writeWideCharArray# :: () => MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
writeIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeWordArray# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeAddrArray# :: () => MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d
writeFloatArray# :: () => MutableByteArray# d -> Int# -> Float# -> State# d -> State# d
writeDoubleArray# :: () => MutableByteArray# d -> Int# -> Double# -> State# d -> State# d
writeStablePtrArray# :: () => MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d
writeInt8Array# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeInt16Array# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeInt32Array# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeInt64Array# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeWord8Array# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeWord16Array# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeWord32Array# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeWord64Array# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeWord8ArrayAsChar# :: () => MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
writeWord8ArrayAsWideChar# :: () => MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
writeWord8ArrayAsAddr# :: () => MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d
writeWord8ArrayAsFloat# :: () => MutableByteArray# d -> Int# -> Float# -> State# d -> State# d
writeWord8ArrayAsDouble# :: () => MutableByteArray# d -> Int# -> Double# -> State# d -> State# d
writeWord8ArrayAsStablePtr# :: () => MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d
writeWord8ArrayAsInt16# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeWord8ArrayAsInt32# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeWord8ArrayAsInt64# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeWord8ArrayAsInt# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
writeWord8ArrayAsWord16# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeWord8ArrayAsWord32# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeWord8ArrayAsWord64# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
writeWord8ArrayAsWord# :: () => MutableByteArray# d -> Int# -> Word# -> State# d -> State# d

-- | <tt>compareByteArrays# src1 src1_ofs src2 src2_ofs n</tt> compares
--   <tt>n</tt> bytes starting at offset <tt>src1_ofs</tt> in the first
--   <tt>ByteArray#</tt> <tt>src1</tt> to the range of <tt>n</tt> bytes
--   (i.e. same length) starting at offset <tt>src2_ofs</tt> of the second
--   <tt>ByteArray#</tt> <tt>src2</tt>. Both arrays must fully contain the
--   specified ranges, but this is not checked. Returns an <tt>Int#</tt>
--   less than, equal to, or greater than zero if the range is found,
--   respectively, to be byte-wise lexicographically less than, to match,
--   or be greater than the second range.
compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#

-- | <tt>copyByteArray# src src_ofs dst dst_ofs n</tt> copies the range
--   starting at offset <tt>src_ofs</tt> of length <tt>n</tt> from the
--   <tt>ByteArray#</tt> <tt>src</tt> to the <tt>MutableByteArray#</tt>
--   <tt>dst</tt> starting at offset <tt>dst_ofs</tt>. Both arrays must
--   fully contain the specified ranges, but this is not checked. The two
--   arrays must not be the same array in different states, but this is not
--   checked either.
copyByteArray# :: () => ByteArray# -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Copy a range of the first MutableByteArray. Both arrays must fully
--   contain the specified ranges, but this is not checked. The regions are
--   allowed to overlap, although this is only possible when the same array
--   is provided as both the source and the destination.
copyMutableByteArray# :: () => MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Copy a range of the ByteArray. The ByteArray must fully contain the
--   specified ranges, but this is not checked. The Addr# must not point
--   into the ByteArray were pinned), but this is not checked either.
copyByteArrayToAddr# :: () => ByteArray# -> Int# -> Addr# -> Int# -> State# d -> State# d

-- | Copy a range of the MutableByteArray# to the memory range starting at
--   the Addr and the memory region at Addr# must fully contain the
--   specified ranges, but this is not checked. The Addr# must not point
--   into the MutableByteArray were pinned), but this is not checked
--   either.
copyMutableByteArrayToAddr# :: () => MutableByteArray# d -> Int# -> Addr# -> Int# -> State# d -> State# d

-- | Copy a memory range starting at the Addr# to the specified range in
--   the MutableByteArray and the ByteArray# must fully contain the
--   specified ranges, but this is not checked. The Addr# must not point
--   into the MutableByteArray were pinned), but this is not checked
--   either.
copyAddrToByteArray# :: () => Addr# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | <tt>setByteArray# ba off len c</tt> sets the byte range <tt>[off,
--   off+len]</tt> of the <tt>MutableByteArray#</tt> to the byte
--   <tt>c</tt>.
setByteArray# :: () => MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> State# d

-- | Given an array and an offset in Int units, read an element. The index
--   is assumed to be in bounds. Implies a full memory barrier.
atomicReadIntArray# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array and an offset in Int units, write an element. The index
--   is assumed to be in bounds. Implies a full memory barrier.
atomicWriteIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Given an array, an offset in Int units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
casIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in Int units, and a value to add,
--   atomically add the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
fetchAddIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in Int units, and a value to subtract,
--   atomically substract the value to the element. Returns the value of
--   the element before the operation. Implies a full memory barrier.
fetchSubIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in Int units, and a value to AND,
--   atomically AND the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
fetchAndIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in Int units, and a value to NAND,
--   atomically NAND the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
fetchNandIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in Int units, and a value to OR, atomically
--   OR the value to the element. Returns the value of the element before
--   the operation. Implies a full memory barrier.
fetchOrIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in Int units, and a value to XOR,
--   atomically XOR the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
fetchXorIntArray# :: () => MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Create a new mutable array of arrays with the specified number of
--   elements, in the specified state thread, with each element recursively
--   referring to the newly created array.
newArrayArray# :: () => Int# -> State# d -> (# State# d, MutableArrayArray# d #)
sameMutableArrayArray# :: () => MutableArrayArray# d -> MutableArrayArray# d -> Int#

-- | Make a mutable array of arrays immutable, without copying.
unsafeFreezeArrayArray# :: () => MutableArrayArray# d -> State# d -> (# State# d, ArrayArray# #)

-- | Return the number of elements in the array.
sizeofArrayArray# :: ArrayArray# -> Int#

-- | Return the number of elements in the array.
sizeofMutableArrayArray# :: () => MutableArrayArray# d -> Int#
indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
readByteArrayArray# :: () => MutableArrayArray# d -> Int# -> State# d -> (# State# d, ByteArray# #)
readMutableByteArrayArray# :: () => MutableArrayArray# d -> Int# -> State# d -> (# State# d, MutableByteArray# d #)
readArrayArrayArray# :: () => MutableArrayArray# d -> Int# -> State# d -> (# State# d, ArrayArray# #)
readMutableArrayArrayArray# :: () => MutableArrayArray# d -> Int# -> State# d -> (# State# d, MutableArrayArray# d #)
writeByteArrayArray# :: () => MutableArrayArray# d -> Int# -> ByteArray# -> State# d -> State# d
writeMutableByteArrayArray# :: () => MutableArrayArray# d -> Int# -> MutableByteArray# d -> State# d -> State# d
writeArrayArrayArray# :: () => MutableArrayArray# d -> Int# -> ArrayArray# -> State# d -> State# d
writeMutableArrayArrayArray# :: () => MutableArrayArray# d -> Int# -> MutableArrayArray# d -> State# d -> State# d

-- | Copy a range of the ArrayArray. Both arrays must fully contain the
--   specified ranges, but this is not checked. The two arrays must not be
--   the same array in different states, but this is not checked either.
copyArrayArray# :: () => ArrayArray# -> Int# -> MutableArrayArray# d -> Int# -> Int# -> State# d -> State# d

-- | Copy a range of the first MutableArrayArray# to the specified region
--   in the second MutableArrayArray#. Both arrays must fully contain the
--   specified ranges, but this is not checked. The regions are allowed to
--   overlap, although this is only possible when the same array is
--   provided as both the source and the destination.
copyMutableArrayArray# :: () => MutableArrayArray# d -> Int# -> MutableArrayArray# d -> Int# -> Int# -> State# d -> State# d
plusAddr# :: Addr# -> Int# -> Addr#

-- | Result is meaningless if two <tt>Addr#</tt>s are so far apart that
--   their difference doesn't fit in an <tt>Int#</tt>.
minusAddr# :: Addr# -> Addr# -> Int#

-- | Return the remainder when the <tt>Addr#</tt> arg, treated like an
--   <tt>Int#</tt>, is divided by the <tt>Int#</tt> arg.
remAddr# :: Addr# -> Int# -> Int#

-- | Coerce directly from address to int. Strongly deprecated.
addr2Int# :: Addr# -> Int#

-- | Coerce directly from int to address. Strongly deprecated.
int2Addr# :: Int# -> Addr#
gtAddr# :: Addr# -> Addr# -> Int#
geAddr# :: Addr# -> Addr# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
neAddr# :: Addr# -> Addr# -> Int#
ltAddr# :: Addr# -> Addr# -> Int#
leAddr# :: Addr# -> Addr# -> Int#

-- | Reads 8-bit character; offset in bytes.
indexCharOffAddr# :: Addr# -> Int# -> Char#

-- | Reads 31-bit character; offset in 4-byte words.
indexWideCharOffAddr# :: Addr# -> Int# -> Char#
indexIntOffAddr# :: Addr# -> Int# -> Int#
indexWordOffAddr# :: Addr# -> Int# -> Word#
indexAddrOffAddr# :: Addr# -> Int# -> Addr#
indexFloatOffAddr# :: Addr# -> Int# -> Float#
indexDoubleOffAddr# :: Addr# -> Int# -> Double#
indexStablePtrOffAddr# :: () => Addr# -> Int# -> StablePtr# a
indexInt8OffAddr# :: Addr# -> Int# -> Int#
indexInt16OffAddr# :: Addr# -> Int# -> Int#
indexInt32OffAddr# :: Addr# -> Int# -> Int#
indexInt64OffAddr# :: Addr# -> Int# -> Int#
indexWord8OffAddr# :: Addr# -> Int# -> Word#
indexWord16OffAddr# :: Addr# -> Int# -> Word#
indexWord32OffAddr# :: Addr# -> Int# -> Word#
indexWord64OffAddr# :: Addr# -> Int# -> Word#

-- | Reads 8-bit character; offset in bytes.
readCharOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | Reads 31-bit character; offset in 4-byte words.
readWideCharOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Char# #)
readIntOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int# #)
readWordOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word# #)
readAddrOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Addr# #)
readFloatOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Float# #)
readDoubleOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Double# #)
readStablePtrOffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, StablePtr# a #)
readInt8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int# #)
readInt16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int# #)
readInt32OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int# #)
readInt64OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int# #)
readWord8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word# #)
readWord16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word# #)
readWord32OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word# #)
readWord64OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word# #)
writeCharOffAddr# :: () => Addr# -> Int# -> Char# -> State# d -> State# d
writeWideCharOffAddr# :: () => Addr# -> Int# -> Char# -> State# d -> State# d
writeIntOffAddr# :: () => Addr# -> Int# -> Int# -> State# d -> State# d
writeWordOffAddr# :: () => Addr# -> Int# -> Word# -> State# d -> State# d
writeAddrOffAddr# :: () => Addr# -> Int# -> Addr# -> State# d -> State# d
writeFloatOffAddr# :: () => Addr# -> Int# -> Float# -> State# d -> State# d
writeDoubleOffAddr# :: () => Addr# -> Int# -> Double# -> State# d -> State# d
writeStablePtrOffAddr# :: () => Addr# -> Int# -> StablePtr# a -> State# d -> State# d
writeInt8OffAddr# :: () => Addr# -> Int# -> Int# -> State# d -> State# d
writeInt16OffAddr# :: () => Addr# -> Int# -> Int# -> State# d -> State# d
writeInt32OffAddr# :: () => Addr# -> Int# -> Int# -> State# d -> State# d
writeInt64OffAddr# :: () => Addr# -> Int# -> Int# -> State# d -> State# d
writeWord8OffAddr# :: () => Addr# -> Int# -> Word# -> State# d -> State# d
writeWord16OffAddr# :: () => Addr# -> Int# -> Word# -> State# d -> State# d
writeWord32OffAddr# :: () => Addr# -> Int# -> Word# -> State# d -> State# d
writeWord64OffAddr# :: () => Addr# -> Int# -> Word# -> State# d -> State# d

-- | Create <tt>MutVar#</tt> with specified initial value in specified
--   state thread.
newMutVar# :: () => a -> State# d -> (# State# d, MutVar# d a #)

-- | Read contents of <tt>MutVar#</tt>. Result is not yet evaluated.
readMutVar# :: () => MutVar# d a -> State# d -> (# State# d, a #)

-- | Write contents of <tt>MutVar#</tt>.
writeMutVar# :: () => MutVar# d a -> a -> State# d -> State# d
sameMutVar# :: () => MutVar# d a -> MutVar# d a -> Int#

-- | Modify the contents of a <tt>MutVar#</tt>. Note that this isn't
--   strictly speaking the correct type for this function, it should really
--   be <tt>MutVar s -&gt; ( s, b #)</tt>, however we don't know about
--   pairs here.
atomicModifyMutVar# :: () => MutVar# d a -> (a -> b) -> State# d -> (# State# d, c #)
casMutVar# :: () => MutVar# d a -> a -> a -> State# d -> (# State# d, Int#, a #)
catch# :: () => (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
raise# :: () => b -> a
raiseIO# :: () => a -> State# RealWorld -> (# State# RealWorld, b #)
maskAsyncExceptions# :: () => (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
maskUninterruptible# :: () => (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
unmaskAsyncExceptions# :: () => (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)
atomically# :: () => (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
retry# :: () => State# RealWorld -> (# State# RealWorld, a #)
catchRetry# :: () => (State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
catchSTM# :: () => (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | Create a new <tt>TVar#</tt> holding a specified initial value.
newTVar# :: () => a -> State# d -> (# State# d, TVar# d a #)

-- | Read contents of <tt>TVar#</tt>. Result is not yet evaluated.
readTVar# :: () => TVar# d a -> State# d -> (# State# d, a #)

-- | Read contents of <tt>TVar#</tt> outside an STM transaction
readTVarIO# :: () => TVar# d a -> State# d -> (# State# d, a #)

-- | Write contents of <tt>TVar#</tt>.
writeTVar# :: () => TVar# d a -> a -> State# d -> State# d
sameTVar# :: () => TVar# d a -> TVar# d a -> Int#

-- | Create new <tt>MVar#</tt>; initially empty.
newMVar# :: () => State# d -> (# State# d, MVar# d a #)

-- | If <tt>MVar#</tt> is empty, block until it becomes full. Then remove
--   and return its contents, and set it empty.
takeMVar# :: () => MVar# d a -> State# d -> (# State# d, a #)

-- | If <tt>MVar#</tt> is empty, immediately return with integer 0 and
--   value undefined. Otherwise, return with integer 1 and contents of
--   <tt>MVar#</tt>, and set <tt>MVar#</tt> empty.
tryTakeMVar# :: () => MVar# d a -> State# d -> (# State# d, Int#, a #)

-- | If <tt>MVar#</tt> is full, block until it becomes empty. Then store
--   value arg as its new contents.
putMVar# :: () => MVar# d a -> a -> State# d -> State# d

-- | If <tt>MVar#</tt> is full, immediately return with integer 0.
--   Otherwise, store value arg as <tt>MVar#</tt>'s new contents, and
--   return with integer 1.
tryPutMVar# :: () => MVar# d a -> a -> State# d -> (# State# d, Int# #)

-- | If <tt>MVar#</tt> is empty, block until it becomes full. Then read its
--   contents without modifying the MVar, without possibility of
--   intervention from other threads.
readMVar# :: () => MVar# d a -> State# d -> (# State# d, a #)

-- | If <tt>MVar#</tt> is empty, immediately return with integer 0 and
--   value undefined. Otherwise, return with integer 1 and contents of
--   <tt>MVar#</tt>.
tryReadMVar# :: () => MVar# d a -> State# d -> (# State# d, Int#, a #)
sameMVar# :: () => MVar# d a -> MVar# d a -> Int#

-- | Return 1 if <tt>MVar#</tt> is empty; 0 otherwise.
isEmptyMVar# :: () => MVar# d a -> State# d -> (# State# d, Int# #)

-- | Sleep specified number of microseconds.
delay# :: () => Int# -> State# d -> State# d

-- | Block until input is available on specified file descriptor.
waitRead# :: () => Int# -> State# d -> State# d

-- | Block until output is possible on specified file descriptor.
waitWrite# :: () => Int# -> State# d -> State# d
fork# :: () => a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
forkOn# :: () => Int# -> a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
killThread# :: () => ThreadId# -> a -> State# RealWorld -> State# RealWorld
yield# :: State# RealWorld -> State# RealWorld
myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
labelThread# :: ThreadId# -> Addr# -> State# RealWorld -> State# RealWorld
isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)
noDuplicate# :: () => State# d -> State# d
threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)

-- | <tt>mkWeak# k v finalizer s</tt> creates a weak reference to value
--   <tt>k</tt>, with an associated reference to some value <tt>v</tt>. If
--   <tt>k</tt> is still alive then <tt>v</tt> can be retrieved using
--   <tt>deRefWeak#</tt>. Note that the type of <tt>k</tt> must be
--   represented by a pointer (i.e. of kind <tt>TYPE 'LiftedRep</tt> or
--   <tt>TYPE 'UnliftedRep</tt>).
mkWeak# :: () => a -> b -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)
mkWeakNoFinalizer# :: () => a -> b -> State# RealWorld -> (# State# RealWorld, Weak# b #)

-- | <tt>addCFinalizerToWeak# fptr ptr flag eptr w</tt> attaches a C
--   function pointer <tt>fptr</tt> to a weak pointer <tt>w</tt> as a
--   finalizer. If <tt>flag</tt> is zero, <tt>fptr</tt> will be called with
--   one argument, <tt>ptr</tt>. Otherwise, it will be called with two
--   arguments, <tt>eptr</tt> and <tt>ptr</tt>.
--   <tt>addCFinalizerToWeak#</tt> returns 1 on success, or 0 if <tt>w</tt>
--   is already dead.
addCFinalizerToWeak# :: () => Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)
deRefWeak# :: () => Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)

-- | Finalize a weak pointer. The return value is an unboxed tuple
--   containing the new state of the world and an "unboxed Maybe",
--   represented by an <tt>Int#</tt> and a (possibly invalid) finalization
--   action. An <tt>Int#</tt> of <tt>1</tt> indicates that the finalizer is
--   valid. The return value <tt>b</tt> from the finalizer should be
--   ignored.
finalizeWeak# :: () => Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
touch# :: () => a -> State# RealWorld -> State# RealWorld
makeStablePtr# :: () => a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)
deRefStablePtr# :: () => StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
eqStablePtr# :: () => StablePtr# a -> StablePtr# a -> Int#
makeStableName# :: () => a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
eqStableName# :: () => StableName# a -> StableName# b -> Int#
stableNameToInt# :: () => StableName# a -> Int#

-- | Create a new Compact with the given size (in bytes, not words). The
--   size is rounded up to a multiple of the allocator block size, and
--   capped to one mega block.
compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)

-- | Set the new allocation size of the compact. This value (in bytes)
--   determines the size of each block in the compact chain.
compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld

-- | Returns 1 otherwise.
compactContains# :: () => Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Returns 1 otherwise.
compactContainsAny# :: () => a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Returns the address and the size (in bytes) of the first block of a
--   compact.
compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Given a compact and the address of one its blocks, returns the next
--   block and its size, or #nullAddr if the argument was the last block in
--   the compact.
compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Attempt to allocate a compact block with the given size (in bytes) at
--   the given address. The first argument is a hint to the allocator,
--   allocation might be satisfied at a different address (which is
--   returned). The resulting block is not known to the GC until
--   compactFixupPointers# is called on it, and care must be taken so that
--   the address does not escape or memory will be leaked.
compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)

-- | Given the pointer to the first block of a compact, and the address of
--   the root object in the old address space, fix up the internal pointers
--   inside the compact to account for a different position in memory than
--   when it was serialized. This method must be called exactly once after
--   importing a serialized compact, and returns the new compact and the
--   new adjusted root address.
compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)

-- | Recursively add a closure and its transitive closure to a {texttt
--   Compact#}, evaluating any unevaluated components at the same time.
--   Note: {texttt compactAdd#} is not thread-safe, so only one thread may
--   call {texttt compactAdd#} with a particular {texttt Compact#} at any
--   given time. The primop does not enforce any mutual exclusion; the
--   caller is expected to arrange this.
compactAdd# :: () => Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Like {texttt compactAdd#}, but retains sharing and cycles during
--   compaction.
compactAddWithSharing# :: () => Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Return the size (in bytes) of the total amount of data in the Compact#
compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)

-- | Returns {texttt 1#} if the given pointers are equal and {texttt 0#}
--   otherwise.
reallyUnsafePtrEquality# :: () => a -> a -> Int#
par# :: () => a -> Int#
spark# :: () => a -> State# d -> (# State# d, a #)
seq# :: () => a -> State# d -> (# State# d, a #)
getSpark# :: () => State# d -> (# State# d, Int#, a #)

-- | Returns the number of sparks in the local spark pool.
numSparks# :: () => State# d -> (# State# d, Int# #)
dataToTag# :: () => a -> Int#
tagToEnum# :: () => Int# -> a

-- | Convert an <tt>Addr#</tt> to a followable Any type.
addrToAny# :: () => Addr# -> (# a #)

-- | Retrieve the address of any Haskell value. This is essentially an
--   {texttt unsafeCoerce#}, but if implemented as such the core lint pass
--   complains and fails to compile. As a primop, it is opaque to core/stg,
--   and only appears in cmm (where the copy propagation pass will get rid
--   of it). Note that "a" must be a value, not a thunk! It's too late for
--   strictness analysis to enforce this, so you're on your own to
--   guarantee this. Also note that {texttt Addr#} is not a GC pointer - up
--   to you to guarantee that it does not become a dangling pointer
--   immediately after you get it.
anyToAddr# :: () => a -> State# RealWorld -> (# State# RealWorld, Addr# #)

-- | Wrap a BCO in a <tt>AP_UPD</tt> thunk which will be updated with the
--   value of the BCO when evaluated.
mkApUpd0# :: () => BCO# -> (# a #)

-- | <tt>newBCO# instrs lits ptrs arity bitmap</tt> creates a new bytecode
--   object. The resulting object encodes a function of the given arity
--   with the instructions encoded in <tt>instrs</tt>, and a static
--   reference table usage bitmap given by <tt>bitmap</tt>.
newBCO# :: () => ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# d -> (# State# d, BCO# #)

-- | <tt>unpackClosure# closure</tt> copies the closure and pointers in the
--   payload of the given closure into two new arrays, and returns a
--   pointer to the first word of the closure's info table, a non-pointer
--   array for the raw bytes of the closure, and a pointer array for the
--   pointers in the payload.
unpackClosure# :: () => a -> (# Addr#, ByteArray#, Array# b #)
getApStackVal# :: () => a -> Int# -> (# Int#, b #)
getCCSOf# :: () => a -> State# d -> (# State# d, Addr# #)

-- | Returns the current <tt>CostCentreStack</tt> (value is <tt>NULL</tt>
--   if not profiling). Takes a dummy argument which can be used to avoid
--   the call to <tt>getCurrentCCS#</tt> being floated out by the
--   simplifier, which would result in an uninformative stack ("CAF").
getCurrentCCS# :: () => a -> State# d -> (# State# d, Addr# #)

-- | Run the supplied IO action with an empty CCS. For example, this is
--   used by the interpreter to run an interpreted computation without the
--   call stack showing that it was invoked from GHC.
clearCCS# :: () => (State# d -> (# State# d, a #)) -> State# d -> (# State# d, a #)

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the zero-terminated byte string passed as the first argument.
--   The event will be emitted either to the .eventlog file, or to stderr,
--   depending on the runtime RTS flags.
traceEvent# :: () => Addr# -> State# d -> State# d

-- | Emits a marker event via the RTS tracing framework. The contents of
--   the event is the zero-terminated byte string passed as the first
--   argument. The event will be emitted either to the .eventlog file, or
--   to stderr, depending on the runtime RTS flags.
traceMarker# :: () => Addr# -> State# d -> State# d

-- | Retrieves the allocation counter for the current thread.
getThreadAllocationCounter# :: State# RealWorld -> (# State# RealWorld, Int# #)

-- | Sets the allocation counter for the current thread to the given value.
setThreadAllocationCounter# :: Int# -> State# RealWorld -> State# RealWorld

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X16# :: Int# -> Int8X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X8# :: Int# -> Int16X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X4# :: Int# -> Int32X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X2# :: Int# -> Int64X2#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X32# :: Int# -> Int8X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X16# :: Int# -> Int16X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X8# :: Int# -> Int32X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X4# :: Int# -> Int64X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt8X64# :: Int# -> Int8X64#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt16X32# :: Int# -> Int16X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt32X16# :: Int# -> Int32X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastInt64X8# :: Int# -> Int64X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X16# :: Word# -> Word8X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X8# :: Word# -> Word16X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X4# :: Word# -> Word32X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X2# :: Word# -> Word64X2#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X32# :: Word# -> Word8X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X16# :: Word# -> Word16X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X8# :: Word# -> Word32X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X4# :: Word# -> Word64X4#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord8X64# :: Word# -> Word8X64#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord16X32# :: Word# -> Word16X32#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord32X16# :: Word# -> Word32X16#

-- | Broadcast a scalar to all elements of a vector.
broadcastWord64X8# :: Word# -> Word64X8#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX4# :: Float# -> FloatX4#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX2# :: Double# -> DoubleX2#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX8# :: Float# -> FloatX8#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX4# :: Double# -> DoubleX4#

-- | Broadcast a scalar to all elements of a vector.
broadcastFloatX16# :: Float# -> FloatX16#

-- | Broadcast a scalar to all elements of a vector.
broadcastDoubleX8# :: Double# -> DoubleX8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X4# :: (# Int#, Int#, Int#, Int# #) -> Int32X4#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X2# :: (# Int#, Int# #) -> Int64X2#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X32# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X32#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X8#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X4# :: (# Int#, Int#, Int#, Int# #) -> Int64X4#

-- | Pack the elements of an unboxed tuple into a vector.
packInt8X64# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X64#

-- | Pack the elements of an unboxed tuple into a vector.
packInt16X32# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X32#

-- | Pack the elements of an unboxed tuple into a vector.
packInt32X16# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X16#

-- | Pack the elements of an unboxed tuple into a vector.
packInt64X8# :: (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int64X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X4# :: (# Word#, Word#, Word#, Word# #) -> Word32X4#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X2# :: (# Word#, Word# #) -> Word64X2#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X32# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X32#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word32X8#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X4# :: (# Word#, Word#, Word#, Word# #) -> Word64X4#

-- | Pack the elements of an unboxed tuple into a vector.
packWord8X64# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X64#

-- | Pack the elements of an unboxed tuple into a vector.
packWord16X32# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X32#

-- | Pack the elements of an unboxed tuple into a vector.
packWord32X16# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word32X16#

-- | Pack the elements of an unboxed tuple into a vector.
packWord64X8# :: (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word64X8#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX4# :: (# Float#, Float#, Float#, Float# #) -> FloatX4#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX2# :: (# Double#, Double# #) -> DoubleX2#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX8# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX4# :: (# Double#, Double#, Double#, Double# #) -> DoubleX4#

-- | Pack the elements of an unboxed tuple into a vector.
packFloatX16# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#

-- | Pack the elements of an unboxed tuple into a vector.
packDoubleX8# :: (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X16# :: Int8X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X8# :: Int16X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X4# :: Int32X4# -> (# Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X2# :: Int64X2# -> (# Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X32# :: Int8X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X16# :: Int16X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X8# :: Int32X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X4# :: Int64X4# -> (# Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt8X64# :: Int8X64# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt16X32# :: Int16X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt32X16# :: Int32X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackInt64X8# :: Int64X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X16# :: Word8X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X8# :: Word16X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X4# :: Word32X4# -> (# Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X2# :: Word64X2# -> (# Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X32# :: Word8X32# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X16# :: Word16X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X8# :: Word32X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X4# :: Word64X4# -> (# Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord8X64# :: Word8X64# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord16X32# :: Word16X32# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord32X16# :: Word32X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackWord64X8# :: Word64X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX4# :: FloatX4# -> (# Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX2# :: DoubleX2# -> (# Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX8# :: FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX4# :: DoubleX4# -> (# Double#, Double#, Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackFloatX16# :: FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
unpackDoubleX8# :: DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)

-- | Insert a scalar at the given position in a vector.
insertInt8X16# :: Int8X16# -> Int# -> Int# -> Int8X16#

-- | Insert a scalar at the given position in a vector.
insertInt16X8# :: Int16X8# -> Int# -> Int# -> Int16X8#

-- | Insert a scalar at the given position in a vector.
insertInt32X4# :: Int32X4# -> Int# -> Int# -> Int32X4#

-- | Insert a scalar at the given position in a vector.
insertInt64X2# :: Int64X2# -> Int# -> Int# -> Int64X2#

-- | Insert a scalar at the given position in a vector.
insertInt8X32# :: Int8X32# -> Int# -> Int# -> Int8X32#

-- | Insert a scalar at the given position in a vector.
insertInt16X16# :: Int16X16# -> Int# -> Int# -> Int16X16#

-- | Insert a scalar at the given position in a vector.
insertInt32X8# :: Int32X8# -> Int# -> Int# -> Int32X8#

-- | Insert a scalar at the given position in a vector.
insertInt64X4# :: Int64X4# -> Int# -> Int# -> Int64X4#

-- | Insert a scalar at the given position in a vector.
insertInt8X64# :: Int8X64# -> Int# -> Int# -> Int8X64#

-- | Insert a scalar at the given position in a vector.
insertInt16X32# :: Int16X32# -> Int# -> Int# -> Int16X32#

-- | Insert a scalar at the given position in a vector.
insertInt32X16# :: Int32X16# -> Int# -> Int# -> Int32X16#

-- | Insert a scalar at the given position in a vector.
insertInt64X8# :: Int64X8# -> Int# -> Int# -> Int64X8#

-- | Insert a scalar at the given position in a vector.
insertWord8X16# :: Word8X16# -> Word# -> Int# -> Word8X16#

-- | Insert a scalar at the given position in a vector.
insertWord16X8# :: Word16X8# -> Word# -> Int# -> Word16X8#

-- | Insert a scalar at the given position in a vector.
insertWord32X4# :: Word32X4# -> Word# -> Int# -> Word32X4#

-- | Insert a scalar at the given position in a vector.
insertWord64X2# :: Word64X2# -> Word# -> Int# -> Word64X2#

-- | Insert a scalar at the given position in a vector.
insertWord8X32# :: Word8X32# -> Word# -> Int# -> Word8X32#

-- | Insert a scalar at the given position in a vector.
insertWord16X16# :: Word16X16# -> Word# -> Int# -> Word16X16#

-- | Insert a scalar at the given position in a vector.
insertWord32X8# :: Word32X8# -> Word# -> Int# -> Word32X8#

-- | Insert a scalar at the given position in a vector.
insertWord64X4# :: Word64X4# -> Word# -> Int# -> Word64X4#

-- | Insert a scalar at the given position in a vector.
insertWord8X64# :: Word8X64# -> Word# -> Int# -> Word8X64#

-- | Insert a scalar at the given position in a vector.
insertWord16X32# :: Word16X32# -> Word# -> Int# -> Word16X32#

-- | Insert a scalar at the given position in a vector.
insertWord32X16# :: Word32X16# -> Word# -> Int# -> Word32X16#

-- | Insert a scalar at the given position in a vector.
insertWord64X8# :: Word64X8# -> Word# -> Int# -> Word64X8#

-- | Insert a scalar at the given position in a vector.
insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#

-- | Insert a scalar at the given position in a vector.
insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#

-- | Insert a scalar at the given position in a vector.
insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#

-- | Insert a scalar at the given position in a vector.
insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#

-- | Insert a scalar at the given position in a vector.
insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#

-- | Insert a scalar at the given position in a vector.
insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#

-- | Add two vectors element-wise.
plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Add two vectors element-wise.
plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Add two vectors element-wise.
plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Add two vectors element-wise.
plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Add two vectors element-wise.
plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Add two vectors element-wise.
plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Add two vectors element-wise.
plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Add two vectors element-wise.
plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Add two vectors element-wise.
plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Add two vectors element-wise.
plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Add two vectors element-wise.
plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Add two vectors element-wise.
plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Add two vectors element-wise.
plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Add two vectors element-wise.
plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Add two vectors element-wise.
plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Add two vectors element-wise.
plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Add two vectors element-wise.
plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Add two vectors element-wise.
plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Add two vectors element-wise.
plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Add two vectors element-wise.
plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Add two vectors element-wise.
plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Add two vectors element-wise.
plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Add two vectors element-wise.
plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Add two vectors element-wise.
plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Add two vectors element-wise.
plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Add two vectors element-wise.
plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Add two vectors element-wise.
plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Add two vectors element-wise.
plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Add two vectors element-wise.
plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Add two vectors element-wise.
plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Subtract two vectors element-wise.
minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Subtract two vectors element-wise.
minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Subtract two vectors element-wise.
minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Subtract two vectors element-wise.
minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Subtract two vectors element-wise.
minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Subtract two vectors element-wise.
minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Subtract two vectors element-wise.
minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Subtract two vectors element-wise.
minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Subtract two vectors element-wise.
minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Subtract two vectors element-wise.
minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Subtract two vectors element-wise.
minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Subtract two vectors element-wise.
minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Subtract two vectors element-wise.
minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Subtract two vectors element-wise.
minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Subtract two vectors element-wise.
minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Subtract two vectors element-wise.
minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Subtract two vectors element-wise.
minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Subtract two vectors element-wise.
minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Subtract two vectors element-wise.
minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Subtract two vectors element-wise.
minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Subtract two vectors element-wise.
minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Subtract two vectors element-wise.
minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Subtract two vectors element-wise.
minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Subtract two vectors element-wise.
minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Subtract two vectors element-wise.
minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Subtract two vectors element-wise.
minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Subtract two vectors element-wise.
minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Subtract two vectors element-wise.
minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Subtract two vectors element-wise.
minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Subtract two vectors element-wise.
minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Multiply two vectors element-wise.
timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Multiply two vectors element-wise.
timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Multiply two vectors element-wise.
timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Multiply two vectors element-wise.
timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Multiply two vectors element-wise.
timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Multiply two vectors element-wise.
timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Multiply two vectors element-wise.
timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Multiply two vectors element-wise.
timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Multiply two vectors element-wise.
timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Multiply two vectors element-wise.
timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Multiply two vectors element-wise.
timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Multiply two vectors element-wise.
timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Multiply two vectors element-wise.
timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Multiply two vectors element-wise.
timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Multiply two vectors element-wise.
timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Multiply two vectors element-wise.
timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Multiply two vectors element-wise.
timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Multiply two vectors element-wise.
timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Multiply two vectors element-wise.
timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Multiply two vectors element-wise.
timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Multiply two vectors element-wise.
timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Multiply two vectors element-wise.
timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Multiply two vectors element-wise.
timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Multiply two vectors element-wise.
timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Multiply two vectors element-wise.
timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Multiply two vectors element-wise.
timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Multiply two vectors element-wise.
timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Multiply two vectors element-wise.
timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Multiply two vectors element-wise.
timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Multiply two vectors element-wise.
timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Divide two vectors element-wise.
divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Divide two vectors element-wise.
divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Divide two vectors element-wise.
divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Divide two vectors element-wise.
divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Divide two vectors element-wise.
divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Divide two vectors element-wise.
divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Rounds towards zero element-wise.
quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Rounds towards zero element-wise.
quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Rounds towards zero element-wise.
quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Rounds towards zero element-wise.
quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Rounds towards zero element-wise.
quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Rounds towards zero element-wise.
quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Rounds towards zero element-wise.
quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Rounds towards zero element-wise.
quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Rounds towards zero element-wise.
quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Rounds towards zero element-wise.
quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Rounds towards zero element-wise.
quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Rounds towards zero element-wise.
quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Rounds towards zero element-wise.
quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Rounds towards zero element-wise.
quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Rounds towards zero element-wise.
quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Rounds towards zero element-wise.
quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Rounds towards zero element-wise.
quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Rounds towards zero element-wise.
quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Rounds towards zero element-wise.
quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Rounds towards zero element-wise.
quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Rounds towards zero element-wise.
quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Rounds towards zero element-wise.
quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Rounds towards zero element-wise.
quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Rounds towards zero element-wise.
quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Satisfies <tt>(quot# x y) times# y plus# (rem# x y) == x</tt>.
remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Negate element-wise.
negateInt8X16# :: Int8X16# -> Int8X16#

-- | Negate element-wise.
negateInt16X8# :: Int16X8# -> Int16X8#

-- | Negate element-wise.
negateInt32X4# :: Int32X4# -> Int32X4#

-- | Negate element-wise.
negateInt64X2# :: Int64X2# -> Int64X2#

-- | Negate element-wise.
negateInt8X32# :: Int8X32# -> Int8X32#

-- | Negate element-wise.
negateInt16X16# :: Int16X16# -> Int16X16#

-- | Negate element-wise.
negateInt32X8# :: Int32X8# -> Int32X8#

-- | Negate element-wise.
negateInt64X4# :: Int64X4# -> Int64X4#

-- | Negate element-wise.
negateInt8X64# :: Int8X64# -> Int8X64#

-- | Negate element-wise.
negateInt16X32# :: Int16X32# -> Int16X32#

-- | Negate element-wise.
negateInt32X16# :: Int32X16# -> Int32X16#

-- | Negate element-wise.
negateInt64X8# :: Int64X8# -> Int64X8#

-- | Negate element-wise.
negateFloatX4# :: FloatX4# -> FloatX4#

-- | Negate element-wise.
negateDoubleX2# :: DoubleX2# -> DoubleX2#

-- | Negate element-wise.
negateFloatX8# :: FloatX8# -> FloatX8#

-- | Negate element-wise.
negateDoubleX4# :: DoubleX4# -> DoubleX4#

-- | Negate element-wise.
negateFloatX16# :: FloatX16# -> FloatX16#

-- | Negate element-wise.
negateDoubleX8# :: DoubleX8# -> DoubleX8#

-- | Read a vector from specified index of immutable array.
indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array.
indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array.
indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array.
indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array.
indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array.
indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array.
indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array.
indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array.
indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array.
indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array.
indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array.
indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array.
indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array.
indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array.
indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array.
indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array.
indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array.
indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array.
indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array.
indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array.
indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array.
indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array.
indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array.
indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array.
indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array.
indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array.
indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array.
indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array.
indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array.
indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a vector from specified index of mutable array.
readInt8X16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Read a vector from specified index of mutable array.
readInt16X8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Read a vector from specified index of mutable array.
readInt32X4Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Read a vector from specified index of mutable array.
readInt64X2Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Read a vector from specified index of mutable array.
readInt8X32Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Read a vector from specified index of mutable array.
readInt16X16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Read a vector from specified index of mutable array.
readInt32X8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Read a vector from specified index of mutable array.
readInt64X4Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Read a vector from specified index of mutable array.
readInt8X64Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Read a vector from specified index of mutable array.
readInt16X32Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Read a vector from specified index of mutable array.
readInt32X16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Read a vector from specified index of mutable array.
readInt64X8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Read a vector from specified index of mutable array.
readWord8X16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Read a vector from specified index of mutable array.
readWord16X8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Read a vector from specified index of mutable array.
readWord32X4Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Read a vector from specified index of mutable array.
readWord64X2Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Read a vector from specified index of mutable array.
readWord8X32Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Read a vector from specified index of mutable array.
readWord16X16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Read a vector from specified index of mutable array.
readWord32X8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Read a vector from specified index of mutable array.
readWord64X4Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Read a vector from specified index of mutable array.
readWord8X64Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Read a vector from specified index of mutable array.
readWord16X32Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Read a vector from specified index of mutable array.
readWord32X16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Read a vector from specified index of mutable array.
readWord64X8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Read a vector from specified index of mutable array.
readFloatX4Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Read a vector from specified index of mutable array.
readDoubleX2Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Read a vector from specified index of mutable array.
readFloatX8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Read a vector from specified index of mutable array.
readDoubleX4Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Read a vector from specified index of mutable array.
readFloatX16Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Read a vector from specified index of mutable array.
readDoubleX8Array# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Write a vector to specified index of mutable array.
writeInt8X16Array# :: () => MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeInt16X8Array# :: () => MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeInt32X4Array# :: () => MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeInt64X2Array# :: () => MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeInt8X32Array# :: () => MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeInt16X16Array# :: () => MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeInt32X8Array# :: () => MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeInt64X4Array# :: () => MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeInt8X64Array# :: () => MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeInt16X32Array# :: () => MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeInt32X16Array# :: () => MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeInt64X8Array# :: () => MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeWord8X16Array# :: () => MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeWord16X8Array# :: () => MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeWord32X4Array# :: () => MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeWord64X2Array# :: () => MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeWord8X32Array# :: () => MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeWord16X16Array# :: () => MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeWord32X8Array# :: () => MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeWord64X4Array# :: () => MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeWord8X64Array# :: () => MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeWord16X32Array# :: () => MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeWord32X16Array# :: () => MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeWord64X8Array# :: () => MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeFloatX4Array# :: () => MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeDoubleX2Array# :: () => MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeFloatX8Array# :: () => MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeDoubleX4Array# :: () => MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeFloatX16Array# :: () => MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
writeDoubleX8Array# :: () => MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d

-- | Reads vector; offset in bytes.
indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#

-- | Reads vector; offset in bytes.
indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#

-- | Reads vector; offset in bytes.
indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in bytes.
indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in bytes.
indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in bytes.
indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in bytes.
indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#

-- | Reads vector; offset in bytes.
indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in bytes.
indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#

-- | Reads vector; offset in bytes.
indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in bytes.
indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in bytes.
indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#

-- | Reads vector; offset in bytes.
indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in bytes.
indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#

-- | Reads vector; offset in bytes.
indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in bytes.
indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in bytes.
indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in bytes.
indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in bytes.
indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#

-- | Reads vector; offset in bytes.
indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in bytes.
indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#

-- | Reads vector; offset in bytes.
indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in bytes.
indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in bytes.
indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#

-- | Reads vector; offset in bytes.
indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in bytes.
indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in bytes.
indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#

-- | Reads vector; offset in bytes.
indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in bytes.
indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in bytes.
indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#

-- | Reads vector; offset in bytes.
readInt8X16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Reads vector; offset in bytes.
readInt16X8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Reads vector; offset in bytes.
readInt32X4OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Reads vector; offset in bytes.
readInt64X2OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Reads vector; offset in bytes.
readInt8X32OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Reads vector; offset in bytes.
readInt16X16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Reads vector; offset in bytes.
readInt32X8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Reads vector; offset in bytes.
readInt64X4OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Reads vector; offset in bytes.
readInt8X64OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Reads vector; offset in bytes.
readInt16X32OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Reads vector; offset in bytes.
readInt32X16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Reads vector; offset in bytes.
readInt64X8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Reads vector; offset in bytes.
readWord8X16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Reads vector; offset in bytes.
readWord16X8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Reads vector; offset in bytes.
readWord32X4OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Reads vector; offset in bytes.
readWord64X2OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Reads vector; offset in bytes.
readWord8X32OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Reads vector; offset in bytes.
readWord16X16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Reads vector; offset in bytes.
readWord32X8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Reads vector; offset in bytes.
readWord64X4OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Reads vector; offset in bytes.
readWord8X64OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Reads vector; offset in bytes.
readWord16X32OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Reads vector; offset in bytes.
readWord32X16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Reads vector; offset in bytes.
readWord64X8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Reads vector; offset in bytes.
readFloatX4OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Reads vector; offset in bytes.
readDoubleX2OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Reads vector; offset in bytes.
readFloatX8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Reads vector; offset in bytes.
readDoubleX4OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Reads vector; offset in bytes.
readFloatX16OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Reads vector; offset in bytes.
readDoubleX8OffAddr# :: () => Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Write vector; offset in bytes.
writeInt8X16OffAddr# :: () => Addr# -> Int# -> Int8X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeInt16X8OffAddr# :: () => Addr# -> Int# -> Int16X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeInt32X4OffAddr# :: () => Addr# -> Int# -> Int32X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeInt64X2OffAddr# :: () => Addr# -> Int# -> Int64X2# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeInt8X32OffAddr# :: () => Addr# -> Int# -> Int8X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeInt16X16OffAddr# :: () => Addr# -> Int# -> Int16X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeInt32X8OffAddr# :: () => Addr# -> Int# -> Int32X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeInt64X4OffAddr# :: () => Addr# -> Int# -> Int64X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeInt8X64OffAddr# :: () => Addr# -> Int# -> Int8X64# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeInt16X32OffAddr# :: () => Addr# -> Int# -> Int16X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeInt32X16OffAddr# :: () => Addr# -> Int# -> Int32X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeInt64X8OffAddr# :: () => Addr# -> Int# -> Int64X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeWord8X16OffAddr# :: () => Addr# -> Int# -> Word8X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeWord16X8OffAddr# :: () => Addr# -> Int# -> Word16X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeWord32X4OffAddr# :: () => Addr# -> Int# -> Word32X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeWord64X2OffAddr# :: () => Addr# -> Int# -> Word64X2# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeWord8X32OffAddr# :: () => Addr# -> Int# -> Word8X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeWord16X16OffAddr# :: () => Addr# -> Int# -> Word16X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeWord32X8OffAddr# :: () => Addr# -> Int# -> Word32X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeWord64X4OffAddr# :: () => Addr# -> Int# -> Word64X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeWord8X64OffAddr# :: () => Addr# -> Int# -> Word8X64# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeWord16X32OffAddr# :: () => Addr# -> Int# -> Word16X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeWord32X16OffAddr# :: () => Addr# -> Int# -> Word32X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeWord64X8OffAddr# :: () => Addr# -> Int# -> Word64X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeFloatX4OffAddr# :: () => Addr# -> Int# -> FloatX4# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeDoubleX2OffAddr# :: () => Addr# -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeFloatX8OffAddr# :: () => Addr# -> Int# -> FloatX8# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeDoubleX4OffAddr# :: () => Addr# -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeFloatX16OffAddr# :: () => Addr# -> Int# -> FloatX16# -> State# d -> State# d

-- | Write vector; offset in bytes.
writeDoubleX8OffAddr# :: () => Addr# -> Int# -> DoubleX8# -> State# d -> State# d

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt8ArrayAsInt8X16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt16ArrayAsInt16X8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt32ArrayAsInt32X4# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt64ArrayAsInt64X2# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt8ArrayAsInt8X32# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt16ArrayAsInt16X16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt32ArrayAsInt32X8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt64ArrayAsInt64X4# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt8ArrayAsInt8X64# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt16ArrayAsInt16X32# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt32ArrayAsInt32X16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readInt64ArrayAsInt64X8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord8ArrayAsWord8X16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord16ArrayAsWord16X8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord32ArrayAsWord32X4# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord64ArrayAsWord64X2# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord8ArrayAsWord8X32# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord16ArrayAsWord16X16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord32ArrayAsWord32X8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord64ArrayAsWord64X4# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord8ArrayAsWord8X64# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord16ArrayAsWord16X32# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord32ArrayAsWord32X16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readWord64ArrayAsWord64X8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readFloatArrayAsFloatX4# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readDoubleArrayAsDoubleX2# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readFloatArrayAsFloatX8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readDoubleArrayAsDoubleX4# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readFloatArrayAsFloatX16# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
readDoubleArrayAsDoubleX8# :: () => MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt8ArrayAsInt8X16# :: () => MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt16ArrayAsInt16X8# :: () => MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt32ArrayAsInt32X4# :: () => MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt64ArrayAsInt64X2# :: () => MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt8ArrayAsInt8X32# :: () => MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt16ArrayAsInt16X16# :: () => MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt32ArrayAsInt32X8# :: () => MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt64ArrayAsInt64X4# :: () => MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt8ArrayAsInt8X64# :: () => MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt16ArrayAsInt16X32# :: () => MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt32ArrayAsInt32X16# :: () => MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeInt64ArrayAsInt64X8# :: () => MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord8ArrayAsWord8X16# :: () => MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord16ArrayAsWord16X8# :: () => MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord32ArrayAsWord32X4# :: () => MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord64ArrayAsWord64X2# :: () => MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord8ArrayAsWord8X32# :: () => MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord16ArrayAsWord16X16# :: () => MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord32ArrayAsWord32X8# :: () => MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord64ArrayAsWord64X4# :: () => MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord8ArrayAsWord8X64# :: () => MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord16ArrayAsWord16X32# :: () => MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord32ArrayAsWord32X16# :: () => MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeWord64ArrayAsWord64X8# :: () => MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeFloatArrayAsFloatX4# :: () => MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeDoubleArrayAsDoubleX2# :: () => MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeFloatArrayAsFloatX8# :: () => MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeDoubleArrayAsDoubleX4# :: () => MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeFloatArrayAsFloatX16# :: () => MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
writeDoubleArrayAsDoubleX8# :: () => MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in scalar elements.
indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#

-- | Reads vector; offset in scalar elements.
indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in scalar elements.
indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in scalar elements.
indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in scalar elements.
indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#

-- | Reads vector; offset in scalar elements.
indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in scalar elements.
indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in scalar elements.
indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in scalar elements.
indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in scalar elements.
indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#

-- | Reads vector; offset in scalar elements.
readInt8OffAddrAsInt8X16# :: () => Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Reads vector; offset in scalar elements.
readInt16OffAddrAsInt16X8# :: () => Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Reads vector; offset in scalar elements.
readInt32OffAddrAsInt32X4# :: () => Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Reads vector; offset in scalar elements.
readInt64OffAddrAsInt64X2# :: () => Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Reads vector; offset in scalar elements.
readInt8OffAddrAsInt8X32# :: () => Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Reads vector; offset in scalar elements.
readInt16OffAddrAsInt16X16# :: () => Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Reads vector; offset in scalar elements.
readInt32OffAddrAsInt32X8# :: () => Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Reads vector; offset in scalar elements.
readInt64OffAddrAsInt64X4# :: () => Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Reads vector; offset in scalar elements.
readInt8OffAddrAsInt8X64# :: () => Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Reads vector; offset in scalar elements.
readInt16OffAddrAsInt16X32# :: () => Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Reads vector; offset in scalar elements.
readInt32OffAddrAsInt32X16# :: () => Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Reads vector; offset in scalar elements.
readInt64OffAddrAsInt64X8# :: () => Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Reads vector; offset in scalar elements.
readWord8OffAddrAsWord8X16# :: () => Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Reads vector; offset in scalar elements.
readWord16OffAddrAsWord16X8# :: () => Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Reads vector; offset in scalar elements.
readWord32OffAddrAsWord32X4# :: () => Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Reads vector; offset in scalar elements.
readWord64OffAddrAsWord64X2# :: () => Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Reads vector; offset in scalar elements.
readWord8OffAddrAsWord8X32# :: () => Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Reads vector; offset in scalar elements.
readWord16OffAddrAsWord16X16# :: () => Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Reads vector; offset in scalar elements.
readWord32OffAddrAsWord32X8# :: () => Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Reads vector; offset in scalar elements.
readWord64OffAddrAsWord64X4# :: () => Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Reads vector; offset in scalar elements.
readWord8OffAddrAsWord8X64# :: () => Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Reads vector; offset in scalar elements.
readWord16OffAddrAsWord16X32# :: () => Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Reads vector; offset in scalar elements.
readWord32OffAddrAsWord32X16# :: () => Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Reads vector; offset in scalar elements.
readWord64OffAddrAsWord64X8# :: () => Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Reads vector; offset in scalar elements.
readFloatOffAddrAsFloatX4# :: () => Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Reads vector; offset in scalar elements.
readDoubleOffAddrAsDoubleX2# :: () => Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Reads vector; offset in scalar elements.
readFloatOffAddrAsFloatX8# :: () => Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Reads vector; offset in scalar elements.
readDoubleOffAddrAsDoubleX4# :: () => Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Reads vector; offset in scalar elements.
readFloatOffAddrAsFloatX16# :: () => Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Reads vector; offset in scalar elements.
readDoubleOffAddrAsDoubleX8# :: () => Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Write vector; offset in scalar elements.
writeInt8OffAddrAsInt8X16# :: () => Addr# -> Int# -> Int8X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeInt16OffAddrAsInt16X8# :: () => Addr# -> Int# -> Int16X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeInt32OffAddrAsInt32X4# :: () => Addr# -> Int# -> Int32X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeInt64OffAddrAsInt64X2# :: () => Addr# -> Int# -> Int64X2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeInt8OffAddrAsInt8X32# :: () => Addr# -> Int# -> Int8X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeInt16OffAddrAsInt16X16# :: () => Addr# -> Int# -> Int16X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeInt32OffAddrAsInt32X8# :: () => Addr# -> Int# -> Int32X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeInt64OffAddrAsInt64X4# :: () => Addr# -> Int# -> Int64X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeInt8OffAddrAsInt8X64# :: () => Addr# -> Int# -> Int8X64# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeInt16OffAddrAsInt16X32# :: () => Addr# -> Int# -> Int16X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeInt32OffAddrAsInt32X16# :: () => Addr# -> Int# -> Int32X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeInt64OffAddrAsInt64X8# :: () => Addr# -> Int# -> Int64X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeWord8OffAddrAsWord8X16# :: () => Addr# -> Int# -> Word8X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeWord16OffAddrAsWord16X8# :: () => Addr# -> Int# -> Word16X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeWord32OffAddrAsWord32X4# :: () => Addr# -> Int# -> Word32X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeWord64OffAddrAsWord64X2# :: () => Addr# -> Int# -> Word64X2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeWord8OffAddrAsWord8X32# :: () => Addr# -> Int# -> Word8X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeWord16OffAddrAsWord16X16# :: () => Addr# -> Int# -> Word16X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeWord32OffAddrAsWord32X8# :: () => Addr# -> Int# -> Word32X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeWord64OffAddrAsWord64X4# :: () => Addr# -> Int# -> Word64X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeWord8OffAddrAsWord8X64# :: () => Addr# -> Int# -> Word8X64# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeWord16OffAddrAsWord16X32# :: () => Addr# -> Int# -> Word16X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeWord32OffAddrAsWord32X16# :: () => Addr# -> Int# -> Word32X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeWord64OffAddrAsWord64X8# :: () => Addr# -> Int# -> Word64X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeFloatOffAddrAsFloatX4# :: () => Addr# -> Int# -> FloatX4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeDoubleOffAddrAsDoubleX2# :: () => Addr# -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeFloatOffAddrAsFloatX8# :: () => Addr# -> Int# -> FloatX8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeDoubleOffAddrAsDoubleX4# :: () => Addr# -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeFloatOffAddrAsFloatX16# :: () => Addr# -> Int# -> FloatX16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
writeDoubleOffAddrAsDoubleX8# :: () => Addr# -> Int# -> DoubleX8# -> State# d -> State# d
prefetchByteArray3# :: () => ByteArray# -> Int# -> State# d -> State# d
prefetchMutableByteArray3# :: () => MutableByteArray# d -> Int# -> State# d -> State# d
prefetchAddr3# :: () => Addr# -> Int# -> State# d -> State# d
prefetchValue3# :: () => a -> State# d -> State# d
prefetchByteArray2# :: () => ByteArray# -> Int# -> State# d -> State# d
prefetchMutableByteArray2# :: () => MutableByteArray# d -> Int# -> State# d -> State# d
prefetchAddr2# :: () => Addr# -> Int# -> State# d -> State# d
prefetchValue2# :: () => a -> State# d -> State# d
prefetchByteArray1# :: () => ByteArray# -> Int# -> State# d -> State# d
prefetchMutableByteArray1# :: () => MutableByteArray# d -> Int# -> State# d -> State# d
prefetchAddr1# :: () => Addr# -> Int# -> State# d -> State# d
prefetchValue1# :: () => a -> State# d -> State# d
prefetchByteArray0# :: () => ByteArray# -> Int# -> State# d -> State# d
prefetchMutableByteArray0# :: () => MutableByteArray# d -> Int# -> State# d -> State# d
prefetchAddr0# :: () => Addr# -> Int# -> State# d -> State# d
prefetchValue0# :: () => a -> State# d -> State# d

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
shiftL# :: Word# -> Int# -> Word#

-- | Shift the argument right by the specified number of bits (which must
--   be non-negative). The <a>RL</a> means "right, logical" (as opposed to
--   RA for arithmetic) (although an arithmetic right shift wouldn't make
--   sense for Word#)
shiftRL# :: Word# -> Int# -> Word#

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
iShiftL# :: Int# -> Int# -> Int#

-- | Shift the argument right (signed) by the specified number of bits
--   (which must be non-negative). The <a>RA</a> means "right, arithmetic"
--   (as opposed to RL for logical)
iShiftRA# :: Int# -> Int# -> Int#

-- | Shift the argument right (unsigned) by the specified number of bits
--   (which must be non-negative). The <a>RL</a> means "right, logical" (as
--   opposed to RA for arithmetic)
iShiftRL# :: Int# -> Int# -> Int#
uncheckedShiftL64# :: Word# -> Int# -> Word#
uncheckedShiftRL64# :: Word# -> Int# -> Word#
uncheckedIShiftL64# :: Int# -> Int# -> Int#
uncheckedIShiftRA64# :: Int# -> Int# -> Int#

-- | Alias for <a>tagToEnum#</a>. Returns True if its parameter is 1# and
--   False if it is 0#.
isTrue# :: Int# -> Bool

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   build g = g (:) []
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>build</a> g)</tt>, which may arise after
--   inlining, to <tt>g k z</tt>, which avoids producing an intermediate
--   list.
build :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   augment g xs = g (:) xs
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>augment</a> g xs)</tt>, which may arise after
--   inlining, to <tt>g k (<a>foldr</a> k z xs)</tt>, which avoids
--   producing an intermediate list.
augment :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a
breakpoint :: a -> a
breakpointCond :: Bool -> a -> a

-- | The <a>lazy</a> function restrains strictness analysis a little. The
--   call <tt>lazy e</tt> means the same as <tt>e</tt>, but <a>lazy</a> has
--   a magical property so far as strictness analysis is concerned: it is
--   lazy in its first argument, even though its semantics is strict. After
--   strictness analysis has run, calls to <a>lazy</a> are inlined to be
--   the identity function.
--   
--   This behaviour is occasionally useful when controlling evaluation
--   order. Notably, <a>lazy</a> is used in the library definition of
--   <a>par</a>:
--   
--   <pre>
--   par :: a -&gt; b -&gt; b
--   par x y = case (par# x) of _ -&gt; lazy y
--   </pre>
--   
--   If <a>lazy</a> were not lazy, <tt>par</tt> would look strict in
--   <tt>y</tt> which would defeat the whole purpose of <tt>par</tt>.
--   
--   Like <a>seq</a>, the argument of <a>lazy</a> can have an unboxed type.
lazy :: () => a -> a

-- | The call <tt>inline f</tt> arranges that <tt>f</tt> is inlined,
--   regardless of its size. More precisely, the call <tt>inline f</tt>
--   rewrites to the right-hand side of <tt>f</tt>'s definition. This
--   allows the programmer to control inlining from a particular call site
--   rather than the definition site of the function (c.f. <tt>INLINE</tt>
--   pragmas).
--   
--   This inlining occurs regardless of the argument to the call or the
--   size of <tt>f</tt>'s definition; it is unconditional. The main caveat
--   is that <tt>f</tt>'s definition must be visible to the compiler; it is
--   therefore recommended to mark the function with an <tt>INLINABLE</tt>
--   pragma at its definition so that GHC guarantees to record its
--   unfolding regardless of size.
--   
--   If no inlining takes place, the <a>inline</a> function expands to the
--   identity function in Phase zero, so its use imposes no overhead.
inline :: () => a -> a

-- | The <a>oneShot</a> function can be used to give a hint to the compiler
--   that its argument will be called at most once, which may (or may not)
--   enable certain optimizations. It can be useful to improve the
--   performance of code in continuation passing style.
--   
--   If <a>oneShot</a> is used wrongly, then it may be that computations
--   whose result that would otherwise be shared are re-evaluated every
--   time they are used. Otherwise, the use of <a>oneShot</a> is safe.
--   
--   <a>oneShot</a> is representation polymorphic: the type variables may
--   refer to lifted or unlifted types.
oneShot :: () => (a -> b) -> a -> b

-- | Apply a function to a 'State# RealWorld' token. When manually applying
--   a function to <tt>realWorld#</tt>, it is necessary to use
--   <tt>NOINLINE</tt> to prevent semantically undesirable floating.
--   <a>runRW#</a> is inlined, but only very late in compilation after all
--   floating is complete.
runRW# :: () => (State# RealWorld -> o) -> o

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
coerce :: Coercible a b => a -> b

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k0) (b :: k0)

-- | Lifted, heterogeneous equality. By lifted, we mean that it can be
--   bogus (deferred type error). By heterogeneous, the two types
--   <tt>a</tt> and <tt>b</tt> might have different kinds. Because
--   <tt>~~</tt> can appear unexpectedly in error messages to users who do
--   not care about the difference between heterogeneous equality
--   <tt>~~</tt> and homogeneous equality <tt>~</tt>, this is printed as
--   <tt>~</tt> unless <tt>-fprint-equality-relations</tt> is set.
class a ~# b => (~~) (a :: k0) (b :: k1)
data TYPE (a :: RuntimeRep) :: RuntimeRep -> Type

-- | GHC maintains a property that the kind of all inhabited types (as
--   distinct from type constructors or type-level data) tells us the
--   runtime representation of values of that type. This datatype encodes
--   the choice of runtime value. Note that <a>TYPE</a> is parameterised by
--   <a>RuntimeRep</a>; this is precisely what we mean by the fact that a
--   type's kind encodes the runtime representation.
--   
--   For boxed values (that is, values that are represented by a pointer),
--   a further distinction is made, between lifted types (that contain ⊥),
--   and unlifted ones (that don't).
data RuntimeRep

-- | a SIMD vector type
VecRep :: VecCount -> VecElem -> RuntimeRep

-- | An unboxed tuple of the given reps
TupleRep :: [RuntimeRep] -> RuntimeRep

-- | An unboxed sum of the given reps
SumRep :: [RuntimeRep] -> RuntimeRep

-- | lifted; represented by a pointer
LiftedRep :: RuntimeRep

-- | unlifted; represented by a pointer
UnliftedRep :: RuntimeRep

-- | signed, word-sized value
IntRep :: RuntimeRep

-- | unsigned, word-sized value
WordRep :: RuntimeRep

-- | signed, 64-bit value (on 32-bit only)
Int64Rep :: RuntimeRep

-- | unsigned, 64-bit value (on 32-bit only)
Word64Rep :: RuntimeRep

-- | A pointer, but <i>not</i> to a Haskell value
AddrRep :: RuntimeRep

-- | a 32-bit floating point number
FloatRep :: RuntimeRep

-- | a 64-bit floating point number
DoubleRep :: RuntimeRep

-- | Length of a SIMD vector type
data VecCount
Vec2 :: VecCount
Vec4 :: VecCount
Vec8 :: VecCount
Vec16 :: VecCount
Vec32 :: VecCount
Vec64 :: VecCount

-- | Element of a SIMD vector type
data VecElem
Int8ElemRep :: VecElem
Int16ElemRep :: VecElem
Int32ElemRep :: VecElem
Int64ElemRep :: VecElem
Word8ElemRep :: VecElem
Word16ElemRep :: VecElem
Word32ElemRep :: VecElem
Word64ElemRep :: VecElem
FloatElemRep :: VecElem
DoubleElemRep :: VecElem

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>). If <tt>a</tt> has
--   an <tt><a>Ord</a></tt> instance associated with it then comparing two
--   values thus wrapped will give you the opposite of their normal sort
--   order. This is particularly useful when sorting in generalised list
--   comprehensions, as in: <tt>then sortWith by <a>Down</a> x</tt>
newtype Down a
Down :: a -> Down a

-- | The <a>groupWith</a> function uses the user supplied function which
--   projects an element out of every list element in order to first sort
--   the input list and then to form groups by equality on these projected
--   elements
groupWith :: Ord b => (a -> b) -> [a] -> [[a]]

-- | The <a>sortWith</a> function sorts a list of elements using the user
--   supplied function to project something out of each element
sortWith :: Ord b => (a -> b) -> [a] -> [a]

-- | <a>the</a> ensures that all the elements of the list are identical and
--   then returns that unique element
the :: Eq a => [a] -> a

-- | <i>Deprecated: Use <a>traceEvent</a> or <a>traceEventIO</a></i>
traceEvent :: String -> IO ()
data SpecConstrAnnotation
NoSpecConstr :: SpecConstrAnnotation
ForceSpecConstr :: SpecConstrAnnotation

-- | Returns a <tt>[String]</tt> representing the current call stack. This
--   can be useful for debugging.
--   
--   The implementation uses the call-stack simulation maintained by the
--   profiler, so it only works if the program was compiled with
--   <tt>-prof</tt> and contains suitable SCC annotations (e.g. by using
--   <tt>-fprof-auto</tt>). Otherwise, the list returned is likely to be
--   empty or uninformative.
currentCallStack :: IO [String]

-- | The kind of constraints, like <tt>Show a</tt>
data Constraint

-- | The type constructor <a>Any</a> is type to which you can unsafely
--   coerce any lifted type, and back. More concretely, for a lifted type
--   <tt>t</tt> and value <tt>x :: t</tt>, -- <tt>unsafeCoerce
--   (unsafeCoerce x :: Any) :: t</tt> is equivalent to <tt>x</tt>.
type family Any :: k0

-- | The <a>IsList</a> class and its methods are intended to be used in
--   conjunction with the OverloadedLists extension.
class IsList l where {
    
    -- | The <a>Item</a> type function returns the type of items of the
    --   structure <tt>l</tt>.
    type family Item l;
}

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length as a hint.
--   Its behaviour should be equivalent to <a>fromList</a>. The hint can be
--   used to construct the structure <tt>l</tt> more efficiently compared
--   to <a>fromList</a>. If the given hint does not equal to the input
--   list's length the behaviour of <a>fromListN</a> is not specified.
fromListN :: IsList l => Int -> [Item l] -> l

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]
instance GHC.Classes.Eq GHC.Exts.SpecConstrAnnotation
instance Data.Data.Data GHC.Exts.SpecConstrAnnotation
instance GHC.Exts.IsList [a]
instance GHC.Exts.IsList (GHC.Base.NonEmpty a)
instance GHC.Exts.IsList Data.Version.Version
instance GHC.Exts.IsList GHC.Stack.Types.CallStack


-- | Symbolic references to values.
--   
--   References to values are usually implemented with memory addresses,
--   and this is practical when communicating values between the different
--   pieces of a single process.
--   
--   When values are communicated across different processes running in
--   possibly different machines, though, addresses are no longer useful
--   since each process may use different addresses to store a given value.
--   
--   To solve such concern, the references provided by this module offer a
--   key that can be used to locate the values on each process. Each
--   process maintains a global table of references which can be looked up
--   with a given key. This table is known as the Static Pointer Table. The
--   reference can then be dereferenced to obtain the value.
--   
--   The various communicating processes need to aggree on the keys used to
--   refer to the values in the Static Pointer Table, or lookups will fail.
--   Only processes launched from the same program binary are guaranteed to
--   use the same set of keys.
module GHC.StaticPtr

-- | A reference to a value of type <tt>a</tt>.
data StaticPtr a

-- | Dereferences a static pointer.
deRefStaticPtr :: StaticPtr a -> a

-- | A key for <tt>StaticPtrs</tt> that can be serialized and used with
--   <a>unsafeLookupStaticPtr</a>.
type StaticKey = Fingerprint

-- | The <a>StaticKey</a> that can be used to look up the given
--   <a>StaticPtr</a>.
staticKey :: StaticPtr a -> StaticKey

-- | Looks up a <a>StaticPtr</a> by its <a>StaticKey</a>.
--   
--   If the <a>StaticPtr</a> is not found returns <tt>Nothing</tt>.
--   
--   This function is unsafe because the program behavior is undefined if
--   the type of the returned <a>StaticPtr</a> does not match the expected
--   one.
unsafeLookupStaticPtr :: StaticKey -> IO (Maybe (StaticPtr a))

-- | Miscelaneous information available for debugging purposes.
data StaticPtrInfo
StaticPtrInfo :: String -> String -> (Int, Int) -> StaticPtrInfo

-- | Package key of the package where the static pointer is defined
[spInfoUnitId] :: StaticPtrInfo -> String

-- | Name of the module where the static pointer is defined
[spInfoModuleName] :: StaticPtrInfo -> String

-- | Source location of the definition of the static pointer as a
--   <tt>(Line, Column)</tt> pair.
[spInfoSrcLoc] :: StaticPtrInfo -> (Int, Int)

-- | <a>StaticPtrInfo</a> of the given <a>StaticPtr</a>.
staticPtrInfo :: StaticPtr a -> StaticPtrInfo

-- | A list of all known keys.
staticPtrKeys :: IO [StaticKey]

-- | A class for things buildable from static pointers.
class IsStatic p
fromStaticPtr :: IsStatic p => StaticPtr a -> p a
instance GHC.Show.Show GHC.StaticPtr.StaticPtrInfo
instance GHC.StaticPtr.IsStatic GHC.StaticPtr.StaticPtr


-- | In mathematics, a semigroup is an algebraic structure consisting of a
--   set together with an associative binary operation. A semigroup
--   generalizes a monoid in that there might not exist an identity
--   element. It also (originally) generalized a group (a monoid with all
--   inverses) to a type where every element did not have to have an
--   inverse, thus the name semigroup.
--   
--   The use of <tt>(&lt;&gt;)</tt> in this module conflicts with an
--   operator with the same name that is being exported by Data.Monoid.
--   However, this package re-exports (most of) the contents of
--   Data.Monoid, so to use semigroups and monoids in the same package just
--   
--   <pre>
--   import Data.Semigroup
--   </pre>
module Data.Semigroup

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the associativity law:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</pre></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <tt>&lt;&gt;</tt>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   Given that this works on a <a>Semigroup</a> it is allowed to fail if
--   you request 0 or fewer repetitions, and the default definition will do
--   so.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in <i>O(1)</i> by picking
--   <tt>stimes = <tt>stimesIdempotent</tt></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | This is a valid definition of <a>stimes</a> for a <a>Monoid</a>.
--   
--   Unlike the default definition of <a>stimes</a>, it is defined for 0
--   and so it should be preferred where possible.
stimesMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Semigroup</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in <i>O(1)</i> rather than <i>O(log n)</i>.
stimesIdempotent :: Integral b => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Monoid</a>.
--   
--   When <tt>mappend x x = x</tt>, this definition should be preferred,
--   because it works in <i>O(1)</i> rather than <i>O(log n)</i>
stimesIdempotentMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   <pre>
--   mtimesDefault n a = a &lt;&gt; a &lt;&gt; ... &lt;&gt; a  -- using &lt;&gt; (n-1) times
--   </pre>
--   
--   Implemented using <a>stimes</a> and <a>mempty</a>.
--   
--   This is a suitable definition for an <tt>mtimes</tt> member of
--   <a>Monoid</a>.
mtimesDefault :: (Integral b, Monoid a) => b -> a -> a
newtype Min a
Min :: a -> Min a
[getMin] :: Min a -> a
newtype Max a
Max :: a -> Max a
[getMax] :: Max a -> a

-- | Use <tt><a>Option</a> (<a>First</a> a)</tt> to get the behavior of
--   <a>First</a> from <a>Data.Monoid</a>.
newtype First a
First :: a -> First a
[getFirst] :: First a -> a

-- | Use <tt><a>Option</a> (<a>Last</a> a)</tt> to get the behavior of
--   <a>Last</a> from <a>Data.Monoid</a>
newtype Last a
Last :: a -> Last a
[getLast] :: Last a -> a

-- | Provide a Semigroup for an arbitrary Monoid.
--   
--   <b>NOTE</b>: This is not needed anymore since <a>Semigroup</a> became
--   a superclass of <a>Monoid</a> in <i>base-4.11</i> and this newtype be
--   deprecated at some point in the future.
newtype WrappedMonoid m
WrapMonoid :: m -> WrappedMonoid m
[unwrapMonoid] :: WrappedMonoid m -> m

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>.
--   
--   <pre>
--   &gt;&gt;&gt; getDual (mappend (Dual "Hello") (Dual "World"))
--   "WorldHello"
--   </pre>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Boolean monoid under conjunction (<a>&amp;&amp;</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAll (mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8]))
--   False
--   </pre>
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Boolean monoid under disjunction (<a>||</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAny (mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8]))
--   True
--   </pre>
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
--   
--   <pre>
--   &gt;&gt;&gt; getSum (Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty)
--   3
--   </pre>
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; getProduct (Product 3 &lt;&gt; Product 4 &lt;&gt; mempty)
--   12
--   </pre>
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | <a>Option</a> is effectively <a>Maybe</a> with a better instance of
--   <a>Monoid</a>, built off of an underlying <a>Semigroup</a> instead of
--   an underlying <a>Monoid</a>.
--   
--   Ideally, this type would not exist at all and we would just fix the
--   <a>Monoid</a> instance of <a>Maybe</a>.
--   
--   In GHC 8.4 and higher, the <a>Monoid</a> instance for <a>Maybe</a> has
--   been corrected to lift a <a>Semigroup</a> instance instead of a
--   <a>Monoid</a> instance. Consequently, this type is no longer useful.
--   It will be marked deprecated in GHC 8.8 and removed in GHC 8.10.
newtype Option a
Option :: Maybe a -> Option a
[getOption] :: Option a -> Maybe a

-- | Fold an <a>Option</a> case-wise, just like <a>maybe</a>.
option :: b -> (a -> b) -> Option a -> b

-- | This lets you use a difference list of a <a>Semigroup</a> as a
--   <a>Monoid</a>.
diff :: Semigroup m => m -> Endo m

-- | A generalization of <a>cycle</a> to an arbitrary <a>Semigroup</a>. May
--   fail to terminate for some values in some semigroups.
cycle1 :: Semigroup m => m -> m

-- | <a>Arg</a> isn't itself a <a>Semigroup</a> in its own right, but it
--   can be placed inside <a>Min</a> and <a>Max</a> to compute an arg min
--   or arg max.
data Arg a b
Arg :: a -> b -> Arg a b
type ArgMin a b = Min (Arg a b)
type ArgMax a b = Max (Arg a b)
instance GHC.Generics.Generic1 Data.Semigroup.Option
instance GHC.Generics.Generic (Data.Semigroup.Option a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Option a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Option a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Option a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Option a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Option a)
instance GHC.Generics.Generic1 Data.Semigroup.WrappedMonoid
instance GHC.Generics.Generic (Data.Semigroup.WrappedMonoid m)
instance Data.Data.Data m => Data.Data.Data (Data.Semigroup.WrappedMonoid m)
instance GHC.Read.Read m => GHC.Read.Read (Data.Semigroup.WrappedMonoid m)
instance GHC.Show.Show m => GHC.Show.Show (Data.Semigroup.WrappedMonoid m)
instance GHC.Classes.Ord m => GHC.Classes.Ord (Data.Semigroup.WrappedMonoid m)
instance GHC.Classes.Eq m => GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m)
instance GHC.Enum.Bounded m => GHC.Enum.Bounded (Data.Semigroup.WrappedMonoid m)
instance GHC.Generics.Generic1 Data.Semigroup.Last
instance GHC.Generics.Generic (Data.Semigroup.Last a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Last a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Last a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Last a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Last a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Last a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Last a)
instance GHC.Generics.Generic1 Data.Semigroup.First
instance GHC.Generics.Generic (Data.Semigroup.First a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.First a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.First a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.First a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.First a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.First a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.First a)
instance GHC.Generics.Generic1 (Data.Semigroup.Arg a)
instance GHC.Generics.Generic (Data.Semigroup.Arg a b)
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Semigroup.Arg a b)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Data.Semigroup.Arg a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Semigroup.Arg a b)
instance GHC.Generics.Generic1 Data.Semigroup.Max
instance GHC.Generics.Generic (Data.Semigroup.Max a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Max a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Max a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Max a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Max a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Max a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Max a)
instance GHC.Generics.Generic1 Data.Semigroup.Min
instance GHC.Generics.Generic (Data.Semigroup.Min a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Min a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Min a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Min a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Min a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Min a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Min a)
instance GHC.Base.Functor Data.Semigroup.Option
instance GHC.Base.Applicative Data.Semigroup.Option
instance GHC.Base.Monad Data.Semigroup.Option
instance GHC.Base.Alternative Data.Semigroup.Option
instance GHC.Base.MonadPlus Data.Semigroup.Option
instance Control.Monad.Fix.MonadFix Data.Semigroup.Option
instance Data.Foldable.Foldable Data.Semigroup.Option
instance Data.Traversable.Traversable Data.Semigroup.Option
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Semigroup.Option a)
instance GHC.Base.Semigroup a => GHC.Base.Monoid (Data.Semigroup.Option a)
instance GHC.Base.Monoid m => GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m)
instance GHC.Base.Monoid m => GHC.Base.Monoid (Data.Semigroup.WrappedMonoid m)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.WrappedMonoid a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Last a)
instance GHC.Base.Semigroup (Data.Semigroup.Last a)
instance GHC.Base.Functor Data.Semigroup.Last
instance Data.Foldable.Foldable Data.Semigroup.Last
instance Data.Traversable.Traversable Data.Semigroup.Last
instance GHC.Base.Applicative Data.Semigroup.Last
instance GHC.Base.Monad Data.Semigroup.Last
instance Control.Monad.Fix.MonadFix Data.Semigroup.Last
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.First a)
instance GHC.Base.Semigroup (Data.Semigroup.First a)
instance GHC.Base.Functor Data.Semigroup.First
instance Data.Foldable.Foldable Data.Semigroup.First
instance Data.Traversable.Traversable Data.Semigroup.First
instance GHC.Base.Applicative Data.Semigroup.First
instance GHC.Base.Monad Data.Semigroup.First
instance Control.Monad.Fix.MonadFix Data.Semigroup.First
instance GHC.Base.Functor (Data.Semigroup.Arg a)
instance Data.Foldable.Foldable (Data.Semigroup.Arg a)
instance Data.Traversable.Traversable (Data.Semigroup.Arg a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Arg a b)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Arg a b)
instance Data.Bifunctor.Bifunctor Data.Semigroup.Arg
instance Data.Bifoldable.Bifoldable Data.Semigroup.Arg
instance Data.Bitraversable.Bitraversable Data.Semigroup.Arg
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Max a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Semigroup.Max a)
instance (GHC.Classes.Ord a, GHC.Enum.Bounded a) => GHC.Base.Monoid (Data.Semigroup.Max a)
instance GHC.Base.Functor Data.Semigroup.Max
instance Data.Foldable.Foldable Data.Semigroup.Max
instance Data.Traversable.Traversable Data.Semigroup.Max
instance GHC.Base.Applicative Data.Semigroup.Max
instance GHC.Base.Monad Data.Semigroup.Max
instance Control.Monad.Fix.MonadFix Data.Semigroup.Max
instance GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Max a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Min a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Semigroup.Min a)
instance (GHC.Classes.Ord a, GHC.Enum.Bounded a) => GHC.Base.Monoid (Data.Semigroup.Min a)
instance GHC.Base.Functor Data.Semigroup.Min
instance Data.Foldable.Foldable Data.Semigroup.Min
instance Data.Traversable.Traversable Data.Semigroup.Min
instance GHC.Base.Applicative Data.Semigroup.Min
instance GHC.Base.Monad Data.Semigroup.Min
instance Control.Monad.Fix.MonadFix Data.Semigroup.Min
instance GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Min a)


-- | A logically uninhabited data type, used to indicate that a given term
--   should not exist.
module Data.Void

-- | Uninhabited data type
data Void

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: Void -> a

-- | If <a>Void</a> is uninhabited then any <a>Functor</a> that holds only
--   values of type <a>Void</a> is holding no values.
vacuous :: Functor f => f Void -> f a
instance GHC.Show.Show Data.Void.Void
instance GHC.Read.Read Data.Void.Void
instance GHC.Classes.Ord Data.Void.Void
instance GHC.Generics.Generic Data.Void.Void
instance Data.Data.Data Data.Void.Void
instance GHC.Classes.Eq Data.Void.Void
instance GHC.Arr.Ix Data.Void.Void
instance GHC.Exception.Type.Exception Data.Void.Void
instance GHC.Base.Semigroup Data.Void.Void


-- | Sums, lifted to functors.
module Data.Functor.Sum

-- | Lifted sum of functors.
data Sum f g a
InL :: f a -> Sum f g a
InR :: g a -> Sum f g a
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (Data.Functor.Sum.Sum f g)
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). GHC.Generics.Generic (Data.Functor.Sum.Sum f g a)
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Typeable.Internal.Typeable k, Data.Data.Data (f a), Data.Data.Data (g a)) => Data.Data.Data (Data.Functor.Sum.Sum f g a)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Functor.Sum.Sum f g a)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Functor.Sum.Sum f g a)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g, GHC.Read.Read a) => GHC.Read.Read (Data.Functor.Sum.Sum f g a)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.Sum.Sum f g a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Sum.Sum f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Functor.Sum.Sum f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Functor.Sum.Sum f g)


-- | Products, lifted to functors.
module Data.Functor.Product

-- | Lifted product of functors.
data Product f g a
Pair :: f a -> g a -> Product f g a
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (Data.Functor.Product.Product f g)
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). GHC.Generics.Generic (Data.Functor.Product.Product f g a)
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Typeable.Internal.Typeable k, Data.Data.Data (f a), Data.Data.Data (g a)) => Data.Data.Data (Data.Functor.Product.Product f g a)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Functor.Product.Product f g a)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Functor.Product.Product f g a)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g, GHC.Read.Read a) => GHC.Read.Read (Data.Functor.Product.Product f g a)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.Product.Product f g a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Product.Product f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Functor.Product.Product f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Functor.Product.Product f g)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (Data.Functor.Product.Product f g)
instance (GHC.Base.Alternative f, GHC.Base.Alternative g) => GHC.Base.Alternative (Data.Functor.Product.Product f g)
instance (GHC.Base.Monad f, GHC.Base.Monad g) => GHC.Base.Monad (Data.Functor.Product.Product f g)
instance (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) => GHC.Base.MonadPlus (Data.Functor.Product.Product f g)
instance (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) => Control.Monad.Fix.MonadFix (Data.Functor.Product.Product f g)
instance (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) => Control.Monad.Zip.MonadZip (Data.Functor.Product.Product f g)


-- | Composition of functors.
module Data.Functor.Compose

-- | Right-to-left composition of functors. The composition of applicative
--   functors is always applicative, but the composition of monads is not
--   always a monad.
newtype Compose f g a
Compose :: f (g a) -> Compose f g a
[getCompose] :: Compose f g a -> f (g a)
infixr 9 `Compose`
infixr 9 `Compose`
instance forall (f :: * -> *) k (g :: k -> *). GHC.Base.Functor f => GHC.Generics.Generic1 (Data.Functor.Compose.Compose f g)
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). GHC.Generics.Generic (Data.Functor.Compose.Compose f g a)
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Typeable.Internal.Typeable k1, Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) => Data.Data.Data (Data.Functor.Compose.Compose f g a)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Functor.Compose.Compose f g a)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Functor.Compose.Compose f g a)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g, GHC.Read.Read a) => GHC.Read.Read (Data.Functor.Compose.Compose f g a)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.Compose.Compose f g a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Compose.Compose f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Functor.Compose.Compose f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Alternative f, GHC.Base.Applicative g) => GHC.Base.Alternative (Data.Functor.Compose.Compose f g)


-- | <a>Contravariant</a> functors, sometimes referred to colloquially as
--   <tt>Cofunctor</tt>, even though the dual of a <a>Functor</a> is just a
--   <a>Functor</a>. As with <a>Functor</a> the definition of
--   <a>Contravariant</a> for a given ADT is unambiguous.
module Data.Functor.Contravariant

-- | The class of contravariant functors.
--   
--   Whereas in Haskell, one can think of a <a>Functor</a> as containing or
--   producing values, a contravariant functor is a functor that can be
--   thought of as <i>consuming</i> values.
--   
--   As an example, consider the type of predicate functions <tt>a -&gt;
--   Bool</tt>. One such predicate might be <tt>negative x = x &lt; 0</tt>,
--   which classifies integers as to whether they are negative. However,
--   given this predicate, we can re-use it in other situations, providing
--   we have a way to map values <i>to</i> integers. For instance, we can
--   use the <tt>negative</tt> predicate on a person's bank balance to work
--   out if they are currently overdrawn:
--   
--   <pre>
--   newtype Predicate a = Predicate { getPredicate :: a -&gt; Bool }
--   
--   instance Contravariant Predicate where
--     contramap f (Predicate p) = Predicate (p . f)
--                                            |   `- First, map the input...
--                                            `----- then apply the predicate.
--   
--   overdrawn :: Predicate Person
--   overdrawn = contramap personBankBalance negative
--   </pre>
--   
--   Any instance should be subject to the following laws:
--   
--   <pre>
--   contramap id = id
--   contramap f . contramap g = contramap (g . f)
--   </pre>
--   
--   Note, that the second law follows from the free theorem of the type of
--   <a>contramap</a> and the first law, so you need only check that the
--   former condition holds.
class Contravariant f
contramap :: Contravariant f => (a -> b) -> f b -> f a

-- | Replace all locations in the output with the same value. The default
--   definition is <tt><a>contramap</a> . <a>const</a></tt>, but this may
--   be overridden with a more efficient version.
(>$) :: Contravariant f => b -> f b -> f a
infixl 4 >$

-- | If <tt>f</tt> is both <a>Functor</a> and <a>Contravariant</a> then by
--   the time you factor in the laws of each of those classes, it can't
--   actually use its argument in any meaningful capacity.
--   
--   This method is surprisingly useful. Where both instances exist and are
--   lawful we have the following laws:
--   
--   <pre>
--   <a>fmap</a> f ≡ <a>phantom</a>
--   <a>contramap</a> f ≡ <a>phantom</a>
--   </pre>
phantom :: (Functor f, Contravariant f) => f a -> f b

-- | This is an infix alias for <a>contramap</a>.
(>$<) :: Contravariant f => (a -> b) -> f b -> f a
infixl 4 >$<

-- | This is an infix version of <a>contramap</a> with the arguments
--   flipped.
(>$$<) :: Contravariant f => f b -> (a -> b) -> f a
infixl 4 >$$<

-- | This is <a>&gt;$</a> with its arguments flipped.
($<) :: Contravariant f => f b -> b -> f a
infixl 4 $<
newtype Predicate a
Predicate :: (a -> Bool) -> Predicate a
[getPredicate] :: Predicate a -> a -> Bool

-- | Defines a total ordering on a type as per <a>compare</a>.
--   
--   This condition is not checked by the types. You must ensure that the
--   supplied values are valid total orderings yourself.
newtype Comparison a
Comparison :: (a -> a -> Ordering) -> Comparison a
[getComparison] :: Comparison a -> a -> a -> Ordering

-- | Compare using <a>compare</a>.
defaultComparison :: Ord a => Comparison a

-- | This data type represents an equivalence relation.
--   
--   Equivalence relations are expected to satisfy three laws:
--   
--   <b>Reflexivity</b>:
--   
--   <pre>
--   <a>getEquivalence</a> f a a = True
--   </pre>
--   
--   <b>Symmetry</b>:
--   
--   <pre>
--   <a>getEquivalence</a> f a b = <a>getEquivalence</a> f b a
--   </pre>
--   
--   <b>Transitivity</b>:
--   
--   If <tt><a>getEquivalence</a> f a b</tt> and <tt><a>getEquivalence</a>
--   f b c</tt> are both <a>True</a> then so is <tt><a>getEquivalence</a> f
--   a c</tt>.
--   
--   The types alone do not enforce these laws, so you'll have to check
--   them yourself.
newtype Equivalence a
Equivalence :: (a -> a -> Bool) -> Equivalence a
[getEquivalence] :: Equivalence a -> a -> a -> Bool

-- | Check for equivalence with <a>==</a>.
--   
--   Note: The instances for <a>Double</a> and <a>Float</a> violate
--   reflexivity for <tt>NaN</tt>.
defaultEquivalence :: Eq a => Equivalence a
comparisonEquivalence :: Comparison a -> Equivalence a

-- | Dual function arrows.
newtype Op a b
Op :: (b -> a) -> Op a b
[getOp] :: Op a b -> b -> a
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (GHC.Generics.M1 i c f)
instance GHC.Base.Semigroup (Data.Functor.Contravariant.Comparison a)
instance GHC.Base.Monoid (Data.Functor.Contravariant.Comparison a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Contravariant.Op a b)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Contravariant.Op a b)
instance Control.Category.Category Data.Functor.Contravariant.Op
instance Data.Functor.Contravariant.Contravariant (Data.Functor.Contravariant.Op a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Functor.Contravariant.Op a b)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Contravariant.Op a b)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Contravariant.Op a b)
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Equivalence
instance GHC.Base.Semigroup (Data.Functor.Contravariant.Equivalence a)
instance GHC.Base.Monoid (Data.Functor.Contravariant.Equivalence a)
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Comparison
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Predicate
instance GHC.Base.Semigroup (Data.Functor.Contravariant.Predicate a)
instance GHC.Base.Monoid (Data.Functor.Contravariant.Predicate a)
instance Data.Functor.Contravariant.Contravariant GHC.Generics.V1
instance Data.Functor.Contravariant.Contravariant GHC.Generics.U1
instance Data.Functor.Contravariant.Contravariant (GHC.Generics.K1 i c)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:*: g)
instance (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:.: g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:+: g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Contravariant (Data.Functor.Const.Const a)
instance (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Compose.Compose f g)
instance Data.Functor.Contravariant.Contravariant Data.Proxy.Proxy


-- | This module defines a "Fixed" type for fixed-precision arithmetic. The
--   parameter to Fixed is any type that's an instance of HasResolution.
--   HasResolution has a single method that gives the resolution of the
--   Fixed type.
--   
--   This module also contains generalisations of div, mod, and divmod to
--   work with any Real instance.
module Data.Fixed

-- | generalisation of <a>div</a> to any instance of Real
div' :: (Real a, Integral b) => a -> a -> b

-- | generalisation of <a>mod</a> to any instance of Real
mod' :: Real a => a -> a -> a

-- | generalisation of <a>divMod</a> to any instance of Real
divMod' :: (Real a, Integral b) => a -> a -> (b, a)

-- | The type parameter should be an instance of <a>HasResolution</a>.
newtype Fixed a
MkFixed :: Integer -> Fixed a
class HasResolution a
resolution :: HasResolution a => p a -> Integer

-- | First arg is whether to chop off trailing zeros
showFixed :: HasResolution a => Bool -> Fixed a -> String
data E0

-- | resolution of 1, this works the same as Integer
type Uni = Fixed E0
data E1

-- | resolution of 10^-1 = .1
type Deci = Fixed E1
data E2

-- | resolution of 10^-2 = .01, useful for many monetary currencies
type Centi = Fixed E2
data E3

-- | resolution of 10^-3 = .001
type Milli = Fixed E3
data E6

-- | resolution of 10^-6 = .000001
type Micro = Fixed E6
data E9

-- | resolution of 10^-9 = .000000001
type Nano = Fixed E9
data E12

-- | resolution of 10^-12 = .000000000001
type Pico = Fixed E12
instance GHC.Classes.Ord (Data.Fixed.Fixed a)
instance GHC.Classes.Eq (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution Data.Fixed.E12
instance Data.Fixed.HasResolution Data.Fixed.E9
instance Data.Fixed.HasResolution Data.Fixed.E6
instance Data.Fixed.HasResolution Data.Fixed.E3
instance Data.Fixed.HasResolution Data.Fixed.E2
instance Data.Fixed.HasResolution Data.Fixed.E1
instance Data.Fixed.HasResolution Data.Fixed.E0
instance Data.Fixed.HasResolution a => GHC.Num.Num (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Real.Real (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Real.Fractional (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Real.RealFrac (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Show.Show (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution a => GHC.Read.Read (Data.Fixed.Fixed a)
instance Data.Typeable.Internal.Typeable a => Data.Data.Data (Data.Fixed.Fixed a)
instance GHC.Enum.Enum (Data.Fixed.Fixed a)


-- | Complex numbers.
module Data.Complex

-- | Complex numbers are an algebraic type.
--   
--   For a complex number <tt>z</tt>, <tt><a>abs</a> z</tt> is a number
--   with the magnitude of <tt>z</tt>, but oriented in the positive real
--   direction, whereas <tt><a>signum</a> z</tt> has the phase of
--   <tt>z</tt>, but unit magnitude.
--   
--   The <a>Foldable</a> and <a>Traversable</a> instances traverse the real
--   part first.
--   
--   Note that <a>Complex</a>'s instances inherit the deficiencies from the
--   type parameter's. For example, <tt>Complex Float</tt>'s <a>Ord</a>
--   instance has similar problems to <a>Float</a>'s.
data Complex a

-- | forms a complex number from its real and imaginary rectangular
--   components.
(:+) :: !a -> !a -> Complex a
infix 6 :+

-- | Extracts the real part of a complex number.
realPart :: Complex a -> a

-- | Extracts the imaginary part of a complex number.
imagPart :: Complex a -> a

-- | Form a complex number from polar components of magnitude and phase.
mkPolar :: Floating a => a -> a -> Complex a

-- | <tt><a>cis</a> t</tt> is a complex value with magnitude <tt>1</tt> and
--   phase <tt>t</tt> (modulo <tt>2*<a>pi</a></tt>).
cis :: Floating a => a -> Complex a

-- | The function <a>polar</a> takes a complex number and returns a
--   (magnitude, phase) pair in canonical form: the magnitude is
--   nonnegative, and the phase in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>; if the magnitude is zero, then so is the phase.
polar :: RealFloat a => Complex a -> (a, a)

-- | The nonnegative magnitude of a complex number.
magnitude :: RealFloat a => Complex a -> a

-- | The phase of a complex number, in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>. If the magnitude is zero, then so is the phase.
phase :: RealFloat a => Complex a -> a

-- | The conjugate of a complex number.
conjugate :: Num a => Complex a -> Complex a
instance Data.Traversable.Traversable Data.Complex.Complex
instance Data.Foldable.Foldable Data.Complex.Complex
instance GHC.Base.Functor Data.Complex.Complex
instance GHC.Generics.Generic1 Data.Complex.Complex
instance GHC.Generics.Generic (Data.Complex.Complex a)
instance Data.Data.Data a => Data.Data.Data (Data.Complex.Complex a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Complex.Complex a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Complex.Complex a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Complex.Complex a)
instance GHC.Float.RealFloat a => GHC.Num.Num (Data.Complex.Complex a)
instance GHC.Float.RealFloat a => GHC.Real.Fractional (Data.Complex.Complex a)
instance GHC.Float.RealFloat a => GHC.Float.Floating (Data.Complex.Complex a)
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Complex.Complex a)
instance GHC.Base.Applicative Data.Complex.Complex
instance GHC.Base.Monad Data.Complex.Complex
