-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Wallet Backend for a Cardano node.
--   
--   Please see README.md
@package cardano-wallet-core
@version 2019.7.24


-- | Provides a mechanism for Daedalus to discover what port the
--   cardano-wallet server is listening on.
--   
--   See
--   <a>https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options</a>
--   for more information about the message protocol.
module Cardano.Wallet.DaedalusIPC

-- | Start up the Daedalus IPC process. It's called <a>daedalusIPC</a>, but
--   this could be any nodejs program that needs to start cardano-wallet.
--   All it does is reply with a port number when asked, using a very
--   nodejs-specific IPC method.
--   
--   If the IPC channel was successfully set up, this function won't return
--   until the parent process exits. Otherwise, it will return immediately.
--   Before returning, it will log an message about why it has exited.
daedalusIPC :: Trace IO Text -> Int -> IO ()
instance GHC.Classes.Eq Cardano.Wallet.DaedalusIPC.NodeChannelError
instance GHC.Show.Show Cardano.Wallet.DaedalusIPC.NodeChannelError
instance GHC.Classes.Eq Cardano.Wallet.DaedalusIPC.MsgOut
instance GHC.Show.Show Cardano.Wallet.DaedalusIPC.MsgOut
instance GHC.Classes.Eq Cardano.Wallet.DaedalusIPC.MsgIn
instance GHC.Show.Show Cardano.Wallet.DaedalusIPC.MsgIn
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.DaedalusIPC.MsgOut
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.DaedalusIPC.MsgIn


-- | This module provides mnemonic (backup phrase) creation, and conversion
--   of a mnemonic to seed for wallet restoration.
--   
--   The module uses a lot of type-level machinery to ensure that entropy
--   and mnemonic sizes are all compatible and legit. Therefore, it isn't
--   possible to generate an invalid seed by using the smart constructors
--   below, and trying to generate an entropy of an invalid size will
--   result in a runtime error.
module Cardano.Wallet.Primitive.Mnemonic

-- | A backup-phrase in the form of a non-empty of Mnemonic words
--   Constructor isn't exposed.
data Mnemonic (mw :: Nat)
data Entropy (n :: Nat)

-- | Smart-constructor for the Entropy
--   
--   <pre>
--   &gt;&gt;&gt; mkEntropy @(EntropySize 15) bytes
--   Entropy {} :: Entropy 160
--   </pre>
mkEntropy :: forall ent csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => ByteString -> Either (EntropyError csz) (Entropy ent)

-- | Smart-constructor for <a>Mnemonic</a>. Requires a type application to
--   disambiguate the mnemonic size:
--   
--   <pre>
--   &gt;&gt;&gt; mkMnemonic @15 sentence
--   Mnemonic {} :: Mnemonic 15
--   </pre>
--   
--   See also <a>FromMnemonic</a> to build a <a>Mnemonic</a> from lists of
--   words of variable sizes.
--   
--   <b>Property</b>:
--   
--   <pre>
--   mkMnemonic (mnemonicToText mnemonic) == Right mnemonic
--   </pre>
mkMnemonic :: forall mw ent csz. (ConsistentEntropy ent mw csz, EntropySize mw ~ ent) => [Text] -> Either (MnemonicError csz) (Mnemonic mw)

-- | Generate Entropy of a given size using a random seed.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; genEntropy @(EntropySize 12)
--   Entropy {} :: Entropy 128
--   </pre>
genEntropy :: forall ent csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => IO (Entropy ent)

-- | This wraps errors from <a>Cardano.Encoding.BIP39</a>
data MnemonicError csz

-- | Wrong number of words in mnemonic.
ErrMnemonicWords :: MnemonicWordsError -> MnemonicError csz

-- | Invalid entropy length or checksum.
ErrEntropy :: EntropyError csz -> MnemonicError csz

-- | Invalid word in mnemonic.
ErrDictionary :: DictionaryError -> MnemonicError csz

-- | This wraps EntropyError of <a>Cardano.Encoding.BIP39</a>
newtype MnemonicException csz

-- | Invalid entropy length or checksum
UnexpectedEntropyError :: EntropyError csz -> MnemonicException csz
mnemonicToEntropy :: Mnemonic mw -> Entropy (EntropySize mw)

-- | Convert an Entropy to a corresponding Mnemonic Sentence. Since
--   <a>Entropy</a> and <a>Mnemonic</a> can only be created through
--   smart-constructors, this function cannot fail and is total.
entropyToMnemonic :: forall mw ent csz. (ValidMnemonicSentence mw, ValidEntropySize ent, ValidChecksumSize ent csz, ent ~ EntropySize mw, mw ~ MnemonicWords ent) => Entropy ent -> Mnemonic mw

-- | Convert <a>Entropy</a> to a plain bytes.
entropyToBytes :: Entropy n -> ScrubbedBytes

-- | Convert a <a>Mnemonic</a> to a sentence of English mnemonic words.
mnemonicToText :: Mnemonic mw -> [Text]
data EntropyError (csz :: Nat)
ErrInvalidEntropyLength :: Int -> Int -> EntropyError
ErrInvalidEntropyChecksum :: Checksum csz -> Checksum csz -> EntropyError
data DictionaryError
ErrInvalidDictionaryWord :: String -> DictionaryError
data MnemonicWordsError
ErrWrongNumberOfWords :: Int -> Int -> MnemonicWordsError
type ValidEntropySize (n :: Nat) = (KnownNat n, NatWithinBound Int n, Elem n 96 : 128 : 160 : 192 : 224 : 256 : ([] :: [Nat]))
type ValidChecksumSize (ent :: Nat) (csz :: Nat) = (KnownNat csz, NatWithinBound Int csz, Elem csz 3 : 4 : 5 : 6 : 7 : 8 : ([] :: [Nat]), CheckSumBits ent ~ csz)
type ConsistentEntropy (ent :: Nat) (mw :: Nat) (csz :: Nat) = (ValidEntropySize ent, ValidChecksumSize ent csz, ValidMnemonicSentence mw, MnemonicWords ent ~ mw)
type family CheckSumBits (n :: Nat) :: Nat
type family EntropySize (n :: Nat) :: Nat
type family MnemonicWords (n :: Nat) :: Nat
instance GHC.Show.Show (Cardano.Wallet.Primitive.Mnemonic.MnemonicError csz)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Mnemonic.MnemonicError csz)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Mnemonic.MnemonicException csz)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Crypto.Encoding.BIP39.EntropyError czs)
instance GHC.Classes.Eq Crypto.Encoding.BIP39.MnemonicWordsError
instance GHC.Classes.Eq Crypto.Encoding.BIP39.Dictionary.DictionaryError
instance GHC.TypeNats.KnownNat csz => GHC.Exception.Type.Exception (Cardano.Wallet.Primitive.Mnemonic.MnemonicException csz)

module Data.Function.Utils

-- | Apply a function <tt>n</tt> times to the specified input.
applyN :: Integral n => n -> (a -> a) -> a -> a


-- | Representation of values with an associated (free) unit of measure.
--   Useful to disambiguate primitive types like <a>Int</a> or <a>Value</a>
--   which can be in different bases depending on the context.
module Data.Quantity

-- | <tt>Quantity (unit :: Symbol) a</tt> is a primitive <tt>a</tt>
--   multiplied by an <tt>unit</tt>.
--   
--   Example:
--   
--   Instead of providing the unit implicitly as a comment, or a part of a
--   name
--   
--   <pre>
--   &gt;&gt;&gt; a :: Word32 -- in lovelace
--   </pre>
--   
--   we can write
--   
--   <pre>
--   &gt;&gt;&gt; a :: Quantity "lovelace" Word32
--   </pre>
--   
--   which now has a different type from
--   
--   <pre>
--   &gt;&gt;&gt; b :: Quantity "lovelace/byte" Word32
--   </pre>
--   
--   so mixing them up is more difficult.
--   
--   The unit is mostly a phantom type, but it is also included in the
--   <tt>ToJSON</tt>/<tt>FromJSON</tt> instances.
--   
--   <pre>
--   &gt;&gt;&gt; Aeson.encode $ Quantity @"lovelace" 14
--   {"unit":"lovelace","quantity":14}
--   </pre>
newtype Quantity (unit :: Symbol) a
Quantity :: a -> Quantity a

-- | Opaque Haskell type to represent values between 0 and 100 (incl).
data Percentage
data MkPercentageError
PercentageOutOfBoundsError :: MkPercentageError

-- | Safe constructor for <a>Percentage</a>
mkPercentage :: Integral i => i -> Either MkPercentageError Percentage
getPercentage :: Percentage -> Word
instance GHC.Classes.Eq Data.Quantity.MkPercentageError
instance GHC.Show.Show Data.Quantity.MkPercentageError
instance Data.Aeson.Types.ToJSON.ToJSON Data.Quantity.Percentage
instance GHC.Classes.Ord Data.Quantity.Percentage
instance GHC.Classes.Eq Data.Quantity.Percentage
instance GHC.Show.Show Data.Quantity.Percentage
instance GHC.Generics.Generic Data.Quantity.Percentage
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Quantity.Quantity unit a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Quantity.Quantity unit a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Quantity.Quantity unit a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Quantity.Quantity unit a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Quantity.Quantity unit a)
instance GHC.Generics.Generic (Data.Quantity.Quantity unit a)
instance Control.DeepSeq.NFData Data.Quantity.Percentage
instance Data.Aeson.Types.FromJSON.FromJSON Data.Quantity.Percentage
instance GHC.Enum.Bounded Data.Quantity.Percentage
instance GHC.Enum.Enum Data.Quantity.Percentage
instance Data.Text.Class.ToText Data.Quantity.Percentage
instance Data.Text.Class.FromText Data.Quantity.Percentage
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Quantity.Quantity unit a)
instance (GHC.TypeLits.KnownSymbol unit, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Data.Quantity.Quantity unit a)
instance (GHC.TypeLits.KnownSymbol unit, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Data.Quantity.Quantity unit a)
instance Data.Text.Class.FromText b => Data.Text.Class.FromText (Data.Quantity.Quantity sym b)
instance Data.Text.Class.ToText b => Data.Text.Class.ToText (Data.Quantity.Quantity sym b)


-- | This module contains the core primitive of a Wallet. This is roughly a
--   Haskell translation of the <a>Formal Specification for a Cardano
--   Wallet</a>
--   
--   It doesn't contain any particular business-logic code, but define a
--   few primitive operations on Wallet core types as well.
module Cardano.Wallet.Primitive.Types
data Block tx
Block :: !BlockHeader -> ![tx] -> Block tx
[$sel:header:Block] :: Block tx -> !BlockHeader
[$sel:transactions:Block] :: Block tx -> ![tx]
data BlockHeader
BlockHeader :: SlotId -> !Hash "BlockHeader" -> BlockHeader
[$sel:slotId:BlockHeader] :: BlockHeader -> SlotId
[$sel:prevBlockHash:BlockHeader] :: BlockHeader -> !Hash "BlockHeader"

-- | An abstraction for computing transaction id. The <tt>target</tt> is an
--   open-type that can be used to discriminate on. For instance:
--   
--   <pre>
--   instance DefineTx (HttpBridge network) where
--     txId _ = {- ... -}
--     ,,,
--   </pre>
--   
--   Note that <a>txId</a> is ambiguous and requires therefore a type
--   application. Likely, a corresponding target would be found in scope
--   (requires however ScopedTypeVariables).
--   
--   For example, assuming there's a type <tt>t</tt> in scope, one can
--   simply do:
--   
--   <pre>
--   txId @t tx
--   </pre>
class (NFData (Tx t), Show (Tx t), Ord (Tx t), Buildable (Tx t)) => DefineTx t where {
    type family Tx t :: *;
}
txId :: DefineTx t => Tx t -> Hash "Tx"

-- | Compute a transaction id; assumed to be effectively injective. It
--   returns an hex-encoded 64-byte hash.
--   
--   NOTE: This is a rather expensive operation
inputs :: DefineTx t => Tx t -> [TxIn]

-- | Get transaction's inputs, ordered
outputs :: DefineTx t => Tx t -> [TxOut]
data TxIn
TxIn :: !Hash "Tx" -> !Word32 -> TxIn
[$sel:inputId:TxIn] :: TxIn -> !Hash "Tx"
[$sel:inputIx:TxIn] :: TxIn -> !Word32
data TxOut
TxOut :: !Address -> !Coin -> TxOut
[$sel:address:TxOut] :: TxOut -> !Address
[$sel:coin:TxOut] :: TxOut -> !Coin
data TxMeta
TxMeta :: !TxStatus -> !Direction -> !SlotId -> !Quantity "lovelace" Natural -> TxMeta
[$sel:status:TxMeta] :: TxMeta -> !TxStatus
[$sel:direction:TxMeta] :: TxMeta -> !Direction
[$sel:slotId:TxMeta] :: TxMeta -> !SlotId
[$sel:amount:TxMeta] :: TxMeta -> !Quantity "lovelace" Natural

-- | The effect of a <tt>Transaction</tt> on the wallet balance.
data Direction

-- | The wallet balance decreases.
Outgoing :: Direction

-- | The wallet balance increases or stays the same.
Incoming :: Direction
data TxStatus
Pending :: TxStatus
InLedger :: TxStatus
Invalidated :: TxStatus

-- | <tt>TxWitness</tt> is proof that transaction inputs are allowed to be
--   spent
newtype TxWitness
TxWitness :: ByteString -> TxWitness
[$sel:unWitness:TxWitness] :: TxWitness -> ByteString

-- | Full expanded and resolved information about a transaction, suitable
--   for presentation to the user.
data TransactionInfo
TransactionInfo :: !Hash "Tx" -> ![(TxIn, Maybe TxOut)] -> ![TxOut] -> !TxMeta -> Quantity "slot" Natural -> UTCTime -> TransactionInfo

-- | Transaction ID of this transaction
[$sel:txInfoId:TransactionInfo] :: TransactionInfo -> !Hash "Tx"

-- | Transaction inputs and (maybe) corresponding outputs of the source.
--   Source information can only be provided for outgoing payments.
[$sel:txInfoInputs:TransactionInfo] :: TransactionInfo -> ![(TxIn, Maybe TxOut)]

-- | Payment destination.
[$sel:txInfoOutputs:TransactionInfo] :: TransactionInfo -> ![TxOut]

-- | Other information calculated from the transaction.
[$sel:txInfoMeta:TransactionInfo] :: TransactionInfo -> !TxMeta

-- | Number of slots since the transaction slot.
[$sel:txInfoDepth:TransactionInfo] :: TransactionInfo -> Quantity "slot" Natural

-- | Creation time of the block including this transaction.
[$sel:txInfoTime:TransactionInfo] :: TransactionInfo -> UTCTime
txIns :: forall t. DefineTx t => Set (Tx t) -> Set TxIn

-- | True if the given tuple refers to a pending transaction
isPending :: TxMeta -> Bool

-- | Representation of Cardano addresses. Addresses are basically a
--   human-friendly representation of public keys. Historically in Cardano,
--   there exists different sort of addresses, and new ones are to come. So
--   far, we can distinguish between three types of addresses:
--   
--   <ul>
--   <li>Byron Random addresses, which holds a payload with derivation path
--   details</li>
--   <li>Byron Sequential addresses, also known as Icarus'style
--   addresses</li>
--   <li>Shelley base addresses, see also
--   <a>implementation-decisions/address</a></li>
--   </ul>
--   
--   For more details, see also <a>About Address Derivation</a>
--   
--   Shelley base addresses can be declined into two types:
--   
--   <ul>
--   <li>Single Addresses: which only holds a public spending key</li>
--   <li>Group Addresses: which hold both a spending and delegation
--   keys</li>
--   </ul>
--   
--   It'll therefore seem legitimate to represent addresses as:
--   
--   <pre>
--   data Address
--     = ByronAddress !ByteString
--     | SingleAddress !XPub
--     | GroupAddress !XPub XPub
--   </pre>
--   
--   However, there's a major drawback to this approach: we have to
--   consider all three constructors everywhere, and make sure we test
--   every function using them three despite having no need for such
--   fine-grained representation.
--   
--   Indeed, from the wallet core code, addresses are nothing more than an
--   opaque bunch of bytes that can be compared with each others. When
--   signing transactions, we have to lookup addresses anyway and
--   therefore, can re-derive their corresponding public keys. The only
--   moment the distinction between address type matters is when it comes
--   to representing addresses at the edge of the application (the API
--   layer). And here, this is precisely where we need to also what target
--   backend we're connected to. Different backends use different encodings
--   which may not be compatible.
--   
--   Therefore, for simplicity, it's easier to consider addresses as
--   "bytes", and only peak into these bytes whenever we need to do
--   something with them. This makes it fairly clear that addresses are
--   just an opaque string for the wallet layer and that the underlying
--   encoding is rather agnostic to the underlying backend.
newtype Address
Address :: ByteString -> Address
[$sel:unAddress:Address] :: Address -> ByteString

-- | Denotes if an address has been previously used or not... whether that
--   be in the output of a transaction on the blockchain or one in our
--   pending set.
data AddressState
Used :: AddressState
Unused :: AddressState

-- | An abstract class to allow encoding of addresses depending on the
--   target backend used.
class EncodeAddress t
encodeAddress :: EncodeAddress t => Proxy t -> Address -> Text

-- | An abstract class to allow decoding of addresses depending on the
--   target backend used.
class DecodeAddress t
decodeAddress :: DecodeAddress t => Proxy t -> Text -> Either TextDecodingError Address

-- | Coins are stored as Lovelace (reminder: 1 Lovelace = 1e6 ADA)
newtype Coin
Coin :: Word64 -> Coin
[$sel:getCoin:Coin] :: Coin -> Word64
isValidCoin :: Coin -> Bool
newtype UTxO
UTxO :: Map TxIn TxOut -> UTxO
[$sel:getUTxO:UTxO] :: UTxO -> Map TxIn TxOut

-- | Compute the balance of a UTxO
balance :: UTxO -> Natural

-- | Compute the balance of a unwrapped UTxO
balance' :: [(TxIn, TxOut)] -> Word64

-- | Pick a random element from a UTxO, returns <a>Nothing</a> if the UTxO
--   is empty. Otherwise, returns the selected entry and, the UTxO minus
--   the selected one.
pickRandom :: MonadRandom m => UTxO -> m (Maybe (TxIn, TxOut), UTxO)

-- | ins⋪ u
excluding :: UTxO -> Set TxIn -> UTxO

-- | a ⊆ b
isSubsetOf :: UTxO -> UTxO -> Bool

-- | ins⊲ u
restrictedBy :: UTxO -> Set TxIn -> UTxO

-- | u ⊳ outs
restrictedTo :: UTxO -> Set TxOut -> UTxO

-- | Allows us to define the "domain" of any type — <tt>UTxO</tt> in
--   particular — and use <a>dom</a> to refer to the <i>inputs</i> of an
--   <i>utxo</i>.
--   
--   This is the terminology used in the <a>Formal Specification for a
--   Cardano Wallet</a> uses.
class Dom a where {
    type family DomElem a :: *;
}
dom :: Dom a => a -> Set (DomElem a)
data UTxOStatistics
UTxOStatistics :: ![HistogramBar] -> !Word64 -> BoundType -> UTxOStatistics
[$sel:histogram:UTxOStatistics] :: UTxOStatistics -> ![HistogramBar]
[$sel:allStakes:UTxOStatistics] :: UTxOStatistics -> !Word64
[$sel:boundType:UTxOStatistics] :: UTxOStatistics -> BoundType
data HistogramBar
HistogramBar :: !Word64 -> !Word64 -> HistogramBar
[$sel:bucketUpperBound:HistogramBar] :: HistogramBar -> !Word64
[$sel:bucketCount:HistogramBar] :: HistogramBar -> !Word64
data BoundType

-- | Compute UtxoStatistics from UTxOs
computeUtxoStatistics :: BoundType -> UTxO -> UTxOStatistics

-- | Smart-constructor to create bounds using a log-10 scale
log10 :: BoundType

-- | A slot identifier is the combination of an epoch and slot.
data SlotId
SlotId :: !Word64 -> !Word16 -> SlotId
[$sel:epochNumber:SlotId] :: SlotId -> !Word64
[$sel:slotNumber:SlotId] :: SlotId -> !Word16

-- | The essential parameters necessary for performing slot arithmetic.
data SlotParameters
SlotParameters :: EpochLength -> SlotLength -> StartTime -> SlotParameters
[$sel:getEpochLength:SlotParameters] :: SlotParameters -> EpochLength
[$sel:getSlotLength:SlotParameters] :: SlotParameters -> SlotLength
[$sel:getGenesisBlockDate:SlotParameters] :: SlotParameters -> StartTime

-- | Duration of a single slot.
newtype SlotLength
SlotLength :: NominalDiffTime -> SlotLength

-- | Number of slots in a single epoch
newtype EpochLength
EpochLength :: Word16 -> EpochLength

-- | Blockchain start time
newtype StartTime
StartTime :: UTCTime -> StartTime

-- | Compute the approximate ratio / progress between two slots. This is an
--   approximation for a few reasons, one of them being that we hard code
--   the epoch length as a static number whereas it may vary in practice.
slotRatio :: EpochLength -> SlotId -> SlotId -> Quantity "percent" Percentage

-- | Convert a <a>SlotId</a> to the number of slots since genesis.
flatSlot :: EpochLength -> SlotId -> Word64

-- | Convert a <a>flatSlot</a> index to <a>SlotId</a>.
fromFlatSlot :: EpochLength -> Word64 -> SlotId

-- | The time that a slot begins.
slotStartTime :: SlotParameters -> SlotId -> UTCTime

-- | For the given time <tt>t</tt>, determine the ID of the earliest slot
--   with start time <tt>s</tt> such that 't ≤ s'.
slotCeiling :: SlotParameters -> UTCTime -> SlotId

-- | For the given time <tt>t</tt>, determine the ID of the latest slot
--   with start time <tt>s</tt> such that 's ≤ t'.
slotFloor :: SlotParameters -> UTCTime -> Maybe SlotId

-- | For the given time <tt>t</tt>, determine the ID of the unique slot
--   with start time <tt>s</tt> and end time <tt>e</tt> such that 's ≤ t ≤
--   e'.
slotAt :: SlotParameters -> UTCTime -> Maybe SlotId

-- | <tt>slotDifference a b</tt> is how many slots <tt>a</tt> is after
--   <tt>b</tt>. The result is non-negative, and if <tt>b &gt; a</tt> then
--   this function returns zero.
slotDifference :: SlotParameters -> SlotId -> SlotId -> Quantity "slot" Natural

-- | Returns the earliest slot.
slotMinBound :: SlotId

-- | Return the slot immediately before the given slot.
slotPred :: SlotParameters -> SlotId -> Maybe SlotId

-- | Return the slot immediately after the given slot.
slotSucc :: SlotParameters -> SlotId -> SlotId

-- | Transforms the given inclusive time range into an inclusive slot
--   range.
--   
--   This function returns a slot range if (and only if) the specified time
--   range intersects with the life of the blockchain.
--   
--   If, on the other hand, the specified time range terminates before the
--   start of the blockchain, this function returns <a>Nothing</a>.
slotRangeFromTimeRange :: SlotParameters -> Range UTCTime -> Maybe (Range SlotId)

-- | Additional information about a wallet that can't simply be derived
--   from the blockchain like <tt>Wallet s t</tt> is.
--   
--   Whereas <tt>Wallet s t</tt> in <a>Primitive</a> can be updated using
--   <tt>applyBlock</tt>, <tt>WalletMetadata</tt> is not*.
--   
--   <ul>
--   <li>) Except for possibly <a>WalletMetadata</a> and
--   <a>$sel:delegation:WalletMetadata</a>...</li>
--   </ul>
data WalletMetadata
WalletMetadata :: !WalletName -> !UTCTime -> !Maybe WalletPassphraseInfo -> !WalletState -> !WalletDelegation PoolId -> WalletMetadata
[$sel:name:WalletMetadata] :: WalletMetadata -> !WalletName
[$sel:creationTime:WalletMetadata] :: WalletMetadata -> !UTCTime
[$sel:passphraseInfo:WalletMetadata] :: WalletMetadata -> !Maybe WalletPassphraseInfo
[$sel:status:WalletMetadata] :: WalletMetadata -> !WalletState
[$sel:delegation:WalletMetadata] :: WalletMetadata -> !WalletDelegation PoolId
newtype WalletId
WalletId :: Digest Blake2b_160 -> WalletId
[$sel:getWalletId:WalletId] :: WalletId -> Digest Blake2b_160

-- | Length-restricted name of a wallet
newtype WalletName
WalletName :: Text -> WalletName
[$sel:getWalletName:WalletName] :: WalletName -> Text

-- | Calling 'fromText @WalletName' on shorter longer string will fail.
walletNameMinLength :: Int

-- | Calling 'fromText @WalletName' on a longer string will fail.
walletNameMaxLength :: Int
data WalletState
Ready :: WalletState
Restoring :: !Quantity "percent" Percentage -> WalletState
data WalletDelegation poolId
NotDelegating :: WalletDelegation poolId
Delegating :: !poolId -> WalletDelegation poolId
newtype WalletPassphraseInfo
WalletPassphraseInfo :: UTCTime -> WalletPassphraseInfo
[$sel:lastUpdatedAt:WalletPassphraseInfo] :: WalletPassphraseInfo -> UTCTime
data WalletBalance
WalletBalance :: !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> WalletBalance
[$sel:available:WalletBalance] :: WalletBalance -> !Quantity "lovelace" Natural
[$sel:total:WalletBalance] :: WalletBalance -> !Quantity "lovelace" Natural

-- | Represent stake pool identifier. Note that the internal representation
--   is left open currently, until we figure out a better type for those.
newtype PoolId
PoolId :: Text -> PoolId
[$sel:getPoolId:PoolId] :: PoolId -> Text

-- | Represents a sort order, applicable to the results returned by a
--   query.
data SortOrder

-- | Sort in ascending order.
Ascending :: SortOrder

-- | Sort in descending order.
Descending :: SortOrder

-- | Represents a range of values.
--   
--   A range is defined by two <i>optional</i> bounds:
--   
--   <ol>
--   <li>an <i>inclusive</i> lower bound</li>
--   <li>an <i>inclusive</i> upper bound</li>
--   </ol>
--   
--   There are four cases:
--   
--   TODO: table
data Range a
Range :: Maybe a -> Maybe a -> Range a
[$sel:inclusiveLowerBound:Range] :: Range a -> Maybe a
[$sel:inclusiveUpperBound:Range] :: Range a -> Maybe a

-- | Represents a range boundary.
data RangeBound a
NegativeInfinity :: RangeBound a
InclusiveBound :: a -> RangeBound a
PositiveInfinity :: RangeBound a

-- | The range that includes everything.
wholeRange :: Range a

-- | Returns <a>True</a> if (and only if) the given range has an upper
--   bound and the specified value is greater than the upper bound.
isAfterRange :: Ord a => a -> Range a -> Bool

-- | Returns <a>True</a> if (and only if) the given range has a lower bound
--   and the specified value is smaller than the lower bound.
isBeforeRange :: Ord a => a -> Range a -> Bool

-- | Returns <a>True</a> if (and only if) the first given range is a
--   subrange of the second given range.
isSubrangeOf :: Ord a => Range a -> Range a -> Bool

-- | Returns <a>True</a> if (and only if) the given value is not smaller
--   than the lower bound (if present) of the given range and is not
--   greater than the upper bound (if present) of the given range.
isWithinRange :: Ord a => a -> Range a -> Bool

-- | Apply a function to the lower bound of a range.
mapRangeLowerBound :: (a -> a) -> Range a -> Range a

-- | Apply a function to the upper bound of a range.
mapRangeUpperBound :: (a -> a) -> Range a -> Range a

-- | Returns <a>True</a> if (and only if) the given range has both a lower
--   and upper bound.
rangeIsFinite :: Range a -> Bool

-- | Returns <a>True</a> if (and only if) the range covers exactly one
--   value.
rangeIsSingleton :: Eq a => Range a -> Bool

-- | Returns <a>True</a> if (and only if) the lower bound of a range is not
--   greater than its upper bound.
rangeIsValid :: Ord a => Range a -> Bool

-- | Returns <a>True</a> if (and only if) the given range has a lower
--   bound.
rangeHasLowerBound :: Range a -> Bool

-- | Returns <a>True</a> if (and only if) the given range has an upper
--   bound.
rangeHasUpperBound :: Range a -> Bool

-- | Get the lower bound of a <a>Range</a>.
rangeLowerBound :: Range a -> RangeBound a

-- | Get the upper bound of a <a>Range</a>.
rangeUpperBound :: Range a -> RangeBound a

-- | Magic constant associated to a given network
newtype ProtocolMagic
ProtocolMagic :: Int32 -> ProtocolMagic
newtype Hash (tag :: Symbol)
Hash :: ByteString -> Hash
[$sel:getHash:Hash] :: Hash -> ByteString

-- | A polymorphic wrapper type with a custom show instance to display data
--   through <a>Buildable</a> instances.
newtype ShowFmt a
ShowFmt :: a -> ShowFmt a

-- | Checks whether or not an invariant holds, by applying the given
--   predicate to the given value.
--   
--   If the invariant does not hold (indicated by the predicate function
--   returning <a>False</a>), throws an error with the specified message.
--   
--   <pre>
--   &gt;&gt;&gt; invariant "not empty" [1,2,3] (not . null)
--   [1, 2, 3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; invariant "not empty" [] (not . null)
--   *** Exception: not empty
--   </pre>
invariant :: String -> a -> (a -> Bool) -> a

-- | Compute distance between two numeric values |a - b|
distance :: (Ord a, Num a) => a -> a -> a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.Block tx)
instance GHC.Classes.Ord tx => GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.Block tx)
instance GHC.Classes.Eq tx => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.Block tx)
instance GHC.Show.Show tx => GHC.Show.Show (Cardano.Wallet.Primitive.Types.Block tx)
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TransactionInfo
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TransactionInfo
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TransactionInfo
instance GHC.Base.Monoid Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TxIn
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxIn
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TxIn
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxIn
instance GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.Hash tag)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.Hash tag)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.Hash tag)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Types.Hash tag)
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.ProtocolMagic
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.ProtocolMagic
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SlotParameters
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SlotParameters
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SlotParameters
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.StartTime
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.StartTime
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.StartTime
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.EpochLength
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.EpochLength
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SlotLength
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SlotLength
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TxMeta
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TxMeta
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxMeta
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxMeta
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.UTxOStatistics
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.UTxOStatistics
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UTxOStatistics
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.BoundType
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.BoundType
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.BoundType
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.BoundType
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.HistogramBar
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.HistogramBar
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.HistogramBar
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.HistogramBar
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TxOut
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxOut
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TxOut
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxOut
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Coin
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Coin
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Coin
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Coin
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.AddressState
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.AddressState
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.AddressState
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.AddressState
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.AddressState
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Address
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Address
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Address
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Address
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TxWitness
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxWitness
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxWitness
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Direction
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Direction
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Direction
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.Direction
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.Direction
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Direction
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletMetadata
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletMetadata
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletMetadata
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.RangeBound a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.RangeBound a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Primitive.Types.Range a)
instance GHC.Base.Functor Cardano.Wallet.Primitive.Types.Range
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.Range a)
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletBalance
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletBalance
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletBalance
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletPassphraseInfo
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.WalletPassphraseInfo
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletPassphraseInfo
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletPassphraseInfo
instance GHC.Show.Show poolId => GHC.Show.Show (Cardano.Wallet.Primitive.Types.WalletDelegation poolId)
instance GHC.Classes.Eq poolId => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.WalletDelegation poolId)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.WalletDelegation poolId)
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletState
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletState
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletState
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletName
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletName
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletName
instance GHC.Base.Functor Cardano.Wallet.Primitive.Types.WalletDelegation
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance Formatting.Buildable.Buildable a => GHC.Show.Show (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance (Formatting.Buildable.Buildable a, Data.Foldable.Foldable f) => GHC.Show.Show (Cardano.Wallet.Primitive.Types.ShowFmt (f a))
instance Control.DeepSeq.NFData tx => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Types.Block tx)
instance Formatting.Buildable.Buildable tx => Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.Block tx)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.BlockHeader
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.BlockHeader
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.UTxO
instance Cardano.Wallet.Primitive.Types.Dom Cardano.Wallet.Primitive.Types.UTxO
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.UTxO
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TxIn
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TxIn
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.TxIn, Cardano.Wallet.Primitive.Types.TxOut)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Types.Hash tag)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.Hash "BlockHeader")
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.Hash "Tx")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash "Tx")
instance Data.Text.Class.ToText (Cardano.Wallet.Primitive.Types.Hash "Tx")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash "BlockHeader")
instance Data.Text.Class.ToText (Cardano.Wallet.Primitive.Types.Hash "BlockHeader")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash "Genesis")
instance Data.Text.Class.ToText (Cardano.Wallet.Primitive.Types.Hash "Genesis")
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TxMeta
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TxMeta
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.SlotId
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UTxOStatistics
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.HistogramBar
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TxOut
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TxOut
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Coin
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.Coin
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Coin
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.AddressState
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.AddressState
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Address
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Address
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.Address
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.Address
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Direction
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Direction
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.Direction
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.Direction
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TxStatus
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TxStatus
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.TxStatus
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.TxStatus
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletMetadata
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletMetadata
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.PoolId
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.PoolId
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.SortOrder
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.SortOrder
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletPassphraseInfo
instance Control.DeepSeq.NFData poolId => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Types.WalletDelegation poolId)
instance Formatting.Buildable.Buildable poolId => Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.WalletDelegation poolId)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletState
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.WalletState
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletState
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletId
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.WalletId
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.WalletId
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletId
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletName
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.WalletName
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.WalletName
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletName

module Cardano.Wallet.Unsafe

-- | Decode an hex-encoded <a>ByteString</a> into raw bytes, or fail.
unsafeFromHex :: HasCallStack => ByteString -> ByteString

-- | Decode a bech32-encoded <a>Text</a> into an <a>Address</a>, or fail.
unsafeDecodeAddress :: (HasCallStack, DecodeAddress t) => Proxy t -> Text -> Address

-- | Run a decoder on a hex-encoded <a>ByteString</a>, or fail.
unsafeDecodeHex :: HasCallStack => Get a -> ByteString -> a

-- | Run an <a>ExceptT</a> and throws the error if any. This makes sense
--   only if called after checking for an invariant or, after ensuring that
--   preconditions for meeting the underlying error have been discarded.
unsafeRunExceptT :: (MonadFail m, Show e) => ExceptT e m a -> m a

-- | Build a <a>XPrv</a> from an hex-encoded bytestring
unsafeXPrv :: HasCallStack => ByteString -> XPrv

-- | Build <a>Mnemonic</a> from literals
unsafeMkMnemonic :: forall mw n csz. (ConsistentEntropy n mw csz, EntropySize mw ~ n, HasCallStack) => [Text] -> Mnemonic mw

-- | CBOR deserialise without error handling - handy for prototypes or
--   testing.
unsafeDeserialiseCbor :: HasCallStack => (forall s. Decoder s a) -> ByteString -> a


-- | Provides the API of Coin Selection algorithm and Fee Calculation This
--   module contains the implementation of adjusting coin selection for a
--   fee. The sender pays for the fee and additional inputs are picked
--   randomly. For more information refer to:
--   <a>https://iohk.io/blog/self-organisation-in-coin-selection/</a>
module Cardano.Wallet.Primitive.CoinSelection
data CoinSelection
CoinSelection :: [(TxIn, TxOut)] -> [TxOut] -> [Coin] -> CoinSelection

-- | Picked inputs
[inputs] :: CoinSelection -> [(TxIn, TxOut)]

-- | Picked outputs
[outputs] :: CoinSelection -> [TxOut]

-- | Resulting changes
[change] :: CoinSelection -> [Coin]
data ErrCoinSelection e

-- | UTxO exhausted during input selection We record the balance of the
--   UTxO as well as the size of the payment we tried to make.
ErrNotEnoughMoney :: Word64 -> Word64 -> ErrCoinSelection e

-- | UTxO is not enough fragmented for the number of transaction outputs We
--   record the number of UTxO entries as well as the number of the outputs
--   of the transaction.
ErrUtxoNotEnoughFragmented :: Word64 -> Word64 -> ErrCoinSelection e

-- | When trying to construct a transaction, the max number of allowed
--   inputs was reached.
ErrMaximumInputsReached :: Word64 -> ErrCoinSelection e

-- | When trying to construct a transaction, the available inputs are
--   depleted even when UTxO is properly fragmented and with enough funds
--   to cover payment
ErrInputsDepleted :: ErrCoinSelection e

-- | Somewhat, we ended up generating an invalid coin selection because of
--   inputs passed down to the coin selection function, or because a target
--   backend has extra-limitations not covered by our coin selection
--   algorithm.
ErrInvalidSelection :: e -> ErrCoinSelection e
data CoinSelectionOptions e
CoinSelectionOptions :: (Word8 -> Word8) -> (CoinSelection -> Either e ()) -> CoinSelectionOptions e

-- | Maximum number of inputs allowed for a given number of outputs
[maximumNumberOfInputs] :: CoinSelectionOptions e -> Word8 -> Word8

-- | Returns any backend-specific error regarding coin selection
[validate] :: CoinSelectionOptions e -> CoinSelection -> Either e ()

-- | Shuffles a list of elements.
--   
--   <pre>
--   &gt;&gt;&gt; shuffle (outputs coinSel)
--   [...]
--   </pre>
shuffle :: [a] -> IO [a]
instance GHC.Classes.Eq e => GHC.Classes.Eq (Cardano.Wallet.Primitive.CoinSelection.ErrCoinSelection e)
instance GHC.Show.Show e => GHC.Show.Show (Cardano.Wallet.Primitive.CoinSelection.ErrCoinSelection e)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.CoinSelection.CoinSelectionOptions e)
instance GHC.Classes.Eq Cardano.Wallet.Primitive.CoinSelection.CoinSelection
instance GHC.Show.Show Cardano.Wallet.Primitive.CoinSelection.CoinSelection
instance GHC.Generics.Generic Cardano.Wallet.Primitive.CoinSelection.CoinSelection
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.CoinSelection.CoinSelection
instance GHC.Base.Monoid Cardano.Wallet.Primitive.CoinSelection.CoinSelection
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.CoinSelection.CoinSelection


-- | This module contains the implementation of largestFirst input
--   selection algorithm
module Cardano.Wallet.Primitive.CoinSelection.LargestFirst

-- | Largest-first input selection policy
largestFirst :: forall m e. Monad m => CoinSelectionOptions e -> NonEmpty TxOut -> UTxO -> ExceptT (ErrCoinSelection e) m (CoinSelection, UTxO)


-- | This module contains the implementation of random input selection
--   algorithm
module Cardano.Wallet.Primitive.CoinSelection.Random

-- | Random-Improve Algorithm
--   
--   <ol>
--   <li>Randomly select outputs from the UTxO until the payment value is
--   covered. (In the rare case that this fails because the maximum number
--   of transaction inputs has been exceeded, fall back on the
--   largest-first algorithm for this step.)</li>
--   <li>The algorithm first makes a random selection for each output from
--   the UTxO, processing the biggest output first and proceeding in a
--   descending order. If the selection is not successful largest-first
--   fallback kicks in. If the selection is successful for each output then
--   the improvement is tried for each selection, once again starting from
--   the selection made for the biggest output. The improvement is tried
--   for the next biggest output's selection. An output is considered an
--   improvement when:</li>
--   </ol>
--   
--   (a) It doesn’t exceed a specified upper limit. (b) Adding the new
--   output gets us closer to the ideal change value. (c) It doesn’t exceed
--   a maximum number of transaction inputs.
--   
--   This algorithm follows three principles:
--   
--   <pre>
--   **Self organisation principle 1**
--   Random selection has a high probability of picking dust outputs precisely
--   when there is a lot of dust in the UTxO.
--   </pre>
--   
--   <pre>
--   **Self organisation principle 2**
--   If for each payment request for value <tt>x</tt> we create a change output roughly
--   of the same value <tt>x</tt>, then we will end up with a lot of change outputs in
--   our UTxO of size <tt>x</tt> precisely when we have a lot of payment requests of
--   size <tt>x</tt>
--   </pre>
--   
--   <pre>
--   **Self organisation principle 3**
--   Searching the UTxO for additional entries to improve our change output is
--   only useful if the UTxO contains entries that are sufficiently small enough.
--   But precisely when the UTxO contains many small entries, it is less likely
--   that a randomly chosen UTxO entry will push the total above the upper bound
--   we set.
--   </pre>
random :: forall m e. MonadRandom m => CoinSelectionOptions e -> NonEmpty TxOut -> UTxO -> ExceptT (ErrCoinSelection e) m (CoinSelection, UTxO)


-- | Primitives for performing address derivation for some given schemes.
--   This is where most of the crypto happens in the wallet and, it is
--   quite important to ensure that the implementations match with other
--   Cardano wallets (like cardano-sl, Yoroi/Icarus, or cardano-cli)
--   
--   The actual implementations are in the following modules:
--   
--   <ul>
--   <li><a>Cardano.Wallet.Primitive.AddressDerivation.Sequential</a></li>
--   <li><a>Cardano.Wallet.Primitive.AddressDerivation.Random</a></li>
--   </ul>
module Cardano.Wallet.Primitive.AddressDerivation

-- | Key Depth in the derivation path, according to BIP-0039 / BIP-0044
--   
--   <pre>
--   m | purpose' | cointype' | account' | change | address
--   </pre>
--   
--   We do not manipulate purpose, cointype and change paths directly, so
--   they are left out of the sum type.
data Depth
RootK :: Depth
AccountK :: Depth
AddressK :: Depth

-- | A derivation index, with phantom-types to disambiguate derivation
--   type.
--   
--   <pre>
--   let accountIx = Index 'Hardened 'AccountK
--   let addressIx = Index 'Soft 'AddressK
--   </pre>
newtype Index (derivationType :: DerivationType) (level :: Depth)
Index :: Word32 -> Index
[getIndex] :: Index -> Word32

-- | Type of derivation that should be used with the given indexes.
data DerivationType
Hardened :: DerivationType
Soft :: DerivationType
data XPub
data XPrv

-- | Encoding of addresses for certain key types and backend targets.
class WalletKey key => KeyToAddress target (key :: Depth -> * -> *)

-- | Convert a public key to an <a>Address</a> depending on a particular
--   target.
--   
--   Note that <a>keyToAddress</a> is ambiguous and requires therefore a
--   type application. See also <tt>TxId</tt>.
keyToAddress :: KeyToAddress target key => key  'AddressK XPub -> Address
class WalletKey (key :: Depth -> * -> *)

-- | Re-encrypt a private key using a different passphrase.
--   
--   <ul>
--   <li>*Important**: This function doesn't check that the old passphrase
--   is correct! Caller is expected to have already checked that. Using an
--   incorrect passphrase here will lead to very bad thing.</li>
--   </ul>
changePassphrase :: WalletKey key => Passphrase "encryption-old" -> Passphrase "encryption-new" -> key depth XPrv -> key depth XPrv

-- | Extract the public key part of a private key.
publicKey :: WalletKey key => key depth XPrv -> key depth XPub

-- | Hash a public key to some other representation.
digest :: (WalletKey key, HashAlgorithm a) => key depth XPub -> Digest a

-- | Unwrap the <a>WalletKey</a> to use the <a>XPrv</a> or <a>XPub</a>.
getRawKey :: WalletKey key => key depth raw -> raw

-- | Produce a fake address key of this scheme, for use in
--   <a>dummyAddress</a>.
dummyKey :: WalletKey key => key  'AddressK XPub

-- | Operations for saving a <a>WalletKey</a> into a database, and
--   restoring it from a database. The keys should be encoded in
--   hexadecimal strings.
class WalletKey key => PersistKey (key :: Depth -> * -> *)

-- | Convert a private key and its password hash into hexadecimal strings
--   suitable for storing in a text file or database column.
serializeXPrv :: PersistKey key => (key  'RootK XPrv, Hash "encryption") -> (ByteString, ByteString)

-- | The reverse of <a>serializeXPrv</a>. This may fail if the inputs are
--   not valid hexadecimal strings, or if the key is of the wrong length.
deserializeXPrv :: PersistKey key => (ByteString, ByteString) -> Either String (key  'RootK XPrv, Hash "encryption")

-- | Produce a fake address of representative size for the target and key
--   type. This can be used in transaction size estimations.
--   
--   This function is ambiguous, like <a>keyToAddress</a>, and types need
--   to be applied.
dummyAddress :: forall target key. KeyToAddress target key => Address

-- | An encapsulated passphrase. The inner format is free, but the wrapper
--   helps readability in function signatures.
newtype Passphrase (purpose :: Symbol)
Passphrase :: ScrubbedBytes -> Passphrase
class PassphraseMinLength (purpose :: Symbol)

-- | Minimal Length for a passphrase, for lack of better validations
passphraseMinLength :: PassphraseMinLength purpose => Proxy purpose -> Int
class PassphraseMaxLength (purpose :: Symbol)

-- | Maximum length for a passphrase
passphraseMaxLength :: PassphraseMaxLength purpose => Proxy purpose -> Int

-- | Create a passphrase from a mnemonic sentence. This class enables
--   caller to parse text list of variable length into mnemonic sentences.
--   
--   <pre>
--   &gt;&gt;&gt; fromMnemonic @'[12,15,18,21] @"generation" ["toilet", "curse", ... ]
--   Right (Passphrase &lt;ScrubbedBytes&gt;)
--   </pre>
--   
--   Note that the given <a>Nat</a>s **have** to be valid mnemonic sizes,
--   otherwise the underlying code won't even compile, with not-so-friendly
--   error messages.
class FromMnemonic (sz :: [Nat]) (purpose :: Symbol)
fromMnemonic :: FromMnemonic sz purpose => [Text] -> Either (FromMnemonicError sz) (Passphrase purpose)

-- | Error reported from trying to create a passphrase from a given
--   mnemonic
newtype FromMnemonicError (sz :: [Nat])
FromMnemonicError :: String -> FromMnemonicError
[getFromMnemonicError] :: FromMnemonicError -> String

-- | Indicate a failure when checking for a given <a>Passphrase</a> match
data ErrWrongPassphrase
ErrWrongPassphrase :: ErrWrongPassphrase

-- | Encrypt a <a>Passphrase</a> into a format that is suitable for storing
--   on disk
encryptPassphrase :: MonadRandom m => Passphrase purpose -> m (Hash purpose)

-- | Check whether a <a>Passphrase</a> matches with a stored <a>Hash</a>
checkPassphrase :: Passphrase purpose -> Hash purpose -> Either ErrWrongPassphrase ()
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDerivation.ErrWrongPassphrase
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDerivation.ErrWrongPassphrase
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.AddressDerivation.FromMnemonicError sz)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.FromMnemonicError sz)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.FromMnemonicError sz)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance GHC.Base.Monoid (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance GHC.Base.Semigroup (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance GHC.Classes.Ord (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz, Cardano.Wallet.Primitive.AddressDerivation.FromMnemonic rest purpose, Cardano.Wallet.Primitive.AddressDerivation.NatVals rest) => Cardano.Wallet.Primitive.AddressDerivation.FromMnemonic (mw : rest) purpose
instance Cardano.Wallet.Primitive.AddressDerivation.NatVals '[]
instance (GHC.TypeNats.KnownNat n, Cardano.Wallet.Primitive.AddressDerivation.NatVals rest) => Cardano.Wallet.Primitive.AddressDerivation.NatVals (n : rest)
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz) => Cardano.Wallet.Primitive.AddressDerivation.FromMnemonic '[mw] purpose
instance Cardano.Wallet.Primitive.AddressDerivation.PassphraseMaxLength "encryption"
instance Cardano.Wallet.Primitive.AddressDerivation.PassphraseMaxLength "encryption-old"
instance Cardano.Wallet.Primitive.AddressDerivation.PassphraseMaxLength "encryption-new"
instance (Cardano.Wallet.Primitive.AddressDerivation.PassphraseMaxLength purpose, Cardano.Wallet.Primitive.AddressDerivation.PassphraseMinLength purpose) => Data.Text.Class.FromText (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance Cardano.Wallet.Primitive.AddressDerivation.PassphraseMinLength "encryption"
instance Cardano.Wallet.Primitive.AddressDerivation.PassphraseMinLength "encryption-old"
instance Cardano.Wallet.Primitive.AddressDerivation.PassphraseMinLength "encryption-new"
instance Data.Text.Class.ToText (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance Crypto.Random.Types.MonadRandom ((->) (Cardano.Wallet.Primitive.AddressDerivation.Passphrase "salt"))
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Enum.Bounded (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Hardened level)
instance GHC.Enum.Bounded (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Soft level)
instance GHC.Enum.Enum (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Hardened level)
instance GHC.Enum.Enum (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Soft level)


-- | An extra interface for operation on transactions (e.g. creating
--   witnesses, estimating size...). This makes it possible to decouple
--   those operations from our wallet layer, keeping the implementation
--   flexible to various backends.
module Cardano.Wallet.Transaction
data TransactionLayer t k
TransactionLayer :: ((Address -> Maybe (k  'AddressK XPrv, Passphrase "encryption")) -> [(TxIn, TxOut)] -> [TxOut] -> Either ErrMkStdTx (Tx t, [TxWitness])) -> (CoinSelection -> Quantity "byte" Int) -> (Quantity "byte" Word16 -> Word8 -> Word8) -> (CoinSelection -> Either (ErrValidateSelection t) ()) -> TransactionLayer t k

-- | Construct a standard transaction
--   
--   " Standard " here refers to the fact that we do not deal with
--   redemption, multisignature transactions, etc.
--   
--   This expects as a first argument a mean to compute or lookup private
--   key corresponding to a particular address.
[mkStdTx] :: TransactionLayer t k -> (Address -> Maybe (k  'AddressK XPrv, Passphrase "encryption")) -> [(TxIn, TxOut)] -> [TxOut] -> Either ErrMkStdTx (Tx t, [TxWitness])

-- | Estimate the size of a <a>CoinSelection</a>, in bytes. This operation
--   is seemingly coupled to the binary representation of a
--   <tt>Transaction</tt>. This estimation is therefore only a best-effort
--   here as many of the encoding values actually depends on the value of
--   parameters at runtime.
--   
--   For instance, with a CBOR encoding, an amount of `50` lovelace would
--   be encoded using 2 bytes, whereas an amount of `1000000` would be
--   encoded using 4 bytes. In Byron, we have only one piece of unknown
--   from the <a>CoinSelection</a> and it's the value of the <tt>crc32</tt>
--   computed on the address payload, which can be 1,2,3 or 5 bytes and we
--   therefore always consider the worst-case scenario of a 5-byte crc. As
--   a consequence, our estimate may be slightly bigger than the actual
--   transaction fee (up-to 4 extra bytes per change output).
[estimateSize] :: TransactionLayer t k -> CoinSelection -> Quantity "byte" Int

-- | Calculate a "theoretical" maximum number of inputs given a maximum
--   transaction size and desired number of outputs.
--   
--   The actual transaction size cannot be known until it has been fully
--   determined by coin selection.
--   
--   This estimate will err on the side of permitting more inputs,
--   resulting in a transaction which may be too large.
[estimateMaxNumberOfInputs] :: TransactionLayer t k -> Quantity "byte" Word16 -> Word8 -> Word8

-- | Validate coin selection regarding rules that may be specific to a
--   particular backend implementation.
--   
--   For example, Byron nodes do not allow null output amounts. Jörmungandr
--   on its side doesn't support more than 255 inputs or outputs.
[validateSelection] :: TransactionLayer t k -> CoinSelection -> Either (ErrValidateSelection t) ()

-- | Possible signing error
newtype ErrMkStdTx

-- | We tried to sign a transaction with inputs that are unknown to us?
ErrKeyNotFoundForAddress :: Address -> ErrMkStdTx

-- | A type family for validations that are specific to a particular
--   backend type. This demands an instantiation of the family for a
--   particular backend:
--   
--   type instance (ErrValidateSelection MyBackend) = MyCustomError
type family ErrValidateSelection t

-- | This is called by the <a>TransactionLayer</a> implementation. It uses
--   the serialization functions to calculate the size of an empty
--   transaction compared to a transaction with one input. The estimation
--   is based on that.
--   
--   It doesn't account for transaction outputs, and assumes there is a
--   single Tx output.
--   
--   All the values used are the smaller ones. For example, the shortest
--   adress type and shortest witness type are chosen to use for the
--   estimate.
estimateMaxNumberOfInputsBase :: forall t k. KeyToAddress t k => EstimateMaxNumberOfInputsParams t -> Quantity "byte" Word16 -> Word8 -> Word8

-- | Backend-specific variables used by
--   <a>estimateMaxNumberOfInputsBase</a>.
data EstimateMaxNumberOfInputsParams t
EstimateMaxNumberOfInputsParams :: ([TxIn] -> [TxOut] -> [TxWitness] -> Int) -> Int -> Int -> EstimateMaxNumberOfInputsParams t

-- | Finds the size of a serialized transaction.
[estMeasureTx] :: EstimateMaxNumberOfInputsParams t -> [TxIn] -> [TxOut] -> [TxWitness] -> Int

-- | Block ID size
[estBlockHashSize] :: EstimateMaxNumberOfInputsParams t -> Int

-- | Tx Witness size
[estTxWitnessSize] :: EstimateMaxNumberOfInputsParams t -> Int
instance GHC.Show.Show Cardano.Wallet.Transaction.ErrMkStdTx
instance GHC.Classes.Eq Cardano.Wallet.Transaction.ErrMkStdTx


-- | This module contains types for address discovery. The two address
--   discovery schemes implemented are:
--   
--   <ul>
--   <li><a>Cardano.Wallet.Primitive.AddressDiscovery.Sequential</a></li>
--   <li><a>Cardano.Wallet.Primitive.AddressDiscovery.Random</a></li>
--   </ul>
module Cardano.Wallet.Primitive.AddressDiscovery

-- | This abstraction exists to give us the ability to keep the wallet
--   business logic agnostic to the address derivation and discovery
--   mechanisms.
--   
--   This is needed because two different address schemes lives on Cardano:
--   
--   <ul>
--   <li>A hierarchical random scheme: rather <tt>custom</tt> made, with
--   several flaws; this is the original and now legacy address
--   scheme.</li>
--   <li>A hierarchical sequential scheme: a new scheme based on the
--   BIP-0044 specification, which is better suited for our present
--   needs.</li>
--   </ul>
--   
--   In practice, we will need a wallet that can support both, even if not
--   at the same time, and this little abstraction can buy us this without
--   introducing too much overhead.
class IsOurs s
isOurs :: IsOurs s => Address -> s -> (Bool, s)

-- | More powerful than <a>isOurs</a>, this abstractions offer the
--   underlying state the ability to find / compute the address private key
--   corresponding to a given known address.
--   
--   Requiring <a>IsOwned</a> as a constraint supposed that there is a way
--   to recover the root private key of a particular wallet. This isn't
--   true for externally owned wallet which would delegate its key
--   management to a third party (like a hardware Ledger or Trezor).
class IsOurs s => IsOwned s key
isOwned :: IsOwned s key => s -> (key  'RootK XPrv, Passphrase "encryption") -> Address -> Maybe (key  'AddressK XPrv, Passphrase "encryption")

-- | Abstracting over change address generation. In theory, this is only
--   needed for sending transactions on a wallet following a particular
--   scheme. This abstractions allows for defining an heuristic to pick new
--   change address. For instance, in BIP-44, change addresses belong to a
--   particular change chain (also called "Internal Chain").
class GenChange s
genChange :: GenChange s => Passphrase "encryption" -> s -> (Address, s)

-- | Ordering addresses by discovery date.
--   
--   If <tt>a1</tt> has been discovered before <tt>a2</tt>, then the
--   following equation holds:
--   
--   <pre>
--   compareDiscovery s a1 a2 == LT
--   </pre>
--   
--   If <tt>a1</tt> has been discovered after <tt>a2</tt>, then the
--   following equation holds:
--   
--   <pre>
--   compareDiscovery s a1 a2 == GT
--   </pre>
--   
--   Note that, if an address isn't known it is considered not discovered
--   and therefore, is always _greater than_ any known address.
class CompareDiscovery s
compareDiscovery :: CompareDiscovery s => s -> Address -> Address -> Ordering

-- | Extract the list of all known addresses.
--   
--   NOTE: Change addresses aren't considered "known" until they've been
--   used. The rationale is that, we don't want users or consumers of the
--   wallet to be using change addresses prematurely.
class KnownAddresses s
knownAddresses :: KnownAddresses s => s -> [Address]


-- | Implementation of address derivation for the sequential schemes, as
--   implemented by Yoroi/Icarus and cardano-cli.
module Cardano.Wallet.Primitive.AddressDerivation.Sequential

-- | A cryptographic key for sequential-scheme address derivation, with
--   phantom-types to disambiguate key types.
--   
--   <pre>
--   let rootPrivateKey = SeqKey 'RootK XPrv
--   let accountPubKey = SeqKey 'AccountK XPub
--   let addressPubKey = SeqKey 'AddressK XPub
--   </pre>
newtype SeqKey (depth :: Depth) key
SeqKey :: key -> SeqKey key
[getKey] :: SeqKey key -> key

-- | Marker for the change chain. In practice, change of a transaction goes
--   onto the addresses generated on the internal chain, whereas the
--   external chain is used for addresses that are part of the
--   <tt>advertised</tt> targets of a transaction
data ChangeChain
ExternalChain :: ChangeChain
InternalChain :: ChangeChain

-- | Generate a root key from a corresponding seed. The seed should be at
--   least 16 bytes.
generateKeyFromSeed :: (Passphrase "seed", Passphrase "generation") -> Passphrase "encryption" -> SeqKey  'RootK XPrv

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <a>generateKeyFromSeed</a>.
unsafeGenerateKeyFromSeed :: (Passphrase "seed", Passphrase "generation") -> Passphrase "encryption" -> SeqKey depth XPrv

-- | The minimum seed length for <a>generateKeyFromSeed</a> and
--   <a>unsafeGenerateKeyFromSeed</a>.
minSeedLengthBytes :: Int

-- | Derives account private key from the given root private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAccountPrivateKey :: Passphrase "encryption" -> SeqKey  'RootK XPrv -> Index  'Hardened  'AccountK -> SeqKey  'AccountK XPrv

-- | Derives address private key from the given account private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   It is preferred to use <a>deriveAddressPublicKey</a> whenever possible
--   to avoid having to manipulate passphrases and private keys.
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAddressPrivateKey :: Passphrase "encryption" -> SeqKey  'AccountK XPrv -> ChangeChain -> Index  'Soft  'AddressK -> SeqKey  'AddressK XPrv

-- | Derives address public key from the given account public key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   This is the preferred way of deriving new sequential address public
--   keys.
deriveAddressPublicKey :: SeqKey  'AccountK XPub -> ChangeChain -> Index  'Soft  'AddressK -> SeqKey  'AddressK XPub

-- | Re-encrypt a private key using a different passphrase.
--   
--   <ul>
--   <li>*Important**: This function doesn't check that the old passphrase
--   is correct! Caller is expected to have already checked that. Using an
--   incorrect passphrase here will lead to very bad thing.</li>
--   </ul>
changePassphraseSeq :: Passphrase "encryption-old" -> Passphrase "encryption-new" -> SeqKey purpose XPrv -> SeqKey purpose XPrv

-- | The reverse of <tt>serializeXPub</tt>. This will fail if the input is
--   not hexadecimal string of the correct length.
deserializeXPubSeq :: ByteString -> Either String (SeqKey purpose XPub)

-- | Convert a public key into a hexadecimal string suitable for storing in
--   a text file or database column.
serializeXPubSeq :: SeqKey purpose XPub -> ByteString
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.AddressDerivation.Sequential.ChangeChain
instance GHC.Classes.Ord Cardano.Wallet.Primitive.AddressDerivation.Sequential.ChangeChain
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDerivation.Sequential.ChangeChain
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDerivation.Sequential.ChangeChain
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDerivation.Sequential.ChangeChain
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Sequential.SeqKey depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Sequential.SeqKey depth key)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.Sequential.SeqKey depth key)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDerivation.Sequential.ChangeChain
instance GHC.Enum.Enum Cardano.Wallet.Primitive.AddressDerivation.Sequential.ChangeChain
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.AddressDerivation.Sequential.ChangeChain
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.AddressDerivation.Sequential.ChangeChain
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Sequential.SeqKey depth key)
instance Cardano.Wallet.Primitive.AddressDerivation.WalletKey Cardano.Wallet.Primitive.AddressDerivation.Sequential.SeqKey
instance Cardano.Wallet.Primitive.AddressDerivation.PersistKey Cardano.Wallet.Primitive.AddressDerivation.Sequential.SeqKey


-- | An implementation of address discovery for the sequential address
--   derivation scheme specified in BIP-0044.
--   
--   The management of _accounts_ is left-out for this implementation
--   focuses on a single account. In practice, one wants to manage a set of
--   pools, one per account.
module Cardano.Wallet.Primitive.AddressDiscovery.Sequential

-- | Maximum number of consecutive undiscovered addresses allowed
data AddressPoolGap

-- | Possible errors when casting to an <a>AddressPoolGap</a>
newtype MkAddressPoolGapError
ErrGapOutOfRange :: Integer -> MkAddressPoolGapError

-- | A default <a>AddressPoolGap</a>, as suggested in BIP-0044
defaultAddressPoolGap :: AddressPoolGap
getAddressPoolGap :: AddressPoolGap -> Word8

-- | Smart constructor for <a>AddressPoolGap</a>
mkAddressPoolGap :: Integer -> Either MkAddressPoolGapError AddressPoolGap

-- | An <a>AddressPool</a> which keeps track of sequential addresses within
--   a given Account and change chain. See <a>mkAddressPool</a> to create a
--   new or existing pool:
--   
--   <pre>
--   &gt;&gt;&gt; mkAddressPool xpub gap changeChain mempty
--   AddressPool { }
--   </pre>
data AddressPool target (chain :: ChangeChain)

-- | The actual gap for the pool. This can't change for a given pool.
gap :: AddressPool target chain -> AddressPoolGap

-- | Get all addresses in the pool, sorted from the first address
--   discovered, up until the next one.
--   
--   In practice, we always have:
--   
--   <pre>
--   mkAddressPool key g cc (addresses pool) == pool
--   </pre>
addresses :: AddressPool t chain -> [Address]

-- | Bring a <a>ChangeChain</a> type back to the term-level. This requires
--   a type application and either a scoped type variable, or an explicit
--   passing of a <a>ChangeChain</a>.
--   
--   <pre>
--   &gt;&gt;&gt; changeChain @'ExternalChain
--   ExternalChain
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; changeChain @chain
--   ...
--   </pre>
changeChain :: forall (c :: ChangeChain). Typeable c => ChangeChain

-- | Corresponding key for the pool (a pool is tied to only one account)
accountPubKey :: AddressPool target chain -> SeqKey  'AccountK XPub

-- | Create a new Address pool from a list of addresses. Note that, the
--   list is expected to be ordered in sequence (first indexes, first in
--   the list).
--   
--   The pool will grow from the start if less than <tt>g ::
--   AddressPoolGap</tt> are given, such that, there are always <tt>g</tt>
--   undiscovered addresses in the pool.
mkAddressPool :: forall t c. (KeyToAddress t SeqKey, Typeable c) => SeqKey  'AccountK XPub -> AddressPoolGap -> [Address] -> AddressPool t c

-- | Lookup an address in the pool. When we find an address in a pool, the
--   pool may be amended if the address was discovered near the edge. It is
--   also possible that the pool is not amended at all - this happens in
--   the case that an address is discovered <tt>far</tt> from the edge.
lookupAddress :: forall t c. (KeyToAddress t SeqKey, Typeable c) => Address -> AddressPool t c -> (Maybe (Index  'Soft  'AddressK), AddressPool t c)

-- | An ordered set of pending indexes. This keep track of indexes used
data PendingIxs

-- | An empty pending set of change indexes.
--   
--   NOTE: We do not define a <a>Monoid</a> instance here because there's
--   no rational of combining two pending sets.
emptyPendingIxs :: PendingIxs
pendingIxsToList :: PendingIxs -> [Index  'Soft  'AddressK]

-- | Construct a <a>PendingIxs</a> from a list, ensuring that it is a set
--   of indexes in descending order.
pendingIxsFromList :: [Index  'Soft  'AddressK] -> PendingIxs

-- | A state to keep track of sequential addresses as described in
--   <a>BIP-44</a>
--   
--   Internally, the state keeps track of a few things for us and is it is
--   parameterized by a type <tt>t</tt> which represents a target backend.
--   This enables the state to be agnostic to the underlying address
--   format.
data SeqState t
SeqState :: !AddressPool t  'InternalChain -> !AddressPool t  'ExternalChain -> !PendingIxs -> SeqState t

-- | Addresses living on the <a>InternalChain</a>
[internalPool] :: SeqState t -> !AddressPool t  'InternalChain

-- | Addresses living on the <a>ExternalChain</a>
[externalPool] :: SeqState t -> !AddressPool t  'ExternalChain

-- | Indexes from the internal pool that have been used in pending
--   transactions. The list is maintained sorted in descending order (cf:
--   <a>PendingIxs</a>)
[pendingChangeIxs] :: SeqState t -> !PendingIxs

-- | Construct a Sequential state for a wallet.
mkSeqState :: KeyToAddress t SeqKey => (SeqKey  'RootK XPrv, Passphrase "encryption") -> AddressPoolGap -> SeqState t
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState t)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState t)
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDiscovery.Sequential.PendingIxs
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.Sequential.PendingIxs
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDiscovery.Sequential.PendingIxs
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPool target chain)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPool target chain)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPool target chain)
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.Sequential.MkAddressPoolGapError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDiscovery.Sequential.MkAddressPoolGapError
instance GHC.Classes.Ord Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState t)
instance Cardano.Wallet.Primitive.AddressDerivation.KeyToAddress t Cardano.Wallet.Primitive.AddressDerivation.Sequential.SeqKey => Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState t)
instance Cardano.Wallet.Primitive.AddressDerivation.KeyToAddress t Cardano.Wallet.Primitive.AddressDerivation.Sequential.SeqKey => Cardano.Wallet.Primitive.AddressDiscovery.GenChange (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState t)
instance Cardano.Wallet.Primitive.AddressDerivation.KeyToAddress t Cardano.Wallet.Primitive.AddressDerivation.Sequential.SeqKey => Cardano.Wallet.Primitive.AddressDiscovery.IsOwned (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState t) Cardano.Wallet.Primitive.AddressDerivation.Sequential.SeqKey
instance Cardano.Wallet.Primitive.AddressDerivation.KeyToAddress t Cardano.Wallet.Primitive.AddressDerivation.Sequential.SeqKey => Cardano.Wallet.Primitive.AddressDiscovery.CompareDiscovery (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState t)
instance Cardano.Wallet.Primitive.AddressDiscovery.KnownAddresses (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState t)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDiscovery.Sequential.PendingIxs
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPool target chain)
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Enum.Enum Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap


-- | Implementation of address derivation for the random scheme, as
--   implemented by the legacy Cardano wallets.
--   
--   For full documentation of the key derivation schemes, see the
--   <a>Cardano.Crypto.Wallet</a> module, and the implementation in
--   <a>cardano-crypto</a>.
module Cardano.Wallet.Primitive.AddressDerivation.Random

-- | Material for deriving HD random scheme keys, which can be used for
--   making addresses.
data RndKey (depth :: Depth) key
RndKey :: key -> DerivationPath depth -> Passphrase "addr-derivation-payload" -> RndKey key

-- | The raw private or public key.
[getKey] :: RndKey key -> key

-- | The address derivation indices for the level of this key.
[derivationPath] :: RndKey key -> DerivationPath depth

-- | Used for encryption of payload containing address derivation path.
[payloadPassphrase] :: RndKey key -> Passphrase "addr-derivation-payload"

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <a>generateKeyFromSeed</a>.
unsafeGenerateKeyFromSeed :: DerivationPath depth -> Passphrase "seed" -> Passphrase "encryption" -> RndKey depth XPrv

-- | Generate a root key from a corresponding seed. The seed should be at
--   least 16 bytes.
generateKeyFromSeed :: Passphrase "seed" -> Passphrase "encryption" -> RndKey  'RootK XPrv

-- | The amount of entropy carried by a BIP-39 12-word mnemonic is 16
--   bytes.
minSeedLengthBytes :: Int

-- | A root key of all zeroes that is used when restoring <tt>RndState</tt>
--   from the database before a root key has been saved.
nullKey :: RndKey  'RootK XPrv

-- | Derives account private key from the given root private key, using
--   derivation scheme 1.
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAccountPrivateKey :: Passphrase "encryption" -> RndKey  'RootK XPrv -> Index  'Hardened  'AccountK -> RndKey  'AccountK XPrv

-- | Derives address private key from the given account private key, using
--   derivation scheme 1.
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAddressPrivateKey :: Passphrase "encryption" -> RndKey  'AccountK XPrv -> Index  'Hardened  'AddressK -> RndKey  'AddressK XPrv
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.Random.RndKey depth key)
instance (GHC.Show.Show key, GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Random.DerivationPath depth)) => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Random.RndKey depth key)
instance (GHC.Classes.Eq key, GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Random.DerivationPath depth)) => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Random.RndKey depth key)
instance (Control.DeepSeq.NFData key, Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Random.DerivationPath depth)) => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Random.RndKey depth key)
instance Cardano.Wallet.Primitive.AddressDerivation.WalletKey Cardano.Wallet.Primitive.AddressDerivation.Random.RndKey
instance Cardano.Wallet.Primitive.AddressDerivation.PersistKey Cardano.Wallet.Primitive.AddressDerivation.Random.RndKey


-- | These are (partial) CBOR decoders for Byron binary types. Note that we
--   ignore most of the block's and header's content and only retrieve the
--   pieces of information relevant to us, wallet (we do assume a trusted
--   node and therefore, we needn't to care about verifying signatures and
--   blocks themselves).
--   
--   The format described in the decoders below are the one used in the
--   Byron era of Cardano and will endure in the first stages of Shelley.
--   They are also used by components like the Rust
--   <a>cardano-http-bridge</a>.
module Cardano.Byron.Codec.Cbor
decodeBlock :: Decoder s (Block ([TxIn], [TxOut]))
decodeAddressDerivationPath :: Passphrase "addr-derivation-payload" -> Decoder s (Maybe (Index  'Hardened  'AccountK, Index  'Hardened  'AddressK))
decodeAddressPayload :: Decoder s ByteString

-- | The attributes are pairs of numeric tags and bytes, where the bytes
--   will be CBOR-encoded stuff. This decoder does not enforce "canonicity"
--   of entries.
decodeAllAttributes :: Decoder s [(Word8, ByteString)]
decodeBlockHeader :: Decoder s BlockHeader
decodeDerivationPathAttr :: Passphrase "addr-derivation-payload" -> [(Word8, ByteString)] -> Decoder s (Maybe (Index  'Hardened  'AccountK, Index  'Hardened  'AddressK))
decodeSignedTx :: Decoder s (([TxIn], [TxOut]), [TxWitness])
decodeTx :: Decoder s ([TxIn], [TxOut])
decodeTxWitness :: Decoder s TxWitness

-- | Encode a public key to a corresponding Cardano Address. The encoding
--   of the attributes part of an address is left out to the caller; This
--   allows for distinguishing between Sequential and Random addresses (the
--   former doesn't have any attributes to encode).
--   
--   <pre>
--   -- Old / Random Addresses
--   let encodeAddrAttributes = mempty
--        &lt;&gt; CBOR.encodeMapLen 1
--        &lt;&gt; CBOR.encodeWord8 1
--        &lt;&gt; encodeDerivationPath (hdPassphrase rootXPub) accIx addrIx
--   let addr = encodeAddress xpub encodeAddrAttributes
--   
--   -- New / Sequential Addresses
--   let encodeAddrAttributes = mempty &lt;&gt; CBOR.encodeMapLen 0
--   let addr = encodeAddress xpub encodeAddrAttributes
--   </pre>
--   
--   Note that we are passing the behavior to encode attributes as a
--   parameter here and do not handle multiple cases in
--   <a>encodeAddress</a> itself for multiple reasons:
--   
--   <ul>
--   <li>Inversion of control gives us a nicer implementation overall</li>
--   <li>Encoding attributes for Random addresses requires more context
--   than just the public key (like the wallet root id and some extra logic
--   for encoding passphrases). This is just scheme-specific and is better
--   left out of this particular function</li>
--   </ul>
encodeAddress :: XPub -> [Encoding] -> Encoding
encodeAttributes :: [Encoding] -> Encoding
encodeDerivationPathAttr :: Passphrase "addr-derivation-payload" -> Index  'Hardened  'AccountK -> Index  'Hardened  'AddressK -> Encoding
encodeProtocolMagicAttr :: ProtocolMagic -> Encoding
encodePublicKeyWitness :: XPub -> Hash "signature" -> Encoding
encodeSignedTx :: (([TxIn], [TxOut]), [TxWitness]) -> Encoding
encodeTx :: ([TxIn], [TxOut]) -> Encoding
encodeTxWitness :: TxWitness -> Encoding

-- | Shortcut for deserialising a strict <tt>Bytestring</tt> with the given
--   decoder.
deserialiseCbor :: (forall s. Decoder s a) -> ByteString -> Maybe a

-- | Inspect the next token that has to be decoded and print it to the
--   console as a trace. Useful for debugging Decoders. Example:
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s MyType
--   myDecoder = do
--       a &lt;- CBOR.decodeWord64
--       inspectNextToken
--       [...]
--   </pre>
inspectNextToken :: Decoder s ()

-- | Decode an list of known length. Very similar to
--   <tt>decodeListIndef</tt>.
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s [MyType]
--   myDecoder = decodeList decodeOne
--     where
--       decodeOne :: CBOR.Decoder s MyType
--   </pre>
decodeList :: forall s a. Decoder s a -> Decoder s [a]

-- | Decode an arbitrary long list. CBOR introduce a "break" character to
--   mark the end of the list, so we simply decode each item until we
--   encounter a break character.
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s [MyType]
--   myDecoder = decodeListIndef decodeOne
--     where
--       decodeOne :: CBOR.Decoder s MyType
--   </pre>
decodeListIndef :: forall s a. Decoder s a -> Decoder s [a]


-- | An implementation of address discovery for the random address scheme
--   as used by the legacy Cardano wallets.
module Cardano.Wallet.Primitive.AddressDiscovery.Random

-- | HD random address discovery state and key material for AD.
data RndState target
RndState :: RndKey  'RootK XPrv -> Index  'Hardened  'AccountK -> Map DerivationPath Address -> Map DerivationPath Address -> StdGen -> RndState target

-- | The wallet root key.
[rndKey] :: RndState target -> RndKey  'RootK XPrv

-- | The account index used for address _generation_ in this wallet. Note
--   that addresses will be _discovered_ from any and all account indices,
--   regardless of this value.
[accountIndex] :: RndState target -> Index  'Hardened  'AccountK

-- | The addresses which have so far been discovered, and their derivation
--   paths.
[addresses] :: RndState target -> Map DerivationPath Address

-- | The addresses which have been generated for use as change addresses,
--   and their derivation paths. Once addresses have been discovered they
--   are removed from this set and added to <a>addresses</a>.
[pendingAddresses] :: RndState target -> Map DerivationPath Address

-- | The state of the RNG.
[gen] :: RndState target -> StdGen

-- | Initialize the HD random address discovery state from a root key and
--   RNG seed.
mkRndState :: RndKey  'RootK XPrv -> Int -> RndState t
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState target)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState target)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState target)
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState t)
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOwned (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState t) Cardano.Wallet.Primitive.AddressDerivation.Random.RndKey
instance Cardano.Wallet.Primitive.AddressDerivation.KeyToAddress t Cardano.Wallet.Primitive.AddressDerivation.Random.RndKey => Cardano.Wallet.Primitive.AddressDiscovery.GenChange (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState t)
instance Cardano.Wallet.Primitive.AddressDiscovery.CompareDiscovery (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState t)
instance Cardano.Wallet.Primitive.AddressDiscovery.KnownAddresses (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState t)


-- | Here we find the "business logic" to manage a Cardano wallet. This is
--   a direct implementation of the model from the <a>Formal Specification
--   for a Cardano Wallet</a> Note that, this module is purposedly agnostic
--   to how blocks are retrieved or how various types are serialized.
--   
--   This is really about how the wallet keep track of its internal state,
--   and its UTxO (where the relationship is defined via the <a>IsOurs</a>
--   abstraction to allow this core code to be used with any sort of
--   derivation scheme).
--   
--   All those functions are pure and there's no reason to shove in any
--   sort of side-effects in here :)
module Cardano.Wallet.Primitive.Model

-- | An opaque wallet type, see <a>initWallet</a> and <a>applyBlocks</a> to
--   construct and update wallets.
--   
--   Internally, this keeps track or a few things including:
--   
--   <ul>
--   <li>UTxOs</li>
--   <li>Pending transaction</li>
--   <li>Transaction history</li>
--   <li>TODO: Known &amp; used addresses</li>
--   </ul>
--   
--   The <a>Wallet</a> is paremeterized over two types:
--   
--   <ul>
--   <li><tt>s</tt>: A _state_ used to keep track of known addresses. The
--   business logic doesn't know how to answer the question 'Is this
--   address ours?', so we expect this state to be able to answer that for
--   us.</li>
--   <li><tt>t</tt>: A target backend. This makes the wallet fairly
--   agnostic to the type of binary representation used by the underlying
--   target network and it allows us to re-use the same logic to provide a
--   wallet backend for multiple backends (for instance, Byron or Shelley)
--   which may have divergence in their binary formats. For the sake of
--   this module, we only care about one particular super-power, and its
--   the ability to compute transaction id (which is intrinsically linked
--   to the transaction's binary format).</li>
--   </ul>
--   
--   A few examples to make it concrete:
--   
--   <pre>
--   Wallet RndState Byron
--   Wallet SeqState Shelley
--   Wallet SeqState Bitcoin
--   </pre>
data Wallet s t

-- | Create a an empty wallet and apply the given genesis block
--   
--   The wallet tip will be set to the header of the applied genesis block.
initWallet :: forall s t. (IsOurs s, NFData s, Show s, DefineTx t) => Block (Tx t) -> s -> Wallet s t

-- | Update the state of an existing Wallet model
updateState :: (IsOurs s, NFData s, Show s) => s -> Wallet s t -> Wallet s t

-- | Apply Block is the only way to make the wallet evolve. It returns a
--   new updated wallet state, as well as the set of all our transaction
--   discovered while applying the block.
applyBlock :: forall s t. DefineTx t => Block (Tx t) -> Wallet s t -> (Map (Hash "Tx") (Tx t, TxMeta), Wallet s t)

-- | Apply multiple blocks in sequence to an existing wallet, returning a
--   list of intermediate wallet states.
--   
--   Each intermediate wallet state is paired with the set of transactions
--   that belong to that state but not the previous state.
--   
--   For an original wallet state <b><tt>w</tt></b> and a list of blocks
--   <b><tt>b</tt></b> such that:
--   
--   <pre>
--   b = [b1, b2, ..., bn]
--   </pre>
--   
--   Returns the following list of updates:
--   
--   <pre>
--   [ (t b1, w + b1)
--   , (t b2, w + b1 + b2)
--   , ...
--   , (t bn, w + b1 + b2 + ... + bn) ]
--   </pre>
--   
--   Where:
--   
--   <ul>
--   <li><b><tt>(t bi)</tt></b> is the set of transactions contained within
--   block <b><tt>bi</tt></b>.</li>
--   <li><b><tt>(w + bi)</tt></b> is the wallet state after applying block
--   <b><tt>bi</tt></b> to wallet <b><tt>w</tt></b>.</li>
--   </ul>
applyBlocks :: forall s t. DefineTx t => NonEmpty (Block (Tx t)) -> Wallet s t -> NonEmpty (Map (Hash "Tx") (Tx t, TxMeta), Wallet s t)
newPending :: (Tx t, TxMeta) -> Wallet s t -> Wallet s t

-- | Constructs a wallet from the exact given state. Using this function
--   instead of <a>initWallet</a> and <a>applyBlock</a> allows the wallet
--   invariants to be broken. Therefore it should only be used in the
--   special case of loading wallet checkpoints from the database (where it
--   is assumed a valid wallet was stored into the database).
unsafeInitWallet :: (IsOurs s, NFData s, Show s, DefineTx t) => UTxO -> Set (Tx t, TxMeta) -> BlockHeader -> s -> Quantity "block" Natural -> Wallet s t

-- | Get the wallet current tip
currentTip :: Wallet s t -> BlockHeader

-- | Get the wallet current state
getState :: Wallet s t -> s

-- | Available balance = <a>balance</a> . <a>availableUTxO</a>
availableBalance :: DefineTx t => Wallet s t -> Natural

-- | Total balance = <a>balance</a> . <a>totalUTxO</a>
totalBalance :: DefineTx t => Wallet s t -> Natural

-- | Total UTxO = <a>availableUTxO</a> <tt>&lt;&gt;</tt> <a>changeUTxO</a>
totalUTxO :: forall s t. DefineTx t => Wallet s t -> UTxO

-- | Available UTxO = <tt>pending ⋪ utxo</tt>
availableUTxO :: forall s t. DefineTx t => Wallet s t -> UTxO

-- | Actual utxo
utxo :: Wallet s t -> UTxO

-- | Get the set of pending transactions
getPending :: Wallet s t -> Set (Tx t, TxMeta)

-- | Get the block height of the chain.
--   
--   A new wallet from <a>initWallet</a> (which already has the genesis
--   block applied) has a block height of 0.
blockHeight :: Wallet s t -> Quantity "block" Natural
instance GHC.Show.Show (Cardano.Wallet.Primitive.Model.Wallet s t)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Cardano.Wallet.Primitive.Model.Wallet s t)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Model.Wallet s t)


-- | An implementation of the wallet database using only pure functions.
--   
--   These functions and types model the behaviour of the SQLite database
--   backend, and are used for QuickCheck state machine testing, and the
--   MVar database backend.
module Cardano.Wallet.DB.Model

-- | Model database, parameterised by the wallet ID type, the wallet AD
--   state type, the target backend, and the private key type.
--   
--   Tne type parameters exist so that simpler mock types can be used in
--   place of actual wallet types.
data Database wid s t xprv
Database :: !Map wid (WalletDatabase s t xprv) -> Map (Hash "Tx") (Tx t) -> Database wid s t xprv

-- | Wallet-related information.
[wallets] :: Database wid s t xprv -> !Map wid (WalletDatabase s t xprv)

-- | In the database, transactions are global and not associated with any
--   particular wallet.
[txs] :: Database wid s t xprv -> Map (Hash "Tx") (Tx t)

-- | Model database record for a single wallet.
data WalletDatabase s t xprv
WalletDatabase :: ![Wallet s t] -> !WalletMetadata -> !Map (Hash "Tx") TxMeta -> !Maybe xprv -> WalletDatabase s t xprv
[checkpoints] :: WalletDatabase s t xprv -> ![Wallet s t]
[metadata] :: WalletDatabase s t xprv -> !WalletMetadata
[txHistory] :: WalletDatabase s t xprv -> !Map (Hash "Tx") TxMeta
[xprv] :: WalletDatabase s t xprv -> !Maybe xprv

-- | Produces an empty model database.
emptyDatabase :: Ord wid => Database wid s t xprv

-- | Shorthand for the readTxHistory result type.
type TxHistory t = [(Hash "Tx", (Tx t, TxMeta))]

-- | Shorthand for the putTxHistory argument type.
type TxHistoryMap t = Map (Hash "Tx") (Tx t, TxMeta)

-- | Apply optional filters on slotId and sort using the default sort order
--   (first time/slotId, then by TxId) to a <a>TxHistory</a>.
filterTxHistory :: SortOrder -> Range SlotId -> TxHistory t -> TxHistory t

-- | A database model operation, which is a function that takes a database
--   and returns: * a value, which is a query of the database, or an error;
--   and * a (possibly) modified database.
type ModelOp wid s t xprv a = Database wid s t xprv -> (Either (Err wid) a, Database wid s t xprv)

-- | All of the possible errors that any of the model database functions
--   might return.
data Err wid
NoSuchWallet :: wid -> Err wid
WalletAlreadyExists :: wid -> Err wid
mCleanDB :: Ord wid => ModelOp wid s t xprv ()
mCreateWallet :: Ord wid => wid -> Wallet s t -> WalletMetadata -> ModelOp wid s t xprv ()
mRemoveWallet :: Ord wid => wid -> ModelOp wid s t xprv ()
mListWallets :: Ord wid => ModelOp wid s t xprv [wid]
mPutCheckpoint :: Ord wid => wid -> Wallet s t -> ModelOp wid s t xprv ()
mReadCheckpoint :: Ord wid => wid -> ModelOp wid s t xprv (Maybe (Wallet s t))
mPutWalletMeta :: Ord wid => wid -> WalletMetadata -> ModelOp wid s t xprv ()
mReadWalletMeta :: Ord wid => wid -> ModelOp wid s t xprv (Maybe WalletMetadata)
mPutTxHistory :: Ord wid => wid -> TxHistoryMap t -> ModelOp wid s t xprv ()
mReadTxHistory :: forall wid s t xprv. Ord wid => wid -> SortOrder -> Range SlotId -> ModelOp wid s t xprv (TxHistory t)
mPutPrivateKey :: Ord wid => wid -> xprv -> ModelOp wid s t xprv ()
mReadPrivateKey :: Ord wid => wid -> ModelOp wid s t xprv (Maybe xprv)
instance Data.Traversable.Traversable Cardano.Wallet.DB.Model.Err
instance Data.Foldable.Foldable Cardano.Wallet.DB.Model.Err
instance GHC.Base.Functor Cardano.Wallet.DB.Model.Err
instance GHC.Classes.Eq wid => GHC.Classes.Eq (Cardano.Wallet.DB.Model.Err wid)
instance GHC.Show.Show wid => GHC.Show.Show (Cardano.Wallet.DB.Model.Err wid)
instance GHC.Generics.Generic (Cardano.Wallet.DB.Model.Database wid s t xprv)
instance GHC.Generics.Generic (Cardano.Wallet.DB.Model.WalletDatabase s t xprv)
instance (GHC.Classes.Eq s, GHC.Classes.Eq xprv) => GHC.Classes.Eq (Cardano.Wallet.DB.Model.WalletDatabase s t xprv)
instance GHC.Show.Show xprv => GHC.Show.Show (Cardano.Wallet.DB.Model.WalletDatabase s t xprv)
instance (GHC.Show.Show (Cardano.Wallet.Primitive.Types.Tx t), GHC.Show.Show wid, GHC.Show.Show xprv) => GHC.Show.Show (Cardano.Wallet.DB.Model.Database wid s t xprv)
instance (GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.Tx t), GHC.Classes.Eq wid, GHC.Classes.Eq xprv, GHC.Classes.Eq s) => GHC.Classes.Eq (Cardano.Wallet.DB.Model.Database wid s t xprv)


-- | Database / Persistence layer for the wallet backend. This is where we
--   define the interface allowing us to store and fetch various data on
--   our wallets.
module Cardano.Wallet.DB

-- | A Database interface for storing various things in a DB. In practice,
--   we'll need some extra contraints on the wallet state that allows us to
--   serialize and unserialize it (e.g. <tt>forall s. (Serialize s) =&gt;
--   ...</tt>)
data DBLayer m s t k
DBLayer :: (PrimaryKey WalletId -> Wallet s t -> WalletMetadata -> ExceptT ErrWalletAlreadyExists m ()) -> (PrimaryKey WalletId -> ExceptT ErrNoSuchWallet m ()) -> m [PrimaryKey WalletId] -> (PrimaryKey WalletId -> Wallet s t -> ExceptT ErrNoSuchWallet m ()) -> (PrimaryKey WalletId -> m (Maybe (Wallet s t))) -> (PrimaryKey WalletId -> WalletMetadata -> ExceptT ErrNoSuchWallet m ()) -> (PrimaryKey WalletId -> m (Maybe WalletMetadata)) -> (DefineTx t => PrimaryKey WalletId -> Map (Hash "Tx") (Tx t, TxMeta) -> ExceptT ErrNoSuchWallet m ()) -> (PrimaryKey WalletId -> SortOrder -> Range SlotId -> m [(Hash "Tx", (Tx t, TxMeta))]) -> (PrimaryKey WalletId -> (k  'RootK XPrv, Hash "encryption") -> ExceptT ErrNoSuchWallet m ()) -> (PrimaryKey WalletId -> m (Maybe (k  'RootK XPrv, Hash "encryption"))) -> (forall e a. () => ExceptT e m a -> ExceptT e m a) -> DBLayer m s t k

-- | Initialize a database entry for a given wallet. <a>putCheckpoint</a>,
--   <a>putWalletMeta</a> or <a>putTxHistory</a> will actually all fail if
--   they are called _first_ on a wallet.
[createWallet] :: DBLayer m s t k -> PrimaryKey WalletId -> Wallet s t -> WalletMetadata -> ExceptT ErrWalletAlreadyExists m ()

-- | Remove a given wallet and all its associated data (checkpoints,
--   metadata, tx history ...)
[removeWallet] :: DBLayer m s t k -> PrimaryKey WalletId -> ExceptT ErrNoSuchWallet m ()

-- | Get the list of all known wallets in the DB, possibly empty.
[listWallets] :: DBLayer m s t k -> m [PrimaryKey WalletId]

-- | Replace the current checkpoint for a given wallet. We do not handle
--   rollbacks yet, and therefore only stores the latest available
--   checkpoint.
--   
--   If the wallet doesn't exist, this operation returns an error.
[putCheckpoint] :: DBLayer m s t k -> PrimaryKey WalletId -> Wallet s t -> ExceptT ErrNoSuchWallet m ()

-- | Fetch the most recent checkpoint of a given wallet.
--   
--   Return <a>Nothing</a> if there's no such wallet.
[readCheckpoint] :: DBLayer m s t k -> PrimaryKey WalletId -> m (Maybe (Wallet s t))

-- | Replace an existing wallet metadata with the given one.
--   
--   If the wallet doesn't exist, this operation returns an error
[putWalletMeta] :: DBLayer m s t k -> PrimaryKey WalletId -> WalletMetadata -> ExceptT ErrNoSuchWallet m ()

-- | Fetch a wallet metadata, if they exist.
--   
--   Return <a>Nothing</a> if there's no such wallet.
[readWalletMeta] :: DBLayer m s t k -> PrimaryKey WalletId -> m (Maybe WalletMetadata)

-- | Augments the transaction history for a known wallet.
--   
--   If an entry for a particular transaction already exists it is not
--   altered nor merged (just ignored).
--   
--   If the wallet doesn't exist, this operation returns an error.
[putTxHistory] :: DBLayer m s t k -> DefineTx t => PrimaryKey WalletId -> Map (Hash "Tx") (Tx t, TxMeta) -> ExceptT ErrNoSuchWallet m ()

-- | Fetch the current transaction history of a known wallet, ordered by
--   descending slot number.
--   
--   Returns an empty list if the wallet isn't found.
[readTxHistory] :: DBLayer m s t k -> PrimaryKey WalletId -> SortOrder -> Range SlotId -> m [(Hash "Tx", (Tx t, TxMeta))]

-- | Store or replace a private key for a given wallet. Note that wallet
--   _could_ be stored and manipulated without any private key associated
--   to it. A private key is only seldomly required for very specific
--   operations (like transaction signing).
[putPrivateKey] :: DBLayer m s t k -> PrimaryKey WalletId -> (k  'RootK XPrv, Hash "encryption") -> ExceptT ErrNoSuchWallet m ()

-- | Read a previously stored private key and its associated passphrase
--   hash.
[readPrivateKey] :: DBLayer m s t k -> PrimaryKey WalletId -> m (Maybe (k  'RootK XPrv, Hash "encryption"))
[withLock] :: DBLayer m s t k -> forall e a. () => ExceptT e m a -> ExceptT e m a

-- | A primary key which can take many forms depending on the value. This
--   may become a type family as we move forward, but for now, it
--   illustrate that some queries are ran against some sort of store;
--   
--   As a matter of fact, we may manipulate multiple wallets at the same
--   time, so, functions like <tt>enqueueCheckpoint</tt> needs to be
--   associated to a corresponding wallet. Some other may not because they
--   are information valid for all wallets (like for instance, the last
--   known network tip).
newtype PrimaryKey key
PrimaryKey :: key -> PrimaryKey key

-- | Clean a database by removing all wallets.
cleanDB :: Monad m => DBLayer m s t k -> m ()

-- | Can't perform given operation because there's no wallet
newtype ErrNoSuchWallet
ErrNoSuchWallet :: WalletId -> ErrNoSuchWallet

-- | Forbidden operation was executed on an already existing wallet
newtype ErrWalletAlreadyExists
ErrWalletAlreadyExists :: WalletId -> ErrWalletAlreadyExists
instance GHC.Classes.Ord key => GHC.Classes.Ord (Cardano.Wallet.DB.PrimaryKey key)
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Wallet.DB.PrimaryKey key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Wallet.DB.PrimaryKey key)
instance GHC.Show.Show Cardano.Wallet.DB.ErrWalletAlreadyExists
instance GHC.Classes.Eq Cardano.Wallet.DB.ErrWalletAlreadyExists
instance GHC.Show.Show Cardano.Wallet.DB.ErrNoSuchWallet
instance GHC.Classes.Eq Cardano.Wallet.DB.ErrNoSuchWallet


-- | Dummy implementation of the database-layer, using <a>MVar</a>. This
--   may be good for testing to compare with an implementation on a real
--   data store, or to use when compiling the wallet for targets which
--   don't have SQLite.
module Cardano.Wallet.DB.MVar

-- | Instantiate a new in-memory "database" layer that simply stores data
--   in a local MVar. Data vanishes if the software is shut down.
newDBLayer :: forall s t k. NFData (k  'RootK XPrv) => IO (DBLayer IO s t k)
instance GHC.Show.Show Cardano.Wallet.DB.MVar.MVarDBError
instance GHC.Exception.Type.Exception Cardano.Wallet.DB.MVar.MVarDBError


-- | Provides the API of Coin Selection algorithm and Fee Calculation This
--   module contains the implementation of adjusting coin selection for a
--   fee. The sender pays for the fee and additional inputs are picked
--   randomly. For more information refer to:
--   <a>https://iohk.io/blog/self-organisation-in-coin-selection/</a>
module Cardano.Wallet.Primitive.Fee

-- | A <a>Fee</a>, isomorph to <a>Coin</a> but ease type-signatures and
--   readability.
newtype Fee
Fee :: Word64 -> Fee
[getFee] :: Fee -> Word64

-- | A linear equation a free variable <tt>x</tt>. Represents the <tt>s
--   -&gt; a + b*s</tt> function where <tt>s</tt> can be the transaction
--   size in bytes or, a number of inputs + outputs.
--   
--   <tt>a</tt> and <tt>b</tt> are constant coefficients.
data FeePolicy
LinearFee :: Quantity "lovelace" Double -> Quantity "lovelace/x" Double -> FeePolicy

-- | Compute fee for a given payload. Fee follows a simple linear equation:
--   
--   <pre>
--   f = a + size * b
--   </pre>
--   
--   where <tt>a</tt> &amp; <tt>b</tt> are values fixed by the protocol.
computeFee :: FeePolicy -> Quantity "byte" Int -> Fee

-- | Proportionally divide the fee over each output.
--   
--   Pre-condition 1: The given outputs list shouldn't be empty
--   Pre-condition 2: None of the outputs should be null
--   
--   It returns the a list of pairs (fee, output).
divvyFee :: Fee -> [Coin] -> [(Fee, Coin)]
data FeeOptions
FeeOptions :: (CoinSelection -> Fee) -> Coin -> FeeOptions

-- | Estimate fees based on number of inputs and values of the outputs Some
--   pointers / order of magnitude from the current configuration: a:
--   155381 # absolute minimal fees per transaction b: 43.946 # additional
--   minimal fees per byte of transaction size
[estimate] :: FeeOptions -> CoinSelection -> Fee

-- | Change addresses below the given threshold will be evicted from the
--   created transaction. Setting <a>dustThreshold</a> to 0 removes output
--   equal to 0
[dustThreshold] :: FeeOptions -> Coin
newtype ErrAdjustForFee

-- | UTxO exhausted during fee covering We record what amount missed to
--   cover the fee
ErrCannotCoverFee :: Word64 -> ErrAdjustForFee

-- | Given the coin selection result from a policy run, adjust the outputs
--   for fees, potentially returning additional inputs that we need to
--   cover all fees. We lose the relationship between the transaction
--   outputs and their corresponding inputs/change outputs here. This is a
--   decision we may wish to revisit later. For now however note that since
--   
--   (a) coin selection tries to establish a particular ratio between
--   payment outputs and change outputs (currently it aims for an average
--   of 1:1)
--   
--   (b) coin selection currently only generates a single change output per
--   payment output, distributing the fee proportionally across all change
--   outputs is roughly equivalent to distributing it proportionally over
--   the payment outputs (roughly, not exactly, because the 1:1 proportion
--   is best effort only, and may in some cases be wildly different).
--   
--   Note that for (a) we don't need the ratio to be 1:1, the above
--   reasoning will remain true for any proportion 1:n. For (b) however, if
--   coin selection starts creating multiple outputs, and this number may
--   vary, then losing the connection between outputs and change outputs
--   will mean that that some outputs may pay a larger percentage of the
--   fee (depending on how many change outputs the algorithm happened to
--   choose).
adjustForFee :: MonadRandom m => FeeOptions -> UTxO -> CoinSelection -> ExceptT ErrAdjustForFee m CoinSelection
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Fee.ErrAdjustForFee
instance GHC.Show.Show Cardano.Wallet.Primitive.Fee.ErrAdjustForFee
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Fee.FeeOptions
instance GHC.Show.Show Cardano.Wallet.Primitive.Fee.FeePolicy
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Fee.FeePolicy
instance GHC.Show.Show Cardano.Wallet.Primitive.Fee.Fee
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Fee.Fee
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Fee.Fee

module Cardano.Wallet.Network
data NetworkLayer t m
NetworkLayer :: (BlockHeader -> ExceptT ErrGetBlock m [Block (Tx t)]) -> ExceptT ErrNetworkTip m (BlockHeader, Quantity "block" Natural) -> ((Tx t, [TxWitness]) -> ExceptT ErrPostTx m ()) -> (ByteString -> ExceptT ErrDecodeExternalTx m (Tx t, [TxWitness])) -> NetworkLayer t m

-- | Fetches a contiguous sequence of blocks from the node, starting from
--   the first block available with a slot greater than the given block
--   header.
--   
--   Blocks are returned in ascending slot order, without skipping blocks.
--   
--   This function will not necessarily return all blocks available after
--   the given point in time, but will return a reasonably-sized sequence.
--   
--   It may return the empty list if the node does not have any blocks
--   after the specified starting slot.
[nextBlocks] :: NetworkLayer t m -> BlockHeader -> ExceptT ErrGetBlock m [Block (Tx t)]

-- | Get the current network tip from the chain producer and the current
--   chain's height.
[networkTip] :: NetworkLayer t m -> ExceptT ErrNetworkTip m (BlockHeader, Quantity "block" Natural)

-- | Broadcast a transaction to the chain producer
[postTx] :: NetworkLayer t m -> (Tx t, [TxWitness]) -> ExceptT ErrPostTx m ()

-- | Decode an externally-signed transaction to the chain producer
[decodeExternalTx] :: NetworkLayer t m -> ByteString -> ExceptT ErrDecodeExternalTx m (Tx t, [TxWitness])

-- | Wait until 'networkTip networkLayer' succeeds according to a given
--   retry policy. Throws an exception otherwise.
waitForConnection :: NetworkLayer t IO -> RetryPolicyM IO -> IO ()

-- | A default <a>RetryPolicy</a> with a constant delay, but retries for no
--   longer than a minute.
defaultRetryPolicy :: Monad m => RetryPolicyM m

-- | Network is unavailable
data ErrNetworkUnavailable

-- | Cannot connect to network backend.
ErrNetworkUnreachable :: Text -> ErrNetworkUnavailable

-- | Network backend reports that the requested network is invalid.
ErrNetworkInvalid :: Text -> ErrNetworkUnavailable

-- | Error while trying to get the network tip
data ErrNetworkTip
ErrNetworkTipNetworkUnreachable :: ErrNetworkUnavailable -> ErrNetworkTip
ErrNetworkTipNotFound :: ErrNetworkTip

-- | Error while trying to get one or more blocks
data ErrGetBlock
ErrGetBlockNetworkUnreachable :: ErrNetworkUnavailable -> ErrGetBlock
ErrGetBlockNotFound :: Hash "BlockHeader" -> ErrGetBlock

-- | Error while trying to send a transaction
data ErrPostTx
ErrPostTxNetworkUnreachable :: ErrNetworkUnavailable -> ErrPostTx
ErrPostTxBadRequest :: Text -> ErrPostTx
ErrPostTxProtocolFailure :: Text -> ErrPostTx

-- | Error while trying to decode externally signed transaction
data ErrDecodeExternalTx
ErrDecodeExternalTxWrongPayload :: Text -> ErrDecodeExternalTx
ErrDecodeExternalTxNotSupported :: ErrDecodeExternalTx
instance GHC.Classes.Eq Cardano.Wallet.Network.ErrDecodeExternalTx
instance GHC.Show.Show Cardano.Wallet.Network.ErrDecodeExternalTx
instance GHC.Generics.Generic Cardano.Wallet.Network.ErrDecodeExternalTx
instance GHC.Classes.Eq Cardano.Wallet.Network.ErrPostTx
instance GHC.Show.Show Cardano.Wallet.Network.ErrPostTx
instance GHC.Generics.Generic Cardano.Wallet.Network.ErrPostTx
instance GHC.Classes.Eq Cardano.Wallet.Network.ErrGetBlock
instance GHC.Show.Show Cardano.Wallet.Network.ErrGetBlock
instance GHC.Classes.Eq Cardano.Wallet.Network.ErrNetworkTip
instance GHC.Show.Show Cardano.Wallet.Network.ErrNetworkTip
instance GHC.Generics.Generic Cardano.Wallet.Network.ErrNetworkTip
instance GHC.Classes.Eq Cardano.Wallet.Network.ErrNetworkUnavailable
instance GHC.Show.Show Cardano.Wallet.Network.ErrNetworkUnavailable
instance GHC.Generics.Generic Cardano.Wallet.Network.ErrNetworkUnavailable
instance GHC.Exception.Type.Exception Cardano.Wallet.Network.ErrDecodeExternalTx
instance GHC.Exception.Type.Exception Cardano.Wallet.Network.ErrPostTx
instance GHC.Exception.Type.Exception Cardano.Wallet.Network.ErrNetworkTip


-- | This module contains instances and types necessary for storing wallets
--   in a SQL database with Persistent.
--   
--   It's in a separate module due to the GHC stage restriction.
--   
--   The ToJSON/FromJSON and Read instance orphans exist due to class
--   constraints on Persistent functions.
module Cardano.Wallet.DB.Sqlite.Types

-- | Settings for generating the Persistent types.
sqlSettings' :: MkPersistSettings

-- | <a>fromText</a> but with a simpler error type.
fromText' :: FromText a => Text -> Either Text a

-- | Aeson parser defined in terms of <a>fromText</a>
aesonFromText :: FromText a => String -> Value -> Parser a

-- | <a>fromPersistValue</a> defined in terms of <a>fromText</a>
fromPersistValueFromText :: FromText a => PersistValue -> Either Text a

-- | <a>fromPersistValue</a> defined in terms of the <a>Read</a> class
fromPersistValueRead :: Read a => PersistValue -> Either Text a
directionToBool :: Direction -> Bool
directionFromBool :: Bool -> Direction
newtype TxId
TxId :: Hash "Tx" -> TxId
[getTxId] :: TxId -> Hash "Tx"
newtype BlockId
BlockId :: Hash "BlockHeader" -> BlockId
[getBlockId] :: BlockId -> Hash "BlockHeader"

-- | As a short-to-medium term solution of persisting <a>SlotId</a>, we use
--   <a>flatSlot</a> with an artificial epochLength. I.e. /not the same
--   epochLength as the blockchain/. This is just for the sake of storing
--   the 64 bit epoch and the 16 bit slot inside a single 64-bit field.
artificialEpochLength :: EpochLength
walletStateNum :: WalletState -> Word8
walletStateFromNum :: Word8 -> WalletState
mkCoin :: Word64 -> Either Text Coin
newtype AddressPoolXPub
AddressPoolXPub :: SeqKey  'AccountK XPub -> AddressPoolXPub
[getAddressPoolXPub] :: AddressPoolXPub -> SeqKey  'AccountK XPub
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Types.AddressPoolXPub
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Types.AddressPoolXPub
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Types.AddressPoolXPub
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Classes.Ord Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Types.TxId
instance GHC.Classes.Ord Cardano.Wallet.DB.Sqlite.Types.TxId
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Types.TxId
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Types.AddressPoolXPub
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Types.AddressPoolXPub
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Read.Read Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Web.PathPieces.PathPiece Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Types.TxId
instance GHC.Read.Read Cardano.Wallet.DB.Sqlite.Types.TxId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.DB.Sqlite.Types.TxId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.DB.Sqlite.Types.TxId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.DB.Sqlite.Types.TxId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.DB.Sqlite.Types.TxId
instance Web.PathPieces.PathPiece Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.Direction
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.Direction
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.WalletId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Primitive.Types.WalletId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Primitive.Types.WalletId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.WalletId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.WalletId
instance Web.PathPieces.PathPiece Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.SlotId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.SlotId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.SlotId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.SlotId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.WalletState
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.WalletState
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.WalletState
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.TxStatus
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.TxStatus
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.Coin
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.Coin
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.Address
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.Address
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.AddressDerivation.Sequential.ChangeChain
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.AddressDerivation.Sequential.ChangeChain
instance Database.Persist.Class.PersistField.PersistField System.Random.StdGen
instance Database.Persist.Sql.Class.PersistFieldSql System.Random.StdGen


-- | Auto-generated Sqlite &amp; Persistent machinery via Template-Haskell.
--   This has been moved into a separate file so that we can treat it
--   slightly differently when computing code-coverage.
--   
--   More than 6K lines end-up being generated from the instructions below!
--   As a result, we're going to ignore code-coverage on the following
--   module and, no hand-written functions should be written in this
--   module!
module Cardano.Wallet.DB.Sqlite.TH
data Wallet
Wallet :: !WalletId -> !UTCTime -> !Text -> !Maybe UTCTime -> !WalletState -> !Maybe Text -> Wallet
[walId] :: Wallet -> !WalletId
[walCreationTime] :: Wallet -> !UTCTime
[walName] :: Wallet -> !Text
[walPassphraseLastUpdatedAt] :: Wallet -> !Maybe UTCTime
[walStatus] :: Wallet -> !WalletState
[walDelegation] :: Wallet -> !Maybe Text
type WalletId = Key Wallet
data PrivateKey
PrivateKey :: !WalletId -> !ByteString -> !ByteString -> PrivateKey
[privateKeyWalletId] :: PrivateKey -> !WalletId
[privateKeyRootKey] :: PrivateKey -> !ByteString
[privateKeyHash] :: PrivateKey -> !ByteString
type PrivateKeyId = Key PrivateKey
data TxMeta
TxMeta :: !TxId -> !WalletId -> !TxStatus -> !Direction -> !SlotId -> !Natural -> TxMeta
[txMetaTxId] :: TxMeta -> !TxId
[txMetaWalletId] :: TxMeta -> !WalletId
[txMetaStatus] :: TxMeta -> !TxStatus
[txMetaDirection] :: TxMeta -> !Direction
[txMetaSlotId] :: TxMeta -> !SlotId
[txMetaAmount] :: TxMeta -> !Natural
type TxMetaId = Key TxMeta
data TxIn
TxIn :: !TxId -> !Int -> !TxId -> !Word32 -> !Maybe Coin -> TxIn
[txInputTxId] :: TxIn -> !TxId
[txInputOrder] :: TxIn -> !Int
[txInputSourceTxId] :: TxIn -> !TxId
[txInputSourceIndex] :: TxIn -> !Word32
[txInputSourceAmount] :: TxIn -> !Maybe Coin
type TxInId = Key TxIn
data TxOut
TxOut :: !TxId -> !Word32 -> !Address -> !Coin -> TxOut
[txOutputTxId] :: TxOut -> !TxId
[txOutputIndex] :: TxOut -> !Word32
[txOutputAddress] :: TxOut -> !Address
[txOutputAmount] :: TxOut -> !Coin
type TxOutId = Key TxOut
data Checkpoint
Checkpoint :: !WalletId -> !SlotId -> !BlockId -> !Word64 -> Checkpoint
[checkpointWalletId] :: Checkpoint -> !WalletId
[checkpointSlot] :: Checkpoint -> !SlotId
[checkpointParent] :: Checkpoint -> !BlockId
[checkpointBlockHeight] :: Checkpoint -> !Word64
type CheckpointId = Key Checkpoint
data UTxO
UTxO :: !WalletId -> !SlotId -> !Maybe SlotId -> !TxId -> !Word32 -> !Address -> !Coin -> UTxO
[utxoWalletId] :: UTxO -> !WalletId
[utxoSlot] :: UTxO -> !SlotId
[utxoSlotSpent] :: UTxO -> !Maybe SlotId
[utxoInputId] :: UTxO -> !TxId
[utxoInputIndex] :: UTxO -> !Word32
[utxoOutputAddress] :: UTxO -> !Address
[utxoOutputCoin] :: UTxO -> !Coin
type UTxOId = Key UTxO
data SeqState
SeqState :: !WalletId -> !AddressPoolGap -> !AddressPoolGap -> !AddressPoolXPub -> SeqState
[seqStateWalletId] :: SeqState -> !WalletId
[seqStateExternalGap] :: SeqState -> !AddressPoolGap
[seqStateInternalGap] :: SeqState -> !AddressPoolGap
[seqStateAccountXPub] :: SeqState -> !AddressPoolXPub
type SeqStateId = Key SeqState
data SeqStateAddress
SeqStateAddress :: !WalletId -> !SlotId -> !Address -> !Word32 -> !ChangeChain -> SeqStateAddress
[seqStateAddressWalletId] :: SeqStateAddress -> !WalletId
[seqStateAddressSlot] :: SeqStateAddress -> !SlotId
[seqStateAddressAddress] :: SeqStateAddress -> !Address
[seqStateAddressIndex] :: SeqStateAddress -> !Word32
[seqStateAddressChangeChain] :: SeqStateAddress -> !ChangeChain
type SeqStateAddressId = Key SeqStateAddress
data SeqStateCheckpoint
SeqStateCheckpoint :: !WalletId -> !SlotId -> SeqStateCheckpoint
[seqStateCheckpointWalletId] :: SeqStateCheckpoint -> !WalletId
[seqStateCheckpointSlot] :: SeqStateCheckpoint -> !SlotId
type SeqStateCheckpointId = Key SeqStateCheckpoint
data SeqStatePendingIx
SeqStatePendingIx :: !Key SeqStateCheckpoint -> !Word32 -> SeqStatePendingIx
[seqStatePendingIxCheckpointId] :: SeqStatePendingIx -> !Key SeqStateCheckpoint
[seqStatePendingIxIndex] :: SeqStatePendingIx -> !Word32
type SeqStatePendingIxId = Key SeqStatePendingIx
data RndState
RndState :: !WalletId -> !Word32 -> RndState
[rndStateWalletId] :: RndState -> !WalletId
[rndStateAccountIndex] :: RndState -> !Word32
type RndStateId = Key RndState
data RndStateAddress
RndStateAddress :: !WalletId -> !SlotId -> !Word32 -> !Word32 -> !Address -> RndStateAddress
[rndStateAddressWalletId] :: RndStateAddress -> !WalletId
[rndStateAddressSlot] :: RndStateAddress -> !SlotId
[rndStateAddressAccountIndex] :: RndStateAddress -> !Word32
[rndStateAddressIndex] :: RndStateAddress -> !Word32
[rndStateAddressAddress] :: RndStateAddress -> !Address
type RndStateAddressId = Key RndStateAddress
data RndStateCheckpoint
RndStateCheckpoint :: !WalletId -> !SlotId -> !StdGen -> RndStateCheckpoint
[rndStateCheckpointWalletId] :: RndStateCheckpoint -> !WalletId
[rndStateCheckpointSlot] :: RndStateCheckpoint -> !SlotId
[rndStateCheckpointGen] :: RndStateCheckpoint -> !StdGen
type RndStateCheckpointId = Key RndStateCheckpoint
data RndStatePendingAddress
RndStatePendingAddress :: !Key RndStateCheckpoint -> !Word32 -> !Word32 -> !Address -> RndStatePendingAddress
[rndStatePendingAddressCheckpointId] :: RndStatePendingAddress -> !Key RndStateCheckpoint
[rndStatePendingAddressAccountIndex] :: RndStatePendingAddress -> !Word32
[rndStatePendingAddressIndex] :: RndStatePendingAddress -> !Word32
[rndStatePendingAddressAddress] :: RndStatePendingAddress -> !Address
type RndStatePendingAddressId = Key RndStatePendingAddress
migrateAll :: Migration
fk_checkpoint_rnd_state :: RndStateCheckpoint -> Key Checkpoint
fk_wallet_rnd_state :: RndState -> Key Wallet
fk_checkpoint_seq_state :: SeqStateCheckpoint -> Key Checkpoint
fk_wallet_seq_state :: SeqState -> Key Wallet
fk_wallet_utxo :: UTxO -> Key Wallet
fk_wallet_checkpoint :: Checkpoint -> Key Wallet
fk_wallet_tx_meta :: TxMeta -> Key Wallet
fk_wallet_private_key :: PrivateKey -> Key Wallet
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.RndStateAddress
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.RndStateAddress
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.RndState
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.RndState
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.SeqState
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.SeqState
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.UTxO
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.UTxO
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.Checkpoint
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.Checkpoint
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.TxOut
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.TxOut
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.TxIn
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.TxIn
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.TxMeta
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.TxMeta
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.PrivateKey
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.PrivateKey
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.TH.Wallet
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.TH.Wallet
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Wallet)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.PrivateKey)
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.UTxO)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqState)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint)
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndState)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateAddress)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress)
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.RndStatePendingAddress backend
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.RndStateCheckpoint backend
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.RndStateAddress
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.RndStateAddress
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.RndStateAddress
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Cardano.Wallet.DB.Sqlite.TH.RndStateAddress
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.RndStateAddress Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.RndStateAddress backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.RndState
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.RndState
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.RndState
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.RndState Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.RndState backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx)
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.SeqStatePendingIx backend
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.SeqStateCheckpoint backend
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.SeqStateAddress backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.SeqState
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.SeqState
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.SeqState
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.SeqState Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.SeqState backend
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.UTxO
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.UTxO
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.UTxO
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.Sql.Types.Internal.SqlBackend Cardano.Wallet.DB.Sqlite.TH.UTxO
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.UTxO Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.UTxO backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.Checkpoint
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.Checkpoint
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.Checkpoint
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.Checkpoint)
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.Checkpoint Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.Checkpoint backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.TxOut
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.TxOut
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.TxOut
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxOut)
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.TxOut Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.TxOut backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.TxIn
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.TxIn
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.TxIn
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxIn)
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.TxIn Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.TxIn backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.TxMeta
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.TxMeta
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.TxMeta
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.TH.TxMeta)
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.TxMeta Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.TxMeta backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.PrivateKey
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.PrivateKey
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.PrivateKey
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.PrivateKey Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.PrivateKey backend
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.TH.Wallet
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.TH.Wallet
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.TH.Wallet
instance (Database.Persist.Class.PersistQuery backend, Database.Persist.Class.PersistEntity.PersistEntityBackend Cardano.Wallet.DB.Sqlite.TH.Wallet Data.Type.Equality.~ Database.Persist.Class.PersistStore.BaseBackend backend) => Database.Persist.Class.DeleteCascade.DeleteCascade Cardano.Wallet.DB.Sqlite.TH.Wallet backend


-- | An implementation of the DBLayer which uses Persistent and SQLite.
module Cardano.Wallet.DB.Sqlite

-- | Context for the SQLite <a>DBLayer</a>.
data SqliteContext

-- | Sets up a connection to the SQLite database.
--   
--   Database migrations are run to create tables if necessary.
--   
--   If the given file path does not exist, it will be created by the
--   sqlite library.
--   
--   <tt>getDBLayer</tt> will provide the actual <a>DBLayer</a>
--   implementation. The database should be closed with
--   <a>destroyDBLayer</a>. If you use <a>withDBLayer</a> then both of
--   these things will be handled for you.
newDBLayer :: forall s t k. (IsOurs s, NFData s, Show s, PersistState s, PersistTx t, PersistKey k) => Configuration -> Trace IO Text -> Maybe FilePath -> IO (SqliteContext, DBLayer IO s t k)

-- | Finalize database statements and close the database connection.
destroyDBLayer :: SqliteContext -> IO ()

-- | Runs an action with a connection to the SQLite database.
--   
--   Database migrations are run to create tables if necessary.
--   
--   If the given file path does not exist, it will be created by the
--   sqlite library.
withDBLayer :: forall s t k a. (IsOurs s, NFData s, Show s, PersistState s, PersistTx t, PersistKey k) => Configuration -> Trace IO Text -> Maybe FilePath -> (DBLayer IO s t k -> IO a) -> IO a

-- | Run a raw query from the outside using an instantiate DB layer. This
--   is completely unsafe because it breaks the abstraction boundary and
--   can have disastrous results on the database consistency.
unsafeRunQuery :: SqliteContext -> SqlPersistT IO a -> IO a

-- | Functions for saving/loading the wallet's address discovery state into
--   SQLite.
class PersistState s

-- | Store the state for a checkpoint.
insertState :: PersistState s => (WalletId, SlotId) -> s -> SqlPersistT IO ()

-- | Load the state for a checkpoint.
selectState :: PersistState s => (WalletId, SlotId) -> SqlPersistT IO (Maybe s)

-- | Remove the state for all checkpoints of a wallet.
deleteState :: PersistState s => WalletId -> SqlPersistT IO ()
class DefineTx t => PersistTx t
resolvedInputs :: PersistTx t => Tx t -> [(TxIn, Maybe Coin)]

-- | Extract transaction resolved inputs. This slightly breaks the
--   abstraction boundary of <a>DefineTx</a> which doesn't really force any
--   structure on the resolved inputs. However, here in the DB-Layer,
--   supporting arbitrary shape for the inputs be much more complex and
--   require quite a lot of work. So, we kinda force the format here and
--   only here, and leave the rest of the code with an opaque
--   <tt>ResolvedTxIn</tt> type.
mkTx :: PersistTx t => Hash "Tx" -> [(TxIn, Maybe Coin)] -> [TxOut] -> Tx t
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.DB.Sqlite.DBLog
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.DBLog
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.DBLog
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.DBLog
instance Cardano.Wallet.Primitive.AddressDerivation.KeyToAddress t Cardano.Wallet.Primitive.AddressDerivation.Sequential.SeqKey => Cardano.Wallet.DB.Sqlite.PersistState (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState t)
instance Cardano.Wallet.DB.Sqlite.PersistState (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState t)


-- | Provides wallet layer functions that are used by API layer. Uses both
--   <a>Cardano.Wallet.DB</a> and <a>Cardano.Wallet.Network</a> to realize
--   its role as being intermediary between the three.
module Cardano.Wallet
data WalletLayer s t k
WalletLayer :: ((Show s, NFData s, IsOurs s, DefineTx t) => WalletId -> WalletName -> s -> ExceptT ErrWalletAlreadyExists IO WalletId) -> (WalletId -> ExceptT ErrNoSuchWallet IO (Wallet s t, WalletMetadata)) -> (WalletId -> (WalletMetadata -> WalletMetadata) -> ExceptT ErrNoSuchWallet IO ()) -> (WalletKey k => WalletId -> (Passphrase "encryption-old", Passphrase "encryption-new") -> ExceptT ErrUpdatePassphrase IO ()) -> IO [WalletId] -> (WalletId -> ExceptT ErrNoSuchWallet IO ()) -> (DefineTx t => WalletId -> ExceptT ErrNoSuchWallet IO ()) -> ((IsOurs s, CompareDiscovery s, KnownAddresses s, DefineTx t) => WalletId -> ExceptT ErrNoSuchWallet IO [(Address, AddressState)]) -> (forall e. (DefineTx t, e ~ ErrValidateSelection t) => WalletId -> NonEmpty TxOut -> ExceptT (ErrCreateUnsignedTx e) IO CoinSelection) -> (forall e. (DefineTx t, e ~ ErrValidateSelection t) => WalletId -> NonEmpty TxOut -> ExceptT (ErrEstimateTxFee e) IO Fee) -> (DefineTx t => WalletId -> ExceptT ErrListUTxOStatistics IO UTxOStatistics) -> ((Show s, NFData s, IsOwned s k, GenChange s) => WalletId -> Passphrase "encryption" -> CoinSelection -> ExceptT ErrSignTx IO (Tx t, TxMeta, [TxWitness])) -> (DefineTx t => WalletId -> (Tx t, TxMeta, [TxWitness]) -> ExceptT ErrSubmitTx IO ()) -> (ByteString -> ExceptT ErrSubmitExternalTx IO (Tx t)) -> (DefineTx t => WalletId -> Maybe UTCTime -> Maybe UTCTime -> SortOrder -> ExceptT ErrListTransactions IO [TransactionInfo]) -> (WalletKey k => WalletId -> (k  'RootK XPrv, Passphrase "encryption") -> ExceptT ErrNoSuchWallet IO ()) -> WalletLayer s t k

-- | Initialise and store a new wallet, returning its ID.
[$sel:createWallet:WalletLayer] :: WalletLayer s t k -> (Show s, NFData s, IsOurs s, DefineTx t) => WalletId -> WalletName -> s -> ExceptT ErrWalletAlreadyExists IO WalletId

-- | Retrieve the wallet state for the wallet with the given ID.
[$sel:readWallet:WalletLayer] :: WalletLayer s t k -> WalletId -> ExceptT ErrNoSuchWallet IO (Wallet s t, WalletMetadata)

-- | Update a wallet's metadata with the given update function.
[$sel:updateWallet:WalletLayer] :: WalletLayer s t k -> WalletId -> (WalletMetadata -> WalletMetadata) -> ExceptT ErrNoSuchWallet IO ()

-- | Change a wallet's passphrase to the given passphrase.
[$sel:updateWalletPassphrase:WalletLayer] :: WalletLayer s t k -> WalletKey k => WalletId -> (Passphrase "encryption-old", Passphrase "encryption-new") -> ExceptT ErrUpdatePassphrase IO ()

-- | Retrieve a list of known wallet IDs.
[$sel:listWallets:WalletLayer] :: WalletLayer s t k -> IO [WalletId]

-- | Remove an existing wallet. Note that there's no particular work to be
--   done regarding the restoration worker as it will simply terminate on
--   the next tick when noticing that the corresponding wallet is gone.
[$sel:removeWallet:WalletLayer] :: WalletLayer s t k -> WalletId -> ExceptT ErrNoSuchWallet IO ()

-- | Restore a wallet from its current tip up to the network tip.
--   
--   This function returns immediately, starting a worker thread in the
--   background that will fetch and apply remaining blocks until the
--   network tip is reached or until failure.
[$sel:restoreWallet:WalletLayer] :: WalletLayer s t k -> DefineTx t => WalletId -> ExceptT ErrNoSuchWallet IO ()

-- | List all addresses of a wallet with their metadata. Addresses are
--   ordered from the most-recently-discovered to the oldest known.
[$sel:listAddresses:WalletLayer] :: WalletLayer s t k -> (IsOurs s, CompareDiscovery s, KnownAddresses s, DefineTx t) => WalletId -> ExceptT ErrNoSuchWallet IO [(Address, AddressState)]

-- | Prepare a transaction and automatically select inputs from the wallet
--   to cover the requested outputs. Note that this only runs coin
--   selection for the given outputs. In order to construct (and sign) an
--   actual transaction, use <a>$sel:signTx:WalletLayer</a>.
[$sel:createUnsignedTx:WalletLayer] :: WalletLayer s t k -> forall e. (DefineTx t, e ~ ErrValidateSelection t) => WalletId -> NonEmpty TxOut -> ExceptT (ErrCreateUnsignedTx e) IO CoinSelection

-- | Estimate a transaction fee by automatically selecting inputs from the
--   wallet to cover the requested outputs.
[$sel:estimateTxFee:WalletLayer] :: WalletLayer s t k -> forall e. (DefineTx t, e ~ ErrValidateSelection t) => WalletId -> NonEmpty TxOut -> ExceptT (ErrEstimateTxFee e) IO Fee

-- | List the wallet's UTxO statistics.
[$sel:listUtxoStatistics:WalletLayer] :: WalletLayer s t k -> DefineTx t => WalletId -> ExceptT ErrListUTxOStatistics IO UTxOStatistics

-- | Produce witnesses and construct a transaction from a given selection.
--   Requires the encryption passphrase in order to decrypt the root
--   private key. Note that this doesn't broadcast the transaction to the
--   network. In order to do so, use <a>$sel:submitTx:WalletLayer</a>.
[$sel:signTx:WalletLayer] :: WalletLayer s t k -> (Show s, NFData s, IsOwned s k, GenChange s) => WalletId -> Passphrase "encryption" -> CoinSelection -> ExceptT ErrSignTx IO (Tx t, TxMeta, [TxWitness])

-- | Broadcast a (signed) transaction to the network.
[$sel:submitTx:WalletLayer] :: WalletLayer s t k -> DefineTx t => WalletId -> (Tx t, TxMeta, [TxWitness]) -> ExceptT ErrSubmitTx IO ()

-- | Broadcast an externally-signed transaction to the network.
[$sel:submitExternalTx:WalletLayer] :: WalletLayer s t k -> ByteString -> ExceptT ErrSubmitExternalTx IO (Tx t)

-- | List all transactions and metadata from history for a given wallet.
[$sel:listTransactions:WalletLayer] :: WalletLayer s t k -> DefineTx t => WalletId -> Maybe UTCTime -> Maybe UTCTime -> SortOrder -> ExceptT ErrListTransactions IO [TransactionInfo]

-- | Attach a given private key to a wallet. The private key is necessary
--   for some operations like signing transactions, or generating new
--   accounts.
[$sel:attachPrivateKey:WalletLayer] :: WalletLayer s t k -> WalletKey k => WalletId -> (k  'RootK XPrv, Passphrase "encryption") -> ExceptT ErrNoSuchWallet IO ()
data BlockchainParameters t
BlockchainParameters :: Block (Tx t) -> StartTime -> FeePolicy -> SlotLength -> EpochLength -> Quantity "byte" Word16 -> Quantity "block" Word32 -> BlockchainParameters t

-- | Very first block.
[$sel:getGenesisBlock:BlockchainParameters] :: BlockchainParameters t -> Block (Tx t)

-- | Start time of the chain.
[$sel:getGenesisBlockDate:BlockchainParameters] :: BlockchainParameters t -> StartTime

-- | Policy regarding transaction fee.
[$sel:getFeePolicy:BlockchainParameters] :: BlockchainParameters t -> FeePolicy

-- | Length, in seconds, of a slot.
[$sel:getSlotLength:BlockchainParameters] :: BlockchainParameters t -> SlotLength

-- | Number of slots in a single epoch.
[$sel:getEpochLength:BlockchainParameters] :: BlockchainParameters t -> EpochLength

-- | Maximum size of a transaction (soft or hard limit).
[$sel:getTxMaxSize:BlockchainParameters] :: BlockchainParameters t -> Quantity "byte" Word16

-- | Length of the suffix of the chain considered unstable
[$sel:getEpochStability:BlockchainParameters] :: BlockchainParameters t -> Quantity "block" Word32
newtype ErrAdjustForFee

-- | UTxO exhausted during fee covering We record what amount missed to
--   cover the fee
ErrCannotCoverFee :: Word64 -> ErrAdjustForFee
data ErrCoinSelection e

-- | UTxO exhausted during input selection We record the balance of the
--   UTxO as well as the size of the payment we tried to make.
ErrNotEnoughMoney :: Word64 -> Word64 -> ErrCoinSelection e

-- | UTxO is not enough fragmented for the number of transaction outputs We
--   record the number of UTxO entries as well as the number of the outputs
--   of the transaction.
ErrUtxoNotEnoughFragmented :: Word64 -> Word64 -> ErrCoinSelection e

-- | When trying to construct a transaction, the max number of allowed
--   inputs was reached.
ErrMaximumInputsReached :: Word64 -> ErrCoinSelection e

-- | When trying to construct a transaction, the available inputs are
--   depleted even when UTxO is properly fragmented and with enough funds
--   to cover payment
ErrInputsDepleted :: ErrCoinSelection e

-- | Somewhat, we ended up generating an invalid coin selection because of
--   inputs passed down to the coin selection function, or because a target
--   backend has extra-limitations not covered by our coin selection
--   algorithm.
ErrInvalidSelection :: e -> ErrCoinSelection e

-- | Errors that can occur when creating an unsigned transaction.
data ErrCreateUnsignedTx e
ErrCreateUnsignedTxNoSuchWallet :: ErrNoSuchWallet -> ErrCreateUnsignedTx e
ErrCreateUnsignedTxCoinSelection :: ErrCoinSelection e -> ErrCreateUnsignedTx e
ErrCreateUnsignedTxFee :: ErrAdjustForFee -> ErrCreateUnsignedTx e

-- | Errors that can occur when estimating transaction fees.
data ErrEstimateTxFee e
ErrEstimateTxFeeNoSuchWallet :: ErrNoSuchWallet -> ErrEstimateTxFee e
ErrEstimateTxFeeCoinSelection :: ErrCoinSelection e -> ErrEstimateTxFee e

-- | Errors that can occur when trying to list transactions.
data ErrListTransactions
ErrListTransactionsNoSuchWallet :: ErrNoSuchWallet -> ErrListTransactions
ErrListTransactionsStartTimeLaterThanEndTime :: ErrStartTimeLaterThanEndTime -> ErrListTransactions

-- | Errors that can occur when listing UTxO statistics.
newtype ErrListUTxOStatistics
ErrListUTxOStatisticsNoSuchWallet :: ErrNoSuchWallet -> ErrListUTxOStatistics

-- | Possible signing error
newtype ErrMkStdTx

-- | We tried to sign a transaction with inputs that are unknown to us?
ErrKeyNotFoundForAddress :: Address -> ErrMkStdTx

-- | Network is unavailable
data ErrNetworkUnavailable

-- | Cannot connect to network backend.
ErrNetworkUnreachable :: Text -> ErrNetworkUnavailable

-- | Network backend reports that the requested network is invalid.
ErrNetworkInvalid :: Text -> ErrNetworkUnavailable

-- | Can't perform given operation because there's no wallet
newtype ErrNoSuchWallet
ErrNoSuchWallet :: WalletId -> ErrNoSuchWallet

-- | Error while trying to send a transaction
data ErrPostTx
ErrPostTxNetworkUnreachable :: ErrNetworkUnavailable -> ErrPostTx
ErrPostTxBadRequest :: Text -> ErrPostTx
ErrPostTxProtocolFailure :: Text -> ErrPostTx

-- | Error while trying to decode externally signed transaction
data ErrDecodeExternalTx
ErrDecodeExternalTxWrongPayload :: Text -> ErrDecodeExternalTx
ErrDecodeExternalTxNotSupported :: ErrDecodeExternalTx

-- | Errors that can occur when signing a transaction.
data ErrSignTx
ErrSignTx :: ErrMkStdTx -> ErrSignTx
ErrSignTxNoSuchWallet :: ErrNoSuchWallet -> ErrSignTx
ErrSignTxWithRootKey :: ErrWithRootKey -> ErrSignTx

-- | Indicates that the specified start time is later than the specified
--   end time.
data ErrStartTimeLaterThanEndTime
ErrStartTimeLaterThanEndTime :: UTCTime -> UTCTime -> ErrStartTimeLaterThanEndTime
[$sel:errStartTime:ErrStartTimeLaterThanEndTime] :: ErrStartTimeLaterThanEndTime -> UTCTime
[$sel:errEndTime:ErrStartTimeLaterThanEndTime] :: ErrStartTimeLaterThanEndTime -> UTCTime

-- | Errors that can occur when submitting a signed transaction to the
--   network.
data ErrSubmitTx
ErrSubmitTxNetwork :: ErrPostTx -> ErrSubmitTx
ErrSubmitTxNoSuchWallet :: ErrNoSuchWallet -> ErrSubmitTx

-- | Errors that can occur when submitting an externally-signed transaction
--   to the network.
data ErrSubmitExternalTx
ErrSubmitExternalTxNetwork :: ErrPostTx -> ErrSubmitExternalTx
ErrSubmitExternalTxDecode :: ErrDecodeExternalTx -> ErrSubmitExternalTx

-- | Errors that can occur when trying to change a wallet's passphrase.
data ErrUpdatePassphrase
ErrUpdatePassphraseNoSuchWallet :: ErrNoSuchWallet -> ErrUpdatePassphrase
ErrUpdatePassphraseWithRootKey :: ErrWithRootKey -> ErrUpdatePassphrase

-- | A type family for validations that are specific to a particular
--   backend type. This demands an instantiation of the family for a
--   particular backend:
--   
--   type instance (ErrValidateSelection MyBackend) = MyCustomError
type family ErrValidateSelection t

-- | Forbidden operation was executed on an already existing wallet
newtype ErrWalletAlreadyExists
ErrWalletAlreadyExists :: WalletId -> ErrWalletAlreadyExists

-- | Errors that can occur when trying to perform an operation on a wallet
--   that requires a private key, but where none is attached to the wallet.
data ErrWithRootKey
ErrWithRootKeyNoRootKey :: WalletId -> ErrWithRootKey
ErrWithRootKeyWrongPassphrase :: WalletId -> ErrWrongPassphrase -> ErrWithRootKey

-- | Indicate a failure when checking for a given <a>Passphrase</a> match
data ErrWrongPassphrase
ErrWrongPassphrase :: ErrWrongPassphrase

-- | Create a new instance of the wallet layer.
newWalletLayer :: forall s t k. Buildable (Tx t) => Trace IO Text -> BlockchainParameters t -> DBLayer IO s t k -> NetworkLayer t IO -> TransactionLayer t k -> IO (WalletLayer s t k)
instance GHC.Classes.Eq Cardano.Wallet.ErrListTransactions
instance GHC.Show.Show Cardano.Wallet.ErrListTransactions
instance GHC.Classes.Eq Cardano.Wallet.ErrStartTimeLaterThanEndTime
instance GHC.Show.Show Cardano.Wallet.ErrStartTimeLaterThanEndTime
instance GHC.Classes.Eq Cardano.Wallet.ErrSignTx
instance GHC.Show.Show Cardano.Wallet.ErrSignTx
instance GHC.Classes.Eq Cardano.Wallet.ErrUpdatePassphrase
instance GHC.Show.Show Cardano.Wallet.ErrUpdatePassphrase
instance GHC.Classes.Eq Cardano.Wallet.ErrWithRootKey
instance GHC.Show.Show Cardano.Wallet.ErrWithRootKey
instance GHC.Classes.Eq Cardano.Wallet.ErrSubmitExternalTx
instance GHC.Show.Show Cardano.Wallet.ErrSubmitExternalTx
instance GHC.Classes.Eq Cardano.Wallet.ErrSubmitTx
instance GHC.Show.Show Cardano.Wallet.ErrSubmitTx
instance GHC.Classes.Eq Cardano.Wallet.ErrListUTxOStatistics
instance GHC.Show.Show Cardano.Wallet.ErrListUTxOStatistics
instance GHC.Classes.Eq e => GHC.Classes.Eq (Cardano.Wallet.ErrEstimateTxFee e)
instance GHC.Show.Show e => GHC.Show.Show (Cardano.Wallet.ErrEstimateTxFee e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Cardano.Wallet.ErrCreateUnsignedTx e)
instance GHC.Show.Show e => GHC.Show.Show (Cardano.Wallet.ErrCreateUnsignedTx e)


-- | Utility functions for converting time values to and from text.
module Data.Time.Text

-- | Convert the specified time value to text, using the specified time
--   format.
utcTimeToText :: TimeFormat -> UTCTime -> Text

-- | Attempt to use each of the specified time formats to parse the given
--   text. Returns a time value that corresponds to the first matching
--   format, or <a>Nothing</a> if none of the formats matched.
utcTimeFromText :: [TimeFormat] -> Text -> Maybe UTCTime

-- | Represents a particular way of representing a moment in time in text.
data TimeFormat
TimeFormat :: String -> String -> TimeFormat
[timeFormatName] :: TimeFormat -> String
[timeFormatPattern] :: TimeFormat -> String

-- | Represents the ISO 8601 basic format (UTC).
iso8601BasicUtc :: TimeFormat

-- | Represents the ISO 8601 basic format (with local timezone).
iso8601BasicLocal :: TimeFormat

-- | Represents the ISO 8601 extended format (UTC).
iso8601ExtendedUtc :: TimeFormat

-- | Represents the ISO 8601 extended format (with local timezone).
iso8601ExtendedLocal :: TimeFormat

-- | Represents the ISO 8601 family of formats.
iso8601 :: [TimeFormat]

-- | Represents the ISO 8601 basic family of formats.
iso8601Basic :: [TimeFormat]

-- | Represents the ISO 8601 extended family of formats.
iso8601Extended :: [TimeFormat]
instance GHC.Classes.Eq Data.Time.Text.TimeFormat


-- | API type representations of various types. We define here pretty much
--   all our user-facing types that are mostly composed with internal /
--   primitive types.
--   
--   This module also define required API instances (JSON, HttpApiData...)
--   for all those types, making sure to match the specification document:
--   
--   <a>Wallet API Specification</a>
module Cardano.Wallet.Api.Types
data ApiAddress t
ApiAddress :: !(ApiT Address, Proxy t) -> !ApiT AddressState -> ApiAddress t
[$sel:id:ApiAddress] :: ApiAddress t -> !(ApiT Address, Proxy t)
[$sel:state:ApiAddress] :: ApiAddress t -> !ApiT AddressState
data ApiWallet
ApiWallet :: !ApiT WalletId -> !ApiT AddressPoolGap -> !ApiT WalletBalance -> !ApiT (WalletDelegation (ApiT PoolId)) -> !ApiT WalletName -> !Maybe (ApiT WalletPassphraseInfo) -> !ApiT WalletState -> ApiWallet
[$sel:id:ApiWallet] :: ApiWallet -> !ApiT WalletId
[$sel:addressPoolGap:ApiWallet] :: ApiWallet -> !ApiT AddressPoolGap
[$sel:balance:ApiWallet] :: ApiWallet -> !ApiT WalletBalance
[$sel:delegation:ApiWallet] :: ApiWallet -> !ApiT (WalletDelegation (ApiT PoolId))
[$sel:name:ApiWallet] :: ApiWallet -> !ApiT WalletName
[$sel:passphrase:ApiWallet] :: ApiWallet -> !Maybe (ApiT WalletPassphraseInfo)
[$sel:state:ApiWallet] :: ApiWallet -> !ApiT WalletState
data ApiUtxoStatistics
ApiUtxoStatistics :: !Quantity "lovelace" Natural -> !ApiT BoundType -> !Map Word64 Word64 -> ApiUtxoStatistics
[$sel:total:ApiUtxoStatistics] :: ApiUtxoStatistics -> !Quantity "lovelace" Natural
[$sel:scale:ApiUtxoStatistics] :: ApiUtxoStatistics -> !ApiT BoundType
[$sel:distribution:ApiUtxoStatistics] :: ApiUtxoStatistics -> !Map Word64 Word64
data WalletBalance
WalletBalance :: !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> WalletBalance
[$sel:available:WalletBalance] :: WalletBalance -> !Quantity "lovelace" Natural
[$sel:total:WalletBalance] :: WalletBalance -> !Quantity "lovelace" Natural
data WalletPostData
WalletPostData :: !Maybe (ApiT AddressPoolGap) -> !ApiMnemonicT '[15, 18, 21, 24] "seed" -> !Maybe (ApiMnemonicT '[9, 12] "generation") -> !ApiT WalletName -> !ApiT (Passphrase "encryption") -> WalletPostData
[$sel:addressPoolGap:WalletPostData] :: WalletPostData -> !Maybe (ApiT AddressPoolGap)
[$sel:mnemonicSentence:WalletPostData] :: WalletPostData -> !ApiMnemonicT '[15, 18, 21, 24] "seed"
[$sel:mnemonicSecondFactor:WalletPostData] :: WalletPostData -> !Maybe (ApiMnemonicT '[9, 12] "generation")
[$sel:name:WalletPostData] :: WalletPostData -> !ApiT WalletName
[$sel:passphrase:WalletPostData] :: WalletPostData -> !ApiT (Passphrase "encryption")
newtype WalletPutData
WalletPutData :: Maybe (ApiT WalletName) -> WalletPutData
[$sel:name:WalletPutData] :: WalletPutData -> Maybe (ApiT WalletName)
data WalletPutPassphraseData
WalletPutPassphraseData :: !ApiT (Passphrase "encryption-old") -> !ApiT (Passphrase "encryption-new") -> WalletPutPassphraseData
[$sel:oldPassphrase:WalletPutPassphraseData] :: WalletPutPassphraseData -> !ApiT (Passphrase "encryption-old")
[$sel:newPassphrase:WalletPutPassphraseData] :: WalletPutPassphraseData -> !ApiT (Passphrase "encryption-new")
data PostTransactionData t
PostTransactionData :: !NonEmpty (AddressAmount t) -> !ApiT (Passphrase "encryption") -> PostTransactionData t
[$sel:payments:PostTransactionData] :: PostTransactionData t -> !NonEmpty (AddressAmount t)
[$sel:passphrase:PostTransactionData] :: PostTransactionData t -> !ApiT (Passphrase "encryption")
newtype PostTransactionFeeData t
PostTransactionFeeData :: NonEmpty (AddressAmount t) -> PostTransactionFeeData t
[$sel:payments:PostTransactionFeeData] :: PostTransactionFeeData t -> NonEmpty (AddressAmount t)
newtype PostExternalTransactionData
PostExternalTransactionData :: ByteString -> PostExternalTransactionData
[$sel:payload:PostExternalTransactionData] :: PostExternalTransactionData -> ByteString
data ApiBlockData
ApiBlockData :: UTCTime -> !ApiT SlotId -> ApiBlockData
[$sel:time:ApiBlockData] :: ApiBlockData -> UTCTime
[$sel:block:ApiBlockData] :: ApiBlockData -> !ApiT SlotId
data ApiTransaction t
ApiTransaction :: !ApiT (Hash "Tx") -> !Quantity "lovelace" Natural -> !Maybe ApiBlockData -> !Quantity "slot" Natural -> !ApiT Direction -> ![ApiTxInput t] -> !NonEmpty (AddressAmount t) -> !ApiT TxStatus -> ApiTransaction t
[$sel:id:ApiTransaction] :: ApiTransaction t -> !ApiT (Hash "Tx")
[$sel:amount:ApiTransaction] :: ApiTransaction t -> !Quantity "lovelace" Natural
[$sel:insertedAt:ApiTransaction] :: ApiTransaction t -> !Maybe ApiBlockData
[$sel:depth:ApiTransaction] :: ApiTransaction t -> !Quantity "slot" Natural
[$sel:direction:ApiTransaction] :: ApiTransaction t -> !ApiT Direction
[$sel:inputs:ApiTransaction] :: ApiTransaction t -> ![ApiTxInput t]
[$sel:outputs:ApiTransaction] :: ApiTransaction t -> !NonEmpty (AddressAmount t)
[$sel:status:ApiTransaction] :: ApiTransaction t -> !ApiT TxStatus
newtype ApiFee
ApiFee :: Quantity "lovelace" Natural -> ApiFee
[$sel:amount:ApiFee] :: ApiFee -> Quantity "lovelace" Natural
newtype ApiTxId
ApiTxId :: ApiT (Hash "Tx") -> ApiTxId
[$sel:id:ApiTxId] :: ApiTxId -> ApiT (Hash "Tx")
data ApiTxInput t
ApiTxInput :: !Maybe (AddressAmount t) -> !ApiT TxIn -> ApiTxInput t
[$sel:source:ApiTxInput] :: ApiTxInput t -> !Maybe (AddressAmount t)
[$sel:input:ApiTxInput] :: ApiTxInput t -> !ApiT TxIn
data AddressAmount t
AddressAmount :: !(ApiT Address, Proxy t) -> !Quantity "lovelace" Natural -> AddressAmount t
[$sel:address:AddressAmount] :: AddressAmount t -> !(ApiT Address, Proxy t)
[$sel:amount:AddressAmount] :: AddressAmount t -> !Quantity "lovelace" Natural

-- | Error codes returned by the API, in the form of snake_cased strings
data ApiErrorCode
NoSuchWallet :: ApiErrorCode
WalletAlreadyExists :: ApiErrorCode
NoRootKey :: ApiErrorCode
WrongEncryptionPassphrase :: ApiErrorCode
MalformedTxPayload :: ApiErrorCode
KeyNotFoundForAddress :: ApiErrorCode
NotEnoughMoney :: ApiErrorCode
UtxoNotEnoughFragmented :: ApiErrorCode
TransactionIsTooBig :: ApiErrorCode
InputsDepleted :: ApiErrorCode
CannotCoverFee :: ApiErrorCode
InvalidCoinSelection :: ApiErrorCode
NetworkUnreachable :: ApiErrorCode
NetworkMisconfigured :: ApiErrorCode
NetworkTipNotFound :: ApiErrorCode
CreatedInvalidTransaction :: ApiErrorCode
RejectedByCoreNode :: ApiErrorCode
BadRequest :: ApiErrorCode
NotFound :: ApiErrorCode
MethodNotAllowed :: ApiErrorCode
NotAcceptable :: ApiErrorCode
StartTimeLaterThanEndTime :: ApiErrorCode
UnsupportedMediaType :: ApiErrorCode
UnexpectedError :: ApiErrorCode

-- | Defines a point in time that can be formatted as and parsed from an
--   ISO 8601-compliant string.
newtype Iso8601Time
Iso8601Time :: UTCTime -> Iso8601Time
[$sel:getIso8601Time:Iso8601Time] :: Iso8601Time -> UTCTime

-- | Polymorphic wrapper type to put around primitive types and, 3rd party
--   lib types to avoid defining orphan instances and/or, undesirable
--   instances on primitive types. It helps to keep a nice separation of
--   concerns between the API layer and other modules.
newtype ApiT a
ApiT :: a -> ApiT a
[$sel:getApiT:ApiT] :: ApiT a -> a

-- | Representation of mnemonics at the API-level, using a polymorphic type
--   in the lengths of mnemonics that are supported (and an underlying
--   purpose). In practice, mnemonics correspond to passphrases or seeds,
--   and although they're nice to manipulate as mnemonics from a
--   user-perspective, carrying around a list of words doesn't really make
--   sense for the business logic, which prefers manipulating scrubbed
--   bytes directly.
--   
--   <pre>
--   data MyWallet
--       { mnemonic :: ApiMnemonicT '[15,18,21,24] "root-seed"
--       }
--   </pre>
--   
--   Note that the given <a>Nat</a>s **have** to be valid mnemonic sizes,
--   otherwise the underlying code won't even compile, with not-so-friendly
--   error messages.
--   
--   Also, the internal representation holds a <tt>[Text]</tt> which
--   contains the list of mnemonic words that was parsed. This is only to
--   be able to implement the <a>ToJSON</a> instances and roundtrip, which
--   is a very dubious argument. In practice, we'll NEVER peek at the
--   mnemonic, output them and whatnot.
newtype ApiMnemonicT (sizes :: [Nat]) (purpose :: Symbol)
ApiMnemonicT :: (Passphrase purpose, [Text]) -> ApiMnemonicT
getApiMnemonicT :: ApiMnemonicT sizes purpose -> Passphrase purpose
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletPostData
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiMnemonicT sizes purpose)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiMnemonicT sizes purpose)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiMnemonicT sizes purpose)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiAddress t)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiAddress t)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiAddress t)
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWallet
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWallet
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWallet
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletPutData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletPutData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletPutData
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance GHC.Show.Show (Cardano.Wallet.Api.Types.PostTransactionData t)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.PostTransactionData t)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.PostTransactionData t)
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiTxId
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiTxId
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiTxId
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiTransaction t)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiTransaction t)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiTransaction t)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiTxInput t)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiTxInput t)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiTxInput t)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.PostTransactionFeeData t)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.PostTransactionFeeData t)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.PostTransactionFeeData t)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.AddressAmount t)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.AddressAmount t)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.AddressAmount t)
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiBlockData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiBlockData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiBlockData
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiT a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Api.Types.ApiT a)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiT a)
instance GHC.Show.Show Cardano.Wallet.Api.Types.Iso8601Time
instance GHC.Classes.Ord Cardano.Wallet.Api.Types.Iso8601Time
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.Iso8601Time
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiErrorCode
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiErrorCode
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiErrorCode
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiFee
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiFee
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiFee
instance GHC.Show.Show Cardano.Wallet.Api.Types.PostExternalTransactionData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.PostExternalTransactionData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.PostExternalTransactionData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletPostData
instance Cardano.Wallet.Primitive.AddressDerivation.FromMnemonic sizes purpose => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiMnemonicT sizes purpose)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiMnemonicT sizes purpose)
instance Cardano.Wallet.Primitive.Types.DecodeAddress t => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiAddress t)
instance Cardano.Wallet.Primitive.Types.EncodeAddress t => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiAddress t)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWallet
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWallet
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletPutData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletPutData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance Cardano.Wallet.Primitive.Types.DecodeAddress t => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.PostTransactionData t)
instance Cardano.Wallet.Primitive.Types.EncodeAddress t => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.PostTransactionData t)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiTxId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiTxId
instance Cardano.Wallet.Primitive.Types.DecodeAddress t => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiTransaction t)
instance Cardano.Wallet.Primitive.Types.EncodeAddress t => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiTransaction t)
instance Cardano.Wallet.Primitive.Types.DecodeAddress t => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiTxInput t)
instance Cardano.Wallet.Primitive.Types.EncodeAddress t => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiTxInput t)
instance Cardano.Wallet.Primitive.Types.DecodeAddress t => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.PostTransactionFeeData t)
instance Cardano.Wallet.Primitive.Types.EncodeAddress t => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.PostTransactionFeeData t)
instance Cardano.Wallet.Primitive.Types.DecodeAddress t => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.AddressAmount t)
instance Cardano.Wallet.Primitive.Types.EncodeAddress t => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.AddressAmount t)
instance Cardano.Wallet.Primitive.Types.DecodeAddress t => Data.Text.Class.FromText (Cardano.Wallet.Api.Types.AddressAmount t)
instance Cardano.Wallet.Primitive.Types.EncodeAddress t => Data.Text.Class.ToText (Cardano.Wallet.Api.Types.AddressAmount t)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiBlockData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiBlockData
instance Cardano.Wallet.Primitive.Types.DecodeAddress t => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Address, Data.Proxy.Proxy t)
instance Cardano.Wallet.Primitive.Types.EncodeAddress t => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Address, Data.Proxy.Proxy t)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.AddressState)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.AddressState)
instance (Cardano.Wallet.Primitive.AddressDerivation.PassphraseMaxLength purpose, Cardano.Wallet.Primitive.AddressDerivation.PassphraseMinLength purpose) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletId)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletId)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletBalance)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletBalance)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.WalletDelegation (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolId)))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.WalletDelegation (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolId)))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletName)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletName)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletPassphraseInfo)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletPassphraseInfo)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletState)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletState)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.BoundType)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.BoundType)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolId)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolId)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SlotId)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SlotId)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TxIn)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TxIn)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash "Tx"))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash "Tx"))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Direction)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Direction)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TxStatus)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TxStatus)
instance Data.Text.Class.FromText a => Web.Internal.HttpApiData.FromHttpApiData (Cardano.Wallet.Api.Types.ApiT a)
instance Data.Text.Class.ToText a => Web.Internal.HttpApiData.ToHttpApiData (Cardano.Wallet.Api.Types.ApiT a)
instance Data.Text.Class.ToText Cardano.Wallet.Api.Types.Iso8601Time
instance Data.Text.Class.FromText Cardano.Wallet.Api.Types.Iso8601Time
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Api.Types.Iso8601Time
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Api.Types.Iso8601Time
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiErrorCode
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiFee
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiFee
instance Data.Text.Class.FromText Cardano.Wallet.Api.Types.PostExternalTransactionData
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.OctetStream Cardano.Wallet.Api.Types.PostExternalTransactionData
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream Cardano.Wallet.Api.Types.PostExternalTransactionData

module Cardano.Wallet.Api
type Api t = Addresses t :<|> Wallets :<|> Transactions t
type Addresses t = ListAddresses t

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listAddresses</a>
type ListAddresses t = "wallets" :> Capture "walletId" (ApiT WalletId) :> "addresses" :> QueryParam "state" (ApiT AddressState) :> Get '[JSON] [ApiAddress t]
type Wallets = DeleteWallet :<|> GetWallet :<|> ListWallets :<|> PostWallet :<|> PutWallet :<|> PutWalletPassphrase :<|> GetUTxOsStatistics

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/deleteWallet</a>
type DeleteWallet = "wallets" :> Capture "walletId" (ApiT WalletId) :> DeleteNoContent '[Any] NoContent

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getWallet</a>
type GetWallet = "wallets" :> Capture "walletId" (ApiT WalletId) :> Get '[JSON] ApiWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listWallets</a>
type ListWallets = "wallets" :> Get '[JSON] [ApiWallet]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postWallet</a>
type PostWallet = "wallets" :> ReqBody '[JSON] WalletPostData :> PostAccepted '[JSON] ApiWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/putWallet</a>
type PutWallet = "wallets" :> Capture "walletId" (ApiT WalletId) :> ReqBody '[JSON] WalletPutData :> Put '[JSON] ApiWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/putWalletPassphrase</a>
type PutWalletPassphrase = "wallets" :> Capture "walletId" (ApiT WalletId) :> "passphrase" :> ReqBody '[JSON] WalletPutPassphraseData :> PutNoContent '[Any] NoContent

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getUTxOsStatistics</a>
type GetUTxOsStatistics = "wallets" :> Capture "walletId" (ApiT WalletId) :> "statistics" :> "utxos" :> Get '[JSON] ApiUtxoStatistics
type Transactions t = CreateTransaction t :<|> ListTransactions t :<|> PostTransactionFee t :<|> PostExternalTransaction

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postTransaction</a>
type CreateTransaction t = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> ReqBody '[JSON] (PostTransactionData t) :> PostAccepted '[JSON] (ApiTransaction t)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postTransactionFee</a>
type PostTransactionFee t = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> "fees" :> ReqBody '[JSON] (PostTransactionFeeData t) :> PostAccepted '[JSON] ApiFee

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listTransaction</a>
type ListTransactions t = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> QueryParam "start" Iso8601Time :> QueryParam "end" Iso8601Time :> QueryParam "order" (ApiT SortOrder) :> Get '[JSON] [ApiTransaction t]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postExternalTransaction</a>
type PostExternalTransaction = "external-transactions" :> ReqBody '[OctetStream] PostExternalTransactionData :> PostAccepted '[JSON] ApiTxId

-- | Any media type
data Any
instance Servant.API.ContentTypes.Accept Cardano.Wallet.Api.Any


-- | Utility functions for manipulating time values.
module Data.Time.Utils

-- | For a given time <tt>t0</tt>, get the closest representable time
--   <tt>t1</tt> to <tt>t0</tt> for which 't1 &lt; t0'.
utcTimePred :: UTCTime -> UTCTime

-- | For a given time <tt>t0</tt>, get the closest representable time
--   <tt>t1</tt> to <tt>t0</tt> for which 't0 &lt; t1'.
utcTimeSucc :: UTCTime -> UTCTime

module Network.Wai.Middleware.Logging

-- | Installs a request &amp; response logger on a Wai application.
--   
--   The logger logs requests' and responses' bodies along with a few other
--   useful piece of information.
withApiLogger :: Trace IO Text -> ApiLoggerSettings -> Middleware

-- | Create a new opaque <a>ApiLoggerSettings</a>
newApiLoggerSettings :: IO ApiLoggerSettings

-- | API logger settings
data ApiLoggerSettings

-- | Define a set of top-level object keys that should be obfuscated for a
--   given request in a JSON format.
obfuscateKeys :: (Request -> [Text]) -> ApiLoggerSettings -> ApiLoggerSettings


-- | Middleware between Wai <a>-</a> Servant to accommodate raw error
--   responses returned by servant. See also <a>handleRawError</a>.
module Network.Wai.Middleware.ServantError

-- | Make sure every error is converted to a suitable application-level
--   error.
--   
--   There are many cases where Servant will handle errors itself and reply
--   to a client without even disturbing the application. This is both
--   handy and clunky since our application return errors in a specific
--   format (e.g. JSON, XML ...).
--   
--   This is the case for instance if the client hits a non-exiting
--   endpoint of the API, or if the client requests an invalid
--   content-type, etc ...
--   
--   Ideally, we would like clients to be able to expect one and only one
--   format, so this middleware allows for manipulating the response
--   returned by a Wai application (what servant boils down to) and adjust
--   the response when necessary. So, any response with or without payload
--   but no content-type will trigger the <tt>convert</tt> function and
--   offer the caller to adjust the response as needed.
handleRawError :: (ServantErr -> ServantErr) -> Middleware


-- | API handlers and server using the underlying wallet layer to provide
--   endpoints reachable through HTTP.
module Cardano.Wallet.Api.Server

-- | How the server should listen for incoming requests.
data Listen

-- | Listen on given TCP port
ListenOnPort :: Port -> Listen

-- | Listen on an unused TCP port, selected at random
ListenOnRandomPort :: Listen

-- | Start the application server, using the given settings and a bound
--   socket.
start :: forall t k. (DefineTx t, KeyToAddress t k, k ~ SeqKey, EncodeAddress t, DecodeAddress t, Buildable (ErrValidateSelection t)) => Settings -> Trace IO Text -> Socket -> WalletLayer (SeqState t) t k -> IO ()

-- | Run an action with a TCP socket bound to a port specified by the
--   <a>Listen</a> parameter.
withListeningSocket :: Listen -> ((Port, Socket) -> IO ()) -> IO ()
getRandomPort :: IO Port
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.Listen
instance GHC.Show.Show Cardano.Wallet.Api.Server.Listen
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.DB.ErrNoSuchWallet
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.DB.ErrWalletAlreadyExists
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrWithRootKey
instance Formatting.Buildable.Buildable e => Cardano.Wallet.Api.Server.LiftHandler (Cardano.Wallet.Primitive.CoinSelection.ErrCoinSelection e)
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.Primitive.Fee.ErrAdjustForFee
instance Formatting.Buildable.Buildable e => Cardano.Wallet.Api.Server.LiftHandler (Cardano.Wallet.ErrCreateUnsignedTx e)
instance Formatting.Buildable.Buildable e => Cardano.Wallet.Api.Server.LiftHandler (Cardano.Wallet.ErrEstimateTxFee e)
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrListUTxOStatistics
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrSignTx
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.Network.ErrDecodeExternalTx
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrSubmitExternalTx
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrSubmitTx
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.Network.ErrNetworkUnavailable
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrUpdatePassphrase
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrListTransactions
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrStartTimeLaterThanEndTime
instance Cardano.Wallet.Api.Server.LiftHandler Servant.Server.Internal.ServantErr.ServantErr

module Cardano.Wallet.Version
version :: Version

-- | Provides one possible concrete representation for <a>Version</a>. For
--   a version with <a>versionBranch</a> <tt>= [1,2,3]</tt> and
--   <a>versionTags</a> <tt>= ["tag1","tag2"]</tt>, the output will be
--   <tt>1.2.3-tag1-tag2</tt>.
showVersion :: Version -> String
