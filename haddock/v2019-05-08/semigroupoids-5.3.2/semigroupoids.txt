-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Semigroupoids: Category sans id
--   
--   Provides a wide array of (semi)groupoids and operations for working
--   with them.
--   
--   A <a>Semigroupoid</a> is a <a>Category</a> without the requirement of
--   identity arrows for every object in the category.
--   
--   A <a>Category</a> is any <a>Semigroupoid</a> for which the Yoneda
--   lemma holds.
--   
--   When working with comonads you often have the <tt>&lt;*&gt;</tt>
--   portion of an <tt>Applicative</tt>, but not the <tt>pure</tt>. This
--   was captured in Uustalu and Vene's "Essence of Dataflow Programming"
--   in the form of the <tt>ComonadZip</tt> class in the days before
--   <tt>Applicative</tt>. Apply provides a weaker invariant, but for the
--   comonads used for data flow programming (found in the streams
--   package), this invariant is preserved. Applicative function
--   composition forms a semigroupoid.
--   
--   Similarly many structures are nearly a comonad, but not quite, for
--   instance lists provide a reasonable <a>extend</a> operation in the
--   form of <a>tails</a>, but do not always contain a value.
--   
--   Ideally the following relationships would hold:
--   
--   <pre>
--   Foldable ----&gt; Traversable &lt;--- Functor ------&gt; Alt ---------&gt; Plus           Semigroupoid
--        |               |            |                              |                  |
--        v               v            v                              v                  v
--   Foldable1 ---&gt; Traversable1     Apply --------&gt; Applicative -&gt; Alternative      Category
--                                     |               |              |                  |
--                                     v               v              v                  v
--                                   Bind ---------&gt; Monad -------&gt; MonadPlus          Arrow
--   </pre>
--   
--   Apply, Bind, and Extend (not shown) give rise the Static, Kleisli and
--   Cokleisli semigroupoids respectively.
--   
--   This lets us remove many of the restrictions from various monad
--   transformers as in many cases the binding operation or
--   <tt>&lt;*&gt;</tt> operation does not require them.
--   
--   Finally, to work with these weaker structures it is beneficial to have
--   containers that can provide stronger guarantees about their contents,
--   so versions of <a>Traversable</a> and <a>Foldable</a> that can be
--   folded with just a <a>Semigroup</a> are added.
@package semigroupoids
@version 5.3.2


module Data.Functor.Extend
class Functor w => Extend w

-- | <pre>
--   duplicated = extended id
--   fmap (fmap f) . duplicated = duplicated . fmap f
--   </pre>
duplicated :: Extend w => w a -> w (w a)

-- | <pre>
--   extended f  = fmap f . duplicated
--   </pre>
extended :: Extend w => (w a -> b) -> w a -> w b
instance Data.Functor.Extend.Extend []
instance Data.Functor.Extend.Extend (Data.Tagged.Tagged a)
instance Data.Functor.Extend.Extend Data.Proxy.Proxy
instance Data.Functor.Extend.Extend GHC.Maybe.Maybe
instance Data.Functor.Extend.Extend (Data.Either.Either a)
instance Data.Functor.Extend.Extend ((,) e)
instance GHC.Base.Semigroup m => Data.Functor.Extend.Extend ((->) m)
instance Data.Functor.Extend.Extend Data.Sequence.Internal.Seq
instance Data.Functor.Extend.Extend Data.Tree.Tree
instance Data.Functor.Extend.Extend w => Data.Functor.Extend.Extend (Control.Comonad.Trans.Env.EnvT e w)
instance Data.Functor.Extend.Extend w => Data.Functor.Extend.Extend (Control.Comonad.Trans.Store.StoreT s w)
instance (Data.Functor.Extend.Extend w, GHC.Base.Semigroup m) => Data.Functor.Extend.Extend (Control.Comonad.Trans.Traced.TracedT m w)
instance Data.Functor.Extend.Extend Data.Functor.Identity.Identity
instance Data.Functor.Extend.Extend w => Data.Functor.Extend.Extend (Control.Monad.Trans.Identity.IdentityT w)
instance Data.Functor.Extend.Extend GHC.Base.NonEmpty
instance (Data.Functor.Extend.Extend f, Data.Functor.Extend.Extend g) => Data.Functor.Extend.Extend (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Extend.Extend f, Data.Functor.Extend.Extend g) => Data.Functor.Extend.Extend (f GHC.Generics.:+: g)
instance Data.Functor.Extend.Extend GHC.Generics.U1
instance Data.Functor.Extend.Extend GHC.Generics.V1
instance Data.Functor.Extend.Extend f => Data.Functor.Extend.Extend (GHC.Generics.M1 i t f)
instance Data.Functor.Extend.Extend GHC.Generics.Par1
instance Data.Functor.Extend.Extend f => Data.Functor.Extend.Extend (GHC.Generics.Rec1 f)
instance Data.Functor.Extend.Extend Data.Semigroup.Internal.Sum
instance Data.Functor.Extend.Extend Data.Semigroup.Internal.Product
instance Data.Functor.Extend.Extend Data.Semigroup.Internal.Dual
instance Data.Functor.Extend.Extend f => Data.Functor.Extend.Extend (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Extend.Extend Data.Semigroup.First
instance Data.Functor.Extend.Extend Data.Semigroup.Last
instance Data.Functor.Extend.Extend Data.Semigroup.Min
instance Data.Functor.Extend.Extend Data.Semigroup.Max


-- | This module is used to resolve the cyclic we get from defining these
--   classes here rather than in a package upstream. Otherwise we'd get
--   orphaned heads for many instances on the types in
--   <tt>transformers</tt> and <tt>bifunctors</tt>.
module Data.Functor.Bind.Class

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   (<a>.</a>) <a>&lt;$&gt;</a> u <a>&lt;.&gt;</a> v <a>&lt;.&gt;</a> w = u <a>&lt;.&gt;</a> (v <a>&lt;.&gt;</a> w)
--   x <a>&lt;.&gt;</a> (f <a>&lt;$&gt;</a> y) = (<a>.</a> f) <a>&lt;$&gt;</a> x <a>&lt;.&gt;</a> y
--   f <a>&lt;$&gt;</a> (x <a>&lt;.&gt;</a> y) = (f <a>.</a>) <a>&lt;$&gt;</a> x <a>&lt;.&gt;</a> y
--   </pre>
--   
--   The laws imply that <a>.&gt;</a> and <a>&lt;.</a> really ignore their
--   left and right results, respectively, and really return their right
--   and left results, respectively. Specifically,
--   
--   <pre>
--   (mf <a>&lt;$&gt;</a> m) <a>.&gt;</a> (nf <a>&lt;$&gt;</a> n) = nf <a>&lt;$&gt;</a> (m <a>.&gt;</a> n)
--   (mf <a>&lt;$&gt;</a> m) <a>&lt;.</a> (nf <a>&lt;$&gt;</a> n) = mf <a>&lt;$&gt;</a> (m <a>&lt;.</a> n)
--   </pre>
class Functor f => Apply f
(<.>) :: Apply f => f (a -> b) -> f a -> f b

-- | <pre>
--   a <a>.&gt;</a> b = <a>const</a> <a>id</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(.>) :: Apply f => f a -> f b -> f b

-- | <pre>
--   a <a>&lt;.</a> b = <a>const</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(<.) :: Apply f => f a -> f b -> f a

-- | Lift a binary function into a comonad with zipping
liftF2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c
infixl 4 <.>
infixl 4 <.
infixl 4 .>

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
[unwrapApplicative] :: WrappedApplicative f a -> f a

-- | Transform a Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
[runMaybeApply] :: MaybeApply f a -> Either (f a) a

-- | A <a>Monad</a> sans <a>return</a>.
--   
--   Minimal definition: Either <a>join</a> or <a>&gt;&gt;-</a>
--   
--   If defining both, then the following laws (the default definitions)
--   must hold:
--   
--   <pre>
--   join = (&gt;&gt;- id)
--   m &gt;&gt;- f = join (fmap f m)
--   </pre>
--   
--   Laws:
--   
--   <pre>
--   induced definition of &lt;.&gt;: f &lt;.&gt; x = f &gt;&gt;- (&lt;$&gt; x)
--   </pre>
--   
--   Finally, there are two associativity conditions:
--   
--   <pre>
--   associativity of (&gt;&gt;-):    (m &gt;&gt;- f) &gt;&gt;- g == m &gt;&gt;- (\x -&gt; f x &gt;&gt;- g)
--   associativity of join:     join . join = join . fmap join
--   </pre>
--   
--   These can both be seen as special cases of the constraint that
--   
--   <pre>
--   associativity of (-&gt;-): (f -&gt;- g) -&gt;- h = f -&gt;- (g -&gt;- h)
--   </pre>
class Apply m => Bind m
(>>-) :: Bind m => m a -> (a -> m b) -> m b
join :: Bind m => m (m a) -> m a
infixl 1 >>-
apDefault :: Bind f => f (a -> b) -> f a -> f b
returning :: Functor f => f a -> (a -> b) -> f b
class Bifunctor p => Biapply p
(<<.>>) :: Biapply p => p (a -> b) (c -> d) -> p a c -> p b d

-- | <pre>
--   a <a>.&gt;</a> b ≡ <a>const</a> <a>id</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(.>>) :: Biapply p => p a b -> p c d -> p c d

-- | <pre>
--   a <a>&lt;.</a> b ≡ <a>const</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(<<.) :: Biapply p => p a b -> p c d -> p a b
infixl 4 <<.>>
infixl 4 <<.
infixl 4 .>>
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (GHC.Generics.M1 i t f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (GHC.Generics.Rec1 f)
instance Data.Functor.Bind.Class.Biapply (,)
instance Data.Functor.Bind.Class.Biapply Data.Semigroup.Arg
instance GHC.Base.Semigroup x => Data.Functor.Bind.Class.Biapply ((,,) x)
instance (GHC.Base.Semigroup x, GHC.Base.Semigroup y) => Data.Functor.Bind.Class.Biapply ((,,,) x y)
instance (GHC.Base.Semigroup x, GHC.Base.Semigroup y, GHC.Base.Semigroup z) => Data.Functor.Bind.Class.Biapply ((,,,,) x y z)
instance Data.Functor.Bind.Class.Biapply Data.Functor.Const.Const
instance Data.Functor.Bind.Class.Biapply Data.Tagged.Tagged
instance (Data.Functor.Bind.Class.Biapply p, Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Apply g) => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Biff.Biff p f g)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Clown.Clown f)
instance Data.Functor.Bind.Class.Biapply p => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Flip.Flip p)
instance Data.Functor.Bind.Class.Apply g => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Joker.Joker g)
instance Data.Functor.Bind.Class.Biapply p => Data.Functor.Bind.Class.Apply (Data.Bifunctor.Join.Join p)
instance (Data.Functor.Bind.Class.Biapply p, Data.Functor.Bind.Class.Biapply q) => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Product.Product p q)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Biapply p) => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Tannen.Tannen f p)
instance Data.Functor.Bind.Class.Biapply p => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.State.Lazy.StateT s m)
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance GHC.Base.Semigroup m => Data.Functor.Bind.Class.Bind ((,) m)
instance Data.Functor.Bind.Class.Bind (Data.Tagged.Tagged a)
instance Data.Functor.Bind.Class.Bind Data.Proxy.Proxy
instance Data.Functor.Bind.Class.Bind (Data.Either.Either a)
instance (Data.Functor.Bind.Class.Bind f, Data.Functor.Bind.Class.Bind g) => Data.Functor.Bind.Class.Bind (Data.Functor.Product.Product f g)
instance Data.Functor.Bind.Class.Bind ((->) m)
instance Data.Functor.Bind.Class.Bind []
instance Data.Functor.Bind.Class.Bind GHC.Base.NonEmpty
instance Data.Functor.Bind.Class.Bind GHC.Types.IO
instance Data.Functor.Bind.Class.Bind GHC.Maybe.Maybe
instance Data.Functor.Bind.Class.Bind Data.Semigroup.Option
instance Data.Functor.Bind.Class.Bind Data.Functor.Identity.Identity
instance Data.Functor.Bind.Class.Bind Language.Haskell.TH.Syntax.Q
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Identity.IdentityT m)
instance GHC.Base.Monad m => Data.Functor.Bind.Class.Bind (Control.Applicative.WrappedMonad m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Maybe.MaybeT m)
instance (Data.Functor.Bind.Class.Apply m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.List.ListT m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Error.ErrorT e m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Reader.ReaderT e m)
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.State.Strict.StateT s m)
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Cont.ContT r m)
instance Data.Functor.Bind.Class.Bind Data.Complex.Complex
instance GHC.Classes.Ord k => Data.Functor.Bind.Class.Bind (Data.Map.Internal.Map k)
instance Data.Functor.Bind.Class.Bind Data.IntMap.Internal.IntMap
instance Data.Functor.Bind.Class.Bind Data.Sequence.Internal.Seq
instance Data.Functor.Bind.Class.Bind Data.Tree.Tree
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Data.Functor.Bind.Class.Bind (Data.HashMap.Base.HashMap k)
instance Data.Functor.Bind.Class.Bind Data.Ord.Down
instance Data.Functor.Bind.Class.Bind Data.Semigroup.Internal.Sum
instance Data.Functor.Bind.Class.Bind Data.Semigroup.Internal.Product
instance Data.Functor.Bind.Class.Bind Data.Semigroup.Internal.Dual
instance Data.Functor.Bind.Class.Bind Data.Monoid.First
instance Data.Functor.Bind.Class.Bind Data.Monoid.Last
instance Data.Functor.Bind.Class.Bind f => Data.Functor.Bind.Class.Bind (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Bind.Class.Bind Data.Semigroup.First
instance Data.Functor.Bind.Class.Bind Data.Semigroup.Last
instance Data.Functor.Bind.Class.Bind Data.Semigroup.Min
instance Data.Functor.Bind.Class.Bind Data.Semigroup.Max
instance Data.Functor.Bind.Class.Bind GHC.Generics.V1
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Bind.Class.MaybeApply f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Data.Functor.Bind.Class.MaybeApply f)
instance Data.Functor.Bind.Class.Apply f => GHC.Base.Applicative (Data.Functor.Bind.Class.MaybeApply f)
instance Data.Functor.Extend.Extend f => Data.Functor.Extend.Extend (Data.Functor.Bind.Class.MaybeApply f)
instance Control.Comonad.Comonad f => Control.Comonad.Comonad (Data.Functor.Bind.Class.MaybeApply f)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Bind.Class.WrappedApplicative f)
instance GHC.Base.Applicative f => Data.Functor.Bind.Class.Apply (Data.Functor.Bind.Class.WrappedApplicative f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Functor.Bind.Class.WrappedApplicative f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Data.Functor.Bind.Class.WrappedApplicative f)
instance Data.Functor.Bind.Class.Apply (Data.Tagged.Tagged a)
instance Data.Functor.Bind.Class.Apply Data.Proxy.Proxy
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Control.Applicative.Backwards.Backwards f)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Apply g) => Data.Functor.Bind.Class.Apply (Data.Functor.Compose.Compose f g)
instance GHC.Base.Semigroup f => Data.Functor.Bind.Class.Apply (Data.Functor.Constant.Constant f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Control.Applicative.Lift.Lift f)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Apply g) => Data.Functor.Bind.Class.Apply (Data.Functor.Product.Product f g)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Data.Functor.Reverse.Reverse f)
instance GHC.Base.Semigroup m => Data.Functor.Bind.Class.Apply ((,) m)
instance Data.Functor.Bind.Class.Apply GHC.Base.NonEmpty
instance Data.Functor.Bind.Class.Apply (Data.Either.Either a)
instance GHC.Base.Semigroup m => Data.Functor.Bind.Class.Apply (Data.Functor.Const.Const m)
instance Data.Functor.Bind.Class.Apply ((->) m)
instance Data.Functor.Bind.Class.Apply Control.Applicative.ZipList
instance Data.Functor.Bind.Class.Apply []
instance Data.Functor.Bind.Class.Apply GHC.Types.IO
instance Data.Functor.Bind.Class.Apply GHC.Maybe.Maybe
instance Data.Functor.Bind.Class.Apply Data.Semigroup.Option
instance Data.Functor.Bind.Class.Apply Data.Functor.Identity.Identity
instance Data.Functor.Bind.Class.Apply w => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Identity.IdentityT w)
instance GHC.Base.Monad m => Data.Functor.Bind.Class.Apply (Control.Applicative.WrappedMonad m)
instance Control.Arrow.Arrow a => Data.Functor.Bind.Class.Apply (Control.Applicative.WrappedArrow a b)
instance Data.Functor.Bind.Class.Apply Data.Complex.Complex
instance Data.Functor.Bind.Class.Apply Language.Haskell.TH.Syntax.Q
instance GHC.Classes.Ord k => Data.Functor.Bind.Class.Apply (Data.Map.Internal.Map k)
instance Data.Functor.Bind.Class.Apply Data.IntMap.Internal.IntMap
instance Data.Functor.Bind.Class.Apply Data.Sequence.Internal.Seq
instance Data.Functor.Bind.Class.Apply Data.Tree.Tree
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Data.Functor.Bind.Class.Apply (Data.HashMap.Base.HashMap k)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Maybe.MaybeT m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Error.ErrorT e m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Functor.Bind.Class.Apply m => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.Functor.Bind.Class.Apply m => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.List.ListT m)
instance (Data.Functor.Bind.Class.Apply m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Data.Functor.Bind.Class.Apply m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Cont.ContT r m)
instance (GHC.Base.Semigroup e, Data.Functor.Bind.Class.Apply w) => Data.Functor.Bind.Class.Apply (Control.Comonad.Trans.Env.EnvT e w)
instance (Data.Functor.Bind.Class.Apply w, GHC.Base.Semigroup s) => Data.Functor.Bind.Class.Apply (Control.Comonad.Trans.Store.StoreT s w)
instance Data.Functor.Bind.Class.Apply w => Data.Functor.Bind.Class.Apply (Control.Comonad.Trans.Traced.TracedT m w)
instance Data.Functor.Bind.Class.Apply (Control.Comonad.Cokleisli w a)
instance Data.Functor.Bind.Class.Apply Data.Ord.Down
instance Data.Functor.Bind.Class.Apply Data.Semigroup.Internal.Sum
instance Data.Functor.Bind.Class.Apply Data.Semigroup.Internal.Product
instance Data.Functor.Bind.Class.Apply Data.Semigroup.Internal.Dual
instance Data.Functor.Bind.Class.Apply Data.Monoid.First
instance Data.Functor.Bind.Class.Apply Data.Monoid.Last
instance Data.Functor.Bind.Class.Apply Data.Semigroup.First
instance Data.Functor.Bind.Class.Apply Data.Semigroup.Last
instance Data.Functor.Bind.Class.Apply Data.Semigroup.Min
instance Data.Functor.Bind.Class.Apply Data.Semigroup.Max
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Apply g) => Data.Functor.Bind.Class.Apply (f GHC.Generics.:*: g)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Apply g) => Data.Functor.Bind.Class.Apply (f GHC.Generics.:.: g)
instance Data.Functor.Bind.Class.Apply GHC.Generics.U1
instance GHC.Base.Semigroup c => Data.Functor.Bind.Class.Apply (GHC.Generics.K1 i c)
instance Data.Functor.Bind.Class.Apply GHC.Generics.Par1
instance Data.Functor.Bind.Class.Apply GHC.Generics.V1


module Data.Functor.Apply

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <tt>$</tt>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <tt>$</tt> is function application, <a>&lt;$&gt;</a> is
--   function application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with a
--   constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with a constant <tt>String</tt>, resulting in an
--   <tt><tt>Either</tt> <tt>Int</tt> <tt>String</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   (<a>.</a>) <a>&lt;$&gt;</a> u <a>&lt;.&gt;</a> v <a>&lt;.&gt;</a> w = u <a>&lt;.&gt;</a> (v <a>&lt;.&gt;</a> w)
--   x <a>&lt;.&gt;</a> (f <a>&lt;$&gt;</a> y) = (<a>.</a> f) <a>&lt;$&gt;</a> x <a>&lt;.&gt;</a> y
--   f <a>&lt;$&gt;</a> (x <a>&lt;.&gt;</a> y) = (f <a>.</a>) <a>&lt;$&gt;</a> x <a>&lt;.&gt;</a> y
--   </pre>
--   
--   The laws imply that <a>.&gt;</a> and <a>&lt;.</a> really ignore their
--   left and right results, respectively, and really return their right
--   and left results, respectively. Specifically,
--   
--   <pre>
--   (mf <a>&lt;$&gt;</a> m) <a>.&gt;</a> (nf <a>&lt;$&gt;</a> n) = nf <a>&lt;$&gt;</a> (m <a>.&gt;</a> n)
--   (mf <a>&lt;$&gt;</a> m) <a>&lt;.</a> (nf <a>&lt;$&gt;</a> n) = mf <a>&lt;$&gt;</a> (m <a>&lt;.</a> n)
--   </pre>
class Functor f => Apply f
(<.>) :: Apply f => f (a -> b) -> f a -> f b

-- | <pre>
--   a <a>.&gt;</a> b = <a>const</a> <a>id</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(.>) :: Apply f => f a -> f b -> f b

-- | <pre>
--   a <a>&lt;.</a> b = <a>const</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(<.) :: Apply f => f a -> f b -> f a

-- | Lift a binary function into a comonad with zipping
liftF2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c
infixl 4 <.>
infixl 4 <.
infixl 4 .>

-- | A variant of <a>&lt;.&gt;</a> with the arguments reversed.
(<..>) :: Apply w => w a -> w (a -> b) -> w b
infixl 4 <..>

-- | Lift a ternary function into a comonad with zipping
liftF3 :: Apply w => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
[unwrapApplicative] :: WrappedApplicative f a -> f a

-- | Transform a Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
[runMaybeApply] :: MaybeApply f a -> Either (f a) a


module Data.Functor.Bind

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <tt>$</tt>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <tt>$</tt> is function application, <a>&lt;$&gt;</a> is
--   function application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with a
--   constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with a constant <tt>String</tt>, resulting in an
--   <tt><tt>Either</tt> <tt>Int</tt> <tt>String</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   (<a>.</a>) <a>&lt;$&gt;</a> u <a>&lt;.&gt;</a> v <a>&lt;.&gt;</a> w = u <a>&lt;.&gt;</a> (v <a>&lt;.&gt;</a> w)
--   x <a>&lt;.&gt;</a> (f <a>&lt;$&gt;</a> y) = (<a>.</a> f) <a>&lt;$&gt;</a> x <a>&lt;.&gt;</a> y
--   f <a>&lt;$&gt;</a> (x <a>&lt;.&gt;</a> y) = (f <a>.</a>) <a>&lt;$&gt;</a> x <a>&lt;.&gt;</a> y
--   </pre>
--   
--   The laws imply that <a>.&gt;</a> and <a>&lt;.</a> really ignore their
--   left and right results, respectively, and really return their right
--   and left results, respectively. Specifically,
--   
--   <pre>
--   (mf <a>&lt;$&gt;</a> m) <a>.&gt;</a> (nf <a>&lt;$&gt;</a> n) = nf <a>&lt;$&gt;</a> (m <a>.&gt;</a> n)
--   (mf <a>&lt;$&gt;</a> m) <a>&lt;.</a> (nf <a>&lt;$&gt;</a> n) = mf <a>&lt;$&gt;</a> (m <a>&lt;.</a> n)
--   </pre>
class Functor f => Apply f
(<.>) :: Apply f => f (a -> b) -> f a -> f b

-- | <pre>
--   a <a>.&gt;</a> b = <a>const</a> <a>id</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(.>) :: Apply f => f a -> f b -> f b

-- | <pre>
--   a <a>&lt;.</a> b = <a>const</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(<.) :: Apply f => f a -> f b -> f a

-- | Lift a binary function into a comonad with zipping
liftF2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c
infixl 4 <.>
infixl 4 <.
infixl 4 .>

-- | A variant of <a>&lt;.&gt;</a> with the arguments reversed.
(<..>) :: Apply w => w a -> w (a -> b) -> w b
infixl 4 <..>

-- | Lift a ternary function into a comonad with zipping
liftF3 :: Apply w => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
[unwrapApplicative] :: WrappedApplicative f a -> f a

-- | Transform a Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
[runMaybeApply] :: MaybeApply f a -> Either (f a) a

-- | A <a>Monad</a> sans <a>return</a>.
--   
--   Minimal definition: Either <a>join</a> or <a>&gt;&gt;-</a>
--   
--   If defining both, then the following laws (the default definitions)
--   must hold:
--   
--   <pre>
--   join = (&gt;&gt;- id)
--   m &gt;&gt;- f = join (fmap f m)
--   </pre>
--   
--   Laws:
--   
--   <pre>
--   induced definition of &lt;.&gt;: f &lt;.&gt; x = f &gt;&gt;- (&lt;$&gt; x)
--   </pre>
--   
--   Finally, there are two associativity conditions:
--   
--   <pre>
--   associativity of (&gt;&gt;-):    (m &gt;&gt;- f) &gt;&gt;- g == m &gt;&gt;- (\x -&gt; f x &gt;&gt;- g)
--   associativity of join:     join . join = join . fmap join
--   </pre>
--   
--   These can both be seen as special cases of the constraint that
--   
--   <pre>
--   associativity of (-&gt;-): (f -&gt;- g) -&gt;- h = f -&gt;- (g -&gt;- h)
--   </pre>
class Apply m => Bind m
(>>-) :: Bind m => m a -> (a -> m b) -> m b
join :: Bind m => m (m a) -> m a
infixl 1 >>-
(-<<) :: Bind m => (a -> m b) -> m a -> m b
infixr 1 -<<
(-<-) :: Bind m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 -<-
(->-) :: Bind m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 ->-
apDefault :: Bind f => f (a -> b) -> f a -> f b
returning :: Functor f => f a -> (a -> b) -> f b


module Data.Functor.Bind.Trans

-- | A subset of monad transformers can transform any <a>Bind</a> as well.
class MonadTrans t => BindTrans t
liftB :: (BindTrans t, Bind b) => b a -> t b a
instance Data.Functor.Bind.Trans.BindTrans Control.Monad.Trans.Identity.IdentityT
instance Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.Reader.ReaderT e)
instance GHC.Base.Monoid w => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.Writer.Strict.WriterT w)
instance Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.State.Strict.StateT s)
instance GHC.Base.Monoid w => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance GHC.Base.Monoid w => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.Cont.ContT r)


module Data.Functor.Alt

-- | Laws:
--   
--   <pre>
--   &lt;!&gt; is associative:             (a &lt;!&gt; b) &lt;!&gt; c = a &lt;!&gt; (b &lt;!&gt; c)
--   &lt;$&gt; left-distributes over &lt;!&gt;:  f &lt;$&gt; (a &lt;!&gt; b) = (f &lt;$&gt; a) &lt;!&gt; (f &lt;$&gt; b)
--   </pre>
--   
--   If extended to an <a>Alternative</a> then <a>&lt;!&gt;</a> should
--   equal <a>&lt;|&gt;</a>.
--   
--   Ideally, an instance of <a>Alt</a> also satisfies the "left
--   distributon" law of MonadPlus with respect to <a>&lt;.&gt;</a>:
--   
--   <pre>
--   &lt;.&gt; right-distributes over &lt;!&gt;: (a &lt;!&gt; b) &lt;.&gt; c = (a &lt;.&gt; c) &lt;!&gt; (b &lt;.&gt; c)
--   </pre>
--   
--   But <a>Maybe</a>, <a>IO</a>, <tt><a>Either</a> a</tt>,
--   <tt><a>ErrorT</a> e m</tt>, and <tt>STM</tt> satisfy the alternative
--   "left catch" law instead:
--   
--   <pre>
--   pure a &lt;!&gt; b = pure a
--   </pre>
--   
--   However, this variation cannot be stated purely in terms of the
--   dependencies of <a>Alt</a>.
--   
--   When and if MonadPlus is successfully refactored, this class should
--   also be refactored to remove these instances.
--   
--   The right distributive law should extend in the cases where the a
--   <a>Bind</a> or <a>Monad</a> is provided to yield variations of the
--   right distributive law:
--   
--   <pre>
--   (m &lt;!&gt; n) &gt;&gt;- f = (m &gt;&gt;- f) &lt;!&gt; (m &gt;&gt;- f)
--   (m &lt;!&gt; n) &gt;&gt;= f = (m &gt;&gt;= f) &lt;!&gt; (m &gt;&gt;= f)
--   </pre>
class Functor f => Alt f

-- | <a>&lt;|&gt;</a> without a required <tt>empty</tt>
(<!>) :: Alt f => f a -> f a -> f a
some :: (Alt f, Applicative f) => f a -> f [a]
many :: (Alt f, Applicative f) => f a -> f [a]
infixl 3 <!>

-- | One or none.
optional :: (Alt f, Applicative f) => f a -> f (Maybe a)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (GHC.Generics.M1 i c f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (GHC.Generics.Rec1 f)
instance (Data.Functor.Alt.Alt f, Data.Functor.Alt.Alt g) => Data.Functor.Alt.Alt (f GHC.Generics.:*: g)
instance Data.Functor.Alt.Alt GHC.Generics.U1
instance Data.Functor.Alt.Alt GHC.Generics.V1
instance Data.Functor.Alt.Alt Data.Proxy.Proxy
instance Data.Functor.Alt.Alt (Data.Either.Either a)
instance Data.Functor.Alt.Alt GHC.Types.IO
instance Data.Functor.Alt.Alt []
instance Data.Functor.Alt.Alt GHC.Maybe.Maybe
instance Data.Functor.Alt.Alt Data.Semigroup.Option
instance GHC.Base.MonadPlus m => Data.Functor.Alt.Alt (Control.Applicative.WrappedMonad m)
instance Control.Arrow.ArrowPlus a => Data.Functor.Alt.Alt (Control.Applicative.WrappedArrow a b)
instance GHC.Classes.Ord k => Data.Functor.Alt.Alt (Data.Map.Internal.Map k)
instance Data.Functor.Alt.Alt Data.IntMap.Internal.IntMap
instance Data.Functor.Alt.Alt Data.Sequence.Internal.Seq
instance Data.Functor.Alt.Alt GHC.Base.NonEmpty
instance GHC.Base.Alternative f => Data.Functor.Alt.Alt (Data.Functor.Bind.Class.WrappedApplicative f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.Reader.ReaderT e f)
instance (Data.Functor.Bind.Class.Bind f, GHC.Base.Monad f) => Data.Functor.Alt.Alt (Control.Monad.Trans.Maybe.MaybeT f)
instance (Data.Functor.Bind.Class.Bind f, GHC.Base.Monad f) => Data.Functor.Alt.Alt (Control.Monad.Trans.Error.ErrorT e f)
instance (Data.Functor.Bind.Class.Bind f, GHC.Base.Monad f, GHC.Base.Semigroup e) => Data.Functor.Alt.Alt (Control.Monad.Trans.Except.ExceptT e f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Alt.Alt (Control.Monad.Trans.List.ListT f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.State.Strict.StateT e f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.State.Lazy.StateT e f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.Writer.Strict.WriterT w f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.Writer.Lazy.WriterT w f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.RWS.Strict.RWST r w s f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.RWS.Lazy.RWST r w s f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Applicative.Backwards.Backwards f)
instance (Data.Functor.Alt.Alt f, GHC.Base.Functor g) => Data.Functor.Alt.Alt (Data.Functor.Compose.Compose f g)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Applicative.Lift.Lift f)
instance (Data.Functor.Alt.Alt f, Data.Functor.Alt.Alt g) => Data.Functor.Alt.Alt (Data.Functor.Product.Product f g)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Alt.Alt Data.Semigroup.First
instance Data.Functor.Alt.Alt Data.Semigroup.Last
instance Data.Functor.Alt.Alt Data.Monoid.First
instance Data.Functor.Alt.Alt Data.Monoid.Last


module Data.Bifunctor.Apply

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
class Bifunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c
class Bifunctor p => Biapply p
(<<.>>) :: Biapply p => p (a -> b) (c -> d) -> p a c -> p b d

-- | <pre>
--   a <a>.&gt;</a> b ≡ <a>const</a> <a>id</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(.>>) :: Biapply p => p a b -> p c d -> p c d

-- | <pre>
--   a <a>&lt;.</a> b ≡ <a>const</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(<<.) :: Biapply p => p a b -> p c d -> p a b
infixl 4 <<.>>
infixl 4 <<.
infixl 4 .>>
(<<$>>) :: () => (a -> b) -> a -> b
infixl 4 <<$>>
(<<..>>) :: Biapply p => p a c -> p (a -> b) (c -> d) -> p b d
infixl 4 <<..>>

-- | Lift binary functions
bilift2 :: Biapply w => (a -> b -> c) -> (d -> e -> f) -> w a d -> w b e -> w c f

-- | Lift ternary functions
bilift3 :: Biapply w => (a -> b -> c -> d) -> (e -> f -> g -> h) -> w a e -> w b f -> w c g -> w d h


module Data.Functor.Plus

-- | Laws:
--   
--   <pre>
--   zero &lt;!&gt; m = m
--   m &lt;!&gt; zero = m
--   </pre>
--   
--   If extended to an <a>Alternative</a> then <a>zero</a> should equal
--   <a>empty</a>.
class Alt f => Plus f
zero :: Plus f => f a
instance Data.Functor.Plus.Plus Data.Proxy.Proxy
instance Data.Functor.Plus.Plus GHC.Generics.U1
instance (Data.Functor.Plus.Plus f, Data.Functor.Plus.Plus g) => Data.Functor.Plus.Plus (f GHC.Generics.:*: g)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (GHC.Generics.M1 i c f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (GHC.Generics.Rec1 f)
instance Data.Functor.Plus.Plus GHC.Types.IO
instance Data.Functor.Plus.Plus []
instance Data.Functor.Plus.Plus GHC.Maybe.Maybe
instance Data.Functor.Plus.Plus Data.Semigroup.Option
instance GHC.Base.MonadPlus m => Data.Functor.Plus.Plus (Control.Applicative.WrappedMonad m)
instance Control.Arrow.ArrowPlus a => Data.Functor.Plus.Plus (Control.Applicative.WrappedArrow a b)
instance GHC.Classes.Ord k => Data.Functor.Plus.Plus (Data.Map.Internal.Map k)
instance Data.Functor.Plus.Plus Data.IntMap.Internal.IntMap
instance Data.Functor.Plus.Plus Data.Sequence.Internal.Seq
instance GHC.Base.Alternative f => Data.Functor.Plus.Plus (Data.Functor.Bind.Class.WrappedApplicative f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.Reader.ReaderT e f)
instance (Data.Functor.Bind.Class.Bind f, GHC.Base.Monad f) => Data.Functor.Plus.Plus (Control.Monad.Trans.Maybe.MaybeT f)
instance (Data.Functor.Bind.Class.Bind f, GHC.Base.Monad f, Control.Monad.Trans.Error.Error e) => Data.Functor.Plus.Plus (Control.Monad.Trans.Error.ErrorT e f)
instance (Data.Functor.Bind.Class.Bind f, GHC.Base.Monad f, GHC.Base.Semigroup e, GHC.Base.Monoid e) => Data.Functor.Plus.Plus (Control.Monad.Trans.Except.ExceptT e f)
instance (Data.Functor.Bind.Class.Apply f, GHC.Base.Applicative f) => Data.Functor.Plus.Plus (Control.Monad.Trans.List.ListT f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.State.Strict.StateT e f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.State.Lazy.StateT e f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.Writer.Strict.WriterT w f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.Writer.Lazy.WriterT w f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.RWS.Strict.RWST r w s f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.RWS.Lazy.RWST r w s f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Applicative.Backwards.Backwards f)
instance (Data.Functor.Plus.Plus f, GHC.Base.Functor g) => Data.Functor.Plus.Plus (Data.Functor.Compose.Compose f g)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Applicative.Lift.Lift f)
instance (Data.Functor.Plus.Plus f, Data.Functor.Plus.Plus g) => Data.Functor.Plus.Plus (Data.Functor.Product.Product f g)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Plus.Plus Data.Monoid.First
instance Data.Functor.Plus.Plus Data.Monoid.Last


-- | A semigroupoid satisfies all of the requirements to be a Category
--   except for the existence of identity arrows.
module Data.Semigroupoid

-- | <a>Category</a> sans <a>id</a>
class Semigroupoid c
o :: Semigroupoid c => c j k -> c i j -> c i k
newtype WrappedCategory k a b
WrapCategory :: k a b -> WrappedCategory k a b
[unwrapCategory] :: WrappedCategory k a b -> k a b
newtype Semi m a b
Semi :: m -> Semi m a b
[getSemi] :: Semi m a b -> m
instance GHC.Base.Semigroup m => Data.Semigroupoid.Semigroupoid (Data.Semigroupoid.Semi m)
instance GHC.Base.Monoid m => Control.Category.Category (Data.Semigroupoid.Semi m)
instance forall k1 (k2 :: k1 -> k1 -> *). Control.Category.Category k2 => Data.Semigroupoid.Semigroupoid (Data.Semigroupoid.WrappedCategory k2)
instance forall k1 (k2 :: k1 -> k1 -> *). Control.Category.Category k2 => Control.Category.Category (Data.Semigroupoid.WrappedCategory k2)
instance Data.Semigroupoid.Semigroupoid (->)
instance Data.Semigroupoid.Semigroupoid (,)
instance Data.Functor.Bind.Class.Bind m => Data.Semigroupoid.Semigroupoid (Control.Arrow.Kleisli m)
instance Data.Functor.Extend.Extend w => Data.Semigroupoid.Semigroupoid (Control.Comonad.Cokleisli w)
instance Data.Semigroupoid.Semigroupoid Data.Functor.Contravariant.Op
instance Data.Semigroupoid.Semigroupoid Data.Functor.Const.Const
instance Data.Semigroupoid.Semigroupoid Data.Tagged.Tagged
instance Data.Semigroupoid.Semigroupoid Data.Type.Coercion.Coercion
instance Data.Semigroupoid.Semigroupoid (Data.Type.Equality.:~:)
instance Data.Semigroupoid.Semigroupoid (Data.Type.Equality.:~~:)


-- | A semigroupoid satisfies all of the requirements to be a Category
--   except for the existence of identity arrows.
module Data.Semigroupoid.Dual
newtype Dual k a b
Dual :: k b a -> Dual k a b
[getDual] :: Dual k a b -> k b a
instance forall k1 (k2 :: k1 -> k1 -> *). Data.Semigroupoid.Semigroupoid k2 => Data.Semigroupoid.Semigroupoid (Data.Semigroupoid.Dual.Dual k2)
instance forall k1 (k2 :: k1 -> k1 -> *). Control.Category.Category k2 => Control.Category.Category (Data.Semigroupoid.Dual.Dual k2)


module Data.Groupoid

-- | semigroupoid with inverses. This technically should be a category with
--   inverses, except we need to use Ob to define the valid objects for the
--   category
class Semigroupoid k => Groupoid k
inv :: Groupoid k => k a b -> k b a
instance forall k1 (k2 :: k1 -> k1 -> *). Data.Groupoid.Groupoid k2 => Data.Groupoid.Groupoid (Data.Semigroupoid.Dual.Dual k2)
instance Data.Groupoid.Groupoid Data.Type.Coercion.Coercion
instance Data.Groupoid.Groupoid (Data.Type.Equality.:~:)
instance Data.Groupoid.Groupoid (Data.Type.Equality.:~~:)


module Data.Isomorphism
data Iso k a b
Iso :: k a b -> k b a -> Iso k a b
[embed] :: Iso k a b -> k a b
[project] :: Iso k a b -> k b a
instance forall k1 (k2 :: k1 -> k1 -> *). Data.Semigroupoid.Semigroupoid k2 => Data.Semigroupoid.Semigroupoid (Data.Isomorphism.Iso k2)
instance forall k1 (k2 :: k1 -> k1 -> *). Data.Semigroupoid.Semigroupoid k2 => Data.Groupoid.Groupoid (Data.Isomorphism.Iso k2)
instance forall k1 (k2 :: k1 -> k1 -> *). Control.Category.Category k2 => Control.Category.Category (Data.Isomorphism.Iso k2)


module Data.Semigroupoid.Ob
class Semigroupoid k => Ob k a
semiid :: Ob k a => k a a
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Monad m) => Data.Semigroupoid.Ob.Ob (Control.Arrow.Kleisli m) a
instance (Data.Functor.Extend.Extend w, Control.Comonad.Comonad w) => Data.Semigroupoid.Ob.Ob (Control.Comonad.Cokleisli w) a
instance Data.Semigroupoid.Ob.Ob (->) a


module Data.Semigroupoid.Static
newtype Static f a b
Static :: f (a -> b) -> Static f a b
[runStatic] :: Static f a b -> f (a -> b)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroupoid.Static.Static f a)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Data.Semigroupoid.Static.Static f a)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Data.Semigroupoid.Static.Static f a)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Data.Semigroupoid.Static.Static f a)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Semigroupoid.Static.Static f a)
instance (Data.Functor.Extend.Extend f, GHC.Base.Semigroup a) => Data.Functor.Extend.Extend (Data.Semigroupoid.Static.Static f a)
instance (Control.Comonad.Comonad f, GHC.Base.Monoid a) => Control.Comonad.Comonad (Data.Semigroupoid.Static.Static f a)
instance Data.Functor.Bind.Class.Apply f => Data.Semigroupoid.Semigroupoid (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Applicative f => Control.Category.Category (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Applicative f => Control.Arrow.Arrow (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Alternative f => Control.Arrow.ArrowZero (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Alternative f => Control.Arrow.ArrowPlus (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Applicative f => Control.Arrow.ArrowChoice (Data.Semigroupoid.Static.Static f)


-- | Re-exports from the `base-orphans` and `transformers-compat` packages.
module Data.Traversable.Instances


module Data.Semigroup.Foldable.Class
class Foldable t => Foldable1 t
fold1 :: (Foldable1 t, Semigroup m) => t m -> m
foldMap1 :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m
toNonEmpty :: Foldable1 t => t a -> NonEmpty a
class Bifoldable t => Bifoldable1 t
bifold1 :: (Bifoldable1 t, Semigroup m) => t m m -> m
bifoldMap1 :: (Bifoldable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m
instance Data.Semigroup.Foldable.Class.Bifoldable1 Data.Semigroup.Arg
instance Data.Semigroup.Foldable.Class.Bifoldable1 Data.Either.Either
instance Data.Semigroup.Foldable.Class.Bifoldable1 (,)
instance Data.Semigroup.Foldable.Class.Bifoldable1 ((,,) x)
instance Data.Semigroup.Foldable.Class.Bifoldable1 ((,,,) x y)
instance Data.Semigroup.Foldable.Class.Bifoldable1 ((,,,,) x y z)
instance Data.Semigroup.Foldable.Class.Bifoldable1 Data.Functor.Const.Const
instance Data.Semigroup.Foldable.Class.Bifoldable1 Data.Tagged.Tagged
instance (Data.Semigroup.Foldable.Class.Bifoldable1 p, Data.Semigroup.Foldable.Class.Foldable1 f, Data.Semigroup.Foldable.Class.Foldable1 g) => Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Bifunctor.Biff.Biff p f g)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Bifunctor.Clown.Clown f)
instance Data.Semigroup.Foldable.Class.Bifoldable1 p => Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Bifunctor.Flip.Flip p)
instance Data.Semigroup.Foldable.Class.Bifoldable1 p => Data.Semigroup.Foldable.Class.Foldable1 (Data.Bifunctor.Join.Join p)
instance Data.Semigroup.Foldable.Class.Foldable1 g => Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Bifunctor.Joker.Joker g)
instance (Data.Semigroup.Foldable.Class.Bifoldable1 f, Data.Semigroup.Foldable.Class.Bifoldable1 g) => Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Bifunctor.Product.Product f g)
instance (Data.Semigroup.Foldable.Class.Foldable1 f, Data.Semigroup.Foldable.Class.Bifoldable1 p) => Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Bifunctor.Tannen.Tannen f p)
instance Data.Semigroup.Foldable.Class.Bifoldable1 p => Data.Semigroup.Foldable.Class.Bifoldable1 (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Semigroup.Internal.Sum
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Semigroup.Internal.Product
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Semigroup.Internal.Dual
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (Data.Semigroup.Internal.Alt f)
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Semigroup.First
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Semigroup.Last
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Semigroup.Min
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Semigroup.Max
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (GHC.Generics.Rec1 f)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (GHC.Generics.M1 i c f)
instance Data.Semigroup.Foldable.Class.Foldable1 GHC.Generics.Par1
instance (Data.Semigroup.Foldable.Class.Foldable1 f, Data.Semigroup.Foldable.Class.Foldable1 g) => Data.Semigroup.Foldable.Class.Foldable1 (f GHC.Generics.:*: g)
instance (Data.Semigroup.Foldable.Class.Foldable1 f, Data.Semigroup.Foldable.Class.Foldable1 g) => Data.Semigroup.Foldable.Class.Foldable1 (f GHC.Generics.:+: g)
instance Data.Semigroup.Foldable.Class.Foldable1 GHC.Generics.V1
instance (Data.Semigroup.Foldable.Class.Foldable1 f, Data.Semigroup.Foldable.Class.Foldable1 g) => Data.Semigroup.Foldable.Class.Foldable1 (f GHC.Generics.:.: g)
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Complex.Complex
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Tree.Tree
instance Data.Semigroup.Foldable.Class.Foldable1 Data.Functor.Identity.Identity
instance Data.Semigroup.Foldable.Class.Foldable1 (Data.Tagged.Tagged a)
instance Data.Semigroup.Foldable.Class.Foldable1 m => Data.Semigroup.Foldable.Class.Foldable1 (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (Control.Applicative.Backwards.Backwards f)
instance (Data.Semigroup.Foldable.Class.Foldable1 f, Data.Semigroup.Foldable.Class.Foldable1 g) => Data.Semigroup.Foldable.Class.Foldable1 (Data.Functor.Compose.Compose f g)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (Control.Applicative.Lift.Lift f)
instance (Data.Semigroup.Foldable.Class.Foldable1 f, Data.Semigroup.Foldable.Class.Foldable1 g) => Data.Semigroup.Foldable.Class.Foldable1 (Data.Functor.Product.Product f g)
instance Data.Semigroup.Foldable.Class.Foldable1 f => Data.Semigroup.Foldable.Class.Foldable1 (Data.Functor.Reverse.Reverse f)
instance (Data.Semigroup.Foldable.Class.Foldable1 f, Data.Semigroup.Foldable.Class.Foldable1 g) => Data.Semigroup.Foldable.Class.Foldable1 (Data.Functor.Sum.Sum f g)
instance Data.Semigroup.Foldable.Class.Foldable1 GHC.Base.NonEmpty
instance Data.Semigroup.Foldable.Class.Foldable1 ((,) a)
instance Data.Semigroup.Foldable.Class.Foldable1 g => Data.Semigroup.Foldable.Class.Foldable1 (Data.Bifunctor.Joker.Joker g a)


module Data.Semigroup.Bifoldable
class Bifoldable t => Bifoldable1 t
bifold1 :: (Bifoldable1 t, Semigroup m) => t m m -> m
bifoldMap1 :: (Bifoldable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m
bitraverse1_ :: (Bifoldable1 t, Apply f) => (a -> f b) -> (c -> f d) -> t a c -> f ()
bifor1_ :: (Bifoldable1 t, Apply f) => t a c -> (a -> f b) -> (c -> f d) -> f ()
bisequenceA1_ :: (Bifoldable1 t, Apply f) => t (f a) (f b) -> f ()

-- | Usable default for foldMap, but only if you define bifoldMap1 yourself
bifoldMapDefault1 :: (Bifoldable1 t, Monoid m) => (a -> m) -> (b -> m) -> t a b -> m
instance Data.Functor.Bind.Class.Apply f => GHC.Base.Semigroup (Data.Semigroup.Bifoldable.Act f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroup.Bifoldable.Act f)


module Data.Semigroup.Foldable
class Foldable t => Foldable1 t
fold1 :: (Foldable1 t, Semigroup m) => t m -> m
foldMap1 :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m
toNonEmpty :: Foldable1 t => t a -> NonEmpty a

-- | Insert an <tt>m</tt> between each pair of 't m'. Equivalent to
--   <a>intercalateMap1</a> with <a>id</a> as the second argument.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| ["how", "are", "you"]
--   "hello, how, are, you"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| []
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 mempty $ "I" :| ["Am", "Fine", "You?"]
--   "IAmFineYou?"
--   </pre>
intercalate1 :: (Foldable1 t, Semigroup m) => m -> t m -> m

-- | Insert <tt>m</tt> between each pair of <tt>m</tt> derived from
--   <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; intercalateMap1 " " show $ True :| [False, True]
--   "True False True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalateMap1 " " show $ True :| []
--   "True"
--   </pre>
intercalateMap1 :: (Foldable1 t, Semigroup m) => m -> (a -> m) -> t a -> m
traverse1_ :: (Foldable1 t, Apply f) => (a -> f b) -> t a -> f ()
for1_ :: (Foldable1 t, Apply f) => t a -> (a -> f b) -> f ()
sequenceA1_ :: (Foldable1 t, Apply f) => t (f a) -> f ()

-- | Usable default for foldMap, but only if you define foldMap1 yourself
foldMapDefault1 :: (Foldable1 t, Monoid m) => (a -> m) -> t a -> m
asum1 :: (Foldable1 t, Alt m) => t (m a) -> m a

-- | Monadic fold over the elements of a non-empty structure, associating
--   to the right, i.e. from right to left.
--   
--   <pre>
--   let g = (=&lt;&lt;) . f
--   in foldrM1 f (x1 :| [x2, ..., xn]) == x1 `g` (x2 `g` ... (xn-1 `f` xn)...)
--   </pre>
foldrM1 :: (Foldable1 t, Monad m) => (a -> a -> m a) -> t a -> m a

-- | Monadic fold over the elements of a non-empty structure, associating
--   to the left, i.e. from left to right.
--   
--   <pre>
--   let g = flip $ (=&lt;&lt;) . f
--   in foldlM1 f (x1 :| [x2, ..., xn]) == (...((x1 `f` x2) `g` x2) `g`...) `g` xn
--   </pre>
foldlM1 :: (Foldable1 t, Monad m) => (a -> a -> m a) -> t a -> m a
instance Data.Functor.Alt.Alt f => GHC.Base.Semigroup (Data.Semigroup.Foldable.Alt_ f a)
instance Data.Functor.Bind.Class.Apply f => GHC.Base.Semigroup (Data.Semigroup.Foldable.Act f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroup.Foldable.Act f)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Semigroup.Foldable.JoinWith a)


module Data.Semigroup.Traversable.Class
class (Bifoldable1 t, Bitraversable t) => Bitraversable1 t
bitraverse1 :: (Bitraversable1 t, Apply f) => (a -> f b) -> (c -> f d) -> t a c -> f (t b d)
bisequence1 :: (Bitraversable1 t, Apply f) => t (f a) (f b) -> f (t a b)
class (Foldable1 t, Traversable t) => Traversable1 t
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
sequence1 :: (Traversable1 t, Apply f) => t (f b) -> f (t b)
instance (Data.Semigroup.Traversable.Class.Bitraversable1 p, Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Biff.Biff p f g)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Clown.Clown f)
instance Data.Semigroup.Traversable.Class.Bitraversable1 p => Data.Semigroup.Traversable.Class.Traversable1 (Data.Bifunctor.Join.Join p)
instance Data.Semigroup.Traversable.Class.Traversable1 g => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Joker.Joker g)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Bitraversable1 p) => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Tannen.Tannen f p)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (GHC.Generics.Rec1 f)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (GHC.Generics.M1 i c f)
instance Data.Semigroup.Traversable.Class.Traversable1 GHC.Generics.Par1
instance Data.Semigroup.Traversable.Class.Traversable1 GHC.Generics.V1
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (f GHC.Generics.:*: g)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (f GHC.Generics.:+: g)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (f GHC.Generics.:.: g)
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Functor.Identity.Identity
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Applicative.Backwards.Backwards f)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (Data.Functor.Compose.Compose f g)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Applicative.Lift.Lift f)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (Data.Functor.Product.Product f g)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Data.Functor.Reverse.Reverse f)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (Data.Functor.Sum.Sum f g)
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Complex.Complex
instance Data.Semigroup.Traversable.Class.Traversable1 (Data.Tagged.Tagged a)
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Tree.Tree
instance Data.Semigroup.Traversable.Class.Traversable1 GHC.Base.NonEmpty
instance Data.Semigroup.Traversable.Class.Traversable1 ((,) a)
instance Data.Semigroup.Traversable.Class.Traversable1 g => Data.Semigroup.Traversable.Class.Traversable1 (Data.Bifunctor.Joker.Joker g a)
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.Internal.Sum
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.Internal.Product
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.Internal.Dual
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Data.Semigroup.Internal.Alt f)
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.First
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.Last
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.Min
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.Max
instance Data.Semigroup.Traversable.Class.Bitraversable1 Data.Semigroup.Arg
instance Data.Semigroup.Traversable.Class.Bitraversable1 Data.Either.Either
instance Data.Semigroup.Traversable.Class.Bitraversable1 (,)
instance Data.Semigroup.Traversable.Class.Bitraversable1 ((,,) x)
instance Data.Semigroup.Traversable.Class.Bitraversable1 ((,,,) x y)
instance Data.Semigroup.Traversable.Class.Bitraversable1 ((,,,,) x y z)
instance Data.Semigroup.Traversable.Class.Bitraversable1 Data.Functor.Const.Const
instance Data.Semigroup.Traversable.Class.Bitraversable1 Data.Tagged.Tagged
instance Data.Semigroup.Traversable.Class.Bitraversable1 p => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Flip.Flip p)
instance (Data.Semigroup.Traversable.Class.Bitraversable1 f, Data.Semigroup.Traversable.Class.Bitraversable1 g) => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Product.Product f g)
instance Data.Semigroup.Traversable.Class.Bitraversable1 p => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Wrapped.WrappedBifunctor p)


module Data.Semigroup.Traversable
class (Foldable1 t, Traversable t) => Traversable1 t
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
sequence1 :: (Traversable1 t, Apply f) => t (f b) -> f (t b)
foldMap1Default :: (Traversable1 f, Semigroup m) => (a -> m) -> f a -> m


module Data.Semigroup.Bitraversable
class (Bifoldable1 t, Bitraversable t) => Bitraversable1 t
bitraverse1 :: (Bitraversable1 t, Apply f) => (a -> f b) -> (c -> f d) -> t a c -> f (t b d)
bisequence1 :: (Bitraversable1 t, Apply f) => t (f a) (f b) -> f (t a b)
bifoldMap1Default :: (Bitraversable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m
