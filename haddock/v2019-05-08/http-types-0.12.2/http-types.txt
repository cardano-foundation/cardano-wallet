-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic HTTP types for Haskell (for both client and server code).
--   
--   Generic HTTP types for Haskell (for both client and server code).
@package http-types
@version 0.12.2

module Network.HTTP.Types.Header

-- | Header
type Header = (HeaderName, ByteString)

-- | Header name
type HeaderName = CI ByteString

-- | Request Headers
type RequestHeaders = [Header]

-- | Response Headers
type ResponseHeaders = [Header]

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hAccept :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hAcceptCharset :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hAcceptEncoding :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hAcceptLanguage :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hAcceptRanges :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hAge :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hAllow :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hAuthorization :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hCacheControl :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hConnection :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hContentEncoding :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hContentLanguage :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hContentLength :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hContentLocation :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hContentMD5 :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hContentRange :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hContentType :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hDate :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hETag :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hExpect :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hExpires :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hFrom :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hHost :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hIfMatch :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hIfModifiedSince :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hIfNoneMatch :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hIfRange :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hIfUnmodifiedSince :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hLastModified :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hLocation :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hMaxForwards :: HeaderName

-- | HTTP Header names according to
--   <a>https://tools.ietf.org/html/rfc6454</a>
hOrigin :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hPragma :: HeaderName

-- | HTTP Header names according to
--   <a>https://tools.ietf.org/html/rfc7240</a>
hPrefer :: HeaderName

-- | HTTP Header names according to
--   <a>https://tools.ietf.org/html/rfc7240</a>
hPreferenceApplied :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hProxyAuthenticate :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hProxyAuthorization :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hRange :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hReferer :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hRetryAfter :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hServer :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hTE :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hTrailer :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hTransferEncoding :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hUpgrade :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hUserAgent :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hVary :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hVia :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hWWWAuthenticate :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hWarning :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html</a>
hContentDisposition :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html</a>
hMIMEVersion :: HeaderName

-- | HTTP Header names according to
--   <a>https://tools.ietf.org/html/rfc6265#section-4</a>
hCookie :: HeaderName

-- | HTTP Header names according to
--   <a>https://tools.ietf.org/html/rfc6265#section-4</a>
hSetCookie :: HeaderName

-- | RFC 2616 Byte range (individual).
--   
--   Negative indices are not allowed!
data ByteRange
ByteRangeFrom :: !Integer -> ByteRange
ByteRangeFromTo :: !Integer -> !Integer -> ByteRange
ByteRangeSuffix :: !Integer -> ByteRange
renderByteRangeBuilder :: ByteRange -> Builder
renderByteRange :: ByteRange -> ByteString

-- | RFC 2616 Byte ranges (set).
type ByteRanges = [ByteRange]
renderByteRangesBuilder :: ByteRanges -> Builder
renderByteRanges :: ByteRanges -> ByteString

-- | Parse the value of a Range header into a <a>ByteRanges</a>.
--   
--   <pre>
--   &gt;&gt;&gt; parseByteRanges "error"
--   Nothing
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=0-499"
--   Just [ByteRangeFromTo 0 499]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=500-999"
--   Just [ByteRangeFromTo 500 999]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=-500"
--   Just [ByteRangeSuffix 500]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=9500-"
--   Just [ByteRangeFrom 9500]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=0-0,-1"
--   Just [ByteRangeFromTo 0 0,ByteRangeSuffix 1]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=500-600,601-999"
--   Just [ByteRangeFromTo 500 600,ByteRangeFromTo 601 999]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=500-700,601-999"
--   Just [ByteRangeFromTo 500 700,ByteRangeFromTo 601 999]
--   </pre>
parseByteRanges :: ByteString -> Maybe ByteRanges
instance Data.Data.Data Network.HTTP.Types.Header.ByteRange
instance GHC.Classes.Ord Network.HTTP.Types.Header.ByteRange
instance GHC.Classes.Eq Network.HTTP.Types.Header.ByteRange
instance GHC.Show.Show Network.HTTP.Types.Header.ByteRange

module Network.HTTP.Types.Method

-- | HTTP method (flat string type).
type Method = ByteString

-- | HTTP Method constants.
methodGet :: Method

-- | HTTP Method constants.
methodPost :: Method

-- | HTTP Method constants.
methodHead :: Method

-- | HTTP Method constants.
methodPut :: Method

-- | HTTP Method constants.
methodDelete :: Method

-- | HTTP Method constants.
methodTrace :: Method

-- | HTTP Method constants.
methodConnect :: Method

-- | HTTP Method constants.
methodOptions :: Method

-- | HTTP Method constants.
methodPatch :: Method

-- | HTTP standard method (as defined by RFC 2616, and PATCH which is
--   defined by RFC 5789).
data StdMethod
GET :: StdMethod
POST :: StdMethod
HEAD :: StdMethod
PUT :: StdMethod
DELETE :: StdMethod
TRACE :: StdMethod
CONNECT :: StdMethod
OPTIONS :: StdMethod
PATCH :: StdMethod

-- | Convert a method <tt>ByteString</tt> to a <a>StdMethod</a> if
--   possible.
parseMethod :: Method -> Either ByteString StdMethod

-- | Convert an algebraic method to a <tt>ByteString</tt>.
renderMethod :: Either ByteString StdMethod -> Method

-- | Convert a <a>StdMethod</a> to a <tt>ByteString</tt>.
renderStdMethod :: StdMethod -> Method
instance GHC.Arr.Ix Network.HTTP.Types.Method.StdMethod
instance GHC.Enum.Bounded Network.HTTP.Types.Method.StdMethod
instance GHC.Enum.Enum Network.HTTP.Types.Method.StdMethod
instance GHC.Classes.Ord Network.HTTP.Types.Method.StdMethod
instance GHC.Classes.Eq Network.HTTP.Types.Method.StdMethod
instance GHC.Show.Show Network.HTTP.Types.Method.StdMethod
instance GHC.Read.Read Network.HTTP.Types.Method.StdMethod

module Network.HTTP.Types.Status

-- | HTTP Status.
--   
--   Only the <a>statusCode</a> is used for comparisons.
--   
--   Please use <a>mkStatus</a> to create status codes from code and
--   message, or the <a>Enum</a> instance or the status code constants
--   (like <a>ok200</a>). There might be additional record members in the
--   future.
--   
--   Note that the Show instance is only for debugging.
data Status
Status :: Int -> ByteString -> Status
[statusCode] :: Status -> Int
[statusMessage] :: Status -> ByteString

-- | Create a Status from status code and message.
mkStatus :: Int -> ByteString -> Status

-- | Continue 100
status100 :: Status

-- | Continue 100
continue100 :: Status

-- | Switching Protocols 101
status101 :: Status

-- | Switching Protocols 101
switchingProtocols101 :: Status

-- | OK 200
status200 :: Status

-- | OK 200
ok200 :: Status

-- | Created 201
status201 :: Status

-- | Created 201
created201 :: Status

-- | Accepted 202
status202 :: Status

-- | Accepted 202
accepted202 :: Status

-- | Non-Authoritative Information 203
status203 :: Status

-- | Non-Authoritative Information 203
nonAuthoritative203 :: Status

-- | No Content 204
status204 :: Status

-- | No Content 204
noContent204 :: Status

-- | Reset Content 205
status205 :: Status

-- | Reset Content 205
resetContent205 :: Status

-- | Partial Content 206
status206 :: Status

-- | Partial Content 206
partialContent206 :: Status

-- | Multiple Choices 300
status300 :: Status

-- | Multiple Choices 300
multipleChoices300 :: Status

-- | Moved Permanently 301
status301 :: Status

-- | Moved Permanently 301
movedPermanently301 :: Status

-- | Found 302
status302 :: Status

-- | Found 302
found302 :: Status

-- | See Other 303
status303 :: Status

-- | See Other 303
seeOther303 :: Status

-- | Not Modified 304
status304 :: Status

-- | Not Modified 304
notModified304 :: Status

-- | Use Proxy 305
status305 :: Status

-- | Use Proxy 305
useProxy305 :: Status

-- | Temporary Redirect 307
status307 :: Status

-- | Temporary Redirect 307
temporaryRedirect307 :: Status

-- | Permanent Redirect 308
status308 :: Status

-- | Permanent Redirect 308
permanentRedirect308 :: Status

-- | Bad Request 400
status400 :: Status

-- | Bad Request 400
badRequest400 :: Status

-- | Unauthorized 401
status401 :: Status

-- | Unauthorized 401
unauthorized401 :: Status

-- | Payment Required 402
status402 :: Status

-- | Payment Required 402
paymentRequired402 :: Status

-- | Forbidden 403
status403 :: Status

-- | Forbidden 403
forbidden403 :: Status

-- | Not Found 404
status404 :: Status

-- | Not Found 404
notFound404 :: Status

-- | Method Not Allowed 405
status405 :: Status

-- | Method Not Allowed 405
methodNotAllowed405 :: Status

-- | Not Acceptable 406
status406 :: Status

-- | Not Acceptable 406
notAcceptable406 :: Status

-- | Proxy Authentication Required 407
status407 :: Status

-- | Proxy Authentication Required 407
proxyAuthenticationRequired407 :: Status

-- | Request Timeout 408
status408 :: Status

-- | Request Timeout 408
requestTimeout408 :: Status

-- | Conflict 409
status409 :: Status

-- | Conflict 409
conflict409 :: Status

-- | Gone 410
status410 :: Status

-- | Gone 410
gone410 :: Status

-- | Length Required 411
status411 :: Status

-- | Length Required 411
lengthRequired411 :: Status

-- | Precondition Failed 412
status412 :: Status

-- | Precondition Failed 412
preconditionFailed412 :: Status

-- | Request Entity Too Large 413
status413 :: Status

-- | Request Entity Too Large 413
requestEntityTooLarge413 :: Status

-- | Request-URI Too Long 414
status414 :: Status

-- | Request-URI Too Long 414
requestURITooLong414 :: Status

-- | Unsupported Media Type 415
status415 :: Status

-- | Unsupported Media Type 415
unsupportedMediaType415 :: Status

-- | Requested Range Not Satisfiable 416
status416 :: Status

-- | Requested Range Not Satisfiable 416
requestedRangeNotSatisfiable416 :: Status

-- | Expectation Failed 417
status417 :: Status

-- | Expectation Failed 417
expectationFailed417 :: Status

-- | I'm a teapot 418
status418 :: Status

-- | I'm a teapot 418
imATeapot418 :: Status

-- | Unprocessable Entity 422 (<a>RFC 4918</a>)
status422 :: Status

-- | Unprocessable Entity 422 (<a>RFC 4918</a>)
unprocessableEntity422 :: Status

-- | Upgrade Required 426
--   (<a>https://tools.ietf.org/html/rfc7231#section-6.5.15</a>)
status426 :: Status

-- | Upgrade Required 426
--   (<a>https://tools.ietf.org/html/rfc7231#section-6.5.15</a>)
upgradeRequired426 :: Status

-- | Precondition Required 428 (<a>RFC 6585</a>)
status428 :: Status

-- | Precondition Required 428 (<a>RFC 6585</a>)
preconditionRequired428 :: Status

-- | Too Many Requests 429 (<a>RFC 6585</a>)
status429 :: Status

-- | Too Many Requests 429 (<a>RFC 6585</a>)
tooManyRequests429 :: Status

-- | Request Header Fields Too Large 431 (<a>RFC 6585</a>)
status431 :: Status

-- | Request Header Fields Too Large 431 (<a>RFC 6585</a>)
requestHeaderFieldsTooLarge431 :: Status

-- | Internal Server Error 500
status500 :: Status

-- | Internal Server Error 500
internalServerError500 :: Status

-- | Not Implemented 501
status501 :: Status

-- | Not Implemented 501
notImplemented501 :: Status

-- | Bad Gateway 502
status502 :: Status

-- | Bad Gateway 502
badGateway502 :: Status

-- | Service Unavailable 503
status503 :: Status

-- | Service Unavailable 503
serviceUnavailable503 :: Status

-- | Gateway Timeout 504
status504 :: Status

-- | Gateway Timeout 504
gatewayTimeout504 :: Status

-- | HTTP Version Not Supported 505
status505 :: Status

-- | Network Authentication Required 511 (<a>RFC 6585</a>)
status511 :: Status

-- | Network Authentication Required 511 (<a>RFC 6585</a>)
networkAuthenticationRequired511 :: Status

-- | HTTP Version Not Supported 505
httpVersionNotSupported505 :: Status

-- | Informational class
statusIsInformational :: Status -> Bool

-- | Successful class
statusIsSuccessful :: Status -> Bool

-- | Redirection class
statusIsRedirection :: Status -> Bool

-- | Client Error class
statusIsClientError :: Status -> Bool

-- | Server Error class
statusIsServerError :: Status -> Bool
instance GHC.Show.Show Network.HTTP.Types.Status.Status
instance GHC.Classes.Eq Network.HTTP.Types.Status.Status
instance GHC.Classes.Ord Network.HTTP.Types.Status.Status
instance GHC.Enum.Enum Network.HTTP.Types.Status.Status
instance GHC.Enum.Bounded Network.HTTP.Types.Status.Status

module Network.HTTP.Types.URI

-- | Query item
type QueryItem = (ByteString, Maybe ByteString)

-- | Query.
--   
--   General form: <tt>a=b&amp;c=d</tt>, but if the value is Nothing, it
--   becomes <tt>a&amp;c=d</tt>.
type Query = [QueryItem]

-- | Simplified Query item type without support for parameter-less items.
type SimpleQueryItem = (ByteString, ByteString)

-- | Simplified Query type without support for parameter-less items.
type SimpleQuery = [SimpleQueryItem]

-- | Convert <a>SimpleQuery</a> to <a>Query</a>.
simpleQueryToQuery :: SimpleQuery -> Query

-- | Convert <a>Query</a> to <tt>ByteString</tt>.
renderQuery :: Bool -> Query -> ByteString

-- | Convert <a>Query</a> to a <tt>Builder</tt>.
renderQueryBuilder :: Bool -> Query -> Builder

-- | Convert <a>SimpleQuery</a> to <tt>ByteString</tt>.
renderSimpleQuery :: Bool -> SimpleQuery -> ByteString

-- | Split out the query string into a list of keys and values. A few
--   importants points:
--   
--   <ul>
--   <li>The result returned is still bytestrings, since we perform no
--   character decoding here. Most likely, you will want to use UTF-8
--   decoding, but this is left to the user of the library.</li>
--   <li>Percent decoding errors are ignored. In particular, <tt>"%Q"</tt>
--   will be output as <tt>"%Q"</tt>.</li>
--   <li>It decodes <tt>'+'</tt> characters to <tt>' '</tt></li>
--   </ul>
parseQuery :: ByteString -> Query

-- | Same functionality as <a>parseQuery</a> with the option to decode
--   <tt>'+'</tt> characters to <tt>' '</tt> or preserve <tt>'+'</tt>
parseQueryReplacePlus :: Bool -> ByteString -> Query

-- | Parse <a>SimpleQuery</a> from a <tt>ByteString</tt>.
parseSimpleQuery :: ByteString -> SimpleQuery

-- | Convert <a>PartialEscapeQuery</a> to <tt>ByteString</tt>.
renderQueryPartialEscape :: Bool -> PartialEscapeQuery -> ByteString

-- | Convert <a>PartialEscapeQuery</a> to a <tt>Builder</tt>.
renderQueryBuilderPartialEscape :: Bool -> PartialEscapeQuery -> Builder

-- | For some URIs characters must not be URI encoded, e.g. <tt>'+'</tt> or
--   <tt>':'</tt> in
--   <tt>q=a+language:haskell+created:2009-01-01..2009-02-01&amp;sort=stars</tt>
--   The character list unreservedPI instead of unreservedQS would solve
--   this. But we explicitly decide what part to encode. This is mandatory
--   when searching for <tt>'+'</tt>: <tt>q=%2B+language:haskell</tt>.
data EscapeItem
QE :: ByteString -> EscapeItem
QN :: ByteString -> EscapeItem

-- | Query item
type PartialEscapeQueryItem = (ByteString, [EscapeItem])

-- | Query with some chars that should not be escaped.
--   
--   General form: <tt>a=b&amp;c=d:e+f&amp;g=h</tt>
type PartialEscapeQuery = [PartialEscapeQueryItem]

-- | Like Query, but with <a>Text</a> instead of <a>ByteString</a>
--   (UTF8-encoded).
type QueryText = [(Text, Maybe Text)]

-- | Convert <a>QueryText</a> to <a>Query</a>.
queryTextToQuery :: QueryText -> Query

-- | Convert <a>Query</a> to <a>QueryText</a> (leniently decoding the
--   UTF-8).
queryToQueryText :: Query -> QueryText

-- | Convert <a>QueryText</a> to a <a>Builder</a>.
renderQueryText :: Bool -> QueryText -> Builder

-- | Parse <a>QueryText</a> from a <a>ByteString</a>. See <a>parseQuery</a>
--   for details.
parseQueryText :: ByteString -> QueryText

-- | Encodes a list of path segments into a valid URL fragment.
--   
--   This function takes the following three steps:
--   
--   <ul>
--   <li>UTF-8 encodes the characters.</li>
--   <li>Performs percent encoding on all unreserved characters, as well as
--   <tt>:@=+$</tt>,</li>
--   <li>Prepends each segment with a slash.</li>
--   </ul>
--   
--   For example:
--   
--   <pre>
--   encodePathSegments [\"foo\", \"bar\", \"baz\"]
--   </pre>
--   
--   "/foo/bar/baz"
--   
--   <pre>
--   encodePathSegments [\"foo bar\", \"baz\/bin\"]
--   </pre>
--   
--   "/foo%20bar/baz%2Fbin"
--   
--   <pre>
--   encodePathSegments [\"שלום\"]
--   </pre>
--   
--   "/%D7%A9%D7%9C%D7%95%D7%9D"
--   
--   Huge thanks to Jeremy Shaw who created the original implementation of
--   this function in web-routes and did such thorough research to
--   determine all correct escaping procedures.
encodePathSegments :: [Text] -> Builder

-- | Parse a list of path segments from a valid URL fragment.
decodePathSegments :: ByteString -> [Text]

-- | Like encodePathSegments, but without the initial slash.
encodePathSegmentsRelative :: [Text] -> Builder

-- | Extract whole path (path segments + query) from a <a>RFC 2616
--   Request-URI</a>.
--   
--   <pre>
--   &gt;&gt;&gt; extractPath "/path"
--   "/path"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPath "http://example.com:8080/path"
--   "/path"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPath "http://example.com"
--   "/"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPath ""
--   "/"
--   </pre>
extractPath :: ByteString -> ByteString

-- | Encode a whole path (path segments + query).
encodePath :: [Text] -> Query -> Builder

-- | Decode a whole path (path segments + query).
decodePath :: ByteString -> ([Text], Query)

-- | Percent-encoding for URLs (using <a>Builder</a>).
urlEncodeBuilder :: Bool -> ByteString -> Builder

-- | Percent-encoding for URLs.
urlEncode :: Bool -> ByteString -> ByteString

-- | Percent-decoding.
urlDecode :: Bool -> ByteString -> ByteString
instance GHC.Classes.Ord Network.HTTP.Types.URI.EscapeItem
instance GHC.Classes.Eq Network.HTTP.Types.URI.EscapeItem
instance GHC.Show.Show Network.HTTP.Types.URI.EscapeItem

module Network.HTTP.Types.QueryLike

-- | Types which can, and commonly are, converted to <a>Query</a> are in
--   this class.
--   
--   You can use lists of simple key value pairs, with <a>ByteString</a>
--   (strict, or lazy: <a>ByteString</a>), <a>Text</a>, or <a>String</a> as
--   the key/value types. You can also have the value type lifted into a
--   Maybe to support keys without values; and finally it is possible to
--   put each pair into a Maybe for key-value pairs that aren't always
--   present.
class QueryLike a

-- | Convert to <a>Query</a>.
toQuery :: QueryLike a => a -> Query

-- | Types which, in a Query-like key-value list, are used in the Key
--   position.
class QueryKeyLike a
toQueryKey :: QueryKeyLike a => a -> ByteString

-- | Types which, in a Query-like key-value list, are used in the Value
--   position.
class QueryValueLike a
toQueryValue :: QueryValueLike a => a -> Maybe ByteString
instance (Network.HTTP.Types.QueryLike.QueryKeyLike k, Network.HTTP.Types.QueryLike.QueryValueLike v) => Network.HTTP.Types.QueryLike.QueryLike [(k, v)]
instance (Network.HTTP.Types.QueryLike.QueryKeyLike k, Network.HTTP.Types.QueryLike.QueryValueLike v) => Network.HTTP.Types.QueryLike.QueryLike [GHC.Maybe.Maybe (k, v)]
instance Network.HTTP.Types.QueryLike.QueryValueLike Data.ByteString.Internal.ByteString
instance Network.HTTP.Types.QueryLike.QueryValueLike Data.ByteString.Lazy.Internal.ByteString
instance Network.HTTP.Types.QueryLike.QueryValueLike Data.Text.Internal.Text
instance Network.HTTP.Types.QueryLike.QueryValueLike [GHC.Types.Char]
instance Network.HTTP.Types.QueryLike.QueryValueLike a => Network.HTTP.Types.QueryLike.QueryValueLike (GHC.Maybe.Maybe a)
instance Network.HTTP.Types.QueryLike.QueryKeyLike Data.ByteString.Internal.ByteString
instance Network.HTTP.Types.QueryLike.QueryKeyLike Data.ByteString.Lazy.Internal.ByteString
instance Network.HTTP.Types.QueryLike.QueryKeyLike Data.Text.Internal.Text
instance Network.HTTP.Types.QueryLike.QueryKeyLike [GHC.Types.Char]

module Network.HTTP.Types.Version

-- | HTTP Version.
--   
--   Note that the Show instance is intended merely for debugging.
data HttpVersion
HttpVersion :: !Int -> !Int -> HttpVersion
[httpMajor] :: HttpVersion -> !Int
[httpMinor] :: HttpVersion -> !Int

-- | HTTP 0.9
http09 :: HttpVersion

-- | HTTP 1.0
http10 :: HttpVersion

-- | HTTP 1.1
http11 :: HttpVersion

-- | HTTP 2.0
http20 :: HttpVersion
instance GHC.Classes.Ord Network.HTTP.Types.Version.HttpVersion
instance GHC.Classes.Eq Network.HTTP.Types.Version.HttpVersion
instance GHC.Show.Show Network.HTTP.Types.Version.HttpVersion

module Network.HTTP.Types

-- | HTTP method (flat string type).
type Method = ByteString

-- | HTTP Method constants.
methodGet :: Method

-- | HTTP Method constants.
methodPost :: Method

-- | HTTP Method constants.
methodHead :: Method

-- | HTTP Method constants.
methodPut :: Method

-- | HTTP Method constants.
methodDelete :: Method

-- | HTTP Method constants.
methodTrace :: Method

-- | HTTP Method constants.
methodConnect :: Method

-- | HTTP Method constants.
methodOptions :: Method

-- | HTTP Method constants.
methodPatch :: Method

-- | HTTP standard method (as defined by RFC 2616, and PATCH which is
--   defined by RFC 5789).
data StdMethod
GET :: StdMethod
POST :: StdMethod
HEAD :: StdMethod
PUT :: StdMethod
DELETE :: StdMethod
TRACE :: StdMethod
CONNECT :: StdMethod
OPTIONS :: StdMethod
PATCH :: StdMethod

-- | Convert a method <tt>ByteString</tt> to a <a>StdMethod</a> if
--   possible.
parseMethod :: Method -> Either ByteString StdMethod

-- | Convert an algebraic method to a <tt>ByteString</tt>.
renderMethod :: Either ByteString StdMethod -> Method

-- | Convert a <a>StdMethod</a> to a <tt>ByteString</tt>.
renderStdMethod :: StdMethod -> Method

-- | HTTP Version.
--   
--   Note that the Show instance is intended merely for debugging.
data HttpVersion
HttpVersion :: !Int -> !Int -> HttpVersion
[httpMajor] :: HttpVersion -> !Int
[httpMinor] :: HttpVersion -> !Int

-- | HTTP 0.9
http09 :: HttpVersion

-- | HTTP 1.0
http10 :: HttpVersion

-- | HTTP 1.1
http11 :: HttpVersion

-- | HTTP 2.0
http20 :: HttpVersion

-- | HTTP Status.
--   
--   Only the <a>statusCode</a> is used for comparisons.
--   
--   Please use <a>mkStatus</a> to create status codes from code and
--   message, or the <a>Enum</a> instance or the status code constants
--   (like <a>ok200</a>). There might be additional record members in the
--   future.
--   
--   Note that the Show instance is only for debugging.
data Status
Status :: Int -> ByteString -> Status
[statusCode] :: Status -> Int
[statusMessage] :: Status -> ByteString

-- | Create a Status from status code and message.
mkStatus :: Int -> ByteString -> Status

-- | Continue 100
status100 :: Status

-- | Continue 100
continue100 :: Status

-- | Switching Protocols 101
status101 :: Status

-- | Switching Protocols 101
switchingProtocols101 :: Status

-- | OK 200
status200 :: Status

-- | OK 200
ok200 :: Status

-- | Created 201
status201 :: Status

-- | Created 201
created201 :: Status

-- | Accepted 202
status202 :: Status

-- | Accepted 202
accepted202 :: Status

-- | Non-Authoritative Information 203
status203 :: Status

-- | Non-Authoritative Information 203
nonAuthoritative203 :: Status

-- | No Content 204
status204 :: Status

-- | No Content 204
noContent204 :: Status

-- | Reset Content 205
status205 :: Status

-- | Reset Content 205
resetContent205 :: Status

-- | Partial Content 206
status206 :: Status

-- | Partial Content 206
partialContent206 :: Status

-- | Multiple Choices 300
status300 :: Status

-- | Multiple Choices 300
multipleChoices300 :: Status

-- | Moved Permanently 301
status301 :: Status

-- | Moved Permanently 301
movedPermanently301 :: Status

-- | Found 302
status302 :: Status

-- | Found 302
found302 :: Status

-- | See Other 303
status303 :: Status

-- | See Other 303
seeOther303 :: Status

-- | Not Modified 304
status304 :: Status

-- | Not Modified 304
notModified304 :: Status

-- | Use Proxy 305
status305 :: Status

-- | Use Proxy 305
useProxy305 :: Status

-- | Temporary Redirect 307
status307 :: Status

-- | Temporary Redirect 307
temporaryRedirect307 :: Status

-- | Permanent Redirect 308
status308 :: Status

-- | Permanent Redirect 308
permanentRedirect308 :: Status

-- | Bad Request 400
status400 :: Status

-- | Bad Request 400
badRequest400 :: Status

-- | Unauthorized 401
status401 :: Status

-- | Unauthorized 401
unauthorized401 :: Status

-- | Payment Required 402
status402 :: Status

-- | Payment Required 402
paymentRequired402 :: Status

-- | Forbidden 403
status403 :: Status

-- | Forbidden 403
forbidden403 :: Status

-- | Not Found 404
status404 :: Status

-- | Not Found 404
notFound404 :: Status

-- | Method Not Allowed 405
status405 :: Status

-- | Method Not Allowed 405
methodNotAllowed405 :: Status

-- | Not Acceptable 406
status406 :: Status

-- | Not Acceptable 406
notAcceptable406 :: Status

-- | Proxy Authentication Required 407
status407 :: Status

-- | Proxy Authentication Required 407
proxyAuthenticationRequired407 :: Status

-- | Request Timeout 408
status408 :: Status

-- | Request Timeout 408
requestTimeout408 :: Status

-- | Conflict 409
status409 :: Status

-- | Conflict 409
conflict409 :: Status

-- | Gone 410
status410 :: Status

-- | Gone 410
gone410 :: Status

-- | Length Required 411
status411 :: Status

-- | Length Required 411
lengthRequired411 :: Status

-- | Precondition Failed 412
status412 :: Status

-- | Precondition Failed 412
preconditionFailed412 :: Status

-- | Request Entity Too Large 413
status413 :: Status

-- | Request Entity Too Large 413
requestEntityTooLarge413 :: Status

-- | Request-URI Too Long 414
status414 :: Status

-- | Request-URI Too Long 414
requestURITooLong414 :: Status

-- | Unsupported Media Type 415
status415 :: Status

-- | Unsupported Media Type 415
unsupportedMediaType415 :: Status

-- | Requested Range Not Satisfiable 416
status416 :: Status

-- | Requested Range Not Satisfiable 416
requestedRangeNotSatisfiable416 :: Status

-- | Expectation Failed 417
status417 :: Status

-- | Expectation Failed 417
expectationFailed417 :: Status

-- | I'm a teapot 418
status418 :: Status

-- | I'm a teapot 418
imATeapot418 :: Status

-- | Unprocessable Entity 422 (<a>RFC 4918</a>)
status422 :: Status

-- | Unprocessable Entity 422 (<a>RFC 4918</a>)
unprocessableEntity422 :: Status

-- | Precondition Required 428 (<a>RFC 6585</a>)
status428 :: Status

-- | Precondition Required 428 (<a>RFC 6585</a>)
preconditionRequired428 :: Status

-- | Too Many Requests 429 (<a>RFC 6585</a>)
status429 :: Status

-- | Too Many Requests 429 (<a>RFC 6585</a>)
tooManyRequests429 :: Status

-- | Request Header Fields Too Large 431 (<a>RFC 6585</a>)
status431 :: Status

-- | Request Header Fields Too Large 431 (<a>RFC 6585</a>)
requestHeaderFieldsTooLarge431 :: Status

-- | Internal Server Error 500
status500 :: Status

-- | Internal Server Error 500
internalServerError500 :: Status

-- | Not Implemented 501
status501 :: Status

-- | Not Implemented 501
notImplemented501 :: Status

-- | Bad Gateway 502
status502 :: Status

-- | Bad Gateway 502
badGateway502 :: Status

-- | Service Unavailable 503
status503 :: Status

-- | Service Unavailable 503
serviceUnavailable503 :: Status

-- | Gateway Timeout 504
status504 :: Status

-- | Gateway Timeout 504
gatewayTimeout504 :: Status

-- | HTTP Version Not Supported 505
status505 :: Status

-- | HTTP Version Not Supported 505
httpVersionNotSupported505 :: Status

-- | Network Authentication Required 511 (<a>RFC 6585</a>)
status511 :: Status

-- | Network Authentication Required 511 (<a>RFC 6585</a>)
networkAuthenticationRequired511 :: Status

-- | Informational class
statusIsInformational :: Status -> Bool

-- | Successful class
statusIsSuccessful :: Status -> Bool

-- | Redirection class
statusIsRedirection :: Status -> Bool

-- | Client Error class
statusIsClientError :: Status -> Bool

-- | Server Error class
statusIsServerError :: Status -> Bool

-- | Header
type Header = (HeaderName, ByteString)

-- | Header name
type HeaderName = CI ByteString

-- | Request Headers
type RequestHeaders = [Header]

-- | Response Headers
type ResponseHeaders = [Header]

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hAccept :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hAcceptLanguage :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hAuthorization :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hCacheControl :: HeaderName

-- | HTTP Header names according to
--   <a>https://tools.ietf.org/html/rfc6265#section-4</a>
hCookie :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hConnection :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hContentEncoding :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hContentLength :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hContentMD5 :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hContentType :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hDate :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hIfModifiedSince :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hIfRange :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hLastModified :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hLocation :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hRange :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hReferer :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hServer :: HeaderName

-- | HTTP Header names according to
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a>
hUserAgent :: HeaderName

-- | RFC 2616 Byte range (individual).
--   
--   Negative indices are not allowed!
data ByteRange
ByteRangeFrom :: !Integer -> ByteRange
ByteRangeFromTo :: !Integer -> !Integer -> ByteRange
ByteRangeSuffix :: !Integer -> ByteRange
renderByteRangeBuilder :: ByteRange -> Builder
renderByteRange :: ByteRange -> ByteString

-- | RFC 2616 Byte ranges (set).
type ByteRanges = [ByteRange]
renderByteRangesBuilder :: ByteRanges -> Builder
renderByteRanges :: ByteRanges -> ByteString

-- | Parse the value of a Range header into a <a>ByteRanges</a>.
--   
--   <pre>
--   &gt;&gt;&gt; parseByteRanges "error"
--   Nothing
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=0-499"
--   Just [ByteRangeFromTo 0 499]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=500-999"
--   Just [ByteRangeFromTo 500 999]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=-500"
--   Just [ByteRangeSuffix 500]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=9500-"
--   Just [ByteRangeFrom 9500]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=0-0,-1"
--   Just [ByteRangeFromTo 0 0,ByteRangeSuffix 1]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=500-600,601-999"
--   Just [ByteRangeFromTo 500 600,ByteRangeFromTo 601 999]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=500-700,601-999"
--   Just [ByteRangeFromTo 500 700,ByteRangeFromTo 601 999]
--   </pre>
parseByteRanges :: ByteString -> Maybe ByteRanges

-- | Query item
type QueryItem = (ByteString, Maybe ByteString)

-- | Query.
--   
--   General form: <tt>a=b&amp;c=d</tt>, but if the value is Nothing, it
--   becomes <tt>a&amp;c=d</tt>.
type Query = [QueryItem]

-- | Simplified Query item type without support for parameter-less items.
type SimpleQueryItem = (ByteString, ByteString)

-- | Simplified Query type without support for parameter-less items.
type SimpleQuery = [SimpleQueryItem]

-- | Convert <a>SimpleQuery</a> to <a>Query</a>.
simpleQueryToQuery :: SimpleQuery -> Query

-- | Convert <a>Query</a> to <tt>ByteString</tt>.
renderQuery :: Bool -> Query -> ByteString

-- | Convert <a>Query</a> to a <tt>Builder</tt>.
renderQueryBuilder :: Bool -> Query -> Builder

-- | Convert <a>SimpleQuery</a> to <tt>ByteString</tt>.
renderSimpleQuery :: Bool -> SimpleQuery -> ByteString

-- | Split out the query string into a list of keys and values. A few
--   importants points:
--   
--   <ul>
--   <li>The result returned is still bytestrings, since we perform no
--   character decoding here. Most likely, you will want to use UTF-8
--   decoding, but this is left to the user of the library.</li>
--   <li>Percent decoding errors are ignored. In particular, <tt>"%Q"</tt>
--   will be output as <tt>"%Q"</tt>.</li>
--   <li>It decodes <tt>'+'</tt> characters to <tt>' '</tt></li>
--   </ul>
parseQuery :: ByteString -> Query

-- | Parse <a>SimpleQuery</a> from a <tt>ByteString</tt>.
parseSimpleQuery :: ByteString -> SimpleQuery

-- | Convert <a>PartialEscapeQuery</a> to <tt>ByteString</tt>.
renderQueryPartialEscape :: Bool -> PartialEscapeQuery -> ByteString

-- | Convert <a>PartialEscapeQuery</a> to a <tt>Builder</tt>.
renderQueryBuilderPartialEscape :: Bool -> PartialEscapeQuery -> Builder

-- | For some URIs characters must not be URI encoded, e.g. <tt>'+'</tt> or
--   <tt>':'</tt> in
--   <tt>q=a+language:haskell+created:2009-01-01..2009-02-01&amp;sort=stars</tt>
--   The character list unreservedPI instead of unreservedQS would solve
--   this. But we explicitly decide what part to encode. This is mandatory
--   when searching for <tt>'+'</tt>: <tt>q=%2B+language:haskell</tt>.
data EscapeItem
QE :: ByteString -> EscapeItem
QN :: ByteString -> EscapeItem

-- | Query item
type PartialEscapeQueryItem = (ByteString, [EscapeItem])

-- | Query with some chars that should not be escaped.
--   
--   General form: <tt>a=b&amp;c=d:e+f&amp;g=h</tt>
type PartialEscapeQuery = [PartialEscapeQueryItem]

-- | Like Query, but with <a>Text</a> instead of <a>ByteString</a>
--   (UTF8-encoded).
type QueryText = [(Text, Maybe Text)]

-- | Convert <a>QueryText</a> to <a>Query</a>.
queryTextToQuery :: QueryText -> Query

-- | Convert <a>Query</a> to <a>QueryText</a> (leniently decoding the
--   UTF-8).
queryToQueryText :: Query -> QueryText

-- | Convert <a>QueryText</a> to a <a>Builder</a>.
renderQueryText :: Bool -> QueryText -> Builder

-- | Parse <a>QueryText</a> from a <a>ByteString</a>. See <a>parseQuery</a>
--   for details.
parseQueryText :: ByteString -> QueryText

-- | Types which can, and commonly are, converted to <a>Query</a> are in
--   this class.
--   
--   You can use lists of simple key value pairs, with <a>ByteString</a>
--   (strict, or lazy: <a>ByteString</a>), <a>Text</a>, or <a>String</a> as
--   the key/value types. You can also have the value type lifted into a
--   Maybe to support keys without values; and finally it is possible to
--   put each pair into a Maybe for key-value pairs that aren't always
--   present.
class QueryLike a

-- | Convert to <a>Query</a>.
toQuery :: QueryLike a => a -> Query

-- | Encodes a list of path segments into a valid URL fragment.
--   
--   This function takes the following three steps:
--   
--   <ul>
--   <li>UTF-8 encodes the characters.</li>
--   <li>Performs percent encoding on all unreserved characters, as well as
--   <tt>:@=+$</tt>,</li>
--   <li>Prepends each segment with a slash.</li>
--   </ul>
--   
--   For example:
--   
--   <pre>
--   encodePathSegments [\"foo\", \"bar\", \"baz\"]
--   </pre>
--   
--   "/foo/bar/baz"
--   
--   <pre>
--   encodePathSegments [\"foo bar\", \"baz\/bin\"]
--   </pre>
--   
--   "/foo%20bar/baz%2Fbin"
--   
--   <pre>
--   encodePathSegments [\"שלום\"]
--   </pre>
--   
--   "/%D7%A9%D7%9C%D7%95%D7%9D"
--   
--   Huge thanks to Jeremy Shaw who created the original implementation of
--   this function in web-routes and did such thorough research to
--   determine all correct escaping procedures.
encodePathSegments :: [Text] -> Builder

-- | Parse a list of path segments from a valid URL fragment.
decodePathSegments :: ByteString -> [Text]

-- | Like encodePathSegments, but without the initial slash.
encodePathSegmentsRelative :: [Text] -> Builder

-- | Extract whole path (path segments + query) from a <a>RFC 2616
--   Request-URI</a>.
--   
--   <pre>
--   &gt;&gt;&gt; extractPath "/path"
--   "/path"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPath "http://example.com:8080/path"
--   "/path"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPath "http://example.com"
--   "/"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPath ""
--   "/"
--   </pre>
extractPath :: ByteString -> ByteString

-- | Encode a whole path (path segments + query).
encodePath :: [Text] -> Query -> Builder

-- | Decode a whole path (path segments + query).
decodePath :: ByteString -> ([Text], Query)

-- | Percent-encoding for URLs (using <a>Builder</a>).
urlEncodeBuilder :: Bool -> ByteString -> Builder

-- | Percent-encoding for URLs.
urlEncode :: Bool -> ByteString -> ByteString

-- | Percent-decoding.
urlDecode :: Bool -> ByteString -> ByteString
