-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Primitive memory-related operations
--   
--   This package provides various primitive memory-related operations.
@package primitive
@version 0.6.4.0


-- | Primitive state-transformer monads
module Control.Monad.Primitive

-- | Class of monads which can perform primitive state-transformer actions
class Monad m => PrimMonad m where {
    
    -- | State token type
    type family PrimState m;
}

-- | Execute a primitive operation
primitive :: PrimMonad m => (State# (PrimState m) -> (# State# (PrimState m), a #)) -> m a

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld :: Type

-- | Execute a primitive operation with no result
primitive_ :: PrimMonad m => (State# (PrimState m) -> State# (PrimState m)) -> m ()

-- | Class of primitive monads for state-transformer actions.
--   
--   Unlike <a>PrimMonad</a>, this typeclass requires that the
--   <tt>Monad</tt> be fully expressed as a state transformer, therefore
--   disallowing other monad transformers on top of the base <tt>IO</tt> or
--   <tt>ST</tt>.
class PrimMonad m => PrimBase m

-- | Expose the internal structure of the monad
internal :: PrimBase m => m a -> State# (PrimState m) -> (# State# (PrimState m), a #)

-- | Lifts a <a>PrimBase</a> into another <a>PrimMonad</a> with the same
--   underlying state token type.
liftPrim :: (PrimBase m1, PrimMonad m2, PrimState m1 ~ PrimState m2) => m1 a -> m2 a

-- | Convert a <a>PrimBase</a> to another monad with the same state token.
primToPrim :: (PrimBase m1, PrimMonad m2, PrimState m1 ~ PrimState m2) => m1 a -> m2 a

-- | Convert a <a>PrimBase</a> with a <a>RealWorld</a> state token to
--   <a>IO</a>
primToIO :: (PrimBase m, PrimState m ~ RealWorld) => m a -> IO a

-- | Convert a <a>PrimBase</a> to <a>ST</a>
primToST :: PrimBase m => m a -> ST (PrimState m) a

-- | Convert an <a>IO</a> action to a <a>PrimMonad</a>.
ioToPrim :: (PrimMonad m, PrimState m ~ RealWorld) => IO a -> m a

-- | Convert an <a>ST</a> action to a <a>PrimMonad</a>.
stToPrim :: PrimMonad m => ST (PrimState m) a -> m a

-- | Convert a <a>PrimBase</a> to another monad with a possibly different
--   state token. This operation is highly unsafe!
unsafePrimToPrim :: (PrimBase m1, PrimMonad m2) => m1 a -> m2 a

-- | Convert any <a>PrimBase</a> to <a>IO</a>. This operation is highly
--   unsafe!
unsafePrimToIO :: PrimBase m => m a -> IO a

-- | Convert any <a>PrimBase</a> to <a>ST</a> with an arbitrary state
--   token. This operation is highly unsafe!
unsafePrimToST :: PrimBase m => m a -> ST s a

-- | Convert an <a>IO</a> action to any <a>PrimMonad</a>. This operation is
--   highly unsafe!
unsafeIOToPrim :: PrimMonad m => IO a -> m a

-- | Convert an <a>ST</a> action with an arbitraty state token to any
--   <a>PrimMonad</a>. This operation is highly unsafe!
unsafeSTToPrim :: PrimMonad m => ST s a -> m a
unsafeInlinePrim :: PrimBase m => m a -> a
unsafeInlineIO :: IO a -> a
unsafeInlineST :: ST s a -> a
touch :: PrimMonad m => a -> m ()

-- | Create an action to force a value; generalizes <a>evaluate</a>
evalPrim :: forall a m. PrimMonad m => a -> m a
instance Control.Monad.Primitive.PrimBase GHC.Types.IO
instance Control.Monad.Primitive.PrimBase m => Control.Monad.Primitive.PrimBase (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Primitive.PrimBase (GHC.ST.ST s)
instance Control.Monad.Primitive.PrimMonad GHC.Types.IO
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.List.ListT m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Maybe.MaybeT m)
instance (Control.Monad.Trans.Error.Error e, Control.Monad.Primitive.PrimMonad m) => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Error.ErrorT e m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Monoid w, Control.Monad.Primitive.PrimMonad m) => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Primitive.PrimMonad m) => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Base.Monoid w, Control.Monad.Primitive.PrimMonad m) => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Accum.AccumT w m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Select.SelectT r m)
instance Control.Monad.Primitive.PrimMonad m => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Control.Monad.Primitive.PrimMonad m) => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Primitive.PrimMonad m) => Control.Monad.Primitive.PrimMonad (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.Primitive.PrimMonad (GHC.ST.ST s)


-- | Primitive arrays of boxed values.
module Data.Primitive.Array

-- | Boxed arrays
data Array a
Array :: Array# a -> Array a
[array#] :: Array a -> Array# a

-- | Mutable boxed arrays associated with a primitive state token.
data MutableArray s a
MutableArray :: MutableArray# s a -> MutableArray s a
[marray#] :: MutableArray s a -> MutableArray# s a

-- | Create a new mutable array of the specified size and initialise all
--   elements with the given value.
newArray :: PrimMonad m => Int -> a -> m (MutableArray (PrimState m) a)

-- | Read a value from the array at the given index.
readArray :: PrimMonad m => MutableArray (PrimState m) a -> Int -> m a

-- | Write a value to the array at the given index.
writeArray :: PrimMonad m => MutableArray (PrimState m) a -> Int -> a -> m ()

-- | Read a value from the immutable array at the given index.
indexArray :: Array a -> Int -> a

-- | Monadically read a value from the immutable array at the given index.
--   This allows us to be strict in the array while remaining lazy in the
--   read element which is very useful for collective operations. Suppose
--   we want to copy an array. We could do something like this:
--   
--   <pre>
--   copy marr arr ... = do ...
--                          writeArray marr i (indexArray arr i) ...
--                          ...
--   </pre>
--   
--   But since primitive arrays are lazy, the calls to <a>indexArray</a>
--   will not be evaluated. Rather, <tt>marr</tt> will be filled with
--   thunks each of which would retain a reference to <tt>arr</tt>. This is
--   definitely not what we want!
--   
--   With <a>indexArrayM</a>, we can instead write
--   
--   <pre>
--   copy marr arr ... = do ...
--                          x &lt;- indexArrayM arr i
--                          writeArray marr i x
--                          ...
--   </pre>
--   
--   Now, indexing is executed immediately although the returned element is
--   still not evaluated.
indexArrayM :: Monad m => Array a -> Int -> m a

-- | Read a value from the immutable array at the given index, returning
--   the result in an unboxed unary tuple. This is currently used to
--   implement folds.
indexArray## :: Array a -> Int -> (# a #)

-- | Create an immutable copy of a slice of an array.
--   
--   This operation makes a copy of the specified section, so it is safe to
--   continue using the mutable array afterward.
freezeArray :: PrimMonad m => MutableArray (PrimState m) a -> Int -> Int -> m (Array a)

-- | Create a mutable array from a slice of an immutable array.
--   
--   This operation makes a copy of the specified slice, so it is safe to
--   use the immutable array afterward.
thawArray :: PrimMonad m => Array a -> Int -> Int -> m (MutableArray (PrimState m) a)
runArray :: (forall s. ST s (MutableArray s a)) -> Array a

-- | Convert a mutable array to an immutable one without copying. The array
--   should not be modified after the conversion.
unsafeFreezeArray :: PrimMonad m => MutableArray (PrimState m) a -> m (Array a)

-- | Convert an immutable array to an mutable one without copying. The
--   immutable array should not be used after the conversion.
unsafeThawArray :: PrimMonad m => Array a -> m (MutableArray (PrimState m) a)

-- | Check whether the two arrays refer to the same memory block.
sameMutableArray :: MutableArray s a -> MutableArray s a -> Bool

-- | Copy a slice of an immutable array to a mutable array.
copyArray :: PrimMonad m => MutableArray (PrimState m) a -> Int -> Array a -> Int -> Int -> m ()

-- | Copy a slice of a mutable array to another array. The two arrays may
--   not be the same.
copyMutableArray :: PrimMonad m => MutableArray (PrimState m) a -> Int -> MutableArray (PrimState m) a -> Int -> Int -> m ()

-- | Return a newly allocated Array with the specified subrange of the
--   provided Array. The provided Array should contain the full subrange
--   specified by the two Ints, but this is not checked.
cloneArray :: Array a -> Int -> Int -> Array a

-- | Return a newly allocated MutableArray. with the specified subrange of
--   the provided MutableArray. The provided MutableArray should contain
--   the full subrange specified by the two Ints, but this is not checked.
cloneMutableArray :: PrimMonad m => MutableArray (PrimState m) a -> Int -> Int -> m (MutableArray (PrimState m) a)
sizeofArray :: Array a -> Int
sizeofMutableArray :: MutableArray s a -> Int

-- | The <a>fromListN</a> function takes the input list's length as a hint.
--   Its behaviour should be equivalent to <a>fromList</a>. The hint can be
--   used to construct the structure <tt>l</tt> more efficiently compared
--   to <a>fromList</a>. If the given hint does not equal to the input
--   list's length the behaviour of <a>fromListN</a> is not specified.
fromListN :: IsList l => Int -> [Item l] -> l

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | Strict map over the elements of the array.
mapArray' :: (a -> b) -> Array a -> Array b

-- | This is the fastest, most straightforward way to traverse an array,
--   but it only works correctly with a sufficiently "affine"
--   <a>PrimMonad</a> instance. In particular, it must only produce *one*
--   result array. <a>ListT</a>-transformed monads, for example, will not
--   work right at all.
traverseArrayP :: PrimMonad m => (a -> m b) -> Array a -> m (Array b)
instance GHC.Base.Monad Data.Primitive.Array.Array
instance GHC.Classes.Eq (Data.Primitive.Array.MutableArray s a)
instance (Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable a) => Data.Data.Data (Data.Primitive.Array.MutableArray s a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Primitive.Array.Array a)
instance Data.Functor.Classes.Eq1 Data.Primitive.Array.Array
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Primitive.Array.Array a)
instance Data.Functor.Classes.Ord1 Data.Primitive.Array.Array
instance Data.Foldable.Foldable Data.Primitive.Array.Array
instance Data.Traversable.Traversable Data.Primitive.Array.Array
instance GHC.Exts.IsList (Data.Primitive.Array.Array a)
instance GHC.Base.Functor Data.Primitive.Array.Array
instance GHC.Base.Applicative Data.Primitive.Array.Array
instance GHC.Base.Alternative Data.Primitive.Array.Array
instance GHC.Base.MonadPlus Data.Primitive.Array.Array
instance Control.Monad.Zip.MonadZip Data.Primitive.Array.Array
instance Control.Monad.Fix.MonadFix Data.Primitive.Array.Array
instance GHC.Base.Semigroup (Data.Primitive.Array.Array a)
instance GHC.Base.Monoid (Data.Primitive.Array.Array a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Primitive.Array.Array a)
instance Data.Functor.Classes.Show1 Data.Primitive.Array.Array
instance GHC.Read.Read a => GHC.Read.Read (Data.Primitive.Array.Array a)
instance Data.Functor.Classes.Read1 Data.Primitive.Array.Array
instance Data.Data.Data a => Data.Data.Data (Data.Primitive.Array.Array a)


-- | Primitive operations on <tt>MVar</tt>. This module provides a similar
--   interface to <a>Control.Concurrent.MVar</a>. However, the functions
--   are generalized to work in any <a>PrimMonad</a> instead of only
--   working in <a>IO</a>. Note that all of the functions here are
--   completely deterministic. Users of <a>MVar</a> are responsible for
--   designing abstractions that guarantee determinism in the presence of
--   multi-threading.
module Data.Primitive.MVar
data MVar s a
MVar :: MVar# s a -> MVar s a

-- | Create a new <a>MVar</a> that holds the supplied argument.
newMVar :: PrimMonad m => a -> m (MVar (PrimState m) a)

-- | Check whether a given <a>MVar</a> is empty.
--   
--   Notice that the boolean value returned is just a snapshot of the state
--   of the MVar. By the time you get to react on its result, the MVar may
--   have been filled (or emptied) - so be extremely careful when using
--   this operation. Use <a>tryTakeMVar</a> instead if possible.
isEmptyMVar :: PrimMonad m => MVar (PrimState m) a -> m Bool

-- | Create a new <a>MVar</a> that is initially empty.
newEmptyMVar :: PrimMonad m => m (MVar (PrimState m) a)

-- | Put a value into an <a>MVar</a>. If the <a>MVar</a> is currently full,
--   <a>putMVar</a> will wait until it becomes empty.
putMVar :: PrimMonad m => MVar (PrimState m) a -> a -> m ()

-- | Atomically read the contents of an <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>readMVar</a> will wait until it is full.
--   <a>readMVar</a> is guaranteed to receive the next <a>putMVar</a>.
--   
--   <i>Multiple Wakeup:</i> <a>readMVar</a> is multiple-wakeup, so when
--   multiple readers are blocked on an <a>MVar</a>, all of them are woken
--   up at the same time.
--   
--   <i>Compatibility note:</i> On GHCs prior to 7.8, <a>readMVar</a> is a
--   combination of <a>takeMVar</a> and <a>putMVar</a>. Consequently, its
--   behavior differs in the following ways:
--   
--   <ul>
--   <li>It is single-wakeup instead of multiple-wakeup.</li>
--   <li>It might not receive the value from the next call to
--   <a>putMVar</a> if there is already a pending thread blocked on
--   <a>takeMVar</a>.</li>
--   <li>If another thread puts a value in the <a>MVar</a> in between the
--   calls to <a>takeMVar</a> and <a>putMVar</a>, that value may be
--   overridden.</li>
--   </ul>
readMVar :: PrimMonad m => MVar (PrimState m) a -> m a

-- | Return the contents of the <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>takeMVar</a> will wait until it is full. After a
--   <a>takeMVar</a>, the <a>MVar</a> is left empty.
takeMVar :: PrimMonad m => MVar (PrimState m) a -> m a

-- | A non-blocking version of <a>putMVar</a>. The <a>tryPutMVar</a>
--   function attempts to put the value <tt>a</tt> into the <a>MVar</a>,
--   returning <a>True</a> if it was successful, or <a>False</a> otherwise.
tryPutMVar :: PrimMonad m => MVar (PrimState m) a -> a -> m Bool

-- | A non-blocking version of <a>readMVar</a>. The <a>tryReadMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>.
--   
--   <i>Compatibility note:</i> On GHCs prior to 7.8, <a>tryReadMVar</a> is
--   a combination of <a>tryTakeMVar</a> and <a>putMVar</a>. Consequently,
--   its behavior differs in the following ways:
--   
--   <ul>
--   <li>It is single-wakeup instead of multiple-wakeup.</li>
--   <li>In the presence of other threads calling <a>putMVar</a>,
--   <a>tryReadMVar</a> may block.</li>
--   <li>If another thread puts a value in the <a>MVar</a> in between the
--   calls to <a>tryTakeMVar</a> and <a>putMVar</a>, that value may be
--   overridden.</li>
--   </ul>
tryReadMVar :: PrimMonad m => MVar (PrimState m) a -> m (Maybe a)

-- | A non-blocking version of <a>takeMVar</a>. The <a>tryTakeMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>. After <a>tryTakeMVar</a>, the <a>MVar</a> is left
--   empty.
tryTakeMVar :: PrimMonad m => MVar (PrimState m) a -> m (Maybe a)
instance GHC.Classes.Eq (Data.Primitive.MVar.MVar s a)


-- | Machine-dependent constants
module Data.Primitive.MachDeps
sIZEOF_CHAR :: Int
aLIGNMENT_CHAR :: Int
sIZEOF_INT :: Int
aLIGNMENT_INT :: Int
sIZEOF_WORD :: Int
aLIGNMENT_WORD :: Int
sIZEOF_DOUBLE :: Int
aLIGNMENT_DOUBLE :: Int
sIZEOF_FLOAT :: Int
aLIGNMENT_FLOAT :: Int
sIZEOF_PTR :: Int
aLIGNMENT_PTR :: Int
sIZEOF_FUNPTR :: Int
aLIGNMENT_FUNPTR :: Int
sIZEOF_STABLEPTR :: Int
aLIGNMENT_STABLEPTR :: Int
sIZEOF_INT8 :: Int
aLIGNMENT_INT8 :: Int
sIZEOF_WORD8 :: Int
aLIGNMENT_WORD8 :: Int
sIZEOF_INT16 :: Int
aLIGNMENT_INT16 :: Int
sIZEOF_WORD16 :: Int
aLIGNMENT_WORD16 :: Int
sIZEOF_INT32 :: Int
aLIGNMENT_INT32 :: Int
sIZEOF_WORD32 :: Int
aLIGNMENT_WORD32 :: Int
sIZEOF_INT64 :: Int
aLIGNMENT_INT64 :: Int
sIZEOF_WORD64 :: Int
aLIGNMENT_WORD64 :: Int
type Word64_# = Word#
type Int64_# = Int#


-- | Primitive boxed mutable variables
module Data.Primitive.MutVar

-- | A <a>MutVar</a> behaves like a single-element mutable array associated
--   with a primitive state token.
data MutVar s a
MutVar :: MutVar# s a -> MutVar s a

-- | Create a new <a>MutVar</a> with the specified initial value
newMutVar :: PrimMonad m => a -> m (MutVar (PrimState m) a)

-- | Read the value of a <a>MutVar</a>
readMutVar :: PrimMonad m => MutVar (PrimState m) a -> m a

-- | Write a new value into a <a>MutVar</a>
writeMutVar :: PrimMonad m => MutVar (PrimState m) a -> a -> m ()

-- | Atomically mutate the contents of a <a>MutVar</a>
atomicModifyMutVar :: PrimMonad m => MutVar (PrimState m) a -> (a -> (a, b)) -> m b

-- | Strict version of <a>atomicModifyMutVar</a>. This forces both the
--   value stored in the <a>MutVar</a> as well as the value returned.
atomicModifyMutVar' :: PrimMonad m => MutVar (PrimState m) a -> (a -> (a, b)) -> m b

-- | Mutate the contents of a <a>MutVar</a>
modifyMutVar :: PrimMonad m => MutVar (PrimState m) a -> (a -> a) -> m ()

-- | Strict version of <a>modifyMutVar</a>
modifyMutVar' :: PrimMonad m => MutVar (PrimState m) a -> (a -> a) -> m ()
instance GHC.Classes.Eq (Data.Primitive.MutVar.MutVar s a)


-- | Small arrays are boxed (im)mutable arrays.
--   
--   The underlying structure of the <tt>Array</tt> type contains a card
--   table, allowing segments of the array to be marked as having been
--   mutated. This allows the garbage collector to only re-traverse
--   segments of the array that have been marked during certain phases,
--   rather than having to traverse the entire array.
--   
--   <a>SmallArray</a> lacks this table. This means that it takes up less
--   memory and has slightly faster writes. It is also more efficient
--   during garbage collection so long as the card table would have a
--   single entry covering the entire array. These advantages make them
--   suitable for use as arrays that are known to be small.
--   
--   The card size is 128, so for uses much larger than that,
--   <tt>Array</tt> would likely be superior.
--   
--   The underlying type, <a>SmallArray#</a>, was introduced in GHC 7.10,
--   so prior to that version, this module simply implements small arrays
--   as <tt>Array</tt>.
module Data.Primitive.SmallArray
data SmallArray a
SmallArray :: SmallArray# a -> SmallArray a
data SmallMutableArray s a
SmallMutableArray :: SmallMutableArray# s a -> SmallMutableArray s a

-- | Create a new small mutable array.
newSmallArray :: PrimMonad m => Int -> a -> m (SmallMutableArray (PrimState m) a)

-- | Read the element at a given index in a mutable array.
readSmallArray :: PrimMonad m => SmallMutableArray (PrimState m) a -> Int -> m a

-- | Write an element at the given idex in a mutable array.
writeSmallArray :: PrimMonad m => SmallMutableArray (PrimState m) a -> Int -> a -> m ()

-- | Copy a slice of an immutable array into a mutable array.
copySmallArray :: PrimMonad m => SmallMutableArray (PrimState m) a -> Int -> SmallArray a -> Int -> Int -> m ()

-- | Copy a slice of one mutable array into another.
copySmallMutableArray :: PrimMonad m => SmallMutableArray (PrimState m) a -> Int -> SmallMutableArray (PrimState m) a -> Int -> Int -> m ()

-- | Look up an element in an immutable array.
indexSmallArray :: SmallArray a -> Int -> a

-- | Look up an element in an immutable array.
--   
--   The purpose of returning a result using a monad is to allow the caller
--   to avoid retaining references to the array. Evaluating the return
--   value will cause the array lookup to be performed, even though it may
--   not require the element of the array to be evaluated (which could
--   throw an exception). For instance:
--   
--   <pre>
--   data Box a = Box a
--   ...
--   
--   f sa = case indexSmallArrayM sa 0 of
--     Box x -&gt; ...
--   </pre>
--   
--   <tt>x</tt> is not a closure that references <tt>sa</tt> as it would be
--   if we instead wrote:
--   
--   <pre>
--   let x = indexSmallArray sa 0
--   </pre>
--   
--   And does not prevent <tt>sa</tt> from being garbage collected.
--   
--   Note that <a>Identity</a> is not adequate for this use, as it is a
--   newtype, and cannot be evaluated without evaluating the element.
indexSmallArrayM :: Monad m => SmallArray a -> Int -> m a

-- | Read a value from the immutable array at the given index, returning
--   the result in an unboxed unary tuple. This is currently used to
--   implement folds.
indexSmallArray## :: SmallArray a -> Int -> (# a #)

-- | Create a copy of a slice of an immutable array.
cloneSmallArray :: SmallArray a -> Int -> Int -> SmallArray a

-- | Create a copy of a slice of a mutable array.
cloneSmallMutableArray :: PrimMonad m => SmallMutableArray (PrimState m) a -> Int -> Int -> m (SmallMutableArray (PrimState m) a)

-- | Create an immutable array corresponding to a slice of a mutable array.
--   
--   This operation copies the portion of the array to be frozen.
freezeSmallArray :: PrimMonad m => SmallMutableArray (PrimState m) a -> Int -> Int -> m (SmallArray a)

-- | Render a mutable array immutable.
--   
--   This operation performs no copying, so care must be taken not to
--   modify the input array after freezing.
unsafeFreezeSmallArray :: PrimMonad m => SmallMutableArray (PrimState m) a -> m (SmallArray a)

-- | Create a mutable array corresponding to a slice of an immutable array.
--   
--   This operation copies the portion of the array to be thawed.
thawSmallArray :: PrimMonad m => SmallArray a -> Int -> Int -> m (SmallMutableArray (PrimState m) a)
runSmallArray :: (forall s. ST s (SmallMutableArray s a)) -> SmallArray a

-- | Render an immutable array mutable.
--   
--   This operation performs no copying, so care must be taken with its
--   use.
unsafeThawSmallArray :: PrimMonad m => SmallArray a -> m (SmallMutableArray (PrimState m) a)
sizeofSmallArray :: SmallArray a -> Int
sizeofSmallMutableArray :: SmallMutableArray s a -> Int

-- | Create a <a>SmallArray</a> from a list.
smallArrayFromList :: [a] -> SmallArray a

-- | Create a <a>SmallArray</a> from a list of a known length. If the
--   length of the list does not match the given length, this throws an
--   exception.
smallArrayFromListN :: Int -> [a] -> SmallArray a

-- | Strict map over the elements of the array.
mapSmallArray' :: (a -> b) -> SmallArray a -> SmallArray b

-- | This is the fastest, most straightforward way to traverse an array,
--   but it only works correctly with a sufficiently "affine"
--   <a>PrimMonad</a> instance. In particular, it must only produce *one*
--   result array. <a>ListT</a>-transformed monads, for example, will not
--   work right at all.
traverseSmallArrayP :: PrimMonad m => (a -> m b) -> SmallArray a -> m (SmallArray b)
instance GHC.Base.Monad Data.Primitive.SmallArray.SmallArray
instance GHC.Classes.Eq (Data.Primitive.SmallArray.SmallMutableArray s a)
instance (Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable a) => Data.Data.Data (Data.Primitive.SmallArray.SmallMutableArray s a)
instance Data.Functor.Classes.Eq1 Data.Primitive.SmallArray.SmallArray
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Primitive.SmallArray.SmallArray a)
instance Data.Functor.Classes.Ord1 Data.Primitive.SmallArray.SmallArray
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Primitive.SmallArray.SmallArray a)
instance Data.Foldable.Foldable Data.Primitive.SmallArray.SmallArray
instance Data.Traversable.Traversable Data.Primitive.SmallArray.SmallArray
instance GHC.Base.Functor Data.Primitive.SmallArray.SmallArray
instance GHC.Base.Applicative Data.Primitive.SmallArray.SmallArray
instance GHC.Base.Alternative Data.Primitive.SmallArray.SmallArray
instance GHC.Base.MonadPlus Data.Primitive.SmallArray.SmallArray
instance Control.Monad.Zip.MonadZip Data.Primitive.SmallArray.SmallArray
instance Control.Monad.Fix.MonadFix Data.Primitive.SmallArray.SmallArray
instance GHC.Base.Semigroup (Data.Primitive.SmallArray.SmallArray a)
instance GHC.Base.Monoid (Data.Primitive.SmallArray.SmallArray a)
instance GHC.Exts.IsList (Data.Primitive.SmallArray.SmallArray a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Primitive.SmallArray.SmallArray a)
instance Data.Functor.Classes.Show1 Data.Primitive.SmallArray.SmallArray
instance GHC.Read.Read a => GHC.Read.Read (Data.Primitive.SmallArray.SmallArray a)
instance Data.Functor.Classes.Read1 Data.Primitive.SmallArray.SmallArray
instance Data.Data.Data a => Data.Data.Data (Data.Primitive.SmallArray.SmallArray a)


-- | Basic types and classes for primitive array operations
module Data.Primitive.Types

-- | Class of types supporting primitive array operations
class Prim a

-- | Size of values of type <tt>a</tt>. The argument is not used.
sizeOf# :: Prim a => a -> Int#

-- | Alignment of values of type <tt>a</tt>. The argument is not used.
alignment# :: Prim a => a -> Int#

-- | Read a value from the array. The offset is in elements of type
--   <tt>a</tt> rather than in bytes.
indexByteArray# :: Prim a => ByteArray# -> Int# -> a

-- | Read a value from the mutable array. The offset is in elements of type
--   <tt>a</tt> rather than in bytes.
readByteArray# :: Prim a => MutableByteArray# s -> Int# -> State# s -> (# State# s, a #)

-- | Write a value to the mutable array. The offset is in elements of type
--   <tt>a</tt> rather than in bytes.
writeByteArray# :: Prim a => MutableByteArray# s -> Int# -> a -> State# s -> State# s

-- | Fill a slice of the mutable array with a value. The offset and length
--   of the chunk are in elements of type <tt>a</tt> rather than in bytes.
setByteArray# :: Prim a => MutableByteArray# s -> Int# -> Int# -> a -> State# s -> State# s

-- | Read a value from a memory position given by an address and an offset.
--   The memory block the address refers to must be immutable. The offset
--   is in elements of type <tt>a</tt> rather than in bytes.
indexOffAddr# :: Prim a => Addr# -> Int# -> a

-- | Read a value from a memory position given by an address and an offset.
--   The offset is in elements of type <tt>a</tt> rather than in bytes.
readOffAddr# :: Prim a => Addr# -> Int# -> State# s -> (# State# s, a #)

-- | Write a value to a memory position given by an address and an offset.
--   The offset is in elements of type <tt>a</tt> rather than in bytes.
writeOffAddr# :: Prim a => Addr# -> Int# -> a -> State# s -> State# s

-- | Fill a memory block given by an address, an offset and a length. The
--   offset and length are in elements of type <tt>a</tt> rather than in
--   bytes.
setOffAddr# :: Prim a => Addr# -> Int# -> Int# -> a -> State# s -> State# s

-- | Size of values of type <tt>a</tt>. The argument is not used.
--   
--   This function has existed since 0.1, but was moved from
--   <a>Primitive</a> to <a>Types</a> in version 0.6.3.0
sizeOf :: Prim a => a -> Int

-- | Alignment of values of type <tt>a</tt>. The argument is not used.
--   
--   This function has existed since 0.1, but was moved from
--   <a>Primitive</a> to <a>Types</a> in version 0.6.3.0
alignment :: Prim a => a -> Int

-- | An implementation of <a>setByteArray#</a> that calls
--   <a>writeByteArray#</a> to set each element. This is helpful when
--   writing a <a>Prim</a> instance for a multi-word data type for which
--   there is no cpu-accelerated way to broadcast a value to contiguous
--   memory. It is typically used alongside <a>defaultSetOffAddr#</a>. For
--   example:
--   
--   <pre>
--   data Trip = Trip Int Int Int
--   
--   instance Prim Trip
--     sizeOf# _ = 3# *# sizeOf# (undefined :: Int)
--     alignment# _ = alignment# (undefined :: Int)
--     indexByteArray# arr# i# = ...
--     readByteArray# arr# i# = ...
--     writeByteArray# arr# i# (Trip a b c) =
--       \s0 -&gt; case writeByteArray# arr# (3# *# i#) a s0 of
--          s1 -&gt; case writeByteArray# arr# ((3# *# i#) +# 1#) b s1 of
--            s2 -&gt; case writeByteArray# arr# ((3# *# i#) +# 2# ) c s2 of
--              s3 -&gt; s3
--     setByteArray# = defaultSetByteArray#
--     indexOffAddr# addr# i# = ...
--     readOffAddr# addr# i# = ...
--     writeOffAddr# addr# i# (Trip a b c) =
--       \s0 -&gt; case writeOffAddr# addr# (3# *# i#) a s0 of
--          s1 -&gt; case writeOffAddr# addr# ((3# *# i#) +# 1#) b s1 of
--            s2 -&gt; case writeOffAddr# addr# ((3# *# i#) +# 2# ) c s2 of
--              s3 -&gt; s3
--     setOffAddr# = defaultSetOffAddr#
--   </pre>
defaultSetByteArray# :: Prim a => MutableByteArray# s -> Int# -> Int# -> a -> State# s -> State# s

-- | An implementation of <a>setOffAddr#</a> that calls
--   <a>writeOffAddr#</a> to set each element. The documentation of
--   <a>defaultSetByteArray#</a> provides an example of how to use this.
defaultSetOffAddr# :: Prim a => Addr# -> Int# -> Int# -> a -> State# s -> State# s

-- | A machine address
data Addr
Addr :: Addr# -> Addr

-- | Newtype that uses a <a>Prim</a> instance to give rise to a
--   <a>Storable</a> instance. This type is intended to be used with the
--   <tt>DerivingVia</tt> extension available in GHC 8.6 and up. For
--   example, consider a user-defined <a>Prim</a> instance for a multi-word
--   data type.
--   
--   <pre>
--   data Uuid = Uuid Word64 Word64
--     deriving Storable via (PrimStorable Uuid)
--   instance Prim Uuid where ...
--   </pre>
--   
--   Writing the <a>Prim</a> instance is tedious and unavoidable, but the
--   <a>Storable</a> instance comes for free once the <a>Prim</a> instance
--   is written.
newtype PrimStorable a
PrimStorable :: a -> PrimStorable a
[getPrimStorable] :: PrimStorable a -> a
instance Data.Primitive.Types.Prim Foreign.C.Types.CChar
instance Data.Primitive.Types.Prim Foreign.C.Types.CSChar
instance Data.Primitive.Types.Prim Foreign.C.Types.CUChar
instance Data.Primitive.Types.Prim Foreign.C.Types.CShort
instance Data.Primitive.Types.Prim Foreign.C.Types.CUShort
instance Data.Primitive.Types.Prim Foreign.C.Types.CInt
instance Data.Primitive.Types.Prim Foreign.C.Types.CUInt
instance Data.Primitive.Types.Prim Foreign.C.Types.CLong
instance Data.Primitive.Types.Prim Foreign.C.Types.CULong
instance Data.Primitive.Types.Prim Foreign.C.Types.CPtrdiff
instance Data.Primitive.Types.Prim Foreign.C.Types.CSize
instance Data.Primitive.Types.Prim Foreign.C.Types.CWchar
instance Data.Primitive.Types.Prim Foreign.C.Types.CSigAtomic
instance Data.Primitive.Types.Prim Foreign.C.Types.CLLong
instance Data.Primitive.Types.Prim Foreign.C.Types.CULLong
instance Data.Primitive.Types.Prim Foreign.C.Types.CBool
instance Data.Primitive.Types.Prim Foreign.C.Types.CIntPtr
instance Data.Primitive.Types.Prim Foreign.C.Types.CUIntPtr
instance Data.Primitive.Types.Prim Foreign.C.Types.CIntMax
instance Data.Primitive.Types.Prim Foreign.C.Types.CUIntMax
instance Data.Primitive.Types.Prim Foreign.C.Types.CClock
instance Data.Primitive.Types.Prim Foreign.C.Types.CTime
instance Data.Primitive.Types.Prim Foreign.C.Types.CUSeconds
instance Data.Primitive.Types.Prim Foreign.C.Types.CSUSeconds
instance Data.Primitive.Types.Prim Foreign.C.Types.CFloat
instance Data.Primitive.Types.Prim Foreign.C.Types.CDouble
instance Data.Primitive.Types.Prim System.Posix.Types.CDev
instance Data.Primitive.Types.Prim System.Posix.Types.CIno
instance Data.Primitive.Types.Prim System.Posix.Types.CMode
instance Data.Primitive.Types.Prim System.Posix.Types.COff
instance Data.Primitive.Types.Prim System.Posix.Types.CPid
instance Data.Primitive.Types.Prim System.Posix.Types.CSsize
instance Data.Primitive.Types.Prim System.Posix.Types.CGid
instance Data.Primitive.Types.Prim System.Posix.Types.CNlink
instance Data.Primitive.Types.Prim System.Posix.Types.CUid
instance Data.Primitive.Types.Prim System.Posix.Types.CCc
instance Data.Primitive.Types.Prim System.Posix.Types.CSpeed
instance Data.Primitive.Types.Prim System.Posix.Types.CTcflag
instance Data.Primitive.Types.Prim System.Posix.Types.CRLim
instance Data.Primitive.Types.Prim System.Posix.Types.CBlkSize
instance Data.Primitive.Types.Prim System.Posix.Types.CBlkCnt
instance Data.Primitive.Types.Prim System.Posix.Types.CClockId
instance Data.Primitive.Types.Prim System.Posix.Types.CFsBlkCnt
instance Data.Primitive.Types.Prim System.Posix.Types.CFsFilCnt
instance Data.Primitive.Types.Prim System.Posix.Types.CId
instance Data.Primitive.Types.Prim System.Posix.Types.CKey
instance Data.Primitive.Types.Prim System.Posix.Types.CTimer
instance Data.Primitive.Types.Prim System.Posix.Types.Fd
instance Data.Primitive.Types.Prim a => Foreign.Storable.Storable (Data.Primitive.Types.PrimStorable a)
instance Data.Primitive.Types.Prim GHC.Types.Word
instance Data.Primitive.Types.Prim GHC.Word.Word8
instance Data.Primitive.Types.Prim GHC.Word.Word16
instance Data.Primitive.Types.Prim GHC.Word.Word32
instance Data.Primitive.Types.Prim GHC.Word.Word64
instance Data.Primitive.Types.Prim GHC.Types.Int
instance Data.Primitive.Types.Prim GHC.Int.Int8
instance Data.Primitive.Types.Prim GHC.Int.Int16
instance Data.Primitive.Types.Prim GHC.Int.Int32
instance Data.Primitive.Types.Prim GHC.Int.Int64
instance Data.Primitive.Types.Prim GHC.Types.Float
instance Data.Primitive.Types.Prim GHC.Types.Double
instance Data.Primitive.Types.Prim GHC.Types.Char
instance Data.Primitive.Types.Prim Data.Primitive.Types.Addr
instance Data.Primitive.Types.Prim (GHC.Ptr.Ptr a)
instance Data.Primitive.Types.Prim (GHC.Ptr.FunPtr a)
instance GHC.Show.Show Data.Primitive.Types.Addr
instance GHC.Classes.Eq Data.Primitive.Types.Addr
instance GHC.Classes.Ord Data.Primitive.Types.Addr
instance Data.Data.Data Data.Primitive.Types.Addr


-- | Primitive operations on ByteArrays
module Data.Primitive.ByteArray

-- | Byte arrays
data ByteArray
ByteArray :: ByteArray# -> ByteArray

-- | Mutable byte arrays associated with a primitive state token
data MutableByteArray s
MutableByteArray :: MutableByteArray# s -> MutableByteArray s
data ByteArray# :: TYPE UnliftedRep
data MutableByteArray# (a :: Type) :: Type -> TYPE UnliftedRep

-- | Create a new mutable byte array of the specified size in bytes.
newByteArray :: PrimMonad m => Int -> m (MutableByteArray (PrimState m))

-- | Create a <i>pinned</i> byte array of the specified size in bytes. The
--   garbage collector is guaranteed not to move it.
newPinnedByteArray :: PrimMonad m => Int -> m (MutableByteArray (PrimState m))

-- | Create a <i>pinned</i> byte array of the specified size in bytes and
--   with the given alignment. The garbage collector is guaranteed not to
--   move it.
newAlignedPinnedByteArray :: PrimMonad m => Int -> Int -> m (MutableByteArray (PrimState m))

-- | Resize a mutable byte array. The new size is given in bytes.
--   
--   This will either resize the array in-place or, if not possible,
--   allocate the contents into a new, unpinned array and copy the original
--   array's contents.
--   
--   To avoid undefined behaviour, the original <a>MutableByteArray</a>
--   shall not be accessed anymore after a <a>resizeMutableByteArray</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutableByteArray</a> in case a new <a>MutableByteArray</a> had to
--   be allocated.
resizeMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> m (MutableByteArray (PrimState m))

-- | Read a primitive value from the byte array. The offset is given in
--   elements of type <tt>a</tt> rather than in bytes.
readByteArray :: (Prim a, PrimMonad m) => MutableByteArray (PrimState m) -> Int -> m a

-- | Write a primitive value to the byte array. The offset is given in
--   elements of type <tt>a</tt> rather than in bytes.
writeByteArray :: (Prim a, PrimMonad m) => MutableByteArray (PrimState m) -> Int -> a -> m ()

-- | Read a primitive value from the byte array. The offset is given in
--   elements of type <tt>a</tt> rather than in bytes.
indexByteArray :: Prim a => ByteArray -> Int -> a
byteArrayFromList :: Prim a => [a] -> ByteArray
byteArrayFromListN :: Prim a => Int -> [a] -> ByteArray

-- | Right-fold over the elements of a <a>ByteArray</a>.
foldrByteArray :: forall a b. Prim a => (a -> b -> b) -> b -> ByteArray -> b

-- | Convert a mutable byte array to an immutable one without copying. The
--   array should not be modified after the conversion.
unsafeFreezeByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> m ByteArray

-- | Convert an immutable byte array to a mutable one without copying. The
--   original array should not be used after the conversion.
unsafeThawByteArray :: PrimMonad m => ByteArray -> m (MutableByteArray (PrimState m))

-- | Copy a slice of an immutable byte array to a mutable byte array.
copyByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> ByteArray -> Int -> Int -> m ()

-- | Copy a slice of a mutable byte array into another array. The two
--   slices may not overlap.
copyMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> MutableByteArray (PrimState m) -> Int -> Int -> m ()

-- | Copy a slice of a byte array to an unmanaged address. These must not
--   overlap. This function is only available when compiling with GHC 7.8
--   or newer.
copyByteArrayToAddr :: PrimMonad m => Addr -> ByteArray -> Int -> Int -> m ()

-- | Copy a slice of a mutable byte array to an unmanaged address. These
--   must not overlap. This function is only available when compiling with
--   GHC 7.8 or newer.
copyMutableByteArrayToAddr :: PrimMonad m => Addr -> MutableByteArray (PrimState m) -> Int -> Int -> m ()

-- | Copy a slice of a mutable byte array into another, potentially
--   overlapping array.
moveByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> MutableByteArray (PrimState m) -> Int -> Int -> m ()

-- | Fill a slice of a mutable byte array with a value. The offset and
--   length are given in elements of type <tt>a</tt> rather than in bytes.
setByteArray :: (Prim a, PrimMonad m) => MutableByteArray (PrimState m) -> Int -> Int -> a -> m ()

-- | Fill a slice of a mutable byte array with a byte.
fillByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Int -> Word8 -> m ()

-- | Size of the byte array in bytes.
sizeofByteArray :: ByteArray -> Int

-- | Size of the mutable byte array in bytes. This function's behavior is
--   undefined if <a>resizeMutableByteArray</a> is ever called on the
--   mutable byte array given as the argument. Consequently, use of this
--   function is discouraged. Prefer <a>getSizeofMutableByteArray</a>,
--   which ensures correct sequencing in the presence of resizing.
sizeofMutableByteArray :: MutableByteArray s -> Int

-- | Get the size of a byte array in bytes. Unlike
--   <a>sizeofMutableByteArray</a>, this function ensures sequencing in the
--   presence of resizing.
getSizeofMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> m Int

-- | Check if the two arrays refer to the same memory block.
sameMutableByteArray :: MutableByteArray s -> MutableByteArray s -> Bool

-- | Check whether or not the byte array is pinned. Pinned byte arrays
--   cannot be moved by the garbage collector. It is safe to use
--   <a>byteArrayContents</a> on such byte arrays. This function is only
--   available when compiling with GHC 8.2 or newer.
isByteArrayPinned :: ByteArray -> Bool

-- | Check whether or not the mutable byte array is pinned. This function
--   is only available when compiling with GHC 8.2 or newer.
isMutableByteArrayPinned :: MutableByteArray s -> Bool

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> byte arrays allocated by <a>newPinnedByteArray</a> or
--   <a>newAlignedPinnedByteArray</a>.
byteArrayContents :: ByteArray -> Addr

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> byte arrays allocated by <a>newPinnedByteArray</a> or
--   <a>newAlignedPinnedByteArray</a>.
mutableByteArrayContents :: MutableByteArray s -> Addr
instance Data.Typeable.Internal.Typeable s => Data.Data.Data (Data.Primitive.ByteArray.MutableByteArray s)
instance Data.Data.Data Data.Primitive.ByteArray.ByteArray
instance GHC.Show.Show Data.Primitive.ByteArray.ByteArray
instance GHC.Classes.Eq Data.Primitive.ByteArray.ByteArray
instance GHC.Classes.Ord Data.Primitive.ByteArray.ByteArray
instance GHC.Base.Semigroup Data.Primitive.ByteArray.ByteArray
instance GHC.Base.Monoid Data.Primitive.ByteArray.ByteArray
instance GHC.Exts.IsList Data.Primitive.ByteArray.ByteArray


-- | Arrays of unboxed primitive types. The function provided by this
--   module match the behavior of those provided by
--   <tt>Data.Primitive.ByteArray</tt>, and the underlying types and
--   primops that back them are the same. However, the type constructors
--   <a>PrimArray</a> and <a>MutablePrimArray</a> take one additional
--   argument than their respective counterparts <a>ByteArray</a> and
--   <tt>MutableByteArray</tt>. This argument is used to designate the type
--   of element in the array. Consequently, all function this modules
--   accepts length and incides in terms of elements, not bytes.
module Data.Primitive.PrimArray

-- | Arrays of unboxed elements. This accepts types like <a>Double</a>,
--   <a>Char</a>, <a>Int</a>, and <a>Word</a>, as well as their
--   fixed-length variants (<tt>Word8</tt>, <tt>Word16</tt>, etc.). Since
--   the elements are unboxed, a <a>PrimArray</a> is strict in its
--   elements. This differs from the behavior of <tt>Array</tt>, which is
--   lazy in its elements.
data PrimArray a
PrimArray :: ByteArray# -> PrimArray a

-- | Mutable primitive arrays associated with a primitive state token.
--   These can be written to and read from in a monadic context that
--   supports sequencing such as <a>IO</a> or <a>ST</a>. Typically, a
--   mutable primitive array will be built and then convert to an immutable
--   primitive array using <a>unsafeFreezePrimArray</a>. However, it is
--   also acceptable to simply discard a mutable primitive array since it
--   lives in managed memory and will be garbage collected when no longer
--   referenced.
data MutablePrimArray s a
MutablePrimArray :: MutableByteArray# s -> MutablePrimArray s a

-- | Create a new mutable primitive array of the given length. The
--   underlying memory is left uninitialized.
newPrimArray :: forall m a. (PrimMonad m, Prim a) => Int -> m (MutablePrimArray (PrimState m) a)

-- | Resize a mutable primitive array. The new size is given in elements.
--   
--   This will either resize the array in-place or, if not possible,
--   allocate the contents into a new, unpinned array and copy the original
--   array's contents.
--   
--   To avoid undefined behaviour, the original <a>MutablePrimArray</a>
--   shall not be accessed anymore after a <a>resizeMutablePrimArray</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutablePrimArray</a> in case a new <a>MutablePrimArray</a> had to
--   be allocated.
resizeMutablePrimArray :: forall m a. (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> m (MutablePrimArray (PrimState m) a)

-- | Shrink a mutable primitive array. The new size is given in elements.
--   It must be smaller than the old size. The array will be resized in
--   place. This function is only available when compiling with GHC 7.10 or
--   newer.
shrinkMutablePrimArray :: forall m a. (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> m ()
readPrimArray :: (Prim a, PrimMonad m) => MutablePrimArray (PrimState m) a -> Int -> m a

-- | Write an element to the given index.
writePrimArray :: (Prim a, PrimMonad m) => MutablePrimArray (PrimState m) a -> Int -> a -> m ()

-- | Read a primitive value from the primitive array.
indexPrimArray :: forall a. Prim a => PrimArray a -> Int -> a

-- | Convert a mutable byte array to an immutable one without copying. The
--   array should not be modified after the conversion.
unsafeFreezePrimArray :: PrimMonad m => MutablePrimArray (PrimState m) a -> m (PrimArray a)

-- | Convert an immutable array to a mutable one without copying. The
--   original array should not be used after the conversion.
unsafeThawPrimArray :: PrimMonad m => PrimArray a -> m (MutablePrimArray (PrimState m) a)

-- | Copy part of an array into another mutable array.
copyPrimArray :: forall m a. (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> PrimArray a -> Int -> Int -> m ()

-- | Copy part of a mutable array into another mutable array. In the case
--   that the destination and source arrays are the same, the regions may
--   overlap.
copyMutablePrimArray :: forall m a. (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> MutablePrimArray (PrimState m) a -> Int -> Int -> m ()

-- | Copy a slice of an immutable primitive array to an address. The offset
--   and length are given in elements of type <tt>a</tt>. This function
--   assumes that the <a>Prim</a> instance of <tt>a</tt> agrees with the
--   <tt>Storable</tt> instance. This function is only available when
--   building with GHC 7.8 or newer.
copyPrimArrayToPtr :: forall m a. (PrimMonad m, Prim a) => Ptr a -> PrimArray a -> Int -> Int -> m ()

-- | Copy a slice of an immutable primitive array to an address. The offset
--   and length are given in elements of type <tt>a</tt>. This function
--   assumes that the <a>Prim</a> instance of <tt>a</tt> agrees with the
--   <tt>Storable</tt> instance. This function is only available when
--   building with GHC 7.8 or newer.
copyMutablePrimArrayToPtr :: forall m a. (PrimMonad m, Prim a) => Ptr a -> MutablePrimArray (PrimState m) a -> Int -> Int -> m ()

-- | Fill a slice of a mutable primitive array with a value.
setPrimArray :: (Prim a, PrimMonad m) => MutablePrimArray (PrimState m) a -> Int -> Int -> a -> m ()

-- | Check if the two arrays refer to the same memory block.
sameMutablePrimArray :: MutablePrimArray s a -> MutablePrimArray s a -> Bool

-- | Get the size of a mutable primitive array in elements. Unlike
--   <a>sizeofMutablePrimArray</a>, this function ensures sequencing in the
--   presence of resizing.
getSizeofMutablePrimArray :: forall m a. (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> m Int

-- | Size of the mutable primitive array in elements. This function shall
--   not be used on primitive arrays that are an argument to or a result of
--   <a>resizeMutablePrimArray</a> or <a>shrinkMutablePrimArray</a>.
sizeofMutablePrimArray :: forall s a. Prim a => MutablePrimArray s a -> Int

-- | Get the size, in elements, of the primitive array.
sizeofPrimArray :: forall a. Prim a => PrimArray a -> Int

-- | Convert the primitive array to a list.
primArrayToList :: forall a. Prim a => PrimArray a -> [a]
primArrayFromList :: Prim a => [a] -> PrimArray a
primArrayFromListN :: forall a. Prim a => Int -> [a] -> PrimArray a

-- | Lazy right-associated fold over the elements of a <a>PrimArray</a>.
foldrPrimArray :: forall a b. Prim a => (a -> b -> b) -> b -> PrimArray a -> b

-- | Strict right-associated fold over the elements of a <a>PrimArray</a>.
foldrPrimArray' :: forall a b. Prim a => (a -> b -> b) -> b -> PrimArray a -> b

-- | Lazy left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArray :: forall a b. Prim a => (b -> a -> b) -> b -> PrimArray a -> b

-- | Strict left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArray' :: forall a b. Prim a => (b -> a -> b) -> b -> PrimArray a -> b

-- | Strict left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArrayM' :: (Prim a, Monad m) => (b -> a -> m b) -> b -> PrimArray a -> m b

-- | Traverse the primitive array, discarding the results. There is no
--   <a>PrimMonad</a> variant of this function since it would not provide
--   any performance benefit.
traversePrimArray_ :: (Applicative f, Prim a) => (a -> f b) -> PrimArray a -> f ()

-- | Traverse the primitive array with the indices, discarding the results.
--   There is no <a>PrimMonad</a> variant of this function since it would
--   not provide any performance benefit.
itraversePrimArray_ :: (Applicative f, Prim a) => (Int -> a -> f b) -> PrimArray a -> f ()

-- | Map over the elements of a primitive array.
mapPrimArray :: (Prim a, Prim b) => (a -> b) -> PrimArray a -> PrimArray b

-- | Indexed map over the elements of a primitive array.
imapPrimArray :: (Prim a, Prim b) => (Int -> a -> b) -> PrimArray a -> PrimArray b

-- | Generate a primitive array.
generatePrimArray :: Prim a => Int -> (Int -> a) -> PrimArray a

-- | Create a primitive array by copying the element the given number of
--   times.
replicatePrimArray :: Prim a => Int -> a -> PrimArray a

-- | Filter elements of a primitive array according to a predicate.
filterPrimArray :: Prim a => (a -> Bool) -> PrimArray a -> PrimArray a

-- | Map over a primitive array, optionally discarding some elements. This
--   has the same behavior as <tt>Data.Maybe.mapMaybe</tt>.
mapMaybePrimArray :: (Prim a, Prim b) => (a -> Maybe b) -> PrimArray a -> PrimArray b

-- | Traverse a primitive array. The traversal performs all of the
--   applicative effects <i>before</i> forcing the resulting values and
--   writing them to the new primitive array. Consequently:
--   
--   <pre>
--   &gt;&gt;&gt; traversePrimArray (\x -&gt; print x $&gt; bool x undefined (x == 2)) (fromList [1, 2, 3 :: Int])
--   1
--   2
--   3
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   The function <a>traversePrimArrayP</a> always outperforms this
--   function, but it requires a <tt>PrimAffineMonad</tt> constraint, and
--   it forces the values as it performs the effects.
traversePrimArray :: (Applicative f, Prim a, Prim b) => (a -> f b) -> PrimArray a -> f (PrimArray b)

-- | Traverse a primitive array with the index of each element.
itraversePrimArray :: (Applicative f, Prim a, Prim b) => (Int -> a -> f b) -> PrimArray a -> f (PrimArray b)

-- | Generate a primitive array by evaluating the applicative generator
--   function at each index.
generatePrimArrayA :: (Applicative f, Prim a) => Int -> (Int -> f a) -> f (PrimArray a)

-- | Execute the applicative action the given number of times and store the
--   results in a vector.
replicatePrimArrayA :: (Applicative f, Prim a) => Int -> f a -> f (PrimArray a)

-- | Filter the primitive array, keeping the elements for which the monadic
--   predicate evaluates true.
filterPrimArrayA :: (Applicative f, Prim a) => (a -> f Bool) -> PrimArray a -> f (PrimArray a)

-- | Map over the primitive array, keeping the elements for which the
--   applicative predicate provides a <a>Just</a>.
mapMaybePrimArrayA :: (Applicative f, Prim a, Prim b) => (a -> f (Maybe b)) -> PrimArray a -> f (PrimArray b)

-- | Traverse a primitive array. The traversal forces the resulting values
--   and writes them to the new primitive array as it performs the monadic
--   effects. Consequently:
--   
--   <pre>
--   &gt;&gt;&gt; traversePrimArrayP (\x -&gt; print x $&gt; bool x undefined (x == 2)) (fromList [1, 2, 3 :: Int])
--   1
--   2
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   In many situations, <a>traversePrimArrayP</a> can replace
--   <a>traversePrimArray</a>, changing the strictness characteristics of
--   the traversal but typically improving the performance. Consider the
--   following short-circuiting traversal:
--   
--   <pre>
--   incrPositiveA :: PrimArray Int -&gt; Maybe (PrimArray Int)
--   incrPositiveA xs = traversePrimArray (\x -&gt; bool Nothing (Just (x + 1)) (x &gt; 0)) xs
--   </pre>
--   
--   This can be rewritten using <a>traversePrimArrayP</a>. To do this, we
--   must change the traversal context to <tt>MaybeT (ST s)</tt>, which has
--   a <a>PrimMonad</a> instance:
--   
--   <pre>
--   incrPositiveB :: PrimArray Int -&gt; Maybe (PrimArray Int)
--   incrPositiveB xs = runST $ runMaybeT $ traversePrimArrayP
--     (\x -&gt; bool (MaybeT (return Nothing)) (MaybeT (return (Just (x + 1)))) (x &gt; 0))
--     xs
--   </pre>
--   
--   Benchmarks demonstrate that the second implementation runs 150 times
--   faster than the first. It also results in fewer allocations.
traversePrimArrayP :: (PrimMonad m, Prim a, Prim b) => (a -> m b) -> PrimArray a -> m (PrimArray b)

-- | Traverse a primitive array with the indices. The traversal forces the
--   resulting values and writes them to the new primitive array as it
--   performs the monadic effects.
itraversePrimArrayP :: (Prim a, Prim b, PrimMonad m) => (Int -> a -> m b) -> PrimArray a -> m (PrimArray b)

-- | Generate a primitive array by evaluating the monadic generator
--   function at each index.
generatePrimArrayP :: (PrimMonad m, Prim a) => Int -> (Int -> m a) -> m (PrimArray a)

-- | Execute the monadic action the given number of times and store the
--   results in a primitive array.
replicatePrimArrayP :: (PrimMonad m, Prim a) => Int -> m a -> m (PrimArray a)

-- | Filter the primitive array, keeping the elements for which the monadic
--   predicate evaluates true.
filterPrimArrayP :: (PrimMonad m, Prim a) => (a -> m Bool) -> PrimArray a -> m (PrimArray a)

-- | Map over the primitive array, keeping the elements for which the
--   monadic predicate provides a <a>Just</a>.
mapMaybePrimArrayP :: (PrimMonad m, Prim a, Prim b) => (a -> m (Maybe b)) -> PrimArray a -> m (PrimArray b)
instance (GHC.Classes.Eq a, Data.Primitive.Types.Prim a) => GHC.Classes.Eq (Data.Primitive.PrimArray.PrimArray a)
instance (GHC.Classes.Ord a, Data.Primitive.Types.Prim a) => GHC.Classes.Ord (Data.Primitive.PrimArray.PrimArray a)
instance Data.Primitive.Types.Prim a => GHC.Exts.IsList (Data.Primitive.PrimArray.PrimArray a)
instance (GHC.Show.Show a, Data.Primitive.Types.Prim a) => GHC.Show.Show (Data.Primitive.PrimArray.PrimArray a)
instance GHC.Base.Semigroup (Data.Primitive.PrimArray.PrimArray a)
instance GHC.Base.Monoid (Data.Primitive.PrimArray.PrimArray a)


-- | Primitive operations on machine addresses
module Data.Primitive.Ptr

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data Ptr a
Ptr :: Addr# -> Ptr a

-- | The constant <a>nullPtr</a> contains a distinguished value of
--   <a>Ptr</a> that is not associated with a valid memory location.
nullPtr :: () => Ptr a

-- | Offset a pointer by the given number of elements.
advancePtr :: forall a. Prim a => Ptr a -> Int -> Ptr a

-- | Subtract a pointer from another pointer. The result represents the
--   number of elements of type <tt>a</tt> that fit in the contiguous
--   memory range bounded by these two pointers.
subtractPtr :: forall a. Prim a => Ptr a -> Ptr a -> Int

-- | Read a value from a memory position given by a pointer and an offset.
--   The memory block the address refers to must be immutable. The offset
--   is in elements of type <tt>a</tt> rather than in bytes.
indexOffPtr :: Prim a => Ptr a -> Int -> a

-- | Read a value from a memory position given by an address and an offset.
--   The offset is in elements of type <tt>a</tt> rather than in bytes.
readOffPtr :: (Prim a, PrimMonad m) => Ptr a -> Int -> m a

-- | Write a value to a memory position given by an address and an offset.
--   The offset is in elements of type <tt>a</tt> rather than in bytes.
writeOffPtr :: (Prim a, PrimMonad m) => Ptr a -> Int -> a -> m ()

-- | Copy the given number of elements from the second <a>Ptr</a> to the
--   first. The areas may not overlap.
copyPtr :: forall m a. (PrimMonad m, Prim a) => Ptr a -> Ptr a -> Int -> m ()

-- | Copy the given number of elements from the second <a>Ptr</a> to the
--   first. The areas may overlap.
movePtr :: forall m a. (PrimMonad m, Prim a) => Ptr a -> Ptr a -> Int -> m ()

-- | Fill a memory block with the given value. The length is in elements of
--   type <tt>a</tt> rather than in bytes.
setPtr :: (Prim a, PrimMonad m) => Ptr a -> Int -> a -> m ()

-- | Copy from a pointer to a mutable primitive array. The offset and
--   length are given in elements of type <tt>a</tt>. This function is only
--   available when building with GHC 7.8 or newer.
copyPtrToMutablePrimArray :: forall m a. (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> Ptr a -> Int -> m ()


-- | Primitive operations on machine addresses
module Data.Primitive.Addr

-- | A machine address
data Addr
Addr :: Addr# -> Addr

-- | The null address
nullAddr :: Addr

-- | Offset an address by the given number of bytes
plusAddr :: Addr -> Int -> Addr
infixl 6 `plusAddr`

-- | Distance in bytes between two addresses. The result is only valid if
--   the difference fits in an <a>Int</a>.
minusAddr :: Addr -> Addr -> Int
infixl 6 `minusAddr`

-- | The remainder of the address and the integer.
remAddr :: Addr -> Int -> Int
infixl 7 `remAddr`

-- | Read a value from a memory position given by an address and an offset.
--   The memory block the address refers to must be immutable. The offset
--   is in elements of type <tt>a</tt> rather than in bytes.
indexOffAddr :: Prim a => Addr -> Int -> a

-- | Read a value from a memory position given by an address and an offset.
--   The offset is in elements of type <tt>a</tt> rather than in bytes.
readOffAddr :: (Prim a, PrimMonad m) => Addr -> Int -> m a

-- | Write a value to a memory position given by an address and an offset.
--   The offset is in elements of type <tt>a</tt> rather than in bytes.
writeOffAddr :: (Prim a, PrimMonad m) => Addr -> Int -> a -> m ()

-- | Copy the given number of bytes from the second <a>Addr</a> to the
--   first. The areas may not overlap.
copyAddr :: PrimMonad m => Addr -> Addr -> Int -> m ()

-- | Copy the given number of bytes from the <a>Addr</a> to the
--   <a>MutableByteArray</a>. The areas may not overlap. This function is
--   only available when compiling with GHC 7.8 or newer.
copyAddrToByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Addr -> Int -> m ()

-- | Copy the given number of bytes from the second <a>Addr</a> to the
--   first. The areas may overlap.
moveAddr :: PrimMonad m => Addr -> Addr -> Int -> m ()

-- | Fill a memory block of with the given value. The length is in elements
--   of type <tt>a</tt> rather than in bytes.
setAddr :: (Prim a, PrimMonad m) => Addr -> Int -> a -> m ()

-- | Convert an <a>Addr</a> to an <a>Int</a>.
addrToInt :: Addr -> Int


-- | GHC contains three general classes of value types:
--   
--   <ol>
--   <li>Unboxed types: values are machine values made up of fixed numbers
--   of bytes</li>
--   <li>Unlifted types: values are pointers, but strictly evaluated</li>
--   <li>Lifted types: values are pointers, lazily evaluated</li>
--   </ol>
--   
--   The first category can be stored in a <a>ByteArray</a>, and this
--   allows types in category 3 that are simple wrappers around category 1
--   types to be stored more efficiently using a <a>ByteArray</a>. This
--   module provides the same facility for category 2 types.
--   
--   GHC has two primitive types, <a>ArrayArray#</a> and
--   <a>MutableArrayArray#</a>. These are arrays of pointers, but of
--   category 2 values, so they are known to not be bottom. This allows
--   types that are wrappers around such types to be stored in an array
--   without an extra level of indirection.
--   
--   The way that the <a>ArrayArray#</a> API works is that one can read and
--   write <a>ArrayArray#</a> values to the positions. This works because
--   all category 2 types share a uniform representation, unlike unboxed
--   values which are represented by varying (by type) numbers of bytes.
--   However, using the this makes the internal API very unsafe to use, as
--   one has to coerce values to and from <a>ArrayArray#</a>.
--   
--   The API presented by this module is more type safe.
--   <a>UnliftedArray</a> and <a>MutableUnliftedArray</a> are parameterized
--   by the type of arrays they contain, and the coercions necessary are
--   abstracted into a class, <a>PrimUnlifted</a>, of things that are
--   eligible to be stored.
module Data.Primitive.UnliftedArray

-- | Immutable arrays that efficiently store types that are simple wrappers
--   around unlifted primitive types. The values of the unlifted type are
--   stored directly, eliminating a layer of indirection.
data UnliftedArray e
UnliftedArray :: ArrayArray# -> UnliftedArray e

-- | Mutable arrays that efficiently store types that are simple wrappers
--   around unlifted primitive types. The values of the unlifted type are
--   stored directly, eliminating a layer of indirection.
data MutableUnliftedArray s e
MutableUnliftedArray :: MutableArrayArray# s -> MutableUnliftedArray s e

-- | Classifies the types that are able to be stored in
--   <a>UnliftedArray</a> and <a>MutableUnliftedArray</a>. These should be
--   types that are just liftings of the unlifted pointer types, so that
--   their internal contents can be safely coerced into an
--   <a>ArrayArray#</a>.
class PrimUnlifted a
toArrayArray# :: PrimUnlifted a => a -> ArrayArray#
fromArrayArray# :: PrimUnlifted a => ArrayArray# -> a

-- | Creates a new <a>MutableUnliftedArray</a>. This function is unsafe
--   because it initializes all elements of the array as pointers to the
--   array itself. Attempting to read one of these elements before writing
--   to it is in effect an unsafe coercion from the
--   <tt>MutableUnliftedArray s a</tt> to the element type.
unsafeNewUnliftedArray :: PrimMonad m => Int -> m (MutableUnliftedArray (PrimState m) a)

-- | Creates a new <a>MutableUnliftedArray</a> with the specified value as
--   initial contents. This is slower than <a>unsafeNewUnliftedArray</a>,
--   but safer.
newUnliftedArray :: (PrimMonad m, PrimUnlifted a) => Int -> a -> m (MutableUnliftedArray (PrimState m) a)

-- | Sets all the positions in an unlifted array to the designated value.
setUnliftedArray :: (PrimMonad m, PrimUnlifted a) => MutableUnliftedArray (PrimState m) a -> a -> m ()

-- | Yields the length of an <a>UnliftedArray</a>.
sizeofUnliftedArray :: UnliftedArray e -> Int

-- | Yields the length of a <a>MutableUnliftedArray</a>.
sizeofMutableUnliftedArray :: MutableUnliftedArray s e -> Int

-- | Gets the value at the specified position of a
--   <a>MutableUnliftedArray</a>.
readUnliftedArray :: (PrimMonad m, PrimUnlifted a) => MutableUnliftedArray (PrimState m) a -> Int -> m a

-- | Sets the value at the specified position of a
--   <a>MutableUnliftedArray</a>.
writeUnliftedArray :: (PrimMonad m, PrimUnlifted a) => MutableUnliftedArray (PrimState m) a -> Int -> a -> m ()

-- | Gets the value at the specified position of an <a>UnliftedArray</a>.
indexUnliftedArray :: PrimUnlifted a => UnliftedArray a -> Int -> a

-- | Gets the value at the specified position of an <a>UnliftedArray</a>.
--   The purpose of the <a>Monad</a> is to allow for being eager in the
--   <a>UnliftedArray</a> value without having to introduce a data
--   dependency directly on the result value.
--   
--   It should be noted that this is not as much of a problem as with a
--   normal <a>Array</a>, because elements of an <a>UnliftedArray</a> are
--   guaranteed to not be exceptional. This function is provided in case it
--   is more desirable than being strict in the result value.
indexUnliftedArrayM :: (PrimUnlifted a, Monad m) => UnliftedArray a -> Int -> m a

-- | Freezes a <a>MutableUnliftedArray</a>, yielding an
--   <a>UnliftedArray</a>. This simply marks the array as frozen in place,
--   so it should only be used when no further modifications to the mutable
--   array will be performed.
unsafeFreezeUnliftedArray :: PrimMonad m => MutableUnliftedArray (PrimState m) a -> m (UnliftedArray a)

-- | Freezes a portion of a <a>MutableUnliftedArray</a>, yielding an
--   <a>UnliftedArray</a>. This operation is safe, in that it copies the
--   frozen portion, and the existing mutable array may still be used
--   afterward.
freezeUnliftedArray :: PrimMonad m => MutableUnliftedArray (PrimState m) a -> Int -> Int -> m (UnliftedArray a)

-- | Thaws a portion of an <a>UnliftedArray</a>, yielding a
--   <a>MutableUnliftedArray</a>. This copies the thawed portion, so
--   mutations will not affect the original array.
thawUnliftedArray :: PrimMonad m => UnliftedArray a -> Int -> Int -> m (MutableUnliftedArray (PrimState m) a)

-- | Execute a stateful computation and freeze the resulting array.
runUnliftedArray :: (forall s. ST s (MutableUnliftedArray s a)) -> UnliftedArray a

-- | Determines whether two <a>MutableUnliftedArray</a> values are the
--   same. This is object/pointer identity, not based on the contents.
sameMutableUnliftedArray :: MutableUnliftedArray s a -> MutableUnliftedArray s a -> Bool

-- | Copies the contents of an immutable array into a mutable array.
copyUnliftedArray :: PrimMonad m => MutableUnliftedArray (PrimState m) a -> Int -> UnliftedArray a -> Int -> Int -> m ()

-- | Copies the contents of one mutable array into another.
copyMutableUnliftedArray :: PrimMonad m => MutableUnliftedArray (PrimState m) a -> Int -> MutableUnliftedArray (PrimState m) a -> Int -> Int -> m ()

-- | Creates a copy of a portion of an <a>UnliftedArray</a>
cloneUnliftedArray :: UnliftedArray a -> Int -> Int -> UnliftedArray a

-- | Creates a new <a>MutableUnliftedArray</a> containing a copy of a
--   portion of another mutable array.
cloneMutableUnliftedArray :: PrimMonad m => MutableUnliftedArray (PrimState m) a -> Int -> Int -> m (MutableUnliftedArray (PrimState m) a)

-- | Convert the unlifted array to a list.
unliftedArrayToList :: PrimUnlifted a => UnliftedArray a -> [a]
unliftedArrayFromList :: PrimUnlifted a => [a] -> UnliftedArray a
unliftedArrayFromListN :: forall a. PrimUnlifted a => Int -> [a] -> UnliftedArray a

-- | Lazy right-associated fold over the elements of an
--   <a>UnliftedArray</a>.
foldrUnliftedArray :: forall a b. PrimUnlifted a => (a -> b -> b) -> b -> UnliftedArray a -> b

-- | Strict right-associated fold over the elements of an 'UnliftedArray.
foldrUnliftedArray' :: forall a b. PrimUnlifted a => (a -> b -> b) -> b -> UnliftedArray a -> b

-- | Lazy left-associated fold over the elements of an
--   <a>UnliftedArray</a>.
foldlUnliftedArray :: forall a b. PrimUnlifted a => (b -> a -> b) -> b -> UnliftedArray a -> b

-- | Strict left-associated fold over the elements of an
--   <a>UnliftedArray</a>.
foldlUnliftedArray' :: forall a b. PrimUnlifted a => (b -> a -> b) -> b -> UnliftedArray a -> b

-- | Map over the elements of an <a>UnliftedArray</a>.
mapUnliftedArray :: (PrimUnlifted a, PrimUnlifted b) => (a -> b) -> UnliftedArray a -> UnliftedArray b
instance Data.Primitive.UnliftedArray.PrimUnlifted (Data.Primitive.UnliftedArray.UnliftedArray e)
instance Data.Primitive.UnliftedArray.PrimUnlifted (Data.Primitive.UnliftedArray.MutableUnliftedArray s e)
instance Data.Primitive.UnliftedArray.PrimUnlifted (Data.Primitive.Array.Array a)
instance Data.Primitive.UnliftedArray.PrimUnlifted (Data.Primitive.Array.MutableArray s a)
instance Data.Primitive.UnliftedArray.PrimUnlifted Data.Primitive.ByteArray.ByteArray
instance Data.Primitive.UnliftedArray.PrimUnlifted (Data.Primitive.ByteArray.MutableByteArray s)
instance Data.Primitive.UnliftedArray.PrimUnlifted (Data.Primitive.PrimArray.PrimArray a)
instance Data.Primitive.UnliftedArray.PrimUnlifted (Data.Primitive.PrimArray.MutablePrimArray s a)
instance Data.Primitive.UnliftedArray.PrimUnlifted (Data.Primitive.SmallArray.SmallArray a)
instance Data.Primitive.UnliftedArray.PrimUnlifted (Data.Primitive.SmallArray.SmallMutableArray s a)
instance Data.Primitive.UnliftedArray.PrimUnlifted (Data.Primitive.MutVar.MutVar s a)
instance Data.Primitive.UnliftedArray.PrimUnlifted (GHC.MVar.MVar a)
instance Data.Primitive.UnliftedArray.PrimUnlifted (GHC.Conc.Sync.TVar a)
instance Data.Primitive.UnliftedArray.PrimUnlifted (GHC.Stable.StablePtr a)
instance Data.Primitive.UnliftedArray.PrimUnlifted (GHC.Weak.Weak a)
instance Data.Primitive.UnliftedArray.PrimUnlifted GHC.Conc.Sync.ThreadId
instance (GHC.Classes.Eq a, Data.Primitive.UnliftedArray.PrimUnlifted a) => GHC.Classes.Eq (Data.Primitive.UnliftedArray.UnliftedArray a)
instance (GHC.Classes.Ord a, Data.Primitive.UnliftedArray.PrimUnlifted a) => GHC.Classes.Ord (Data.Primitive.UnliftedArray.UnliftedArray a)
instance (GHC.Show.Show a, Data.Primitive.UnliftedArray.PrimUnlifted a) => GHC.Show.Show (Data.Primitive.UnliftedArray.UnliftedArray a)
instance Data.Primitive.UnliftedArray.PrimUnlifted a => GHC.Base.Semigroup (Data.Primitive.UnliftedArray.UnliftedArray a)
instance Data.Primitive.UnliftedArray.PrimUnlifted a => GHC.Base.Monoid (Data.Primitive.UnliftedArray.UnliftedArray a)
instance Data.Primitive.UnliftedArray.PrimUnlifted a => GHC.Exts.IsList (Data.Primitive.UnliftedArray.UnliftedArray a)
instance GHC.Classes.Eq (Data.Primitive.UnliftedArray.MutableUnliftedArray s a)


-- | Reexports all primitive operations
module Data.Primitive
