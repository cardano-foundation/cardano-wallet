-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Low-level networking interface
--   
--   This package provides a low-level networking interface.
--   
--   In network-2.6 the <tt>Network.URI</tt> module was split off into its
--   own package, network-uri-2.6. If you're using the <tt>Network.URI</tt>
--   module you can automatically get it from the right package by adding
--   this to your .cabal file:
--   
--   <pre>
--   library
--     build-depends: network-uri-flag
--   </pre>
@package network
@version 2.8.0.0


-- | A module containing semi-public <a>Socket</a> internals. Modules which
--   extend the <a>Socket</a> module will need to use this module while
--   ideally most users will be able to make do with the public interface.
module Network.Socket.Internal

-- | The raw network byte order number is read using host byte order.
--   Therefore on little-endian architectures the byte order is swapped.
--   For example <tt>127.0.0.1</tt> is represented as <tt>0x0100007f</tt>
--   on little-endian hosts and as <tt>0x7f000001</tt> on big-endian hosts.
--   
--   For direct manipulation prefer <a>hostAddressToTuple</a> and
--   <a>tupleToHostAddress</a>.
type HostAddress = Word32

-- | Independent of endianness. For example <tt>::1</tt> is stored as
--   <tt>(0, 0, 0, 1)</tt>.
--   
--   For direct manipulation prefer <a>hostAddress6ToTuple</a> and
--   <a>tupleToHostAddress6</a>.
type HostAddress6 = (Word32, Word32, Word32, Word32)
type FlowInfo = Word32
type ScopeID = Word32

-- | Use the <tt>Num</tt> instance (i.e. use a literal) to create a
--   <tt>PortNumber</tt> value.
--   
--   <pre>
--   &gt;&gt;&gt; 1 :: PortNumber
--   1
--   
--   &gt;&gt;&gt; read "1" :: PortNumber
--   1
--   
--   &gt;&gt;&gt; show (12345 :: PortNumber)
--   "12345"
--   
--   &gt;&gt;&gt; 50000 &lt; (51000 :: PortNumber)
--   True
--   
--   &gt;&gt;&gt; 50000 &lt; (52000 :: PortNumber)
--   True
--   
--   &gt;&gt;&gt; 50000 + (10000 :: PortNumber)
--   60000
--   </pre>
newtype PortNumber
PortNum :: Word16 -> PortNumber

-- | The existence of a constructor does not necessarily imply that that
--   socket address type is supported on your system: see
--   <a>isSupportedSockAddr</a>.
data SockAddr
SockAddrInet :: PortNumber -> HostAddress -> SockAddr
SockAddrInet6 :: PortNumber -> FlowInfo -> HostAddress6 -> ScopeID -> SockAddr
SockAddrUnix :: String -> SockAddr

-- | <i>Deprecated: This will be removed in 3.0</i>
SockAddrCan :: Int32 -> SockAddr

-- | Read a <a>SockAddr</a> from the given memory location.
peekSockAddr :: Ptr SockAddr -> IO SockAddr

-- | Write the given <a>SockAddr</a> to the given memory location.
pokeSockAddr :: Ptr a -> SockAddr -> IO ()

-- | Computes the storage requirements (in bytes) of the given
--   <a>SockAddr</a>. This function differs from <a>sizeOf</a> in that the
--   value of the argument <i>is</i> used.
sizeOfSockAddr :: SockAddr -> Int

-- | Computes the storage requirements (in bytes) required for a
--   <a>SockAddr</a> with the given <a>Family</a>.
sizeOfSockAddrByFamily :: Family -> Int

-- | Use a <a>SockAddr</a> with a function requiring a pointer to a
--   <a>SockAddr</a> and the length of that <a>SockAddr</a>.
withSockAddr :: SockAddr -> (Ptr SockAddr -> Int -> IO a) -> IO a

-- | Create a new <a>SockAddr</a> for use with a function requiring a
--   pointer to a <a>SockAddr</a> and the length of that <a>SockAddr</a>.
withNewSockAddr :: Family -> (Ptr SockAddr -> Int -> IO a) -> IO a

-- | Address families.
--   
--   A constructor being present here does not mean it is supported by the
--   operating system: see <a>isSupportedFamily</a>.
data Family
AF_UNSPEC :: Family
AF_UNIX :: Family
AF_INET :: Family
AF_INET6 :: Family
AF_IMPLINK :: Family
AF_PUP :: Family
AF_CHAOS :: Family
AF_NS :: Family
AF_NBS :: Family
AF_ECMA :: Family
AF_DATAKIT :: Family
AF_CCITT :: Family
AF_SNA :: Family
AF_DECnet :: Family
AF_DLI :: Family
AF_LAT :: Family
AF_HYLINK :: Family
AF_APPLETALK :: Family
AF_ROUTE :: Family
AF_NETBIOS :: Family
AF_NIT :: Family
AF_802 :: Family
AF_ISO :: Family
AF_OSI :: Family
AF_NETMAN :: Family
AF_X25 :: Family
AF_AX25 :: Family
AF_OSINET :: Family
AF_GOSSIP :: Family
AF_IPX :: Family
Pseudo_AF_XTP :: Family
AF_CTF :: Family
AF_WAN :: Family
AF_SDL :: Family
AF_NETWARE :: Family
AF_NDD :: Family
AF_INTF :: Family
AF_COIP :: Family
AF_CNT :: Family
Pseudo_AF_RTIP :: Family
Pseudo_AF_PIP :: Family
AF_SIP :: Family
AF_ISDN :: Family
Pseudo_AF_KEY :: Family
AF_NATM :: Family
AF_ARP :: Family
Pseudo_AF_HDRCMPLT :: Family
AF_ENCAP :: Family
AF_LINK :: Family
AF_RAW :: Family
AF_RIF :: Family
AF_NETROM :: Family
AF_BRIDGE :: Family
AF_ATMPVC :: Family
AF_ROSE :: Family
AF_NETBEUI :: Family
AF_SECURITY :: Family
AF_PACKET :: Family
AF_ASH :: Family
AF_ECONET :: Family
AF_ATMSVC :: Family
AF_IRDA :: Family
AF_PPPOX :: Family
AF_WANPIPE :: Family
AF_BLUETOOTH :: Family
AF_CAN :: Family

-- | Throw an <a>IOError</a> corresponding to the current socket error.
throwSocketError :: String -> IO a

-- | Like <a>throwSocketError</a>, but the error code is supplied as an
--   argument.
--   
--   On Windows, do not use errno. Use a system error code instead.
throwSocketErrorCode :: String -> CInt -> IO a

-- | Throw an <a>IOError</a> corresponding to the current socket error if
--   the IO action returns a result of <tt>-1</tt>. Discards the result of
--   the IO action after error handling.
throwSocketErrorIfMinus1_ :: (Eq a, Num a) => String -> IO a -> IO ()

-- | Throw an <a>IOError</a> corresponding to the current socket error if
--   the IO action returns a result of <tt>-1</tt>, but retries in case of
--   an interrupted operation.
throwSocketErrorIfMinus1Retry :: (Eq a, Num a) => String -> IO a -> IO a

-- | Throw an <a>IOError</a> corresponding to the current socket error if
--   the IO action returns a result of <tt>-1</tt>, but retries in case of
--   an interrupted operation. Discards the result of the IO action after
--   error handling.
throwSocketErrorIfMinus1Retry_ :: (Eq a, Num a) => String -> IO a -> IO ()

-- | Throw an <a>IOError</a> corresponding to the current socket error if
--   the IO action returns a result of <tt>-1</tt>, but retries in case of
--   an interrupted operation. Checks for operations that would block and
--   executes an alternative action before retrying in that case.
throwSocketErrorIfMinus1RetryMayBlock :: (Eq a, Num a) => String -> IO b -> IO a -> IO a

-- | Like <a>throwSocketErrorIfMinus1Retry</a>, but if the action fails
--   with <tt>EWOULDBLOCK</tt> or similar, wait for the socket to be
--   read-ready, and try again.
throwSocketErrorWaitRead :: (Eq a, Num a) => Socket -> String -> IO a -> IO a

-- | Like <a>throwSocketErrorIfMinus1Retry</a>, but if the action fails
--   with <tt>EWOULDBLOCK</tt> or similar, wait for the socket to be
--   write-ready, and try again.
throwSocketErrorWaitWrite :: (Eq a, Num a) => Socket -> String -> IO a -> IO a

-- | With older versions of the <tt>network</tt> library (version 2.6.0.2
--   or earlier) on Windows operating systems, the networking subsystem
--   must be initialised using <a>withSocketsDo</a> before any networking
--   operations can be used. eg.
--   
--   <pre>
--   main = withSocketsDo $ do {...}
--   </pre>
--   
--   It is fine to nest calls to <a>withSocketsDo</a>, and to perform
--   networking operations after <a>withSocketsDo</a> has returned.
--   
--   In newer versions of the <tt>network</tt> library (version v2.6.1.0 or
--   later) it is only necessary to call <a>withSocketsDo</a> if you are
--   calling the <a>MkSocket</a> constructor directly. However, for
--   compatibility with older versions on Windows, it is good practice to
--   always call <a>withSocketsDo</a> (it's very cheap).
withSocketsDo :: IO a -> IO a

-- | Zero a structure.
zeroMemory :: Ptr a -> CSize -> IO ()


-- | This is the main module of the network package supposed to be used
--   with either <a>Network.Socket.ByteString</a> or
--   <a>Network.Socket.ByteString.Lazy</a> for sending/receiving.
--   
--   Here are two minimal example programs using the TCP/IP protocol: a
--   server that echoes all data that it receives back (servicing only one
--   client) and a client using it.
--   
--   <pre>
--   -- Echo server program
--   module Main (main) where
--   
--   import Control.Concurrent (forkFinally)
--   import qualified Control.Exception as E
--   import Control.Monad (unless, forever, void)
--   import qualified Data.ByteString as S
--   import Network.Socket hiding (recv)
--   import Network.Socket.ByteString (recv, sendAll)
--   
--   main :: IO ()
--   main = withSocketsDo $ do
--       addr &lt;- resolve "3000"
--       E.bracket (open addr) close loop
--     where
--       resolve port = do
--           let hints = defaultHints {
--                   addrFlags = [AI_PASSIVE]
--                 , addrSocketType = Stream
--                 }
--           addr:_ &lt;- getAddrInfo (Just hints) Nothing (Just port)
--           return addr
--       open addr = do
--           sock &lt;- socket (addrFamily addr) (addrSocketType addr) (addrProtocol addr)
--           setSocketOption sock ReuseAddr 1
--           bind sock (addrAddress addr)
--           -- If the prefork technique is not used,
--           -- set CloseOnExec for the security reasons.
--           let fd = fdSocket sock
--           setCloseOnExecIfNeeded fd
--           listen sock 10
--           return sock
--       loop sock = forever $ do
--           (conn, peer) &lt;- accept sock
--           putStrLn $ "Connection from " ++ show peer
--           void $ forkFinally (talk conn) (\_ -&gt; close conn)
--       talk conn = do
--           msg &lt;- recv conn 1024
--           unless (S.null msg) $ do
--             sendAll conn msg
--             talk conn
--   </pre>
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   -- Echo client program
--   module Main (main) where
--   
--   import qualified Control.Exception as E
--   import qualified Data.ByteString.Char8 as C
--   import Network.Socket hiding (recv)
--   import Network.Socket.ByteString (recv, sendAll)
--   
--   main :: IO ()
--   main = withSocketsDo $ do
--       addr &lt;- resolve "127.0.0.1" "3000"
--       E.bracket (open addr) close talk
--     where
--       resolve host port = do
--           let hints = defaultHints { addrSocketType = Stream }
--           addr:_ &lt;- getAddrInfo (Just hints) (Just host) (Just port)
--           return addr
--       open addr = do
--           sock &lt;- socket (addrFamily addr) (addrSocketType addr) (addrProtocol addr)
--           connect sock $ addrAddress addr
--           return sock
--       talk sock = do
--           sendAll sock "Hello, world!"
--           msg &lt;- recv sock 1024
--           putStr "Received: "
--           C.putStrLn msg
--   </pre>
--   
--   The proper programming model is that one <a>Socket</a> is handled by a
--   single thread. If multiple threads use one <a>Socket</a> concurrently,
--   unexpected things would happen. There is one exception for multiple
--   threads vs a single <a>Socket</a>: one thread reads data from a
--   <a>Socket</a> only and the other thread writes data to the
--   <a>Socket</a> only.
module Network.Socket

-- | With older versions of the <tt>network</tt> library (version 2.6.0.2
--   or earlier) on Windows operating systems, the networking subsystem
--   must be initialised using <a>withSocketsDo</a> before any networking
--   operations can be used. eg.
--   
--   <pre>
--   main = withSocketsDo $ do {...}
--   </pre>
--   
--   It is fine to nest calls to <a>withSocketsDo</a>, and to perform
--   networking operations after <a>withSocketsDo</a> has returned.
--   
--   In newer versions of the <tt>network</tt> library (version v2.6.1.0 or
--   later) it is only necessary to call <a>withSocketsDo</a> if you are
--   calling the <a>MkSocket</a> constructor directly. However, for
--   compatibility with older versions on Windows, it is good practice to
--   always call <a>withSocketsDo</a> (it's very cheap).
withSocketsDo :: IO a -> IO a

-- | Resolve a host or service name to one or more addresses. The
--   <a>AddrInfo</a> values that this function returns contain
--   <a>SockAddr</a> values that you can pass directly to <a>connect</a> or
--   <a>bind</a>.
--   
--   This function is protocol independent. It can return both IPv4 and
--   IPv6 address information.
--   
--   The <a>AddrInfo</a> argument specifies the preferred query behaviour,
--   socket options, or protocol. You can override these conveniently using
--   Haskell's record update syntax on <a>defaultHints</a>, for example as
--   follows:
--   
--   <pre>
--   &gt;&gt;&gt; let hints = defaultHints { addrFlags = [AI_NUMERICHOST], addrSocketType = Stream }
--   </pre>
--   
--   You must provide a <a>Just</a> value for at least one of the
--   <a>HostName</a> or <a>ServiceName</a> arguments. <a>HostName</a> can
--   be either a numeric network address (dotted quad for IPv4,
--   colon-separated hex for IPv6) or a hostname. In the latter case, its
--   addresses will be looked up unless <a>AI_NUMERICHOST</a> is specified
--   as a hint. If you do not provide a <a>HostName</a> value <i>and</i> do
--   not set <a>AI_PASSIVE</a> as a hint, network addresses in the result
--   will contain the address of the loopback interface.
--   
--   If the query fails, this function throws an IO exception instead of
--   returning an empty list. Otherwise, it returns a non-empty list of
--   <a>AddrInfo</a> values.
--   
--   There are several reasons why a query might result in several values.
--   For example, the queried-for host could be multihomed, or the service
--   might be available via several protocols.
--   
--   Note: the order of arguments is slightly different to that defined for
--   <tt>getaddrinfo</tt> in RFC 2553. The <a>AddrInfo</a> parameter comes
--   first to make partial application easier.
--   
--   <pre>
--   &gt;&gt;&gt; addr:_ &lt;- getAddrInfo (Just hints) (Just "127.0.0.1") (Just "http")
--   
--   &gt;&gt;&gt; addrAddress addr
--   127.0.0.1:80
--   </pre>
getAddrInfo :: Maybe AddrInfo -> Maybe HostName -> Maybe ServiceName -> IO [AddrInfo]

-- | Either a host name e.g., <tt>"haskell.org"</tt> or a numeric host
--   address string consisting of a dotted decimal IPv4 address or an IPv6
--   address e.g., <tt>"192.168.0.1"</tt>.
type HostName = String
type ServiceName = String
data AddrInfo
AddrInfo :: [AddrInfoFlag] -> Family -> SocketType -> ProtocolNumber -> SockAddr -> Maybe String -> AddrInfo
[addrFlags] :: AddrInfo -> [AddrInfoFlag]
[addrFamily] :: AddrInfo -> Family
[addrSocketType] :: AddrInfo -> SocketType
[addrProtocol] :: AddrInfo -> ProtocolNumber
[addrAddress] :: AddrInfo -> SockAddr
[addrCanonName] :: AddrInfo -> Maybe String

-- | Default hints for address lookup with <a>getAddrInfo</a>. The values
--   of the <a>addrAddress</a> and <a>addrCanonName</a> fields are
--   <a>undefined</a>, and are never inspected by <a>getAddrInfo</a>.
--   
--   <pre>
--   &gt;&gt;&gt; addrFlags defaultHints
--   []
--   
--   &gt;&gt;&gt; addrFamily defaultHints
--   AF_UNSPEC
--   
--   &gt;&gt;&gt; addrSocketType defaultHints
--   NoSocketType
--   
--   &gt;&gt;&gt; addrProtocol defaultHints
--   0
--   </pre>
defaultHints :: AddrInfo

-- | Flags that control the querying behaviour of <a>getAddrInfo</a>. For
--   more information, see
--   <a>https://tools.ietf.org/html/rfc3493#page-25</a>
data AddrInfoFlag

-- | The list of returned <a>AddrInfo</a> values will only contain IPv4
--   addresses if the local system has at least one IPv4 interface
--   configured, and likewise for IPv6. (Only some platforms support this.)
AI_ADDRCONFIG :: AddrInfoFlag

-- | If <a>AI_ALL</a> is specified, return all matching IPv6 and IPv4
--   addresses. Otherwise, this flag has no effect. (Only some platforms
--   support this.)
AI_ALL :: AddrInfoFlag

-- | The <a>addrCanonName</a> field of the first returned <a>AddrInfo</a>
--   will contain the "canonical name" of the host.
AI_CANONNAME :: AddrInfoFlag

-- | The <a>HostName</a> argument <i>must</i> be a numeric address in
--   string form, and network name lookups will not be attempted.
AI_NUMERICHOST :: AddrInfoFlag

-- | The <a>ServiceName</a> argument <i>must</i> be a port number in string
--   form, and service name lookups will not be attempted. (Only some
--   platforms support this.)
AI_NUMERICSERV :: AddrInfoFlag

-- | If no <a>HostName</a> value is provided, the network address in each
--   <a>SockAddr</a> will be left as a "wild card". This is useful for
--   server applications that will accept connections from any client.
AI_PASSIVE :: AddrInfoFlag

-- | If an IPv6 lookup is performed, and no IPv6 addresses are found,
--   IPv6-mapped IPv4 addresses will be returned. (Only some platforms
--   support this.)
AI_V4MAPPED :: AddrInfoFlag

-- | Indicate whether the given <a>AddrInfoFlag</a> will have any effect on
--   this system.
addrInfoFlagImplemented :: AddrInfoFlag -> Bool

-- | Connect to a remote socket at address.
connect :: Socket -> SockAddr -> IO ()

-- | Bind the socket to an address. The socket must not already be bound.
--   The <a>Family</a> passed to <tt>bind</tt> must be the same as that
--   passed to <a>socket</a>. If the special port number <a>defaultPort</a>
--   is passed then the system assigns the next available use port.
bind :: Socket -> SockAddr -> IO ()

-- | Listen for connections made to the socket. The second argument
--   specifies the maximum number of queued connections and should be at
--   least 1; the maximum value is system-dependent (usually 5).
listen :: Socket -> Int -> IO ()

-- | Accept a connection. The socket must be bound to an address and
--   listening for connections. The return value is a pair <tt>(conn,
--   address)</tt> where <tt>conn</tt> is a new socket object usable to
--   send and receive data on the connection, and <tt>address</tt> is the
--   address bound to the socket on the other end of the connection.
accept :: Socket -> IO (Socket, SockAddr)

-- | Close the socket. This function does not throw exceptions even if the
--   underlying system call returns errors.
--   
--   Sending data to or receiving data from closed socket may lead to
--   undefined behaviour.
--   
--   If multiple threads use the same socket and one uses <a>fdSocket</a>
--   and the other use <a>close</a>, unexpected behavior may happen. For
--   more information, please refer to the documentation of
--   <a>fdSocket</a>.
close :: Socket -> IO ()

-- | Close the socket. This function throws exceptions if the underlying
--   system call returns errors.
--   
--   Sending data to or receiving data from closed socket may lead to
--   undefined behaviour.
close' :: Socket -> IO ()

-- | Shut down one or both halves of the connection, depending on the
--   second argument to the function. If the second argument is
--   <a>ShutdownReceive</a>, further receives are disallowed. If it is
--   <a>ShutdownSend</a>, further sends are disallowed. If it is
--   <a>ShutdownBoth</a>, further sends and receives are disallowed.
shutdown :: Socket -> ShutdownCmd -> IO ()
data ShutdownCmd
ShutdownReceive :: ShutdownCmd
ShutdownSend :: ShutdownCmd
ShutdownBoth :: ShutdownCmd

-- | Socket options for use with <a>setSocketOption</a> and
--   <a>getSocketOption</a>.
--   
--   The existence of a constructor does not imply that the relevant option
--   is supported on your system: see <a>isSupportedSocketOption</a>
data SocketOption

-- | SO_DEBUG
Debug :: SocketOption

-- | SO_REUSEADDR
ReuseAddr :: SocketOption

-- | SO_TYPE
Type :: SocketOption

-- | SO_ERROR
SoError :: SocketOption

-- | SO_DONTROUTE
DontRoute :: SocketOption

-- | SO_BROADCAST
Broadcast :: SocketOption

-- | SO_SNDBUF
SendBuffer :: SocketOption

-- | SO_RCVBUF
RecvBuffer :: SocketOption

-- | SO_KEEPALIVE
KeepAlive :: SocketOption

-- | SO_OOBINLINE
OOBInline :: SocketOption

-- | IP_TTL
TimeToLive :: SocketOption

-- | TCP_MAXSEG
MaxSegment :: SocketOption

-- | TCP_NODELAY
NoDelay :: SocketOption

-- | TCP_CORK
Cork :: SocketOption

-- | SO_LINGER
Linger :: SocketOption

-- | SO_REUSEPORT
ReusePort :: SocketOption

-- | SO_RCVLOWAT
RecvLowWater :: SocketOption

-- | SO_SNDLOWAT
SendLowWater :: SocketOption

-- | SO_RCVTIMEO
RecvTimeOut :: SocketOption

-- | SO_SNDTIMEO
SendTimeOut :: SocketOption

-- | SO_USELOOPBACK
UseLoopBack :: SocketOption

-- | TCP_USER_TIMEOUT
UserTimeout :: SocketOption

-- | IPV6_V6ONLY
IPv6Only :: SocketOption
CustomSockOpt :: (CInt, CInt) -> SocketOption

-- | Does the <a>SocketOption</a> exist on this system?
isSupportedSocketOption :: SocketOption -> Bool

-- | Get a socket option that gives an Int value. There is currently no API
--   to get e.g. the timeval socket options
getSocketOption :: Socket -> SocketOption -> IO Int

-- | Set a socket option that expects an Int value. There is currently no
--   API to set e.g. the timeval socket options
setSocketOption :: Socket -> SocketOption -> Int -> IO ()

-- | A socket data type. <a>Socket</a>s are not GCed unless they are closed
--   by <tt>close</tt>.
data Socket

-- | <i>Deprecated: <a>MkSocket</a> will not be available in version
--   3.0.0.0 or later. Use fdSocket instead</i>
MkSocket :: CInt -> Family -> SocketType -> ProtocolNumber -> MVar SocketStatus -> Socket

-- | Create a new socket using the given address family, socket type and
--   protocol number. The address family is usually <a>AF_INET</a>,
--   <a>AF_INET6</a>, or <a>AF_UNIX</a>. The socket type is usually
--   <a>Stream</a> or <a>Datagram</a>. The protocol number is usually
--   <a>defaultProtocol</a>. If <a>AF_INET6</a> is used and the socket type
--   is <a>Stream</a> or <a>Datagram</a>, the <a>IPv6Only</a> socket option
--   is set to 0 so that both IPv4 and IPv6 can be handled with one socket.
--   
--   <pre>
--   &gt;&gt;&gt; let hints = defaultHints { addrFlags = [AI_NUMERICHOST, AI_NUMERICSERV], addrSocketType = Stream }
--   
--   &gt;&gt;&gt; addr:_ &lt;- getAddrInfo (Just hints) (Just "127.0.0.1") (Just "5000")
--   
--   &gt;&gt;&gt; sock &lt;- socket (addrFamily addr) (addrSocketType addr) (addrProtocol addr)
--   
--   &gt;&gt;&gt; bind sock (addrAddress addr)
--   
--   &gt;&gt;&gt; getSocketName sock
--   127.0.0.1:5000
--   </pre>
socket :: Family -> SocketType -> ProtocolNumber -> IO Socket

-- | Obtaining the file descriptor from a socket.
--   
--   If a <a>Socket</a> is shared with multiple threads and one uses
--   <a>fdSocket</a>, unexpected issues may happen. Consider the following
--   scenario:
--   
--   1) Thread A acquires a <tt>Fd</tt> from <a>Socket</a> by
--   <a>fdSocket</a>.
--   
--   2) Thread B close the <a>Socket</a>.
--   
--   3) Thread C opens a new <a>Socket</a>. Unfortunately it gets the same
--   <tt>Fd</tt> number which thread A is holding.
--   
--   In this case, it is safer for Thread A to clone <tt>Fd</tt> by
--   <a>dup</a>. But this would still suffer from a rase condition between
--   <a>fdSocket</a> and <tt>close</tt>.
fdSocket :: Socket -> CInt

-- | Smart constructor for constructing a <a>Socket</a>. It should only be
--   called once for every new file descriptor. The caller must make sure
--   that the socket is in non-blocking mode. See
--   <a>setNonBlockIfNeeded</a>.
mkSocket :: CInt -> Family -> SocketType -> ProtocolNumber -> SocketStatus -> IO Socket

-- | Turns a Socket into an <a>Handle</a>. By default, the new handle is
--   unbuffered. Use <a>hSetBuffering</a> to change the buffering.
--   
--   Note that since a <a>Handle</a> is automatically closed by a finalizer
--   when it is no longer referenced, you should avoid doing any more
--   operations on the <a>Socket</a> after calling <a>socketToHandle</a>.
--   To close the <a>Socket</a> after <a>socketToHandle</a>, call
--   <a>hClose</a> on the <a>Handle</a>.
socketToHandle :: Socket -> IOMode -> IO Handle

-- | Socket Types.
--   
--   The existence of a constructor does not necessarily imply that that
--   socket type is supported on your system: see
--   <a>isSupportedSocketType</a>.
data SocketType

-- | 0, used in getAddrInfo hints, for example
NoSocketType :: SocketType

-- | SOCK_STREAM
Stream :: SocketType

-- | SOCK_DGRAM
Datagram :: SocketType

-- | SOCK_RAW
Raw :: SocketType

-- | SOCK_RDM
RDM :: SocketType

-- | SOCK_SEQPACKET
SeqPacket :: SocketType

-- | Does the SOCK_ constant corresponding to the given SocketType exist on
--   this system?
isSupportedSocketType :: SocketType -> Bool

-- | Address families.
--   
--   A constructor being present here does not mean it is supported by the
--   operating system: see <a>isSupportedFamily</a>.
data Family
AF_UNSPEC :: Family
AF_UNIX :: Family
AF_INET :: Family
AF_INET6 :: Family
AF_IMPLINK :: Family
AF_PUP :: Family
AF_CHAOS :: Family
AF_NS :: Family
AF_NBS :: Family
AF_ECMA :: Family
AF_DATAKIT :: Family
AF_CCITT :: Family
AF_SNA :: Family
AF_DECnet :: Family
AF_DLI :: Family
AF_LAT :: Family
AF_HYLINK :: Family
AF_APPLETALK :: Family
AF_ROUTE :: Family
AF_NETBIOS :: Family
AF_NIT :: Family
AF_802 :: Family
AF_ISO :: Family
AF_OSI :: Family
AF_NETMAN :: Family
AF_X25 :: Family
AF_AX25 :: Family
AF_OSINET :: Family
AF_GOSSIP :: Family
AF_IPX :: Family
Pseudo_AF_XTP :: Family
AF_CTF :: Family
AF_WAN :: Family
AF_SDL :: Family
AF_NETWARE :: Family
AF_NDD :: Family
AF_INTF :: Family
AF_COIP :: Family
AF_CNT :: Family
Pseudo_AF_RTIP :: Family
Pseudo_AF_PIP :: Family
AF_SIP :: Family
AF_ISDN :: Family
Pseudo_AF_KEY :: Family
AF_NATM :: Family
AF_ARP :: Family
Pseudo_AF_HDRCMPLT :: Family
AF_ENCAP :: Family
AF_LINK :: Family
AF_RAW :: Family
AF_RIF :: Family
AF_NETROM :: Family
AF_BRIDGE :: Family
AF_ATMPVC :: Family
AF_ROSE :: Family
AF_NETBEUI :: Family
AF_SECURITY :: Family
AF_PACKET :: Family
AF_ASH :: Family
AF_ECONET :: Family
AF_ATMSVC :: Family
AF_IRDA :: Family
AF_PPPOX :: Family
AF_WANPIPE :: Family
AF_BLUETOOTH :: Family
AF_CAN :: Family

-- | Does the AF_ constant corresponding to the given family exist on this
--   system?
isSupportedFamily :: Family -> Bool
type ProtocolNumber = CInt

-- | This is the default protocol for a given service.
defaultProtocol :: ProtocolNumber

-- | The existence of a constructor does not necessarily imply that that
--   socket address type is supported on your system: see
--   <a>isSupportedSockAddr</a>.
data SockAddr
SockAddrInet :: PortNumber -> HostAddress -> SockAddr
SockAddrInet6 :: PortNumber -> FlowInfo -> HostAddress6 -> ScopeID -> SockAddr
SockAddrUnix :: String -> SockAddr

-- | <i>Deprecated: This will be removed in 3.0</i>
SockAddrCan :: Int32 -> SockAddr

-- | Is the socket address type supported on this system?
isSupportedSockAddr :: SockAddr -> Bool
getPeerName :: Socket -> IO SockAddr
getSocketName :: Socket -> IO SockAddr

-- | The raw network byte order number is read using host byte order.
--   Therefore on little-endian architectures the byte order is swapped.
--   For example <tt>127.0.0.1</tt> is represented as <tt>0x0100007f</tt>
--   on little-endian hosts and as <tt>0x7f000001</tt> on big-endian hosts.
--   
--   For direct manipulation prefer <a>hostAddressToTuple</a> and
--   <a>tupleToHostAddress</a>.
type HostAddress = Word32

-- | Converts <a>HostAddress</a> to representation-independent IPv4
--   quadruple. For example for <tt>127.0.0.1</tt> the function will return
--   <tt>(0x7f, 0, 0, 1)</tt> regardless of host endianness.
hostAddressToTuple :: HostAddress -> (Word8, Word8, Word8, Word8)

-- | Converts IPv4 quadruple to <a>HostAddress</a>.
tupleToHostAddress :: (Word8, Word8, Word8, Word8) -> HostAddress

-- | Independent of endianness. For example <tt>::1</tt> is stored as
--   <tt>(0, 0, 0, 1)</tt>.
--   
--   For direct manipulation prefer <a>hostAddress6ToTuple</a> and
--   <a>tupleToHostAddress6</a>.
type HostAddress6 = (Word32, Word32, Word32, Word32)
hostAddress6ToTuple :: HostAddress6 -> (Word16, Word16, Word16, Word16, Word16, Word16, Word16, Word16)
tupleToHostAddress6 :: (Word16, Word16, Word16, Word16, Word16, Word16, Word16, Word16) -> HostAddress6
type FlowInfo = Word32
type ScopeID = Word32

-- | Returns the index corresponding to the interface name.
--   
--   Since 2.7.0.0.
ifNameToIndex :: String -> IO (Maybe Int)

-- | Returns the interface name corresponding to the index.
--   
--   Since 2.7.0.0.
ifIndexToName :: Int -> IO (Maybe String)

-- | Use the <tt>Num</tt> instance (i.e. use a literal) to create a
--   <tt>PortNumber</tt> value.
--   
--   <pre>
--   &gt;&gt;&gt; 1 :: PortNumber
--   1
--   
--   &gt;&gt;&gt; read "1" :: PortNumber
--   1
--   
--   &gt;&gt;&gt; show (12345 :: PortNumber)
--   "12345"
--   
--   &gt;&gt;&gt; 50000 &lt; (51000 :: PortNumber)
--   True
--   
--   &gt;&gt;&gt; 50000 &lt; (52000 :: PortNumber)
--   True
--   
--   &gt;&gt;&gt; 50000 + (10000 :: PortNumber)
--   60000
--   </pre>
data PortNumber
defaultPort :: PortNumber

-- | Getting the port of socket.
socketPortSafe :: Socket -> IO (Maybe PortNumber)

-- | Getting the port of socket. <a>IOError</a> is thrown if a port is not
--   available.
socketPort :: Socket -> IO PortNumber

-- | Whether or not UNIX-domain sockets are available.
--   
--   Since 3.0.0.0.
isUnixDomainSocketAvailable :: Bool

-- | Build a pair of connected socket objects using the given address
--   family, socket type, and protocol number. Address family, socket type,
--   and protocol number are as for the <a>socket</a> function above.
--   Availability: Unix.
socketPair :: Family -> SocketType -> ProtocolNumber -> IO (Socket, Socket)
sendFd :: Socket -> CInt -> IO ()

-- | Receive a file descriptor over a domain socket. Note that the
--   resulting file descriptor may have to be put into non-blocking mode in
--   order to be used safely. See <a>setNonBlockIfNeeded</a>.
recvFd :: Socket -> IO CInt

-- | Getting process ID, user ID and group ID for UNIX-domain sockets.
--   
--   This is implemented with SO_PEERCRED on Linux and getpeereid() on BSD
--   variants. Unfortunately, on some BSD variants getpeereid() returns
--   unexpected results, rather than an error, for AF_INET sockets. It is
--   the user's responsibility to make sure that the socket is a
--   UNIX-domain socket. Also, on some BSD variants, getpeereid() does not
--   return credentials for sockets created via <a>socketPair</a>, only
--   separately created and then explicitly connected UNIX-domain sockets
--   work on such systems.
--   
--   Since 2.7.0.0.
getPeerCredential :: Socket -> IO (Maybe CUInt, Maybe CUInt, Maybe CUInt)

-- | Flags that control the querying behaviour of <a>getNameInfo</a>. For
--   more information, see
--   <a>https://tools.ietf.org/html/rfc3493#page-30</a>
data NameInfoFlag

-- | Resolve a datagram-based service name. This is required only for the
--   few protocols that have different port numbers for their
--   datagram-based versions than for their stream-based versions.
NI_DGRAM :: NameInfoFlag

-- | If the hostname cannot be looked up, an IO error is thrown.
NI_NAMEREQD :: NameInfoFlag

-- | If a host is local, return only the hostname part of the FQDN.
NI_NOFQDN :: NameInfoFlag

-- | The name of the host is not looked up. Instead, a numeric
--   representation of the host's address is returned. For an IPv4 address,
--   this will be a dotted-quad string. For IPv6, it will be
--   colon-separated hexadecimal.
NI_NUMERICHOST :: NameInfoFlag

-- | The name of the service is not looked up. Instead, a numeric
--   representation of the service is returned.
NI_NUMERICSERV :: NameInfoFlag

-- | Resolve an address to a host or service name. This function is
--   protocol independent. The list of <a>NameInfoFlag</a> values controls
--   query behaviour.
--   
--   If a host or service's name cannot be looked up, then the numeric form
--   of the address or service will be returned.
--   
--   If the query fails, this function throws an IO exception.
--   
--   Example: <tt> (hostName, _) &lt;- getNameInfo [] True False myAddress
--   </tt>
getNameInfo :: [NameInfoFlag] -> Bool -> Bool -> SockAddr -> IO (Maybe HostName, Maybe ServiceName)

-- | Set the close_on_exec flag on Unix. On Windows, nothing is done.
--   
--   Since 2.7.0.0.
setCloseOnExecIfNeeded :: CInt -> IO ()

-- | Get the nonblocking flag. On Windows, this function always returns
--   <a>False</a>.
--   
--   Since 2.7.0.0.
getCloseOnExec :: CInt -> IO Bool

-- | Set the nonblocking flag on Unix. On Windows, nothing is done.
setNonBlockIfNeeded :: CInt -> IO ()

-- | Get the close_on_exec flag. On Windows, this function always returns
--   <a>False</a>.
--   
--   Since 2.7.0.0.
getNonBlock :: CInt -> IO Bool

-- | Send data to the socket. The socket must be connected to a remote
--   socket. Returns the number of bytes sent. Applications are responsible
--   for ensuring that all data has been sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.
sendBuf :: Socket -> Ptr Word8 -> Int -> IO Int

-- | Receive data from the socket. The socket must be in a connected state.
--   This function may return fewer bytes than specified. If the message is
--   longer than the specified length, it may be discarded depending on the
--   type of socket. This function may block until a message arrives.
--   
--   Considering hardware and network realities, the maximum number of
--   bytes to receive should be a small power of 2, e.g., 4096.
--   
--   For TCP sockets, a zero length return value means the peer has closed
--   its half side of the connection.
--   
--   Receiving data from closed socket may lead to undefined behaviour.
recvBuf :: Socket -> Ptr Word8 -> Int -> IO Int

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. Returns the number of
--   bytes sent. Applications are responsible for ensuring that all data
--   has been sent.
sendBufTo :: Socket -> Ptr a -> Int -> SockAddr -> IO Int

-- | Receive data from the socket, writing it into buffer instead of
--   creating a new string. The socket need not be in a connected state.
--   Returns <tt>(nbytes, address)</tt> where <tt>nbytes</tt> is the number
--   of bytes received and <tt>address</tt> is a <a>SockAddr</a>
--   representing the address of the sending socket.
--   
--   NOTE: blocking on Windows unless you compile with -threaded (see GHC
--   ticket #1129)
recvBufFrom :: Socket -> Ptr a -> Int -> IO (Int, SockAddr)

-- | This is the value of SOMAXCONN, typically 128. 128 is good enough for
--   normal network servers but is too small for high performance servers.
maxListenQueue :: Int

-- | Send data to the socket. The socket must be connected to a remote
--   socket. Returns the number of bytes sent. Applications are responsible
--   for ensuring that all data has been sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.

-- | <i>Deprecated: Use send defined in
--   <a>Network.Socket.ByteString</a></i>
send :: Socket -> String -> IO Int

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. Returns the number of
--   bytes sent. Applications are responsible for ensuring that all data
--   has been sent.
--   
--   NOTE: blocking on Windows unless you compile with -threaded (see GHC
--   ticket #1129)

-- | <i>Deprecated: Use sendTo defined in
--   <a>Network.Socket.ByteString</a></i>
sendTo :: Socket -> String -> SockAddr -> IO Int

-- | Receive data from the socket. The socket must be in a connected state.
--   This function may return fewer bytes than specified. If the message is
--   longer than the specified length, it may be discarded depending on the
--   type of socket. This function may block until a message arrives.
--   
--   Considering hardware and network realities, the maximum number of
--   bytes to receive should be a small power of 2, e.g., 4096.
--   
--   For TCP sockets, a zero length return value means the peer has closed
--   its half side of the connection.
--   
--   Receiving data from closed socket may lead to undefined behaviour.

-- | <i>Deprecated: Use recv defined in
--   <a>Network.Socket.ByteString</a></i>
recv :: Socket -> Int -> IO String

-- | Receive data from the socket. The socket need not be in a connected
--   state. Returns <tt>(bytes, nbytes, address)</tt> where <tt>bytes</tt>
--   is a <tt>String</tt> of length <tt>nbytes</tt> representing the data
--   received and <tt>address</tt> is a <a>SockAddr</a> representing the
--   address of the sending socket.
--   
--   NOTE: blocking on Windows unless you compile with -threaded (see GHC
--   ticket #1129)

-- | <i>Deprecated: Use recvFrom defined in
--   <a>Network.Socket.ByteString</a></i>
recvFrom :: Socket -> Int -> IO (String, Int, SockAddr)

-- | <i>Deprecated: Use recv defined in <a>Network.Socket.ByteString</a>
--   with "Data.Bytestring.length"</i>
recvLen :: Socket -> Int -> IO (String, Int)

-- | Converts the from host byte order to network byte order.

-- | <i>Deprecated: Use getAddrInfo instead</i>
htonl :: Word32 -> Word32

-- | Converts the from network byte order to host byte order.

-- | <i>Deprecated: Use getAddrInfo instead</i>
ntohl :: Word32 -> Word32

-- | <i>Deprecated: Use "getAddrInfo" instead</i>
inet_addr :: String -> IO HostAddress

-- | <i>Deprecated: Use "getNameInfo" instead</i>
inet_ntoa :: HostAddress -> IO String

-- | Deprecated alias for <a>bind</a>.

-- | <i>Deprecated: use <a>bind</a></i>
bindSocket :: Socket -> SockAddr -> IO ()

-- | Deprecated alias for <a>close</a>.

-- | <i>Deprecated: use <a>close</a></i>
sClose :: Socket -> IO ()

-- | The status of the socket as <i>determined by this library</i>, not
--   necessarily reflecting the state of the connection itself.
--   
--   For example, the <a>Closed</a> status is applied when the
--   <tt>close</tt> function is called.

-- | <i>Deprecated: SocketStatus will be removed</i>
data SocketStatus

-- | Newly created, unconnected socket
NotConnected :: SocketStatus

-- | Bound, via <tt>bind</tt>
Bound :: SocketStatus

-- | Listening, via <tt>listen</tt>
Listening :: SocketStatus

-- | Connected or accepted, via <tt>connect</tt> or <tt>accept</tt>
Connected :: SocketStatus

-- | Is now a <tt>Handle</tt> (via <tt>socketToHandle</tt>), don't touch
ConvertedToHandle :: SocketStatus

-- | Closed was closed by <tt>close</tt>
Closed :: SocketStatus

-- | Determines whether <a>close</a> has been used on the <a>Socket</a>.
--   This does <i>not</i> indicate any status about the socket beyond this.
--   If the socket has been closed remotely, this function can still return
--   <a>True</a>.

-- | <i>Deprecated: SocketStatus will be removed</i>
isConnected :: Socket -> IO Bool

-- | <i>Deprecated: SocketStatus will be removed</i>
isBound :: Socket -> IO Bool

-- | <i>Deprecated: SocketStatus will be removed</i>
isListening :: Socket -> IO Bool

-- | <i>Deprecated: SocketStatus will be removed</i>
isReadable :: Socket -> IO Bool

-- | <i>Deprecated: SocketStatus will be removed</i>
isWritable :: Socket -> IO Bool

-- | <i>Deprecated: SocketStatus will be removed</i>
sIsConnected :: Socket -> IO Bool

-- | <i>Deprecated: SocketStatus will be removed</i>
sIsBound :: Socket -> IO Bool

-- | <i>Deprecated: SocketStatus will be removed</i>
sIsListening :: Socket -> IO Bool

-- | <i>Deprecated: SocketStatus will be removed</i>
sIsReadable :: Socket -> IO Bool

-- | <i>Deprecated: SocketStatus will be removed</i>
sIsWritable :: Socket -> IO Bool

-- | <i>Deprecated: Use defaultPort instead</i>
aNY_PORT :: PortNumber

-- | The IPv4 wild card address.

-- | <i>Deprecated: Use getAddrInfo instead</i>
iNADDR_ANY :: HostAddress

-- | The IPv6 wild card address.

-- | <i>Deprecated: Use getAddrInfo instead</i>
iN6ADDR_ANY :: HostAddress6

-- | <i>Deprecated: Use maxListenQueue instead</i>
sOMAXCONN :: Int

-- | <i>Deprecated: This is not necessary anymore</i>
sOL_SOCKET :: Int

-- | <i>Deprecated: This is not necessary anymore</i>
sCM_RIGHTS :: Int
packFamily :: Family -> CInt
unpackFamily :: CInt -> Family

-- | <i>Deprecated: packSocketType will not be available in version 3.0.0.0
--   or later.</i>
packSocketType :: SocketType -> CInt

-- | Returns the processID, userID and groupID of the socket's peer.
--   
--   Only available on platforms that support SO_PEERCRED or GETPEEREID(3)
--   on domain sockets. GETPEEREID(3) returns userID and groupID. processID
--   is always 0.

-- | <i>Deprecated: Use getPeerCredential instead</i>
getPeerCred :: Socket -> IO (CUInt, CUInt, CUInt)
instance GHC.Show.Show Network.Socket.NameInfoFlag
instance GHC.Read.Read Network.Socket.NameInfoFlag
instance GHC.Classes.Eq Network.Socket.NameInfoFlag
instance GHC.Show.Show Network.Socket.AddrInfo
instance GHC.Classes.Eq Network.Socket.AddrInfo
instance GHC.Show.Show Network.Socket.AddrInfoFlag
instance GHC.Read.Read Network.Socket.AddrInfoFlag
instance GHC.Classes.Eq Network.Socket.AddrInfoFlag
instance GHC.Show.Show Network.Socket.SocketOption
instance GHC.Show.Show Network.Socket.Types.SockAddr
instance Foreign.Storable.Storable Network.Socket.AddrInfo


-- | This module provides access to the BSD <i>socket</i> interface. This
--   module is generally more efficient than the <a>String</a> based
--   network functions in <a>Socket</a>. For detailed documentation,
--   consult your favorite POSIX socket reference. All functions
--   communicate failures by converting the error number to <a>IOError</a>.
--   
--   This module is made to be imported with <a>Socket</a> like so:
--   
--   <pre>
--   import Network.Socket hiding (send, sendTo, recv, recvFrom)
--   import Network.Socket.ByteString
--   </pre>
module Network.Socket.ByteString

-- | Send data to the socket. The socket must be connected to a remote
--   socket. Returns the number of bytes sent. Applications are responsible
--   for ensuring that all data has been sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.
send :: Socket -> ByteString -> IO Int

-- | Send data to the socket. The socket must be connected to a remote
--   socket. Unlike <a>send</a>, this function continues to send data until
--   either all data has been sent or an error occurs. On error, an
--   exception is raised, and there is no way to determine how much data,
--   if any, was successfully sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.
sendAll :: Socket -> ByteString -> IO ()

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. Returns the number of
--   bytes sent. Applications are responsible for ensuring that all data
--   has been sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.
sendTo :: Socket -> ByteString -> SockAddr -> IO Int

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. Unlike <a>sendTo</a>,
--   this function continues to send data until either all data has been
--   sent or an error occurs. On error, an exception is raised, and there
--   is no way to determine how much data, if any, was successfully sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.
sendAllTo :: Socket -> ByteString -> SockAddr -> IO ()

-- | Send data to the socket. The socket must be in a connected state. The
--   data is sent as if the parts have been concatenated. This function
--   continues to send data until either all data has been sent or an error
--   occurs. On error, an exception is raised, and there is no way to
--   determine how much data, if any, was successfully sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.
sendMany :: Socket -> [ByteString] -> IO ()

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. The data is sent as if
--   the parts have been concatenated. This function continues to send data
--   until either all data has been sent or an error occurs. On error, an
--   exception is raised, and there is no way to determine how much data,
--   if any, was successfully sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.
sendManyTo :: Socket -> [ByteString] -> SockAddr -> IO ()

-- | Receive data from the socket. The socket must be in a connected state.
--   This function may return fewer bytes than specified. If the message is
--   longer than the specified length, it may be discarded depending on the
--   type of socket. This function may block until a message arrives.
--   
--   Considering hardware and network realities, the maximum number of
--   bytes to receive should be a small power of 2, e.g., 4096.
--   
--   For TCP sockets, a zero length return value means the peer has closed
--   its half side of the connection.
--   
--   Receiving data from closed socket may lead to undefined behaviour.
recv :: Socket -> Int -> IO ByteString

-- | Receive data from the socket. The socket need not be in a connected
--   state. Returns <tt>(bytes, address)</tt> where <tt>bytes</tt> is a
--   <a>ByteString</a> representing the data received and <tt>address</tt>
--   is a <a>SockAddr</a> representing the address of the sending socket.
--   
--   Receiving data from closed socket may lead to undefined behaviour.
recvFrom :: Socket -> Int -> IO (ByteString, SockAddr)


-- | This module provides access to the BSD <i>socket</i> interface. This
--   module is generally more efficient than the <a>String</a> based
--   network functions in <a>Socket</a>. For detailed documentation,
--   consult your favorite POSIX socket reference. All functions
--   communicate failures by converting the error number to <a>IOError</a>.
--   
--   This module is made to be imported with <a>Socket</a> like so:
--   
--   <pre>
--   import Network.Socket hiding (send, sendTo, recv, recvFrom)
--   import Network.Socket.ByteString.Lazy
--   import Prelude hiding (getContents)
--   </pre>
module Network.Socket.ByteString.Lazy
send :: Socket -> ByteString -> IO Int64
sendAll :: Socket -> ByteString -> IO ()

-- | Receive data from the socket. The socket must be in a connected state.
--   Data is received on demand, in chunks; each chunk will be sized to
--   reflect the amount of data received by individual <a>recv</a> calls.
--   
--   All remaining data from the socket is consumed. When there is no more
--   data to be received, the receiving side of the socket is shut down. If
--   there is an error and an exception is thrown, the socket is not shut
--   down.
getContents :: Socket -> IO ByteString

-- | Receive data from the socket. The socket must be in a connected state.
--   This function may return fewer bytes than specified. If the received
--   data is longer than the specified length, it may be discarded
--   depending on the type of socket. This function may block until a
--   message arrives.
--   
--   If there is no more data to be received, returns an empty
--   <a>ByteString</a>.
--   
--   Receiving data from closed socket may lead to undefined behaviour.
recv :: Socket -> Int64 -> IO ByteString
