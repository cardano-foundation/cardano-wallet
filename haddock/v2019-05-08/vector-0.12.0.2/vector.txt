-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient Arrays
--   
--   An efficient implementation of Int-indexed arrays (both mutable and
--   immutable), with a powerful loop optimisation framework .
--   
--   It is structured as follows:
--   
--   <ul>
--   <li><i><a>Data.Vector</a></i> Boxed vectors of arbitrary types.</li>
--   <li><i><a>Data.Vector.Unboxed</a></i> Unboxed vectors with an adaptive
--   representation based on data type families.</li>
--   <li><i><a>Data.Vector.Storable</a></i> Unboxed vectors of
--   <a>Storable</a> types.</li>
--   <li><i><a>Data.Vector.Primitive</a></i> Unboxed vectors of primitive
--   types as defined by the <tt>primitive</tt> package.
--   <a>Data.Vector.Unboxed</a> is more flexible at no performance
--   cost.</li>
--   <li><i><a>Data.Vector.Generic</a></i> Generic interface to the vector
--   types.</li>
--   </ul>
--   
--   There is also a (draft) tutorial on common uses of vector.
--   
--   <ul>
--   
--   <li><a>http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial</a></li>
--   </ul>
@package vector
@version 0.12.0.2


-- | Fusion-related utility types
module Data.Vector.Fusion.Util

-- | Identity monad
newtype Id a
Id :: a -> Id a
[unId] :: Id a -> a

-- | Box monad
data Box a
Box :: a -> Box a
[unBox] :: Box a -> a

-- | Delay inlining a function until late in the game (simplifier phase 0).
delay_inline :: (a -> b) -> a -> b

-- | <a>min</a> inlined in phase 0
delayed_min :: Int -> Int -> Int
instance GHC.Base.Functor Data.Vector.Fusion.Util.Box
instance GHC.Base.Applicative Data.Vector.Fusion.Util.Box
instance GHC.Base.Monad Data.Vector.Fusion.Util.Box
instance GHC.Base.Functor Data.Vector.Fusion.Util.Id
instance GHC.Base.Applicative Data.Vector.Fusion.Util.Id
instance GHC.Base.Monad Data.Vector.Fusion.Util.Id


-- | Size hints for streams.
module Data.Vector.Fusion.Bundle.Size

-- | Size hint
data Size

-- | Exact size
Exact :: Int -> Size

-- | Upper bound on the size
Max :: Int -> Size

-- | Unknown size
Unknown :: Size

-- | Subtract two sizes with clamping to 0, for drop-like things
clampedSubtract :: Size -> Size -> Size

-- | Minimum of two size hints
smaller :: Size -> Size -> Size

-- | Maximum of two size hints
larger :: Size -> Size -> Size

-- | Convert a size hint to an upper bound
toMax :: Size -> Size

-- | Compute the maximum size from a size hint if possible
upperBound :: Size -> Maybe Int

-- | Compute the minimum size from a size hint
lowerBound :: Size -> Int
instance GHC.Show.Show Data.Vector.Fusion.Bundle.Size.Size
instance GHC.Classes.Eq Data.Vector.Fusion.Bundle.Size.Size
instance GHC.Num.Num Data.Vector.Fusion.Bundle.Size.Size


-- | Class of mutable vectors
module Data.Vector.Generic.Mutable.Base

-- | Class of mutable vectors parametrised with a primitive state token.
class MVector v a

-- | Length of the mutable vector. This method should not be called
--   directly, use <a>length</a> instead.
basicLength :: MVector v a => v s a -> Int

-- | Yield a part of the mutable vector without copying it. This method
--   should not be called directly, use <tt>unsafeSlice</tt> instead.
basicUnsafeSlice :: MVector v a => Int -> Int -> v s a -> v s a

-- | Check whether two vectors overlap. This method should not be called
--   directly, use <tt>overlaps</tt> instead.
basicOverlaps :: MVector v a => v s a -> v s a -> Bool

-- | Create a mutable vector of the given length. This method should not be
--   called directly, use <tt>unsafeNew</tt> instead.
basicUnsafeNew :: (MVector v a, PrimMonad m) => Int -> m (v (PrimState m) a)

-- | Initialize a vector to a standard value. This is intended to be called
--   as part of the safe new operation (and similar operations), to
--   properly blank the newly allocated memory if necessary.
--   
--   Vectors that are necessarily initialized as part of creation may
--   implement this as a no-op.
basicInitialize :: (MVector v a, PrimMonad m) => v (PrimState m) a -> m ()

-- | Create a mutable vector of the given length and fill it with an
--   initial value. This method should not be called directly, use
--   <a>replicate</a> instead.
basicUnsafeReplicate :: (MVector v a, PrimMonad m) => Int -> a -> m (v (PrimState m) a)

-- | Yield the element at the given position. This method should not be
--   called directly, use <tt>unsafeRead</tt> instead.
basicUnsafeRead :: (MVector v a, PrimMonad m) => v (PrimState m) a -> Int -> m a

-- | Replace the element at the given position. This method should not be
--   called directly, use <tt>unsafeWrite</tt> instead.
basicUnsafeWrite :: (MVector v a, PrimMonad m) => v (PrimState m) a -> Int -> a -> m ()

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is usually a noop for unboxed
--   vectors. This method should not be called directly, use <tt>clear</tt>
--   instead.
basicClear :: (MVector v a, PrimMonad m) => v (PrimState m) a -> m ()

-- | Set all elements of the vector to the given value. This method should
--   not be called directly, use <tt>set</tt> instead.
basicSet :: (MVector v a, PrimMonad m) => v (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors may not overlap. This method should not
--   be called directly, use <tt>unsafeCopy</tt> instead.
basicUnsafeCopy :: (MVector v a, PrimMonad m) => v (PrimState m) a -> v (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors may overlap. This
--   method should not be called directly, use <tt>unsafeMove</tt> instead.
basicUnsafeMove :: (MVector v a, PrimMonad m) => v (PrimState m) a -> v (PrimState m) a -> m ()

-- | Grow a vector by the given number of elements. This method should not
--   be called directly, use <tt>unsafeGrow</tt> instead.
basicUnsafeGrow :: (MVector v a, PrimMonad m) => v (PrimState m) a -> Int -> m (v (PrimState m) a)


-- | Bounds checking infrastructure
module Data.Vector.Internal.Check
data Checks
Bounds :: Checks
Unsafe :: Checks
Internal :: Checks
doChecks :: Checks -> Bool
error :: String -> Int -> String -> String -> a
internalError :: String -> Int -> String -> String -> a
check :: String -> Int -> Checks -> String -> String -> Bool -> a -> a
checkIndex :: String -> Int -> Checks -> String -> Int -> Int -> a -> a
checkLength :: String -> Int -> Checks -> String -> Int -> a -> a
checkSlice :: String -> Int -> Checks -> String -> Int -> Int -> Int -> a -> a
instance GHC.Classes.Eq Data.Vector.Internal.Check.Checks


-- | Monadic stream combinators.
module Data.Vector.Fusion.Stream.Monadic

-- | Monadic streams
data Stream m a
Stream :: (s -> m (Step s a)) -> s -> Stream m a

-- | Result of taking a single step in a stream
data Step s a
[Yield] :: a -> s -> Step s a
[Skip] :: s -> Step s a
[Done] :: Step s a

-- | <a>SPEC</a> is used by GHC in the <tt>SpecConstr</tt> pass in order to
--   inform the compiler when to be particularly aggressive. In particular,
--   it tells GHC to specialize regardless of size or the number of
--   specializations. However, not all loops fall into this category.
--   
--   Libraries can specify this by using <a>SPEC</a> data type to inform
--   which loops should be aggressively specialized.
data SPEC
SPEC :: SPEC
SPEC2 :: SPEC

-- | Length of a <a>Stream</a>
length :: Monad m => Stream m a -> m Int

-- | Check if a <a>Stream</a> is empty
null :: Monad m => Stream m a -> m Bool

-- | Empty <a>Stream</a>
empty :: Monad m => Stream m a

-- | Singleton <a>Stream</a>
singleton :: Monad m => a -> Stream m a

-- | Prepend an element
cons :: Monad m => a -> Stream m a -> Stream m a

-- | Append an element
snoc :: Monad m => Stream m a -> a -> Stream m a

-- | Replicate a value to a given length
replicate :: Monad m => Int -> a -> Stream m a

-- | Yield a <a>Stream</a> of values obtained by performing the monadic
--   action the given number of times
replicateM :: Monad m => Int -> m a -> Stream m a
generate :: Monad m => Int -> (Int -> a) -> Stream m a

-- | Generate a stream from its indices
generateM :: Monad m => Int -> (Int -> m a) -> Stream m a

-- | Concatenate two <a>Stream</a>s
(++) :: Monad m => Stream m a -> Stream m a -> Stream m a
infixr 5 ++

-- | First element of the <a>Stream</a> or error if empty
head :: Monad m => Stream m a -> m a

-- | Last element of the <a>Stream</a> or error if empty
last :: Monad m => Stream m a -> m a

-- | Element at the given position
(!!) :: Monad m => Stream m a -> Int -> m a
infixl 9 !!

-- | Element at the given position or <a>Nothing</a> if out of bounds
(!?) :: Monad m => Stream m a -> Int -> m (Maybe a)
infixl 9 !?

-- | Extract a substream of the given length starting at the given
--   position.
slice :: Monad m => Int -> Int -> Stream m a -> Stream m a

-- | All but the last element
init :: Monad m => Stream m a -> Stream m a

-- | All but the first element
tail :: Monad m => Stream m a -> Stream m a

-- | The first <tt>n</tt> elements
take :: Monad m => Int -> Stream m a -> Stream m a

-- | All but the first <tt>n</tt> elements
drop :: Monad m => Int -> Stream m a -> Stream m a

-- | Map a function over a <a>Stream</a>
map :: Monad m => (a -> b) -> Stream m a -> Stream m b

-- | Map a monadic function over a <a>Stream</a>
mapM :: Monad m => (a -> m b) -> Stream m a -> Stream m b

-- | Execute a monadic action for each element of the <a>Stream</a>
mapM_ :: Monad m => (a -> m b) -> Stream m a -> m ()

-- | Transform a <a>Stream</a> to use a different monad
trans :: (Monad m, Monad m') => (forall z. m z -> m' z) -> Stream m a -> Stream m' a
unbox :: Monad m => Stream m (Box a) -> Stream m a
concatMap :: Monad m => (a -> Stream m b) -> Stream m a -> Stream m b

-- | Create a <a>Stream</a> of values from a <a>Stream</a> of streamable
--   things
flatten :: Monad m => (a -> m s) -> (s -> m (Step s b)) -> Stream m a -> Stream m b

-- | Pair each element in a <a>Stream</a> with its index
indexed :: Monad m => Stream m a -> Stream m (Int, a)

-- | Pair each element in a <a>Stream</a> with its index, starting from the
--   right and counting down
indexedR :: Monad m => Int -> Stream m a -> Stream m (Int, a)
zipWithM_ :: Monad m => (a -> b -> m c) -> Stream m a -> Stream m b -> m ()

-- | Zip two <a>Stream</a>s with the given monadic function
zipWithM :: Monad m => (a -> b -> m c) -> Stream m a -> Stream m b -> Stream m c
zipWith3M :: Monad m => (a -> b -> c -> m d) -> Stream m a -> Stream m b -> Stream m c -> Stream m d
zipWith4M :: Monad m => (a -> b -> c -> d -> m e) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e
zipWith5M :: Monad m => (a -> b -> c -> d -> e -> m f) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f
zipWith6M :: Monad m => (a -> b -> c -> d -> e -> f -> m g) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f -> Stream m g
zipWith :: Monad m => (a -> b -> c) -> Stream m a -> Stream m b -> Stream m c
zipWith3 :: Monad m => (a -> b -> c -> d) -> Stream m a -> Stream m b -> Stream m c -> Stream m d
zipWith4 :: Monad m => (a -> b -> c -> d -> e) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e
zipWith5 :: Monad m => (a -> b -> c -> d -> e -> f) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f
zipWith6 :: Monad m => (a -> b -> c -> d -> e -> f -> g) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f -> Stream m g
zip :: Monad m => Stream m a -> Stream m b -> Stream m (a, b)
zip3 :: Monad m => Stream m a -> Stream m b -> Stream m c -> Stream m (a, b, c)
zip4 :: Monad m => Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m (a, b, c, d)
zip5 :: Monad m => Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m (a, b, c, d, e)
zip6 :: Monad m => Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f -> Stream m (a, b, c, d, e, f)

-- | Check if two <a>Stream</a>s are equal
eqBy :: Monad m => (a -> b -> Bool) -> Stream m a -> Stream m b -> m Bool

-- | Lexicographically compare two <a>Stream</a>s
cmpBy :: Monad m => (a -> b -> Ordering) -> Stream m a -> Stream m b -> m Ordering

-- | Drop elements which do not satisfy the predicate
filter :: Monad m => (a -> Bool) -> Stream m a -> Stream m a

-- | Drop elements which do not satisfy the monadic predicate
filterM :: Monad m => (a -> m Bool) -> Stream m a -> Stream m a

-- | Drop repeated adjacent elements.
uniq :: (Eq a, Monad m) => Stream m a -> Stream m a
mapMaybe :: Monad m => (a -> Maybe b) -> Stream m a -> Stream m b

-- | Longest prefix of elements that satisfy the predicate
takeWhile :: Monad m => (a -> Bool) -> Stream m a -> Stream m a

-- | Longest prefix of elements that satisfy the monadic predicate
takeWhileM :: Monad m => (a -> m Bool) -> Stream m a -> Stream m a

-- | Drop the longest prefix of elements that satisfy the predicate
dropWhile :: Monad m => (a -> Bool) -> Stream m a -> Stream m a

-- | Drop the longest prefix of elements that satisfy the monadic predicate
dropWhileM :: Monad m => (a -> m Bool) -> Stream m a -> Stream m a

-- | Check whether the <a>Stream</a> contains an element
elem :: (Monad m, Eq a) => a -> Stream m a -> m Bool
infix 4 `elem`

-- | Inverse of <a>elem</a>
notElem :: (Monad m, Eq a) => a -> Stream m a -> m Bool
infix 4 `notElem`

-- | Yield <a>Just</a> the first element that satisfies the predicate or
--   <a>Nothing</a> if no such element exists.
find :: Monad m => (a -> Bool) -> Stream m a -> m (Maybe a)

-- | Yield <a>Just</a> the first element that satisfies the monadic
--   predicate or <a>Nothing</a> if no such element exists.
findM :: Monad m => (a -> m Bool) -> Stream m a -> m (Maybe a)

-- | Yield <a>Just</a> the index of the first element that satisfies the
--   predicate or <a>Nothing</a> if no such element exists.
findIndex :: Monad m => (a -> Bool) -> Stream m a -> m (Maybe Int)

-- | Yield <a>Just</a> the index of the first element that satisfies the
--   monadic predicate or <a>Nothing</a> if no such element exists.
findIndexM :: Monad m => (a -> m Bool) -> Stream m a -> m (Maybe Int)

-- | Left fold
foldl :: Monad m => (a -> b -> a) -> a -> Stream m b -> m a

-- | Left fold with a monadic operator
foldlM :: Monad m => (a -> b -> m a) -> a -> Stream m b -> m a

-- | Left fold over a non-empty <a>Stream</a>
foldl1 :: Monad m => (a -> a -> a) -> Stream m a -> m a

-- | Left fold over a non-empty <a>Stream</a> with a monadic operator
foldl1M :: Monad m => (a -> a -> m a) -> Stream m a -> m a

-- | Same as <a>foldlM</a>
foldM :: Monad m => (a -> b -> m a) -> a -> Stream m b -> m a

-- | Same as <a>foldl1M</a>
fold1M :: Monad m => (a -> a -> m a) -> Stream m a -> m a

-- | Left fold with a strict accumulator
foldl' :: Monad m => (a -> b -> a) -> a -> Stream m b -> m a

-- | Left fold with a strict accumulator and a monadic operator
foldlM' :: Monad m => (a -> b -> m a) -> a -> Stream m b -> m a

-- | Left fold over a non-empty <a>Stream</a> with a strict accumulator
foldl1' :: Monad m => (a -> a -> a) -> Stream m a -> m a

-- | Left fold over a non-empty <a>Stream</a> with a strict accumulator and
--   a monadic operator
foldl1M' :: Monad m => (a -> a -> m a) -> Stream m a -> m a

-- | Same as <a>foldlM'</a>
foldM' :: Monad m => (a -> b -> m a) -> a -> Stream m b -> m a

-- | Same as <a>foldl1M'</a>
fold1M' :: Monad m => (a -> a -> m a) -> Stream m a -> m a

-- | Right fold
foldr :: Monad m => (a -> b -> b) -> b -> Stream m a -> m b

-- | Right fold with a monadic operator
foldrM :: Monad m => (a -> b -> m b) -> b -> Stream m a -> m b

-- | Right fold over a non-empty stream
foldr1 :: Monad m => (a -> a -> a) -> Stream m a -> m a

-- | Right fold over a non-empty stream with a monadic operator
foldr1M :: Monad m => (a -> a -> m a) -> Stream m a -> m a
and :: Monad m => Stream m Bool -> m Bool
or :: Monad m => Stream m Bool -> m Bool
concatMapM :: Monad m => (a -> m (Stream m b)) -> Stream m a -> Stream m b

-- | Unfold
unfoldr :: Monad m => (s -> Maybe (a, s)) -> s -> Stream m a

-- | Unfold with a monadic function
unfoldrM :: Monad m => (s -> m (Maybe (a, s))) -> s -> Stream m a
unfoldrN :: Monad m => Int -> (s -> Maybe (a, s)) -> s -> Stream m a

-- | Unfold at most <tt>n</tt> elements with a monadic functions
unfoldrNM :: Monad m => Int -> (s -> m (Maybe (a, s))) -> s -> Stream m a

-- | Apply function n times to value. Zeroth element is original value.
iterateN :: Monad m => Int -> (a -> a) -> a -> Stream m a

-- | Apply monadic function n times to value. Zeroth element is original
--   value.
iterateNM :: Monad m => Int -> (a -> m a) -> a -> Stream m a

-- | Prefix scan
prescanl :: Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a

-- | Prefix scan with a monadic operator
prescanlM :: Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a

-- | Prefix scan with strict accumulator
prescanl' :: Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a

-- | Prefix scan with strict accumulator and a monadic operator
prescanlM' :: Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a

-- | Suffix scan
postscanl :: Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a

-- | Suffix scan with a monadic operator
postscanlM :: Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a

-- | Suffix scan with strict accumulator
postscanl' :: Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a

-- | Suffix scan with strict acccumulator and a monadic operator
postscanlM' :: Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a

-- | Haskell-style scan
scanl :: Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a

-- | Haskell-style scan with a monadic operator
scanlM :: Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a

-- | Haskell-style scan with strict accumulator
scanl' :: Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a

-- | Haskell-style scan with strict accumulator and a monadic operator
scanlM' :: Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a

-- | Scan over a non-empty <a>Stream</a>
scanl1 :: Monad m => (a -> a -> a) -> Stream m a -> Stream m a

-- | Scan over a non-empty <a>Stream</a> with a monadic operator
scanl1M :: Monad m => (a -> a -> m a) -> Stream m a -> Stream m a

-- | Scan over a non-empty <a>Stream</a> with a strict accumulator
scanl1' :: Monad m => (a -> a -> a) -> Stream m a -> Stream m a

-- | Scan over a non-empty <a>Stream</a> with a strict accumulator and a
--   monadic operator
scanl1M' :: Monad m => (a -> a -> m a) -> Stream m a -> Stream m a

-- | Yield a <a>Stream</a> of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc.
enumFromStepN :: (Num a, Monad m) => a -> a -> Int -> Stream m a

-- | Enumerate values
--   
--   <i>WARNING:</i> This operation can be very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromTo :: (Enum a, Monad m) => a -> a -> Stream m a

-- | Enumerate values with a given step.
--   
--   <i>WARNING:</i> This operation is very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromThenTo :: (Enum a, Monad m) => a -> a -> a -> Stream m a

-- | Convert a <a>Stream</a> to a list
toList :: Monad m => Stream m a -> m [a]

-- | Convert a list to a <a>Stream</a>
fromList :: Monad m => [a] -> Stream m a

-- | Convert the first <tt>n</tt> elements of a list to a <tt>Bundle</tt>
fromListN :: Monad m => Int -> [a] -> Stream m a
instance GHC.Base.Monad m => GHC.Base.Functor (Data.Vector.Fusion.Stream.Monadic.Stream m)
instance GHC.Base.Functor (Data.Vector.Fusion.Stream.Monadic.Step s)


-- | Monadic bundles.
module Data.Vector.Fusion.Bundle.Monadic

-- | Monadic streams
data Bundle m v a
Bundle :: Stream m a -> Stream m (Chunk v a) -> Maybe (v a) -> Size -> Bundle m v a
[sElems] :: Bundle m v a -> Stream m a
[sChunks] :: Bundle m v a -> Stream m (Chunk v a)
[sVector] :: Bundle m v a -> Maybe (v a)
[sSize] :: Bundle m v a -> Size
data Chunk v a
Chunk :: Int -> (forall m. (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> m ()) -> Chunk v a

-- | <a>Size</a> hint of a <a>Bundle</a>
size :: Bundle m v a -> Size

-- | Attach a <a>Size</a> hint to a <a>Bundle</a>
sized :: Bundle m v a -> Size -> Bundle m v a

-- | Length of a <a>Bundle</a>
length :: Monad m => Bundle m v a -> m Int

-- | Check if a <a>Bundle</a> is empty
null :: Monad m => Bundle m v a -> m Bool

-- | Empty <a>Bundle</a>
empty :: Monad m => Bundle m v a

-- | Singleton <a>Bundle</a>
singleton :: Monad m => a -> Bundle m v a

-- | Prepend an element
cons :: Monad m => a -> Bundle m v a -> Bundle m v a

-- | Append an element
snoc :: Monad m => Bundle m v a -> a -> Bundle m v a

-- | Replicate a value to a given length
replicate :: Monad m => Int -> a -> Bundle m v a

-- | Yield a <a>Bundle</a> of values obtained by performing the monadic
--   action the given number of times
replicateM :: Monad m => Int -> m a -> Bundle m v a
generate :: Monad m => Int -> (Int -> a) -> Bundle m v a

-- | Generate a stream from its indices
generateM :: Monad m => Int -> (Int -> m a) -> Bundle m v a

-- | Concatenate two <a>Bundle</a>s
(++) :: Monad m => Bundle m v a -> Bundle m v a -> Bundle m v a
infixr 5 ++

-- | First element of the <a>Bundle</a> or error if empty
head :: Monad m => Bundle m v a -> m a

-- | Last element of the <a>Bundle</a> or error if empty
last :: Monad m => Bundle m v a -> m a

-- | Element at the given position
(!!) :: Monad m => Bundle m v a -> Int -> m a
infixl 9 !!

-- | Element at the given position or <a>Nothing</a> if out of bounds
(!?) :: Monad m => Bundle m v a -> Int -> m (Maybe a)
infixl 9 !?

-- | Extract a substream of the given length starting at the given
--   position.
slice :: Monad m => Int -> Int -> Bundle m v a -> Bundle m v a

-- | All but the last element
init :: Monad m => Bundle m v a -> Bundle m v a

-- | All but the first element
tail :: Monad m => Bundle m v a -> Bundle m v a

-- | The first <tt>n</tt> elements
take :: Monad m => Int -> Bundle m v a -> Bundle m v a

-- | All but the first <tt>n</tt> elements
drop :: Monad m => Int -> Bundle m v a -> Bundle m v a

-- | Map a function over a <a>Bundle</a>
map :: Monad m => (a -> b) -> Bundle m v a -> Bundle m v b

-- | Map a monadic function over a <a>Bundle</a>
mapM :: Monad m => (a -> m b) -> Bundle m v a -> Bundle m v b

-- | Execute a monadic action for each element of the <a>Bundle</a>
mapM_ :: Monad m => (a -> m b) -> Bundle m v a -> m ()

-- | Transform a <a>Bundle</a> to use a different monad
trans :: (Monad m, Monad m') => (forall z. m z -> m' z) -> Bundle m v a -> Bundle m' v a
unbox :: Monad m => Bundle m v (Box a) -> Bundle m v a
concatMap :: Monad m => (a -> Bundle m v b) -> Bundle m v a -> Bundle m v b

-- | Create a <a>Bundle</a> of values from a <a>Bundle</a> of streamable
--   things
flatten :: Monad m => (a -> m s) -> (s -> m (Step s b)) -> Size -> Bundle m v a -> Bundle m v b

-- | Pair each element in a <a>Bundle</a> with its index
indexed :: Monad m => Bundle m v a -> Bundle m v (Int, a)

-- | Pair each element in a <a>Bundle</a> with its index, starting from the
--   right and counting down
indexedR :: Monad m => Int -> Bundle m v a -> Bundle m v (Int, a)
zipWithM_ :: Monad m => (a -> b -> m c) -> Bundle m v a -> Bundle m v b -> m ()

-- | Zip two <a>Bundle</a>s with the given monadic function
zipWithM :: Monad m => (a -> b -> m c) -> Bundle m v a -> Bundle m v b -> Bundle m v c
zipWith3M :: Monad m => (a -> b -> c -> m d) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d
zipWith4M :: Monad m => (a -> b -> c -> d -> m e) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e
zipWith5M :: Monad m => (a -> b -> c -> d -> e -> m f) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f
zipWith6M :: Monad m => (a -> b -> c -> d -> e -> f -> m g) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f -> Bundle m v g
zipWith :: Monad m => (a -> b -> c) -> Bundle m v a -> Bundle m v b -> Bundle m v c
zipWith3 :: Monad m => (a -> b -> c -> d) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d
zipWith4 :: Monad m => (a -> b -> c -> d -> e) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e
zipWith5 :: Monad m => (a -> b -> c -> d -> e -> f) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f
zipWith6 :: Monad m => (a -> b -> c -> d -> e -> f -> g) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f -> Bundle m v g
zip :: Monad m => Bundle m v a -> Bundle m v b -> Bundle m v (a, b)
zip3 :: Monad m => Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v (a, b, c)
zip4 :: Monad m => Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v (a, b, c, d)
zip5 :: Monad m => Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v (a, b, c, d, e)
zip6 :: Monad m => Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f -> Bundle m v (a, b, c, d, e, f)

-- | Check if two <a>Bundle</a>s are equal
eqBy :: Monad m => (a -> b -> Bool) -> Bundle m v a -> Bundle m v b -> m Bool

-- | Lexicographically compare two <a>Bundle</a>s
cmpBy :: Monad m => (a -> b -> Ordering) -> Bundle m v a -> Bundle m v b -> m Ordering

-- | Drop elements which do not satisfy the predicate
filter :: Monad m => (a -> Bool) -> Bundle m v a -> Bundle m v a

-- | Drop elements which do not satisfy the monadic predicate
filterM :: Monad m => (a -> m Bool) -> Bundle m v a -> Bundle m v a

-- | Longest prefix of elements that satisfy the predicate
takeWhile :: Monad m => (a -> Bool) -> Bundle m v a -> Bundle m v a

-- | Longest prefix of elements that satisfy the monadic predicate
takeWhileM :: Monad m => (a -> m Bool) -> Bundle m v a -> Bundle m v a

-- | Drop the longest prefix of elements that satisfy the predicate
dropWhile :: Monad m => (a -> Bool) -> Bundle m v a -> Bundle m v a

-- | Drop the longest prefix of elements that satisfy the monadic predicate
dropWhileM :: Monad m => (a -> m Bool) -> Bundle m v a -> Bundle m v a

-- | Check whether the <a>Bundle</a> contains an element
elem :: (Monad m, Eq a) => a -> Bundle m v a -> m Bool
infix 4 `elem`

-- | Inverse of <a>elem</a>
notElem :: (Monad m, Eq a) => a -> Bundle m v a -> m Bool
infix 4 `notElem`

-- | Yield <a>Just</a> the first element that satisfies the predicate or
--   <a>Nothing</a> if no such element exists.
find :: Monad m => (a -> Bool) -> Bundle m v a -> m (Maybe a)

-- | Yield <a>Just</a> the first element that satisfies the monadic
--   predicate or <a>Nothing</a> if no such element exists.
findM :: Monad m => (a -> m Bool) -> Bundle m v a -> m (Maybe a)

-- | Yield <a>Just</a> the index of the first element that satisfies the
--   predicate or <a>Nothing</a> if no such element exists.
findIndex :: Monad m => (a -> Bool) -> Bundle m v a -> m (Maybe Int)

-- | Yield <a>Just</a> the index of the first element that satisfies the
--   monadic predicate or <a>Nothing</a> if no such element exists.
findIndexM :: Monad m => (a -> m Bool) -> Bundle m v a -> m (Maybe Int)

-- | Left fold
foldl :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> m a

-- | Left fold with a monadic operator
foldlM :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> m a

-- | Left fold over a non-empty <a>Bundle</a>
foldl1 :: Monad m => (a -> a -> a) -> Bundle m v a -> m a

-- | Left fold over a non-empty <a>Bundle</a> with a monadic operator
foldl1M :: Monad m => (a -> a -> m a) -> Bundle m v a -> m a

-- | Same as <a>foldlM</a>
foldM :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> m a

-- | Same as <a>foldl1M</a>
fold1M :: Monad m => (a -> a -> m a) -> Bundle m v a -> m a

-- | Left fold with a strict accumulator
foldl' :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> m a

-- | Left fold with a strict accumulator and a monadic operator
foldlM' :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> m a

-- | Left fold over a non-empty <a>Bundle</a> with a strict accumulator
foldl1' :: Monad m => (a -> a -> a) -> Bundle m v a -> m a

-- | Left fold over a non-empty <a>Bundle</a> with a strict accumulator and
--   a monadic operator
foldl1M' :: Monad m => (a -> a -> m a) -> Bundle m v a -> m a

-- | Same as <a>foldlM'</a>
foldM' :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> m a

-- | Same as <a>foldl1M'</a>
fold1M' :: Monad m => (a -> a -> m a) -> Bundle m v a -> m a

-- | Right fold
foldr :: Monad m => (a -> b -> b) -> b -> Bundle m v a -> m b

-- | Right fold with a monadic operator
foldrM :: Monad m => (a -> b -> m b) -> b -> Bundle m v a -> m b

-- | Right fold over a non-empty stream
foldr1 :: Monad m => (a -> a -> a) -> Bundle m v a -> m a

-- | Right fold over a non-empty stream with a monadic operator
foldr1M :: Monad m => (a -> a -> m a) -> Bundle m v a -> m a
and :: Monad m => Bundle m v Bool -> m Bool
or :: Monad m => Bundle m v Bool -> m Bool
concatMapM :: Monad m => (a -> m (Bundle m v b)) -> Bundle m v a -> Bundle m v b

-- | Unfold
unfoldr :: Monad m => (s -> Maybe (a, s)) -> s -> Bundle m u a

-- | Unfold with a monadic function
unfoldrM :: Monad m => (s -> m (Maybe (a, s))) -> s -> Bundle m u a

-- | Unfold at most <tt>n</tt> elements
unfoldrN :: Monad m => Int -> (s -> Maybe (a, s)) -> s -> Bundle m u a

-- | Unfold at most <tt>n</tt> elements with a monadic functions
unfoldrNM :: Monad m => Int -> (s -> m (Maybe (a, s))) -> s -> Bundle m u a

-- | Apply function n times to value. Zeroth element is original value.
iterateN :: Monad m => Int -> (a -> a) -> a -> Bundle m u a

-- | Apply monadic function n times to value. Zeroth element is original
--   value.
iterateNM :: Monad m => Int -> (a -> m a) -> a -> Bundle m u a

-- | Prefix scan
prescanl :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a

-- | Prefix scan with a monadic operator
prescanlM :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a

-- | Prefix scan with strict accumulator
prescanl' :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a

-- | Prefix scan with strict accumulator and a monadic operator
prescanlM' :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a

-- | Suffix scan
postscanl :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a

-- | Suffix scan with a monadic operator
postscanlM :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a

-- | Suffix scan with strict accumulator
postscanl' :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a

-- | Suffix scan with strict acccumulator and a monadic operator
postscanlM' :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a

-- | Haskell-style scan
scanl :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a

-- | Haskell-style scan with a monadic operator
scanlM :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a

-- | Haskell-style scan with strict accumulator
scanl' :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a

-- | Haskell-style scan with strict accumulator and a monadic operator
scanlM' :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a

-- | Scan over a non-empty <a>Bundle</a>
scanl1 :: Monad m => (a -> a -> a) -> Bundle m v a -> Bundle m v a

-- | Scan over a non-empty <a>Bundle</a> with a monadic operator
scanl1M :: Monad m => (a -> a -> m a) -> Bundle m v a -> Bundle m v a

-- | Scan over a non-empty <a>Bundle</a> with a strict accumulator
scanl1' :: Monad m => (a -> a -> a) -> Bundle m v a -> Bundle m v a

-- | Scan over a non-empty <a>Bundle</a> with a strict accumulator and a
--   monadic operator
scanl1M' :: Monad m => (a -> a -> m a) -> Bundle m v a -> Bundle m v a

-- | Yield a <a>Bundle</a> of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc.
enumFromStepN :: (Num a, Monad m) => a -> a -> Int -> Bundle m v a

-- | Enumerate values
--   
--   <i>WARNING:</i> This operation can be very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromTo :: (Enum a, Monad m) => a -> a -> Bundle m v a

-- | Enumerate values with a given step.
--   
--   <i>WARNING:</i> This operation is very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromThenTo :: (Enum a, Monad m) => a -> a -> a -> Bundle m v a

-- | Convert a <a>Bundle</a> to a list
toList :: Monad m => Bundle m v a -> m [a]

-- | Convert a list to a <a>Bundle</a>
fromList :: Monad m => [a] -> Bundle m v a

-- | Convert the first <tt>n</tt> elements of a list to a <a>Bundle</a>
fromListN :: Monad m => Int -> [a] -> Bundle m v a

-- | Convert a list to a <a>Bundle</a> with the given <a>Size</a> hint.
unsafeFromList :: Monad m => Size -> [a] -> Bundle m v a
fromVector :: (Monad m, Vector v a) => v a -> Bundle m v a
reVector :: Monad m => Bundle m u a -> Bundle m v a
fromVectors :: forall m v a. (Monad m, Vector v a) => [v a] -> Bundle m v a
concatVectors :: (Monad m, Vector v a) => Bundle m u (v a) -> Bundle m v a
fromStream :: Monad m => Stream m a -> Size -> Bundle m v a
chunks :: Bundle m v a -> Stream m (Chunk v a)
elements :: Bundle m v a -> Stream m a
instance GHC.Base.Monad m => GHC.Base.Functor (Data.Vector.Fusion.Bundle.Monadic.Bundle m v)


-- | Bundles for stream fusion
module Data.Vector.Fusion.Bundle

-- | Result of taking a single step in a stream
data Step s a
[Yield] :: a -> s -> Step s a
[Skip] :: s -> Step s a
[Done] :: Step s a
data Chunk v a
Chunk :: Int -> (forall m. (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> m ()) -> Chunk v a

-- | The type of pure streams
type Bundle = Bundle Id

-- | Alternative name for monadic streams
type MBundle = Bundle
inplace :: (forall m. Monad m => Stream m a -> Stream m b) -> (Size -> Size) -> Bundle v a -> Bundle v b

-- | <a>Size</a> hint of a <a>Bundle</a>
size :: Bundle v a -> Size

-- | Attach a <a>Size</a> hint to a <a>Bundle</a>
sized :: Bundle v a -> Size -> Bundle v a

-- | Length of a <a>Bundle</a>
length :: Bundle v a -> Int

-- | Check if a <a>Bundle</a> is empty
null :: Bundle v a -> Bool

-- | Empty <a>Bundle</a>
empty :: Bundle v a

-- | Singleton <a>Bundle</a>
singleton :: a -> Bundle v a

-- | Prepend an element
cons :: a -> Bundle v a -> Bundle v a

-- | Append an element
snoc :: Bundle v a -> a -> Bundle v a

-- | Replicate a value to a given length
replicate :: Int -> a -> Bundle v a

-- | Generate a stream from its indices
generate :: Int -> (Int -> a) -> Bundle v a

-- | Concatenate two <a>Bundle</a>s
(++) :: Bundle v a -> Bundle v a -> Bundle v a
infixr 5 ++

-- | First element of the <a>Bundle</a> or error if empty
head :: Bundle v a -> a

-- | Last element of the <a>Bundle</a> or error if empty
last :: Bundle v a -> a

-- | Element at the given position
(!!) :: Bundle v a -> Int -> a
infixl 9 !!

-- | Element at the given position or <a>Nothing</a> if out of bounds
(!?) :: Bundle v a -> Int -> Maybe a
infixl 9 !?

-- | Extract a substream of the given length starting at the given
--   position.
slice :: Int -> Int -> Bundle v a -> Bundle v a

-- | All but the last element
init :: Bundle v a -> Bundle v a

-- | All but the first element
tail :: Bundle v a -> Bundle v a

-- | The first <tt>n</tt> elements
take :: Int -> Bundle v a -> Bundle v a

-- | All but the first <tt>n</tt> elements
drop :: Int -> Bundle v a -> Bundle v a

-- | Map a function over a <a>Bundle</a>
map :: (a -> b) -> Bundle v a -> Bundle v b
concatMap :: (a -> Bundle v b) -> Bundle v a -> Bundle v b

-- | Create a <a>Bundle</a> of values from a <a>Bundle</a> of streamable
--   things
flatten :: (a -> s) -> (s -> Step s b) -> Size -> Bundle v a -> Bundle v b
unbox :: Bundle v (Box a) -> Bundle v a

-- | Pair each element in a <a>Bundle</a> with its index
indexed :: Bundle v a -> Bundle v (Int, a)

-- | Pair each element in a <a>Bundle</a> with its index, starting from the
--   right and counting down
indexedR :: Int -> Bundle v a -> Bundle v (Int, a)

-- | Zip two <a>Bundle</a>s with the given function
zipWith :: (a -> b -> c) -> Bundle v a -> Bundle v b -> Bundle v c

-- | Zip three <a>Bundle</a>s with the given function
zipWith3 :: (a -> b -> c -> d) -> Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d
zipWith4 :: (a -> b -> c -> d -> e) -> Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e
zipWith5 :: (a -> b -> c -> d -> e -> f) -> Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e -> Bundle v f
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e -> Bundle v f -> Bundle v g
zip :: Bundle v a -> Bundle v b -> Bundle v (a, b)
zip3 :: Bundle v a -> Bundle v b -> Bundle v c -> Bundle v (a, b, c)
zip4 :: Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v (a, b, c, d)
zip5 :: Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e -> Bundle v (a, b, c, d, e)
zip6 :: Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e -> Bundle v f -> Bundle v (a, b, c, d, e, f)

-- | Drop elements which do not satisfy the predicate
filter :: (a -> Bool) -> Bundle v a -> Bundle v a

-- | Longest prefix of elements that satisfy the predicate
takeWhile :: (a -> Bool) -> Bundle v a -> Bundle v a

-- | Drop the longest prefix of elements that satisfy the predicate
dropWhile :: (a -> Bool) -> Bundle v a -> Bundle v a

-- | Check whether the <a>Bundle</a> contains an element
elem :: Eq a => a -> Bundle v a -> Bool
infix 4 `elem`

-- | Inverse of <a>elem</a>
notElem :: Eq a => a -> Bundle v a -> Bool
infix 4 `notElem`

-- | Yield <a>Just</a> the first element matching the predicate or
--   <a>Nothing</a> if no such element exists.
find :: (a -> Bool) -> Bundle v a -> Maybe a

-- | Yield <a>Just</a> the index of the first element matching the
--   predicate or <a>Nothing</a> if no such element exists.
findIndex :: (a -> Bool) -> Bundle v a -> Maybe Int

-- | Left fold
foldl :: (a -> b -> a) -> a -> Bundle v b -> a

-- | Left fold on non-empty <a>Bundle</a>s
foldl1 :: (a -> a -> a) -> Bundle v a -> a

-- | Left fold with strict accumulator
foldl' :: (a -> b -> a) -> a -> Bundle v b -> a

-- | Left fold on non-empty <a>Bundle</a>s with strict accumulator
foldl1' :: (a -> a -> a) -> Bundle v a -> a

-- | Right fold
foldr :: (a -> b -> b) -> b -> Bundle v a -> b

-- | Right fold on non-empty <a>Bundle</a>s
foldr1 :: (a -> a -> a) -> Bundle v a -> a
and :: Bundle v Bool -> Bool
or :: Bundle v Bool -> Bool

-- | Unfold
unfoldr :: (s -> Maybe (a, s)) -> s -> Bundle v a

-- | Unfold at most <tt>n</tt> elements
unfoldrN :: Int -> (s -> Maybe (a, s)) -> s -> Bundle v a

-- | Apply function n-1 times to value. Zeroth element is original value.
iterateN :: Int -> (a -> a) -> a -> Bundle v a

-- | Prefix scan
prescanl :: (a -> b -> a) -> a -> Bundle v b -> Bundle v a

-- | Prefix scan with strict accumulator
prescanl' :: (a -> b -> a) -> a -> Bundle v b -> Bundle v a

-- | Suffix scan
postscanl :: (a -> b -> a) -> a -> Bundle v b -> Bundle v a

-- | Suffix scan with strict accumulator
postscanl' :: (a -> b -> a) -> a -> Bundle v b -> Bundle v a

-- | Haskell-style scan
scanl :: (a -> b -> a) -> a -> Bundle v b -> Bundle v a

-- | Haskell-style scan with strict accumulator
scanl' :: (a -> b -> a) -> a -> Bundle v b -> Bundle v a

-- | Scan over a non-empty <a>Bundle</a>
scanl1 :: (a -> a -> a) -> Bundle v a -> Bundle v a

-- | Scan over a non-empty <a>Bundle</a> with a strict accumulator
scanl1' :: (a -> a -> a) -> Bundle v a -> Bundle v a

-- | Yield a <a>Bundle</a> of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc.
enumFromStepN :: Num a => a -> a -> Int -> Bundle v a

-- | Enumerate values
--   
--   <i>WARNING:</i> This operations can be very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromTo :: Enum a => a -> a -> Bundle v a

-- | Enumerate values with a given step.
--   
--   <i>WARNING:</i> This operations is very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromThenTo :: Enum a => a -> a -> a -> Bundle v a

-- | Convert a <a>Bundle</a> to a list
toList :: Bundle v a -> [a]

-- | Create a <a>Bundle</a> from a list
fromList :: [a] -> Bundle v a

-- | Create a <a>Bundle</a> from the first <tt>n</tt> elements of a list
--   
--   <pre>
--   fromListN n xs = fromList (take n xs)
--   </pre>
fromListN :: Int -> [a] -> Bundle v a
unsafeFromList :: Size -> [a] -> Bundle v a

-- | Convert a pure stream to a monadic stream
lift :: Monad m => Bundle v a -> Bundle m v a
fromVector :: Vector v a => v a -> Bundle v a
reVector :: Bundle u a -> Bundle v a
fromVectors :: Vector v a => [v a] -> Bundle v a
concatVectors :: Vector v a => Bundle u (v a) -> Bundle v a

-- | Apply a monadic action to each element of the stream, producing a
--   monadic stream of results
mapM :: Monad m => (a -> m b) -> Bundle v a -> Bundle m v b

-- | Apply a monadic action to each element of the stream
mapM_ :: Monad m => (a -> m b) -> Bundle v a -> m ()
zipWithM :: Monad m => (a -> b -> m c) -> Bundle v a -> Bundle v b -> Bundle m v c
zipWithM_ :: Monad m => (a -> b -> m c) -> Bundle v a -> Bundle v b -> m ()

-- | Yield a monadic stream of elements that satisfy the monadic predicate
filterM :: Monad m => (a -> m Bool) -> Bundle v a -> Bundle m v a

-- | Monadic fold
foldM :: Monad m => (a -> b -> m a) -> a -> Bundle v b -> m a

-- | Monadic fold over non-empty stream
fold1M :: Monad m => (a -> a -> m a) -> Bundle v a -> m a

-- | Monadic fold with strict accumulator
foldM' :: Monad m => (a -> b -> m a) -> a -> Bundle v b -> m a

-- | Monad fold over non-empty stream with strict accumulator
fold1M' :: Monad m => (a -> a -> m a) -> Bundle v a -> m a

-- | Check if two <a>Bundle</a>s are equal
eq :: Eq a => Bundle v a -> Bundle v a -> Bool

-- | Lexicographically compare two <a>Bundle</a>s
cmp :: Ord a => Bundle v a -> Bundle v a -> Ordering
eqBy :: (a -> b -> Bool) -> Bundle v a -> Bundle v b -> Bool
cmpBy :: (a -> b -> Ordering) -> Bundle v a -> Bundle v b -> Ordering
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Vector.Fusion.Bundle.Monadic.Bundle Data.Vector.Fusion.Util.Id v a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Vector.Fusion.Bundle.Monadic.Bundle Data.Vector.Fusion.Util.Id v a)
instance Data.Functor.Classes.Eq1 (Data.Vector.Fusion.Bundle.Monadic.Bundle Data.Vector.Fusion.Util.Id v)
instance Data.Functor.Classes.Ord1 (Data.Vector.Fusion.Bundle.Monadic.Bundle Data.Vector.Fusion.Util.Id v)


-- | Generic interface to mutable vectors
module Data.Vector.Generic.Mutable

-- | Class of mutable vectors parametrised with a primitive state token.
class MVector v a

-- | Length of the mutable vector. This method should not be called
--   directly, use <a>length</a> instead.
basicLength :: MVector v a => v s a -> Int

-- | Yield a part of the mutable vector without copying it. This method
--   should not be called directly, use <tt>unsafeSlice</tt> instead.
basicUnsafeSlice :: MVector v a => Int -> Int -> v s a -> v s a

-- | Check whether two vectors overlap. This method should not be called
--   directly, use <tt>overlaps</tt> instead.
basicOverlaps :: MVector v a => v s a -> v s a -> Bool

-- | Create a mutable vector of the given length. This method should not be
--   called directly, use <tt>unsafeNew</tt> instead.
basicUnsafeNew :: (MVector v a, PrimMonad m) => Int -> m (v (PrimState m) a)

-- | Initialize a vector to a standard value. This is intended to be called
--   as part of the safe new operation (and similar operations), to
--   properly blank the newly allocated memory if necessary.
--   
--   Vectors that are necessarily initialized as part of creation may
--   implement this as a no-op.
basicInitialize :: (MVector v a, PrimMonad m) => v (PrimState m) a -> m ()

-- | Create a mutable vector of the given length and fill it with an
--   initial value. This method should not be called directly, use
--   <a>replicate</a> instead.
basicUnsafeReplicate :: (MVector v a, PrimMonad m) => Int -> a -> m (v (PrimState m) a)

-- | Yield the element at the given position. This method should not be
--   called directly, use <tt>unsafeRead</tt> instead.
basicUnsafeRead :: (MVector v a, PrimMonad m) => v (PrimState m) a -> Int -> m a

-- | Replace the element at the given position. This method should not be
--   called directly, use <tt>unsafeWrite</tt> instead.
basicUnsafeWrite :: (MVector v a, PrimMonad m) => v (PrimState m) a -> Int -> a -> m ()

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is usually a noop for unboxed
--   vectors. This method should not be called directly, use <tt>clear</tt>
--   instead.
basicClear :: (MVector v a, PrimMonad m) => v (PrimState m) a -> m ()

-- | Set all elements of the vector to the given value. This method should
--   not be called directly, use <tt>set</tt> instead.
basicSet :: (MVector v a, PrimMonad m) => v (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors may not overlap. This method should not
--   be called directly, use <tt>unsafeCopy</tt> instead.
basicUnsafeCopy :: (MVector v a, PrimMonad m) => v (PrimState m) a -> v (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors may overlap. This
--   method should not be called directly, use <tt>unsafeMove</tt> instead.
basicUnsafeMove :: (MVector v a, PrimMonad m) => v (PrimState m) a -> v (PrimState m) a -> m ()

-- | Grow a vector by the given number of elements. This method should not
--   be called directly, use <tt>unsafeGrow</tt> instead.
basicUnsafeGrow :: (MVector v a, PrimMonad m) => v (PrimState m) a -> Int -> m (v (PrimState m) a)

-- | Length of the mutable vector.
length :: MVector v a => v s a -> Int

-- | Check whether the vector is empty
null :: MVector v a => v s a -> Bool

-- | Yield a part of the mutable vector without copying it.
slice :: MVector v a => Int -> Int -> v s a -> v s a
init :: MVector v a => v s a -> v s a
tail :: MVector v a => v s a -> v s a
take :: MVector v a => Int -> v s a -> v s a
drop :: MVector v a => Int -> v s a -> v s a
splitAt :: MVector v a => Int -> v s a -> (v s a, v s a)

-- | Yield a part of the mutable vector without copying it. No bounds
--   checks are performed.
unsafeSlice :: MVector v a => Int -> Int -> v s a -> v s a
unsafeInit :: MVector v a => v s a -> v s a
unsafeTail :: MVector v a => v s a -> v s a
unsafeTake :: MVector v a => Int -> v s a -> v s a
unsafeDrop :: MVector v a => Int -> v s a -> v s a

-- | Check whether two vectors overlap.
overlaps :: MVector v a => v s a -> v s a -> Bool

-- | Create a mutable vector of the given length.
new :: (PrimMonad m, MVector v a) => Int -> m (v (PrimState m) a)

-- | Create a mutable vector of the given length. The memory is not
--   initialized.
unsafeNew :: (PrimMonad m, MVector v a) => Int -> m (v (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with an initial value.
replicate :: (PrimMonad m, MVector v a) => Int -> a -> m (v (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with values produced by repeatedly executing the
--   monadic action.
replicateM :: (PrimMonad m, MVector v a) => Int -> m a -> m (v (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: (PrimMonad m, MVector v a) => v (PrimState m) a -> m (v (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   positive.
grow :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m (v (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   positive but this is not checked.
unsafeGrow :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m (v (PrimState m) a)
growFront :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m (v (PrimState m) a)
unsafeGrowFront :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m (v (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is usually a noop for unboxed
--   vectors.
clear :: (PrimMonad m, MVector v a) => v (PrimState m) a -> m ()

-- | Yield the element at the given position.
read :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m a

-- | Replace the element at the given position.
write :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position.
modify :: (PrimMonad m, MVector v a) => v (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Swap the elements at the given positions.
swap :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> Int -> m ()

-- | Replace the element at the give position and return the old element.
exchange :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> a -> m a

-- | Yield the element at the given position. No bounds checks are
--   performed.
unsafeRead :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m a

-- | Replace the element at the given position. No bounds checks are
--   performed.
unsafeWrite :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position. No bounds checks are
--   performed.
unsafeModify :: (PrimMonad m, MVector v a) => v (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Swap the elements at the given positions. No bounds checks are
--   performed.
unsafeSwap :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> Int -> m ()

-- | Replace the element at the give position and return the old element.
--   No bounds checks are performed.
unsafeExchange :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> a -> m a

-- | Compute the next (lexicographically) permutation of given vector
--   in-place. Returns False when input is the last permtuation
nextPermutation :: (PrimMonad m, Ord e, MVector v e) => v (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: (PrimMonad m, MVector v a) => v (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap.
copy :: (PrimMonad m, MVector v a) => v (PrimState m) a -> v (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length.
--   
--   If the vectors do not overlap, then this is equivalent to <a>copy</a>.
--   Otherwise, the copying is performed as if the source vector were
--   copied to a temporary vector and then the temporary vector was copied
--   to the target vector.
move :: (PrimMonad m, MVector v a) => v (PrimState m) a -> v (PrimState m) a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap. This is not checked.
unsafeCopy :: (PrimMonad m, MVector v a) => v (PrimState m) a -> v (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length, but this is not checked.
--   
--   If the vectors do not overlap, then this is equivalent to
--   <a>unsafeCopy</a>. Otherwise, the copying is performed as if the
--   source vector were copied to a temporary vector and then the temporary
--   vector was copied to the target vector.
unsafeMove :: (PrimMonad m, MVector v a) => v (PrimState m) a -> v (PrimState m) a -> m ()
mstream :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Stream m a
mstreamR :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Stream m a

-- | Create a new mutable vector and fill it with elements from the
--   <a>Bundle</a>. The vector will grow exponentially if the maximum size
--   of the <a>Bundle</a> is unknown.
unstream :: (PrimMonad m, MVector v a) => Bundle u a -> m (v (PrimState m) a)

-- | Create a new mutable vector and fill it with elements from the
--   <a>Bundle</a> from right to left. The vector will grow exponentially
--   if the maximum size of the <a>Bundle</a> is unknown.
unstreamR :: (PrimMonad m, MVector v a) => Bundle u a -> m (v (PrimState m) a)

-- | Create a new mutable vector and fill it with elements from the
--   <a>Bundle</a>. The vector will grow exponentially if the maximum size
--   of the <a>Bundle</a> is unknown.
vunstream :: (PrimMonad m, Vector v a) => Bundle v a -> m (Mutable v (PrimState m) a)

-- | Create a new mutable vector and fill it with elements from the monadic
--   stream. The vector will grow exponentially if the maximum size of the
--   stream is unknown.
munstream :: (PrimMonad m, MVector v a) => MBundle m u a -> m (v (PrimState m) a)

-- | Create a new mutable vector and fill it with elements from the monadic
--   stream from right to left. The vector will grow exponentially if the
--   maximum size of the stream is unknown.
munstreamR :: (PrimMonad m, MVector v a) => MBundle m u a -> m (v (PrimState m) a)
transform :: (PrimMonad m, MVector v a) => (Stream m a -> Stream m a) -> v (PrimState m) a -> m (v (PrimState m) a)
transformR :: (PrimMonad m, MVector v a) => (Stream m a -> Stream m a) -> v (PrimState m) a -> m (v (PrimState m) a)
fill :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Stream m a -> m (v (PrimState m) a)
fillR :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Stream m a -> m (v (PrimState m) a)
unsafeAccum :: (PrimMonad m, MVector v a) => (a -> b -> a) -> v (PrimState m) a -> Bundle u (Int, b) -> m ()
accum :: (PrimMonad m, MVector v a) => (a -> b -> a) -> v (PrimState m) a -> Bundle u (Int, b) -> m ()
unsafeUpdate :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Bundle u (Int, a) -> m ()
update :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Bundle u (Int, a) -> m ()
reverse :: (PrimMonad m, MVector v a) => v (PrimState m) a -> m ()
unstablePartition :: forall m v a. (PrimMonad m, MVector v a) => (a -> Bool) -> v (PrimState m) a -> m Int
unstablePartitionBundle :: (PrimMonad m, MVector v a) => (a -> Bool) -> Bundle u a -> m (v (PrimState m) a, v (PrimState m) a)
partitionBundle :: (PrimMonad m, MVector v a) => (a -> Bool) -> Bundle u a -> m (v (PrimState m) a, v (PrimState m) a)


-- | Purely functional interface to initialisation of mutable vectors
module Data.Vector.Generic.New
data New v a
New :: (forall s. ST s (Mutable v s a)) -> New v a
create :: (forall s. ST s (Mutable v s a)) -> New v a
run :: New v a -> ST s (Mutable v s a)
runPrim :: PrimMonad m => New v a -> m (Mutable v (PrimState m) a)
apply :: (forall s. Mutable v s a -> Mutable v s a) -> New v a -> New v a
modify :: (forall s. Mutable v s a -> ST s ()) -> New v a -> New v a
modifyWithBundle :: (forall s. Mutable v s a -> Bundle u b -> ST s ()) -> New v a -> Bundle u b -> New v a
unstream :: Vector v a => Bundle v a -> New v a
transform :: Vector v a => (forall m. Monad m => Stream m a -> Stream m a) -> (Size -> Size) -> New v a -> New v a
unstreamR :: Vector v a => Bundle v a -> New v a
transformR :: Vector v a => (forall m. Monad m => Stream m a -> Stream m a) -> (Size -> Size) -> New v a -> New v a
slice :: Vector v a => Int -> Int -> New v a -> New v a
init :: Vector v a => New v a -> New v a
tail :: Vector v a => New v a -> New v a
take :: Vector v a => Int -> New v a -> New v a
drop :: Vector v a => Int -> New v a -> New v a
unsafeSlice :: Vector v a => Int -> Int -> New v a -> New v a
unsafeInit :: Vector v a => New v a -> New v a
unsafeTail :: Vector v a => New v a -> New v a


-- | Generic interface to pure vectors.
module Data.Vector.Generic

-- | Class of immutable vectors. Every immutable vector is associated with
--   its mutable version through the <a>Mutable</a> type family. Methods of
--   this class should not be used directly. Instead,
--   <a>Data.Vector.Generic</a> and other Data.Vector modules provide safe
--   and fusible wrappers.
--   
--   Minimum complete implementation:
--   
--   <ul>
--   <li><a>basicUnsafeFreeze</a></li>
--   <li><a>basicUnsafeThaw</a></li>
--   <li><a>basicLength</a></li>
--   <li><a>basicUnsafeSlice</a></li>
--   <li><a>basicUnsafeIndexM</a></li>
--   </ul>
class MVector (Mutable v) a => Vector v a

-- | <i>Assumed complexity: O(1)</i>
--   
--   Unsafely convert a mutable vector to its immutable version without
--   copying. The mutable vector may not be used after this operation.
basicUnsafeFreeze :: (Vector v a, PrimMonad m) => Mutable v (PrimState m) a -> m (v a)

-- | <i>Assumed complexity: O(1)</i>
--   
--   Unsafely convert an immutable vector to its mutable version without
--   copying. The immutable vector may not be used after this operation.
basicUnsafeThaw :: (Vector v a, PrimMonad m) => v a -> m (Mutable v (PrimState m) a)

-- | <i>Assumed complexity: O(1)</i>
--   
--   Yield the length of the vector.
basicLength :: Vector v a => v a -> Int

-- | <i>Assumed complexity: O(1)</i>
--   
--   Yield a slice of the vector without copying it. No range checks are
--   performed.
basicUnsafeSlice :: Vector v a => Int -> Int -> v a -> v a

-- | <i>Assumed complexity: O(1)</i>
--   
--   Yield the element at the given position in a monad. No range checks
--   are performed.
--   
--   The monad allows us to be strict in the vector if we want. Suppose we
--   had
--   
--   <pre>
--   unsafeIndex :: v a -&gt; Int -&gt; a
--   </pre>
--   
--   instead. Now, if we wanted to copy a vector, we'd do something like
--   
--   <pre>
--   copy mv v ... = ... unsafeWrite mv i (unsafeIndex v i) ...
--   </pre>
--   
--   For lazy vectors, the indexing would not be evaluated which means that
--   we would retain a reference to the original vector in each element we
--   write. This is not what we want!
--   
--   With <a>basicUnsafeIndexM</a>, we can do
--   
--   <pre>
--   copy mv v ... = ... case basicUnsafeIndexM v i of
--                         Box x -&gt; unsafeWrite mv i x ...
--   </pre>
--   
--   which does not have this problem because indexing (but not the
--   returned element!) is evaluated immediately.
basicUnsafeIndexM :: (Vector v a, Monad m) => v a -> Int -> m a

-- | <i>Assumed complexity: O(n)</i>
--   
--   Copy an immutable vector into a mutable one. The two vectors must have
--   the same length but this is not checked.
--   
--   Instances of <a>Vector</a> should redefine this method if they wish to
--   support an efficient block copy operation.
--   
--   Default definition: copying basic on <a>basicUnsafeIndexM</a> and
--   <tt>basicUnsafeWrite</tt>.
basicUnsafeCopy :: (Vector v a, PrimMonad m) => Mutable v (PrimState m) a -> v a -> m ()

-- | Evaluate <tt>a</tt> as far as storing it in a vector would and yield
--   <tt>b</tt>. The <tt>v a</tt> argument only fixes the type and is not
--   touched. The method is only used for optimisation purposes. Thus, it
--   is safe for instances of <a>Vector</a> to evaluate <tt>a</tt> less
--   than it would be when stored in a vector although this might result in
--   suboptimal code.
--   
--   <pre>
--   elemseq v x y = (singleton x `asTypeOf` v) `seq` y
--   </pre>
--   
--   Default defintion: <tt>a</tt> is not evaluated at all
elemseq :: Vector v a => v a -> a -> b -> b

-- | <tt>Mutable v s a</tt> is the mutable version of the pure vector type
--   <tt>v a</tt> with the state token <tt>s</tt>. It is injective on GHC 8
--   and newer.
type family Mutable (v :: * -> *) = (mv :: * -> * -> *) | mv -> v

-- | <i>O(1)</i> Yield the length of the vector
length :: Vector v a => v a -> Int

-- | <i>O(1)</i> Test whether a vector is empty
null :: Vector v a => v a -> Bool

-- | O(1) Indexing
(!) :: Vector v a => v a -> Int -> a
infixl 9 !

-- | O(1) Safe indexing
(!?) :: Vector v a => v a -> Int -> Maybe a
infixl 9 !?

-- | <i>O(1)</i> First element
head :: Vector v a => v a -> a

-- | <i>O(1)</i> Last element
last :: Vector v a => v a -> a

-- | <i>O(1)</i> Unsafe indexing without bounds checking
unsafeIndex :: Vector v a => v a -> Int -> a

-- | <i>O(1)</i> First element without checking if the vector is empty
unsafeHead :: Vector v a => v a -> a

-- | <i>O(1)</i> Last element without checking if the vector is empty
unsafeLast :: Vector v a => v a -> a

-- | <i>O(1)</i> Indexing in a monad.
--   
--   The monad allows operations to be strict in the vector when necessary.
--   Suppose vector copying is implemented like this:
--   
--   <pre>
--   copy mv v = ... write mv i (v ! i) ...
--   </pre>
--   
--   For lazy vectors, <tt>v ! i</tt> would not be evaluated which means
--   that <tt>mv</tt> would unnecessarily retain a reference to <tt>v</tt>
--   in each element written.
--   
--   With <a>indexM</a>, copying can be implemented like this instead:
--   
--   <pre>
--   copy mv v = ... do
--                     x &lt;- indexM v i
--                     write mv i x
--   </pre>
--   
--   Here, no references to <tt>v</tt> are retained because indexing (but
--   <i>not</i> the elements) is evaluated eagerly.
indexM :: (Vector v a, Monad m) => v a -> Int -> m a

-- | <i>O(1)</i> First element of a vector in a monad. See <a>indexM</a>
--   for an explanation of why this is useful.
headM :: (Vector v a, Monad m) => v a -> m a

-- | <i>O(1)</i> Last element of a vector in a monad. See <a>indexM</a> for
--   an explanation of why this is useful.
lastM :: (Vector v a, Monad m) => v a -> m a

-- | <i>O(1)</i> Indexing in a monad without bounds checks. See
--   <a>indexM</a> for an explanation of why this is useful.
unsafeIndexM :: (Vector v a, Monad m) => v a -> Int -> m a

-- | <i>O(1)</i> First element in a monad without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeHeadM :: (Vector v a, Monad m) => v a -> m a

-- | <i>O(1)</i> Last element in a monad without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeLastM :: (Vector v a, Monad m) => v a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it. The vector
--   must contain at least <tt>i+n</tt> elements.
slice :: Vector v a => Int -> Int -> v a -> v a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty.
init :: Vector v a => v a -> v a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty.
tail :: Vector v a => v a -> v a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements without copying. The
--   vector may contain less than <tt>n</tt> elements in which case it is
--   returned unchanged.
take :: Vector v a => Int -> v a -> v a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector may contain less than <tt>n</tt> elements in which
--   case an empty vector is returned.
drop :: Vector v a => Int -> v a -> v a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements paired with the
--   remainder without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt> but slightly more
--   efficient.
splitAt :: Vector v a => Int -> v a -> (v a, v a)

-- | <i>O(1)</i> Yield a slice of the vector without copying. The vector
--   must contain at least <tt>i+n</tt> elements but this is not checked.
unsafeSlice :: Vector v a => Int -> Int -> v a -> v a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty but this is not checked.
unsafeInit :: Vector v a => v a -> v a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty but this is not checked.
unsafeTail :: Vector v a => v a -> v a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements without copying. The
--   vector must contain at least <tt>n</tt> elements but this is not
--   checked.
unsafeTake :: Vector v a => Int -> v a -> v a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector must contain at least <tt>n</tt> elements but this
--   is not checked.
unsafeDrop :: Vector v a => Int -> v a -> v a

-- | <i>O(1)</i> Empty vector
empty :: Vector v a => v a

-- | <i>O(1)</i> Vector with exactly one element
singleton :: forall v a. Vector v a => a -> v a

-- | <i>O(n)</i> Vector of the given length with the same value in each
--   position
replicate :: forall v a. Vector v a => Int -> a -> v a

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index
generate :: Vector v a => Int -> (Int -> a) -> v a

-- | <i>O(n)</i> Apply function n times to value. Zeroth element is
--   original value.
iterateN :: Vector v a => Int -> (a -> a) -> a -> v a

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a vector.
replicateM :: (Monad m, Vector v a) => Int -> m a -> m (v a)

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   monadic action to each index
generateM :: (Monad m, Vector v a) => Int -> (Int -> m a) -> m (v a)

-- | <i>O(n)</i> Apply monadic function n times to value. Zeroth element is
--   original value.
iterateNM :: (Monad m, Vector v a) => Int -> (a -> m a) -> a -> m (v a)

-- | Execute the monadic action and freeze the resulting vector.
--   
--   <pre>
--   create (do { v &lt;- <a>new</a> 2; <a>write</a> v 0 'a'; <a>write</a> v 1 'b'; return v }) = &lt;<tt>a</tt>,<tt>b</tt>&gt;
--   </pre>
create :: Vector v a => (forall s. ST s (Mutable v s a)) -> v a

-- | Execute the monadic action and freeze the resulting vectors.
createT :: (Traversable f, Vector v a) => (forall s. ST s (f (Mutable v s a))) -> f (v a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the generator
--   function to a seed. The generator function yields <a>Just</a> the next
--   element and the new seed or <a>Nothing</a> if there are no more
--   elements.
--   
--   <pre>
--   unfoldr (\n -&gt; if n == 0 then Nothing else Just (n,n-1)) 10
--    = &lt;10,9,8,7,6,5,4,3,2,1&gt;
--   </pre>
unfoldr :: Vector v a => (b -> Maybe (a, b)) -> b -> v a

-- | <i>O(n)</i> Construct a vector with at most <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields <a>Just</a> the next element and the new seed or
--   <a>Nothing</a> if there are no more elements.
--   
--   <pre>
--   unfoldrN 3 (\n -&gt; Just (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrN :: Vector v a => Int -> (b -> Maybe (a, b)) -> b -> v a

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
unfoldrM :: (Monad m, Vector v a) => (b -> m (Maybe (a, b))) -> b -> m (v a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
unfoldrNM :: (Monad m, Vector v a) => Int -> (b -> m (Maybe (a, b))) -> b -> m (v a)

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements by repeatedly
--   applying the generator function to the already constructed part of the
--   vector.
--   
--   <pre>
--   constructN 3 f = let a = f &lt;&gt; ; b = f &lt;a&gt; ; c = f &lt;a,b&gt; in f &lt;a,b,c&gt;
--   </pre>
constructN :: forall v a. Vector v a => Int -> (v a -> a) -> v a

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements from right to
--   left by repeatedly applying the generator function to the already
--   constructed part of the vector.
--   
--   <pre>
--   constructrN 3 f = let a = f &lt;&gt; ; b = f&lt;a&gt; ; c = f &lt;b,a&gt; in f &lt;c,b,a&gt;
--   </pre>
constructrN :: forall v a. Vector v a => Int -> (v a -> a) -> v a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+1</tt> etc. This operation is usually more efficient
--   than <a>enumFromTo</a>.
--   
--   <pre>
--   enumFromN 5 3 = &lt;5,6,7&gt;
--   </pre>
enumFromN :: (Vector v a, Num a) => a -> Int -> v a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc. This operations is
--   usually more efficient than <a>enumFromThenTo</a>.
--   
--   <pre>
--   enumFromStepN 1 0.1 5 = &lt;1,1.1,1.2,1.3,1.4&gt;
--   </pre>
enumFromStepN :: forall v a. (Vector v a, Num a) => a -> a -> Int -> v a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If at all
--   possible, use <a>enumFromN</a> instead.
enumFromTo :: (Vector v a, Enum a) => a -> a -> v a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt> with a
--   specific step <tt>z</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromThenTo :: (Vector v a, Enum a) => a -> a -> a -> v a

-- | <i>O(n)</i> Prepend an element
cons :: forall v a. Vector v a => a -> v a -> v a

-- | <i>O(n)</i> Append an element
snoc :: forall v a. Vector v a => v a -> a -> v a

-- | <i>O(m+n)</i> Concatenate two vectors
(++) :: Vector v a => v a -> v a -> v a
infixr 5 ++

-- | <i>O(n)</i> Concatenate all vectors in the list
concat :: Vector v a => [v a] -> v a

-- | <i>O(n)</i> Concatenate all vectors in the non-empty list
concatNE :: Vector v a => NonEmpty (v a) -> v a

-- | <i>O(n)</i> Yield the argument but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: Vector v a => v a -> v a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list, replace the
--   vector element at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: Vector v a => v a -> [(Int, a)] -> v a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the vector of
--   index/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   update &lt;5,9,2,7&gt; &lt;(2,1),(0,3),(2,8)&gt; = &lt;3,9,8,7&gt;
--   </pre>
update :: (Vector v a, Vector v (Int, a)) => v a -> v (Int, a) -> v a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>a</tt> from the value vector, replace
--   the element of the initial vector at position <tt>i</tt> by
--   <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
--   
--   This function is useful for instances of <a>Vector</a> that cannot
--   store pairs. Otherwise, <a>update</a> is probably more convenient.
--   
--   <pre>
--   update_ xs is ys = <a>update</a> xs (<a>zip</a> is ys)
--   </pre>
update_ :: (Vector v a, Vector v Int) => v a -> v Int -> v a -> v a

-- | Same as (<a>//</a>) but without bounds checking.
unsafeUpd :: Vector v a => v a -> [(Int, a)] -> v a

-- | Same as <a>update</a> but without bounds checking.
unsafeUpdate :: (Vector v a, Vector v (Int, a)) => v a -> v (Int, a) -> v a

-- | Same as <a>update_</a> but without bounds checking.
unsafeUpdate_ :: (Vector v a, Vector v Int) => v a -> v Int -> v a -> v a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <pre>
--   accum (+) &lt;5,9,2&gt; [(2,4),(1,6),(0,3),(1,7)] = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accum :: Vector v a => (a -> b -> a) -> v a -> [(Int, b)] -> v a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the vector of pairs,
--   replace the vector element <tt>a</tt> at position <tt>i</tt> by <tt>f
--   a b</tt>.
--   
--   <pre>
--   accumulate (+) &lt;5,9,2&gt; &lt;(2,4),(1,6),(0,3),(1,7)&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accumulate :: (Vector v a, Vector v (Int, b)) => (a -> b -> a) -> v a -> v (Int, b) -> v a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>b</tt> from the the value vector,
--   replace the element of the initial vector at position <tt>i</tt> by
--   <tt>f a b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
--   
--   This function is useful for instances of <a>Vector</a> that cannot
--   store pairs. Otherwise, <a>accumulate</a> is probably more convenient:
--   
--   <pre>
--   accumulate_ f as is bs = <a>accumulate</a> f as (<a>zip</a> is bs)
--   </pre>
accumulate_ :: (Vector v a, Vector v Int, Vector v b) => (a -> b -> a) -> v a -> v Int -> v b -> v a

-- | Same as <a>accum</a> but without bounds checking.
unsafeAccum :: Vector v a => (a -> b -> a) -> v a -> [(Int, b)] -> v a

-- | Same as <a>accumulate</a> but without bounds checking.
unsafeAccumulate :: (Vector v a, Vector v (Int, b)) => (a -> b -> a) -> v a -> v (Int, b) -> v a

-- | Same as <a>accumulate_</a> but without bounds checking.
unsafeAccumulate_ :: (Vector v a, Vector v Int, Vector v b) => (a -> b -> a) -> v a -> v Int -> v b -> v a

-- | <i>O(n)</i> Reverse a vector
reverse :: Vector v a => v a -> v a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<a>!</a>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<a>!</a>) is</tt> but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: (Vector v a, Vector v Int) => v a -> v Int -> v a

-- | Same as <a>backpermute</a> but without bounds checking.
unsafeBackpermute :: (Vector v a, Vector v Int) => v a -> v Int -> v a

-- | Apply a destructive operation to a vector. The operation will be
--   performed in place if it is safe to do so and will modify a copy of
--   the vector otherwise.
--   
--   <pre>
--   modify (\v -&gt; <a>write</a> v 0 'x') (<a>replicate</a> 3 'a') = &lt;'x','a','a'&gt;
--   </pre>
modify :: Vector v a => (forall s. Mutable v s a -> ST s ()) -> v a -> v a

-- | <i>O(n)</i> Pair each element in a vector with its index
indexed :: (Vector v a, Vector v (Int, a)) => v a -> v (Int, a)

-- | <i>O(n)</i> Map a function over a vector
map :: (Vector v a, Vector v b) => (a -> b) -> v a -> v b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index
imap :: (Vector v a, Vector v b) => (Int -> a -> b) -> v a -> v b

-- | Map a function over a vector and concatenate the results.
concatMap :: (Vector v a, Vector v b) => (a -> v b) -> v a -> v b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results
mapM :: (Monad m, Vector v a, Vector v b) => (a -> m b) -> v a -> m (v b)

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, yielding a vector of results
imapM :: (Monad m, Vector v a, Vector v b) => (Int -> a -> m b) -> v a -> m (v b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results
mapM_ :: (Monad m, Vector v a) => (a -> m b) -> v a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, ignoring the results
imapM_ :: (Monad m, Vector v a) => (Int -> a -> m b) -> v a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equivalent to <tt>flip <a>mapM</a></tt>.
forM :: (Monad m, Vector v a, Vector v b) => v a -> (a -> m b) -> m (v b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: (Monad m, Vector v a) => v a -> (a -> m b) -> m ()

-- | <i>O(min(m,n))</i> Zip two vectors with the given function.
zipWith :: (Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> v a -> v b -> v c

-- | Zip three vectors with the given function.
zipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (a -> b -> c -> d) -> v a -> v b -> v c -> v d
zipWith4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => (a -> b -> c -> d -> e) -> v a -> v b -> v c -> v d -> v e
zipWith5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => (a -> b -> c -> d -> e -> f) -> v a -> v b -> v c -> v d -> v e -> v f
zipWith6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => (a -> b -> c -> d -> e -> f -> g) -> v a -> v b -> v c -> v d -> v e -> v f -> v g

-- | <i>O(min(m,n))</i> Zip two vectors with a function that also takes the
--   elements' indices.
izipWith :: (Vector v a, Vector v b, Vector v c) => (Int -> a -> b -> c) -> v a -> v b -> v c
izipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (Int -> a -> b -> c -> d) -> v a -> v b -> v c -> v d
izipWith4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => (Int -> a -> b -> c -> d -> e) -> v a -> v b -> v c -> v d -> v e
izipWith5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => (Int -> a -> b -> c -> d -> e -> f) -> v a -> v b -> v c -> v d -> v e -> v f
izipWith6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => (Int -> a -> b -> c -> d -> e -> f -> g) -> v a -> v b -> v c -> v d -> v e -> v f -> v g

-- | <i>O(min(m,n))</i> Zip two vectors
zip :: (Vector v a, Vector v b, Vector v (a, b)) => v a -> v b -> v (a, b)
zip3 :: (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => v a -> v b -> v c -> v (a, b, c)
zip4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => v a -> v b -> v c -> v d -> v (a, b, c, d)
zip5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => v a -> v b -> v c -> v d -> v e -> v (a, b, c, d, e)
zip6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => v a -> v b -> v c -> v d -> v e -> v f -> v (a, b, c, d, e, f)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   yield a vector of results
zipWithM :: (Monad m, Vector v a, Vector v b, Vector v c) => (a -> b -> m c) -> v a -> v b -> m (v c)

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and yield a vector of results
izipWithM :: (Monad m, Vector v a, Vector v b, Vector v c) => (Int -> a -> b -> m c) -> v a -> v b -> m (v c)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   ignore the results
zipWithM_ :: (Monad m, Vector v a, Vector v b) => (a -> b -> m c) -> v a -> v b -> m ()

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and ignore the results
izipWithM_ :: (Monad m, Vector v a, Vector v b) => (Int -> a -> b -> m c) -> v a -> v b -> m ()

-- | <i>O(min(m,n))</i> Unzip a vector of pairs.
unzip :: (Vector v a, Vector v b, Vector v (a, b)) => v (a, b) -> (v a, v b)
unzip3 :: (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => v (a, b, c) -> (v a, v b, v c)
unzip4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => v (a, b, c, d) -> (v a, v b, v c, v d)
unzip5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => v (a, b, c, d, e) -> (v a, v b, v c, v d, v e)
unzip6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => v (a, b, c, d, e, f) -> (v a, v b, v c, v d, v e, v f)

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate
filter :: Vector v a => (a -> Bool) -> v a -> v a

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate which is
--   applied to values and their indices
ifilter :: Vector v a => (Int -> a -> Bool) -> v a -> v a

-- | <i>O(n)</i> Drop repeated adjacent elements.
uniq :: (Vector v a, Eq a) => v a -> v a

-- | <i>O(n)</i> Drop elements when predicate returns Nothing
mapMaybe :: (Vector v a, Vector v b) => (a -> Maybe b) -> v a -> v b

-- | <i>O(n)</i> Drop elements when predicate, applied to index and value,
--   returns Nothing
imapMaybe :: (Vector v a, Vector v b) => (Int -> a -> Maybe b) -> v a -> v b

-- | <i>O(n)</i> Drop elements that do not satisfy the monadic predicate
filterM :: (Monad m, Vector v a) => (a -> m Bool) -> v a -> m (v a)

-- | <i>O(n)</i> Yield the longest prefix of elements satisfying the
--   predicate without copying.
takeWhile :: Vector v a => (a -> Bool) -> v a -> v a

-- | <i>O(n)</i> Drop the longest prefix of elements that satisfy the
--   predicate without copying.
dropWhile :: Vector v a => (a -> Bool) -> v a -> v a

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The relative order of the elements is preserved at the
--   cost of a sometimes reduced performance compared to
--   <a>unstablePartition</a>.
partition :: Vector v a => (a -> Bool) -> v a -> (v a, v a)

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The order of the elements is not preserved but the
--   operation is often faster than <a>partition</a>.
unstablePartition :: Vector v a => (a -> Bool) -> v a -> (v a, v a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   satisfy the predicate and the rest without copying.
span :: Vector v a => (a -> Bool) -> v a -> (v a, v a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   do not satisfy the predicate and the rest without copying.
break :: Vector v a => (a -> Bool) -> v a -> (v a, v a)

-- | <i>O(n)</i> Check if the vector contains an element
elem :: (Vector v a, Eq a) => a -> v a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>)
notElem :: (Vector v a, Eq a) => a -> v a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
find :: Vector v a => (a -> Bool) -> v a -> Maybe a

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: Vector v a => (a -> Bool) -> v a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of elements satisfying the predicate in
--   ascending order.
findIndices :: (Vector v a, Vector v Int) => (a -> Bool) -> v a -> v Int

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurence of the
--   given element or <a>Nothing</a> if the vector does not contain the
--   element. This is a specialised version of <a>findIndex</a>.
elemIndex :: (Vector v a, Eq a) => a -> v a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of all occurences of the given element
--   in ascending order. This is a specialised version of
--   <a>findIndices</a>.
elemIndices :: (Vector v a, Vector v Int, Eq a) => a -> v a -> v Int

-- | <i>O(n)</i> Left fold
foldl :: Vector v b => (a -> b -> a) -> a -> v b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors
foldl1 :: Vector v a => (a -> a -> a) -> v a -> a

-- | <i>O(n)</i> Left fold with strict accumulator
foldl' :: Vector v b => (a -> b -> a) -> a -> v b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator
foldl1' :: Vector v a => (a -> a -> a) -> v a -> a

-- | <i>O(n)</i> Right fold
foldr :: Vector v a => (a -> b -> b) -> b -> v a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors
foldr1 :: Vector v a => (a -> a -> a) -> v a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator
foldr' :: Vector v a => (a -> b -> b) -> b -> v a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator
foldr1' :: Vector v a => (a -> a -> a) -> v a -> a

-- | <i>O(n)</i> Left fold (function applied to each element and its index)
ifoldl :: Vector v b => (a -> Int -> b -> a) -> a -> v b -> a

-- | <i>O(n)</i> Left fold with strict accumulator (function applied to
--   each element and its index)
ifoldl' :: Vector v b => (a -> Int -> b -> a) -> a -> v b -> a

-- | <i>O(n)</i> Right fold (function applied to each element and its
--   index)
ifoldr :: Vector v a => (Int -> a -> b -> b) -> b -> v a -> b

-- | <i>O(n)</i> Right fold with strict accumulator (function applied to
--   each element and its index)
ifoldr' :: Vector v a => (Int -> a -> b -> b) -> b -> v a -> b

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: Vector v a => (a -> Bool) -> v a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: Vector v a => (a -> Bool) -> v a -> Bool

-- | <i>O(n)</i> Check if all elements are <a>True</a>
and :: Vector v Bool => v Bool -> Bool

-- | <i>O(n)</i> Check if any element is <a>True</a>
or :: Vector v Bool => v Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements
sum :: (Vector v a, Num a) => v a -> a

-- | <i>O(n)</i> Compute the produce of the elements
product :: (Vector v a, Num a) => v a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector. The vector may
--   not be empty.
maximum :: (Vector v a, Ord a) => v a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector according to the
--   given comparison function. The vector may not be empty.
maximumBy :: Vector v a => (a -> a -> Ordering) -> v a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector. The vector may
--   not be empty.
minimum :: (Vector v a, Ord a) => v a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector according to the
--   given comparison function. The vector may not be empty.
minimumBy :: Vector v a => (a -> a -> Ordering) -> v a -> a

-- | <i>O(n)</i> Yield the index of the minimum element of the vector. The
--   vector may not be empty.
minIndex :: (Vector v a, Ord a) => v a -> Int

-- | <i>O(n)</i> Yield the index of the minimum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
minIndexBy :: Vector v a => (a -> a -> Ordering) -> v a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector. The
--   vector may not be empty.
maxIndex :: (Vector v a, Ord a) => v a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
maxIndexBy :: Vector v a => (a -> a -> Ordering) -> v a -> Int

-- | <i>O(n)</i> Monadic fold
foldM :: (Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m a

-- | <i>O(n)</i> Monadic fold (action applied to each element and its
--   index)
ifoldM :: (Monad m, Vector v b) => (a -> Int -> b -> m a) -> a -> v b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator
foldM' :: (Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator (action applied to
--   each element and its index)
ifoldM' :: (Monad m, Vector v b) => (a -> Int -> b -> m a) -> a -> v b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors
fold1M :: (Monad m, Vector v a) => (a -> a -> m a) -> v a -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator
fold1M' :: (Monad m, Vector v a) => (a -> a -> m a) -> v a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result
foldM_ :: (Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m ()

-- | <i>O(n)</i> Monadic fold that discards the result (action applied to
--   each element and its index)
ifoldM_ :: (Monad m, Vector v b) => (a -> Int -> b -> m a) -> a -> v b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result
foldM'_ :: (Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result (action applied to each element and its index)
ifoldM'_ :: (Monad m, Vector v b) => (a -> Int -> b -> m a) -> a -> v b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result
fold1M_ :: (Monad m, Vector v a) => (a -> a -> m a) -> v a -> m ()

-- | <i>O(n)</i> Monad fold over non-empty vectors with strict accumulator
--   that discards the result
fold1M'_ :: (Monad m, Vector v a) => (a -> a -> m a) -> v a -> m ()

-- | Evaluate each action and collect the results
sequence :: (Monad m, Vector v a, Vector v (m a)) => v (m a) -> m (v a)

-- | Evaluate each action and discard the results
sequence_ :: (Monad m, Vector v (m a)) => v (m a) -> m ()

-- | <i>O(n)</i> Prescan
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>prescanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6&gt;</tt>
prescanl :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Prescan with strict accumulator
prescanl' :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Scan
--   
--   <pre>
--   postscanl f z = <a>tail</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>postscanl (+) 0 &lt;1,2,3,4&gt; = &lt;1,3,6,10&gt;</tt>
postscanl :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Scan with strict accumulator
postscanl' :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Haskell-style scan
--   
--   <pre>
--   scanl f z &lt;x1,...,xn&gt; = &lt;y1,...,y(n+1)&gt;
--     where y1 = z
--           yi = f y(i-1) x(i-1)
--   </pre>
--   
--   Example: <tt>scanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6,10&gt;</tt>
scanl :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Haskell-style scan with strict accumulator
scanl' :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Scan over a non-empty vector
--   
--   <pre>
--   scanl f &lt;x1,...,xn&gt; = &lt;y1,...,yn&gt;
--     where y1 = x1
--           yi = f y(i-1) xi
--   </pre>
scanl1 :: Vector v a => (a -> a -> a) -> v a -> v a

-- | <i>O(n)</i> Scan over a non-empty vector with a strict accumulator
scanl1' :: Vector v a => (a -> a -> a) -> v a -> v a

-- | <i>O(n)</i> Scan over a vector with its index
iscanl :: (Vector v a, Vector v b) => (Int -> a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Scan over a vector (strictly) with its index
iscanl' :: (Vector v a, Vector v b) => (Int -> a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Right-to-left prescan
--   
--   <pre>
--   prescanr f z = <a>reverse</a> . <a>prescanl</a> (flip f) z . <a>reverse</a>
--   </pre>
prescanr :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator
prescanr' :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Right-to-left scan
postscanr :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator
postscanr' :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Right-to-left Haskell-style scan
scanr :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Right-to-left Haskell-style scan with strict accumulator
scanr' :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector
scanr1 :: Vector v a => (a -> a -> a) -> v a -> v a

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector with a strict
--   accumulator
scanr1' :: Vector v a => (a -> a -> a) -> v a -> v a

-- | <i>O(n)</i> Right-to-left scan over a vector with its index
iscanr :: (Vector v a, Vector v b) => (Int -> a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Right-to-left scan over a vector (strictly) with its index
iscanr' :: (Vector v a, Vector v b) => (Int -> a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Convert a vector to a list
toList :: Vector v a => v a -> [a]

-- | <i>O(n)</i> Convert a list to a vector
fromList :: Vector v a => [a] -> v a

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector
--   
--   <pre>
--   fromListN n xs = <a>fromList</a> (<a>take</a> n xs)
--   </pre>
fromListN :: Vector v a => Int -> [a] -> v a

-- | <i>O(n)</i> Convert different vector types
convert :: (Vector v a, Vector w a) => v a -> w a

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> m (v a)

-- | <i>O(n)</i> Yield a mutable copy of the immutable vector.
thaw :: (PrimMonad m, Vector v a) => v a -> m (Mutable v (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length.
copy :: (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> v a -> m ()

-- | <i>O(1)</i> Unsafe convert a mutable vector to an immutable one
--   without copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> m (v a)

-- | <i>O(1)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. The immutable vector may not be used after this
--   operation.
unsafeThaw :: (PrimMonad m, Vector v a) => v a -> m (Mutable v (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length. This is not checked.
unsafeCopy :: (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> v a -> m ()

-- | <i>O(1)</i> Convert a vector to a <a>Bundle</a>
stream :: Vector v a => v a -> Bundle v a

-- | <i>O(n)</i> Construct a vector from a <a>Bundle</a>
unstream :: Vector v a => Bundle v a -> v a

-- | <i>O(1)</i> Convert a vector to a <a>Bundle</a>, proceeding from right
--   to left
streamR :: Vector v a => v a -> Bundle u a

-- | <i>O(n)</i> Construct a vector from a <a>Bundle</a>, proceeding from
--   right to left
unstreamR :: Vector v a => Bundle v a -> v a

-- | Construct a vector from a monadic initialiser.
new :: Vector v a => New v a -> v a

-- | Convert a vector to an initialiser which, when run, produces a copy of
--   the vector.
clone :: Vector v a => v a -> New v a

-- | <i>O(n)</i> Check if two vectors are equal. All <a>Vector</a>
--   instances are also instances of <a>Eq</a> and it is usually more
--   appropriate to use those. This function is primarily intended for
--   implementing <a>Eq</a> instances for new vector types.
eq :: (Vector v a, Eq a) => v a -> v a -> Bool

-- | <i>O(n)</i> Compare two vectors lexicographically. All <a>Vector</a>
--   instances are also instances of <a>Ord</a> and it is usually more
--   appropriate to use those. This function is primarily intended for
--   implementing <a>Ord</a> instances for new vector types.
cmp :: (Vector v a, Ord a) => v a -> v a -> Ordering

-- | <i>O(n)</i>
eqBy :: (Vector v a, Vector v b) => (a -> b -> Bool) -> v a -> v b -> Bool

-- | <i>O(n)</i>
cmpBy :: (Vector v a, Vector v b) => (a -> b -> Ordering) -> v a -> v b -> Ordering

-- | Generic definition of <a>showsPrec</a>
showsPrec :: (Vector v a, Show a) => Int -> v a -> ShowS

-- | Generic definition of <a>readPrec</a>
readPrec :: (Vector v a, Read a) => ReadPrec (v a)
liftShowsPrec :: Vector v a => (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> v a -> ShowS

-- | <i>Note:</i> uses <a>ReadS</a>
liftReadsPrec :: Vector v a => (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (v a)

-- | Generic definion of <a>gfoldl</a> that views a <a>Vector</a> as a
--   list.
gfoldl :: (Vector v a, Data a) => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> v a -> c (v a)
dataCast :: (Vector v a, Data a, Typeable v, Typeable t) => (forall d. Data d => c (t d)) -> Maybe (c (v a))
mkType :: String -> DataType


-- | Mutable boxed vectors.
module Data.Vector.Mutable

-- | Mutable boxed vectors keyed on the monad they live in (<a>IO</a> or
--   <tt><tt>ST</tt> s</tt>).
data MVector s a
MVector :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !MutableArray s a -> MVector s a
type IOVector = MVector RealWorld
type STVector s = MVector s

-- | Length of the mutable vector.
length :: MVector s a -> Int

-- | Check whether the vector is empty
null :: MVector s a -> Bool

-- | Yield a part of the mutable vector without copying it.
slice :: Int -> Int -> MVector s a -> MVector s a
init :: MVector s a -> MVector s a
tail :: MVector s a -> MVector s a
take :: Int -> MVector s a -> MVector s a
drop :: Int -> MVector s a -> MVector s a
splitAt :: Int -> MVector s a -> (MVector s a, MVector s a)

-- | Yield a part of the mutable vector without copying it. No bounds
--   checks are performed.
unsafeSlice :: Int -> Int -> MVector s a -> MVector s a
unsafeInit :: MVector s a -> MVector s a
unsafeTail :: MVector s a -> MVector s a
unsafeTake :: Int -> MVector s a -> MVector s a
unsafeDrop :: Int -> MVector s a -> MVector s a

-- | Check whether two vectors overlap.
overlaps :: MVector s a -> MVector s a -> Bool

-- | Create a mutable vector of the given length.
new :: PrimMonad m => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length. The memory is not
--   initialized.
unsafeNew :: PrimMonad m => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with an initial value.
replicate :: PrimMonad m => Int -> a -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with values produced by repeatedly executing the
--   monadic action.
replicateM :: PrimMonad m => Int -> m a -> m (MVector (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: PrimMonad m => MVector (PrimState m) a -> m (MVector (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   positive.
grow :: PrimMonad m => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   positive but this is not checked.
unsafeGrow :: PrimMonad m => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is usually a noop for unboxed
--   vectors.
clear :: PrimMonad m => MVector (PrimState m) a -> m ()

-- | Yield the element at the given position.
read :: PrimMonad m => MVector (PrimState m) a -> Int -> m a

-- | Replace the element at the given position.
write :: PrimMonad m => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position.
modify :: PrimMonad m => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Swap the elements at the given positions.
swap :: PrimMonad m => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Yield the element at the given position. No bounds checks are
--   performed.
unsafeRead :: PrimMonad m => MVector (PrimState m) a -> Int -> m a

-- | Replace the element at the given position. No bounds checks are
--   performed.
unsafeWrite :: PrimMonad m => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position. No bounds checks are
--   performed.
unsafeModify :: PrimMonad m => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Swap the elements at the given positions. No bounds checks are
--   performed.
unsafeSwap :: PrimMonad m => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Compute the next (lexicographically) permutation of given vector
--   in-place. Returns False when input is the last permtuation
nextPermutation :: (PrimMonad m, Ord e) => MVector (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: PrimMonad m => MVector (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap.
copy :: PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length.
--   
--   If the vectors do not overlap, then this is equivalent to <a>copy</a>.
--   Otherwise, the copying is performed as if the source vector were
--   copied to a temporary vector and then the temporary vector was copied
--   to the target vector.
move :: PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap. This is not checked.
unsafeCopy :: PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length, but this is not checked.
--   
--   If the vectors do not overlap, then this is equivalent to
--   <a>unsafeCopy</a>. Otherwise, the copying is performed as if the
--   source vector were copied to a temporary vector and then the temporary
--   vector was copied to the target vector.
unsafeMove :: PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Mutable.MVector a


-- | A library for boxed vectors (that is, polymorphic arrays capable of
--   holding any Haskell value). The vectors come in two flavours:
--   
--   <ul>
--   <li>mutable</li>
--   <li>immutable</li>
--   </ul>
--   
--   and support a rich interface of both list-like operations, and bulk
--   array operations.
--   
--   For unboxed arrays, use <a>Data.Vector.Unboxed</a>
module Data.Vector

-- | Boxed vectors, supporting efficient slicing.
data Vector a

-- | Mutable boxed vectors keyed on the monad they live in (<a>IO</a> or
--   <tt><tt>ST</tt> s</tt>).
data MVector s a

-- | <i>O(1)</i> Yield the length of the vector
length :: Vector a -> Int

-- | <i>O(1)</i> Test whether a vector is empty
null :: Vector a -> Bool

-- | O(1) Indexing
(!) :: Vector a -> Int -> a

-- | O(1) Safe indexing
(!?) :: Vector a -> Int -> Maybe a

-- | <i>O(1)</i> First element
head :: Vector a -> a

-- | <i>O(1)</i> Last element
last :: Vector a -> a

-- | <i>O(1)</i> Unsafe indexing without bounds checking
unsafeIndex :: Vector a -> Int -> a

-- | <i>O(1)</i> First element without checking if the vector is empty
unsafeHead :: Vector a -> a

-- | <i>O(1)</i> Last element without checking if the vector is empty
unsafeLast :: Vector a -> a

-- | <i>O(1)</i> Indexing in a monad.
--   
--   The monad allows operations to be strict in the vector when necessary.
--   Suppose vector copying is implemented like this:
--   
--   <pre>
--   copy mv v = ... write mv i (v ! i) ...
--   </pre>
--   
--   For lazy vectors, <tt>v ! i</tt> would not be evaluated which means
--   that <tt>mv</tt> would unnecessarily retain a reference to <tt>v</tt>
--   in each element written.
--   
--   With <a>indexM</a>, copying can be implemented like this instead:
--   
--   <pre>
--   copy mv v = ... do
--                     x &lt;- indexM v i
--                     write mv i x
--   </pre>
--   
--   Here, no references to <tt>v</tt> are retained because indexing (but
--   <i>not</i> the elements) is evaluated eagerly.
indexM :: Monad m => Vector a -> Int -> m a

-- | <i>O(1)</i> First element of a vector in a monad. See <a>indexM</a>
--   for an explanation of why this is useful.
headM :: Monad m => Vector a -> m a

-- | <i>O(1)</i> Last element of a vector in a monad. See <a>indexM</a> for
--   an explanation of why this is useful.
lastM :: Monad m => Vector a -> m a

-- | <i>O(1)</i> Indexing in a monad without bounds checks. See
--   <a>indexM</a> for an explanation of why this is useful.
unsafeIndexM :: Monad m => Vector a -> Int -> m a

-- | <i>O(1)</i> First element in a monad without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeHeadM :: Monad m => Vector a -> m a

-- | <i>O(1)</i> Last element in a monad without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeLastM :: Monad m => Vector a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it. The vector
--   must contain at least <tt>i+n</tt> elements.
slice :: Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty.
init :: Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty.
tail :: Vector a -> Vector a

-- | <i>O(1)</i> Yield at the first <tt>n</tt> elements without copying.
--   The vector may contain less than <tt>n</tt> elements in which case it
--   is returned unchanged.
take :: Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector may contain less than <tt>n</tt> elements in which
--   case an empty vector is returned.
drop :: Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements paired with the
--   remainder without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt> but slightly more
--   efficient.
splitAt :: Int -> Vector a -> (Vector a, Vector a)

-- | <i>O(1)</i> Yield a slice of the vector without copying. The vector
--   must contain at least <tt>i+n</tt> elements but this is not checked.
unsafeSlice :: Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty but this is not checked.
unsafeInit :: Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty but this is not checked.
unsafeTail :: Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements without copying. The
--   vector must contain at least <tt>n</tt> elements but this is not
--   checked.
unsafeTake :: Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector must contain at least <tt>n</tt> elements but this
--   is not checked.
unsafeDrop :: Int -> Vector a -> Vector a

-- | <i>O(1)</i> Empty vector
empty :: Vector a

-- | <i>O(1)</i> Vector with exactly one element
singleton :: a -> Vector a

-- | <i>O(n)</i> Vector of the given length with the same value in each
--   position
replicate :: Int -> a -> Vector a

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index
generate :: Int -> (Int -> a) -> Vector a

-- | <i>O(n)</i> Apply function n times to value. Zeroth element is
--   original value.
iterateN :: Int -> (a -> a) -> a -> Vector a

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a vector.
replicateM :: Monad m => Int -> m a -> m (Vector a)

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   monadic action to each index
generateM :: Monad m => Int -> (Int -> m a) -> m (Vector a)

-- | <i>O(n)</i> Apply monadic function n times to value. Zeroth element is
--   original value.
iterateNM :: Monad m => Int -> (a -> m a) -> a -> m (Vector a)

-- | Execute the monadic action and freeze the resulting vector.
--   
--   <pre>
--   create (do { v &lt;- new 2; write v 0 'a'; write v 1 'b'; return v }) = &lt;<tt>a</tt>,<tt>b</tt>&gt;
--   </pre>
create :: (forall s. ST s (MVector s a)) -> Vector a

-- | Execute the monadic action and freeze the resulting vectors.
createT :: Traversable f => (forall s. ST s (f (MVector s a))) -> f (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the generator
--   function to a seed. The generator function yields <a>Just</a> the next
--   element and the new seed or <a>Nothing</a> if there are no more
--   elements.
--   
--   <pre>
--   unfoldr (\n -&gt; if n == 0 then Nothing else Just (n,n-1)) 10
--    = &lt;10,9,8,7,6,5,4,3,2,1&gt;
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector with at most <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields <a>Just</a> the next element and the new seed or
--   <a>Nothing</a> if there are no more elements.
--   
--   <pre>
--   unfoldrN 3 (\n -&gt; Just (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrN :: Int -> (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
unfoldrM :: Monad m => (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
unfoldrNM :: Monad m => Int -> (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements by repeatedly
--   applying the generator function to the already constructed part of the
--   vector.
--   
--   <pre>
--   constructN 3 f = let a = f &lt;&gt; ; b = f &lt;a&gt; ; c = f &lt;a,b&gt; in f &lt;a,b,c&gt;
--   </pre>
constructN :: Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements from right to
--   left by repeatedly applying the generator function to the already
--   constructed part of the vector.
--   
--   <pre>
--   constructrN 3 f = let a = f &lt;&gt; ; b = f&lt;a&gt; ; c = f &lt;b,a&gt; in f &lt;c,b,a&gt;
--   </pre>
constructrN :: Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+1</tt> etc. This operation is usually more efficient
--   than <a>enumFromTo</a>.
--   
--   <pre>
--   enumFromN 5 3 = &lt;5,6,7&gt;
--   </pre>
enumFromN :: Num a => a -> Int -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc. This operations is
--   usually more efficient than <a>enumFromThenTo</a>.
--   
--   <pre>
--   enumFromStepN 1 0.1 5 = &lt;1,1.1,1.2,1.3,1.4&gt;
--   </pre>
enumFromStepN :: Num a => a -> a -> Int -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If at all
--   possible, use <a>enumFromN</a> instead.
enumFromTo :: Enum a => a -> a -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt> with a
--   specific step <tt>z</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromThenTo :: Enum a => a -> a -> a -> Vector a

-- | <i>O(n)</i> Prepend an element
cons :: a -> Vector a -> Vector a

-- | <i>O(n)</i> Append an element
snoc :: Vector a -> a -> Vector a

-- | <i>O(m+n)</i> Concatenate two vectors
(++) :: Vector a -> Vector a -> Vector a
infixr 5 ++

-- | <i>O(n)</i> Concatenate all vectors in the list
concat :: [Vector a] -> Vector a

-- | <i>O(n)</i> Yield the argument but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list, replace the
--   vector element at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: Vector a -> [(Int, a)] -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the vector of
--   index/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   update &lt;5,9,2,7&gt; &lt;(2,1),(0,3),(2,8)&gt; = &lt;3,9,8,7&gt;
--   </pre>
update :: Vector a -> Vector (Int, a) -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>a</tt> from the value vector, replace
--   the element of the initial vector at position <tt>i</tt> by
--   <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
--   
--   The function <a>update</a> provides the same functionality and is
--   usually more convenient.
--   
--   <pre>
--   update_ xs is ys = <a>update</a> xs (<a>zip</a> is ys)
--   </pre>
update_ :: Vector a -> Vector Int -> Vector a -> Vector a

-- | Same as (<a>//</a>) but without bounds checking.
unsafeUpd :: Vector a -> [(Int, a)] -> Vector a

-- | Same as <a>update</a> but without bounds checking.
unsafeUpdate :: Vector a -> Vector (Int, a) -> Vector a

-- | Same as <a>update_</a> but without bounds checking.
unsafeUpdate_ :: Vector a -> Vector Int -> Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <pre>
--   accum (+) &lt;5,9,2&gt; [(2,4),(1,6),(0,3),(1,7)] = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accum :: (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the vector of pairs,
--   replace the vector element <tt>a</tt> at position <tt>i</tt> by <tt>f
--   a b</tt>.
--   
--   <pre>
--   accumulate (+) &lt;5,9,2&gt; &lt;(2,4),(1,6),(0,3),(1,7)&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accumulate :: (a -> b -> a) -> Vector a -> Vector (Int, b) -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>b</tt> from the the value vector,
--   replace the element of the initial vector at position <tt>i</tt> by
--   <tt>f a b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
--   
--   The function <a>accumulate</a> provides the same functionality and is
--   usually more convenient.
--   
--   <pre>
--   accumulate_ f as is bs = <a>accumulate</a> f as (<a>zip</a> is bs)
--   </pre>
accumulate_ :: (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | Same as <a>accum</a> but without bounds checking.
unsafeAccum :: (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | Same as <a>accumulate</a> but without bounds checking.
unsafeAccumulate :: (a -> b -> a) -> Vector a -> Vector (Int, b) -> Vector a

-- | Same as <a>accumulate_</a> but without bounds checking.
unsafeAccumulate_ :: (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | <i>O(n)</i> Reverse a vector
reverse :: Vector a -> Vector a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<a>!</a>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<a>!</a>) is</tt> but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: Vector a -> Vector Int -> Vector a

-- | Same as <a>backpermute</a> but without bounds checking.
unsafeBackpermute :: Vector a -> Vector Int -> Vector a

-- | Apply a destructive operation to a vector. The operation will be
--   performed in place if it is safe to do so and will modify a copy of
--   the vector otherwise.
--   
--   <pre>
--   modify (\v -&gt; write v 0 'x') (<a>replicate</a> 3 'a') = &lt;'x','a','a'&gt;
--   </pre>
modify :: (forall s. MVector s a -> ST s ()) -> Vector a -> Vector a

-- | <i>O(n)</i> Pair each element in a vector with its index
indexed :: Vector a -> Vector (Int, a)

-- | <i>O(n)</i> Map a function over a vector
map :: (a -> b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index
imap :: (Int -> a -> b) -> Vector a -> Vector b

-- | Map a function over a vector and concatenate the results.
concatMap :: (a -> Vector b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results
mapM :: Monad m => (a -> m b) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, yielding a vector of results
imapM :: Monad m => (Int -> a -> m b) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results
mapM_ :: Monad m => (a -> m b) -> Vector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, ignoring the results
imapM_ :: Monad m => (Int -> a -> m b) -> Vector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equivalent to <tt>flip <a>mapM</a></tt>.
forM :: Monad m => Vector a -> (a -> m b) -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: Monad m => Vector a -> (a -> m b) -> m ()

-- | <i>O(min(m,n))</i> Zip two vectors with the given function.
zipWith :: (a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors with the given function.
zipWith3 :: (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
zipWith4 :: (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
zipWith5 :: (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(min(m,n))</i> Zip two vectors with a function that also takes the
--   elements' indices.
izipWith :: (Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors and their indices with the given function.
izipWith3 :: (Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
izipWith4 :: (Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
izipWith5 :: (Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
izipWith6 :: (Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | Elementwise pairing of array elements.
zip :: Vector a -> Vector b -> Vector (a, b)

-- | zip together three vectors into a vector of triples
zip3 :: Vector a -> Vector b -> Vector c -> Vector (a, b, c)
zip4 :: Vector a -> Vector b -> Vector c -> Vector d -> Vector (a, b, c, d)
zip5 :: Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector (a, b, c, d, e)
zip6 :: Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector (a, b, c, d, e, f)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   yield a vector of results
zipWithM :: Monad m => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and yield a vector of results
izipWithM :: Monad m => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   ignore the results
zipWithM_ :: Monad m => (a -> b -> m c) -> Vector a -> Vector b -> m ()

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and ignore the results
izipWithM_ :: Monad m => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m ()

-- | <i>O(min(m,n))</i> Unzip a vector of pairs.
unzip :: Vector (a, b) -> (Vector a, Vector b)
unzip3 :: Vector (a, b, c) -> (Vector a, Vector b, Vector c)
unzip4 :: Vector (a, b, c, d) -> (Vector a, Vector b, Vector c, Vector d)
unzip5 :: Vector (a, b, c, d, e) -> (Vector a, Vector b, Vector c, Vector d, Vector e)
unzip6 :: Vector (a, b, c, d, e, f) -> (Vector a, Vector b, Vector c, Vector d, Vector e, Vector f)

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate
filter :: (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate which is
--   applied to values and their indices
ifilter :: (Int -> a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop repeated adjacent elements.
uniq :: Eq a => Vector a -> Vector a

-- | <i>O(n)</i> Drop elements when predicate returns Nothing
mapMaybe :: (a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Drop elements when predicate, applied to index and value,
--   returns Nothing
imapMaybe :: (Int -> a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Drop elements that do not satisfy the monadic predicate
filterM :: Monad m => (a -> m Bool) -> Vector a -> m (Vector a)

-- | <i>O(n)</i> Yield the longest prefix of elements satisfying the
--   predicate without copying.
takeWhile :: (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop the longest prefix of elements that satisfy the
--   predicate without copying.
dropWhile :: (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The relative order of the elements is preserved at the
--   cost of a sometimes reduced performance compared to
--   <a>unstablePartition</a>.
partition :: (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The order of the elements is not preserved but the
--   operation is often faster than <a>partition</a>.
unstablePartition :: (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   satisfy the predicate and the rest without copying.
span :: (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   do not satisfy the predicate and the rest without copying.
break :: (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Check if the vector contains an element
elem :: Eq a => a -> Vector a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>)
notElem :: Eq a => a -> Vector a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
find :: (a -> Bool) -> Vector a -> Maybe a

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: (a -> Bool) -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of elements satisfying the predicate in
--   ascending order.
findIndices :: (a -> Bool) -> Vector a -> Vector Int

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurence of the
--   given element or <a>Nothing</a> if the vector does not contain the
--   element. This is a specialised version of <a>findIndex</a>.
elemIndex :: Eq a => a -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of all occurences of the given element
--   in ascending order. This is a specialised version of
--   <a>findIndices</a>.
elemIndices :: Eq a => a -> Vector a -> Vector Int

-- | <i>O(n)</i> Left fold
foldl :: (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors
foldl1 :: (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold with strict accumulator
foldl' :: (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator
foldl1' :: (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold
foldr :: (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors
foldr1 :: (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator
foldr' :: (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator
foldr1' :: (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold (function applied to each element and its index)
ifoldl :: (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold with strict accumulator (function applied to
--   each element and its index)
ifoldl' :: (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Right fold (function applied to each element and its
--   index)
ifoldr :: (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold with strict accumulator (function applied to
--   each element and its index)
ifoldr' :: (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Check if all elements are <a>True</a>
and :: Vector Bool -> Bool

-- | <i>O(n)</i> Check if any element is <a>True</a>
or :: Vector Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements
sum :: Num a => Vector a -> a

-- | <i>O(n)</i> Compute the produce of the elements
product :: Num a => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector. The vector may
--   not be empty.
maximum :: Ord a => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector according to the
--   given comparison function. The vector may not be empty.
maximumBy :: (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector. The vector may
--   not be empty.
minimum :: Ord a => Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector according to the
--   given comparison function. The vector may not be empty.
minimumBy :: (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the index of the minimum element of the vector. The
--   vector may not be empty.
minIndex :: Ord a => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the minimum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
minIndexBy :: (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector. The
--   vector may not be empty.
maxIndex :: Ord a => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
maxIndexBy :: (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Monadic fold
foldM :: Monad m => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold (action applied to each element and its
--   index)
ifoldM :: Monad m => (a -> Int -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator
foldM' :: Monad m => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator (action applied to
--   each element and its index)
ifoldM' :: Monad m => (a -> Int -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors
fold1M :: Monad m => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator
fold1M' :: Monad m => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result
foldM_ :: Monad m => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold that discards the result (action applied to
--   each element and its index)
ifoldM_ :: Monad m => (a -> Int -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result
foldM'_ :: Monad m => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result (action applied to each element and its index)
ifoldM'_ :: Monad m => (a -> Int -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result
fold1M_ :: Monad m => (a -> a -> m a) -> Vector a -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator that discards the result
fold1M'_ :: Monad m => (a -> a -> m a) -> Vector a -> m ()

-- | Evaluate each action and collect the results
sequence :: Monad m => Vector (m a) -> m (Vector a)

-- | Evaluate each action and discard the results
sequence_ :: Monad m => Vector (m a) -> m ()

-- | <i>O(n)</i> Prescan
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>prescanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6&gt;</tt>
prescanl :: (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Prescan with strict accumulator
prescanl' :: (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Scan
--   
--   <pre>
--   postscanl f z = <a>tail</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>postscanl (+) 0 &lt;1,2,3,4&gt; = &lt;1,3,6,10&gt;</tt>
postscanl :: (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Scan with strict accumulator
postscanl' :: (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Haskell-style scan
--   
--   <pre>
--   scanl f z &lt;x1,...,xn&gt; = &lt;y1,...,y(n+1)&gt;
--     where y1 = z
--           yi = f y(i-1) x(i-1)
--   </pre>
--   
--   Example: <tt>scanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6,10&gt;</tt>
scanl :: (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Haskell-style scan with strict accumulator
scanl' :: (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Scan over a non-empty vector
--   
--   <pre>
--   scanl f &lt;x1,...,xn&gt; = &lt;y1,...,yn&gt;
--     where y1 = x1
--           yi = f y(i-1) xi
--   </pre>
scanl1 :: (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Scan over a non-empty vector with a strict accumulator
scanl1' :: (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Scan over a vector with its index
iscanl :: (Int -> a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Scan over a vector (strictly) with its index
iscanl' :: (Int -> a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Right-to-left prescan
--   
--   <pre>
--   prescanr f z = <a>reverse</a> . <a>prescanl</a> (flip f) z . <a>reverse</a>
--   </pre>
prescanr :: (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator
prescanr' :: (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan
postscanr :: (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator
postscanr' :: (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left Haskell-style scan
scanr :: (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left Haskell-style scan with strict accumulator
scanr' :: (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector
scanr1 :: (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector with a strict
--   accumulator
scanr1' :: (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left scan over a vector with its index
iscanr :: (Int -> a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan over a vector (strictly) with its index
iscanr' :: (Int -> a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Convert a vector to a list
toList :: Vector a -> [a]

-- | <i>O(n)</i> Convert a list to a vector
fromList :: [a] -> Vector a

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector
--   
--   <pre>
--   fromListN n xs = <a>fromList</a> (<a>take</a> n xs)
--   </pre>
fromListN :: Int -> [a] -> Vector a

-- | <i>O(n)</i> Convert different vector types
convert :: (Vector v a, Vector w a) => v a -> w a

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(n)</i> Yield a mutable copy of the immutable vector.
thaw :: PrimMonad m => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length.
copy :: PrimMonad m => MVector (PrimState m) a -> Vector a -> m ()

-- | <i>O(1)</i> Unsafe convert a mutable vector to an immutable one
--   without copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(1)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. The immutable vector may not be used after this
--   operation.
unsafeThaw :: PrimMonad m => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length. This is not checked.
unsafeCopy :: PrimMonad m => MVector (PrimState m) a -> Vector a -> m ()
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Vector.Vector a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Vector.Vector a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Vector.Vector a)
instance Data.Functor.Classes.Show1 Data.Vector.Vector
instance Data.Functor.Classes.Read1 Data.Vector.Vector
instance GHC.Exts.IsList (Data.Vector.Vector a)
instance Data.Data.Data a => Data.Data.Data (Data.Vector.Vector a)
instance Data.Vector.Generic.Base.Vector Data.Vector.Vector a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Vector.Vector a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Vector.Vector a)
instance Data.Functor.Classes.Eq1 Data.Vector.Vector
instance Data.Functor.Classes.Ord1 Data.Vector.Vector
instance GHC.Base.Semigroup (Data.Vector.Vector a)
instance GHC.Base.Monoid (Data.Vector.Vector a)
instance GHC.Base.Functor Data.Vector.Vector
instance GHC.Base.Monad Data.Vector.Vector
instance GHC.Base.MonadPlus Data.Vector.Vector
instance Control.Monad.Zip.MonadZip Data.Vector.Vector
instance GHC.Base.Applicative Data.Vector.Vector
instance GHC.Base.Alternative Data.Vector.Vector
instance Data.Foldable.Foldable Data.Vector.Vector
instance Data.Traversable.Traversable Data.Vector.Vector


-- | Mutable primitive vectors.
module Data.Vector.Primitive.Mutable

-- | Mutable vectors of primitive types.
data MVector s a

-- | offset, length, underlying mutable byte array
MVector :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !MutableByteArray s -> MVector s a
type IOVector = MVector RealWorld
type STVector s = MVector s

-- | Class of types supporting primitive array operations
class Prim a

-- | Length of the mutable vector.
length :: Prim a => MVector s a -> Int

-- | Check whether the vector is empty
null :: Prim a => MVector s a -> Bool

-- | Yield a part of the mutable vector without copying it.
slice :: Prim a => Int -> Int -> MVector s a -> MVector s a
init :: Prim a => MVector s a -> MVector s a
tail :: Prim a => MVector s a -> MVector s a
take :: Prim a => Int -> MVector s a -> MVector s a
drop :: Prim a => Int -> MVector s a -> MVector s a
splitAt :: Prim a => Int -> MVector s a -> (MVector s a, MVector s a)

-- | Yield a part of the mutable vector without copying it. No bounds
--   checks are performed.
unsafeSlice :: Prim a => Int -> Int -> MVector s a -> MVector s a
unsafeInit :: Prim a => MVector s a -> MVector s a
unsafeTail :: Prim a => MVector s a -> MVector s a
unsafeTake :: Prim a => Int -> MVector s a -> MVector s a
unsafeDrop :: Prim a => Int -> MVector s a -> MVector s a

-- | Check whether two vectors overlap.
overlaps :: Prim a => MVector s a -> MVector s a -> Bool

-- | Create a mutable vector of the given length.
new :: (PrimMonad m, Prim a) => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length. The memory is not
--   initialized.
unsafeNew :: (PrimMonad m, Prim a) => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with an initial value.
replicate :: (PrimMonad m, Prim a) => Int -> a -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with values produced by repeatedly executing the
--   monadic action.
replicateM :: (PrimMonad m, Prim a) => Int -> m a -> m (MVector (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> m (MVector (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   positive.
grow :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   positive but this is not checked.
unsafeGrow :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is usually a noop for unboxed
--   vectors.
clear :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> m ()

-- | Yield the element at the given position.
read :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> m a

-- | Replace the element at the given position.
write :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position.
modify :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Swap the elements at the given positions.
swap :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Yield the element at the given position. No bounds checks are
--   performed.
unsafeRead :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> m a

-- | Replace the element at the given position. No bounds checks are
--   performed.
unsafeWrite :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position. No bounds checks are
--   performed.
unsafeModify :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Swap the elements at the given positions. No bounds checks are
--   performed.
unsafeSwap :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Compute the next (lexicographically) permutation of given vector
--   in-place. Returns False when input is the last permtuation
nextPermutation :: (PrimMonad m, Ord e, Prim e) => MVector (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap.
copy :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length.
--   
--   If the vectors do not overlap, then this is equivalent to <a>copy</a>.
--   Otherwise, the copying is performed as if the source vector were
--   copied to a temporary vector and then the temporary vector was copied
--   to the target vector.
move :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap. This is not checked.
unsafeCopy :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length, but this is not checked.
--   
--   If the vectors do not overlap, then this is equivalent to
--   <a>unsafeCopy</a>. Otherwise, the copying is performed as if the
--   source vector were copied to a temporary vector and then the temporary
--   vector was copied to the target vector.
unsafeMove :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
instance Control.DeepSeq.NFData (Data.Vector.Primitive.Mutable.MVector s a)
instance Data.Primitive.Types.Prim a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Primitive.Mutable.MVector a


-- | Unboxed vectors of primitive types. The use of this module is not
--   recommended except in very special cases. Adaptive unboxed vectors
--   defined in <a>Data.Vector.Unboxed</a> are significantly more flexible
--   at no performance cost.
module Data.Vector.Primitive

-- | Unboxed vectors of primitive types
data Vector a

-- | offset, length, underlying byte array
Vector :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !ByteArray -> Vector a

-- | Mutable vectors of primitive types.
data MVector s a

-- | offset, length, underlying mutable byte array
MVector :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !MutableByteArray s -> MVector s a

-- | Class of types supporting primitive array operations
class Prim a

-- | <i>O(1)</i> Yield the length of the vector
length :: Prim a => Vector a -> Int

-- | <i>O(1)</i> Test whether a vector is empty
null :: Prim a => Vector a -> Bool

-- | O(1) Indexing
(!) :: Prim a => Vector a -> Int -> a

-- | O(1) Safe indexing
(!?) :: Prim a => Vector a -> Int -> Maybe a

-- | <i>O(1)</i> First element
head :: Prim a => Vector a -> a

-- | <i>O(1)</i> Last element
last :: Prim a => Vector a -> a

-- | <i>O(1)</i> Unsafe indexing without bounds checking
unsafeIndex :: Prim a => Vector a -> Int -> a

-- | <i>O(1)</i> First element without checking if the vector is empty
unsafeHead :: Prim a => Vector a -> a

-- | <i>O(1)</i> Last element without checking if the vector is empty
unsafeLast :: Prim a => Vector a -> a

-- | <i>O(1)</i> Indexing in a monad.
--   
--   The monad allows operations to be strict in the vector when necessary.
--   Suppose vector copying is implemented like this:
--   
--   <pre>
--   copy mv v = ... write mv i (v ! i) ...
--   </pre>
--   
--   For lazy vectors, <tt>v ! i</tt> would not be evaluated which means
--   that <tt>mv</tt> would unnecessarily retain a reference to <tt>v</tt>
--   in each element written.
--   
--   With <a>indexM</a>, copying can be implemented like this instead:
--   
--   <pre>
--   copy mv v = ... do
--                     x &lt;- indexM v i
--                     write mv i x
--   </pre>
--   
--   Here, no references to <tt>v</tt> are retained because indexing (but
--   <i>not</i> the elements) is evaluated eagerly.
indexM :: (Prim a, Monad m) => Vector a -> Int -> m a

-- | <i>O(1)</i> First element of a vector in a monad. See <a>indexM</a>
--   for an explanation of why this is useful.
headM :: (Prim a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Last element of a vector in a monad. See <a>indexM</a> for
--   an explanation of why this is useful.
lastM :: (Prim a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Indexing in a monad without bounds checks. See
--   <a>indexM</a> for an explanation of why this is useful.
unsafeIndexM :: (Prim a, Monad m) => Vector a -> Int -> m a

-- | <i>O(1)</i> First element in a monad without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeHeadM :: (Prim a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Last element in a monad without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeLastM :: (Prim a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it. The vector
--   must contain at least <tt>i+n</tt> elements.
slice :: Prim a => Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty.
init :: Prim a => Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty.
tail :: Prim a => Vector a -> Vector a

-- | <i>O(1)</i> Yield at the first <tt>n</tt> elements without copying.
--   The vector may contain less than <tt>n</tt> elements in which case it
--   is returned unchanged.
take :: Prim a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector may contain less than <tt>n</tt> elements in which
--   case an empty vector is returned.
drop :: Prim a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements paired with the
--   remainder without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt> but slightly more
--   efficient.
splitAt :: Prim a => Int -> Vector a -> (Vector a, Vector a)

-- | <i>O(1)</i> Yield a slice of the vector without copying. The vector
--   must contain at least <tt>i+n</tt> elements but this is not checked.
unsafeSlice :: Prim a => Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty but this is not checked.
unsafeInit :: Prim a => Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty but this is not checked.
unsafeTail :: Prim a => Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements without copying. The
--   vector must contain at least <tt>n</tt> elements but this is not
--   checked.
unsafeTake :: Prim a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector must contain at least <tt>n</tt> elements but this
--   is not checked.
unsafeDrop :: Prim a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Empty vector
empty :: Prim a => Vector a

-- | <i>O(1)</i> Vector with exactly one element
singleton :: Prim a => a -> Vector a

-- | <i>O(n)</i> Vector of the given length with the same value in each
--   position
replicate :: Prim a => Int -> a -> Vector a

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index
generate :: Prim a => Int -> (Int -> a) -> Vector a

-- | <i>O(n)</i> Apply function n times to value. Zeroth element is
--   original value.
iterateN :: Prim a => Int -> (a -> a) -> a -> Vector a

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a vector.
replicateM :: (Monad m, Prim a) => Int -> m a -> m (Vector a)

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   monadic action to each index
generateM :: (Monad m, Prim a) => Int -> (Int -> m a) -> m (Vector a)

-- | <i>O(n)</i> Apply monadic function n times to value. Zeroth element is
--   original value.
iterateNM :: (Monad m, Prim a) => Int -> (a -> m a) -> a -> m (Vector a)

-- | Execute the monadic action and freeze the resulting vector.
--   
--   <pre>
--   create (do { v &lt;- new 2; write v 0 'a'; write v 1 'b'; return v }) = &lt;<tt>a</tt>,<tt>b</tt>&gt;
--   </pre>
create :: Prim a => (forall s. ST s (MVector s a)) -> Vector a

-- | Execute the monadic action and freeze the resulting vectors.
createT :: (Traversable f, Prim a) => (forall s. ST s (f (MVector s a))) -> f (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the generator
--   function to a seed. The generator function yields <a>Just</a> the next
--   element and the new seed or <a>Nothing</a> if there are no more
--   elements.
--   
--   <pre>
--   unfoldr (\n -&gt; if n == 0 then Nothing else Just (n,n-1)) 10
--    = &lt;10,9,8,7,6,5,4,3,2,1&gt;
--   </pre>
unfoldr :: Prim a => (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector with at most <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields <a>Just</a> the next element and the new seed or
--   <a>Nothing</a> if there are no more elements.
--   
--   <pre>
--   unfoldrN 3 (\n -&gt; Just (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrN :: Prim a => Int -> (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
unfoldrM :: (Monad m, Prim a) => (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
unfoldrNM :: (Monad m, Prim a) => Int -> (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements by repeatedly
--   applying the generator function to the already constructed part of the
--   vector.
--   
--   <pre>
--   constructN 3 f = let a = f &lt;&gt; ; b = f &lt;a&gt; ; c = f &lt;a,b&gt; in f &lt;a,b,c&gt;
--   </pre>
constructN :: Prim a => Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements from right to
--   left by repeatedly applying the generator function to the already
--   constructed part of the vector.
--   
--   <pre>
--   constructrN 3 f = let a = f &lt;&gt; ; b = f&lt;a&gt; ; c = f &lt;b,a&gt; in f &lt;c,b,a&gt;
--   </pre>
constructrN :: Prim a => Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+1</tt> etc. This operation is usually more efficient
--   than <a>enumFromTo</a>.
--   
--   <pre>
--   enumFromN 5 3 = &lt;5,6,7&gt;
--   </pre>
enumFromN :: (Prim a, Num a) => a -> Int -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc. This operations is
--   usually more efficient than <a>enumFromThenTo</a>.
--   
--   <pre>
--   enumFromStepN 1 0.1 5 = &lt;1,1.1,1.2,1.3,1.4&gt;
--   </pre>
enumFromStepN :: (Prim a, Num a) => a -> a -> Int -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If at all
--   possible, use <a>enumFromN</a> instead.
enumFromTo :: (Prim a, Enum a) => a -> a -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt> with a
--   specific step <tt>z</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromThenTo :: (Prim a, Enum a) => a -> a -> a -> Vector a

-- | <i>O(n)</i> Prepend an element
cons :: Prim a => a -> Vector a -> Vector a

-- | <i>O(n)</i> Append an element
snoc :: Prim a => Vector a -> a -> Vector a

-- | <i>O(m+n)</i> Concatenate two vectors
(++) :: Prim a => Vector a -> Vector a -> Vector a
infixr 5 ++

-- | <i>O(n)</i> Concatenate all vectors in the list
concat :: Prim a => [Vector a] -> Vector a

-- | <i>O(n)</i> Yield the argument but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: Prim a => Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list, replace the
--   vector element at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: Prim a => Vector a -> [(Int, a)] -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>a</tt> from the value vector, replace
--   the element of the initial vector at position <tt>i</tt> by
--   <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
update_ :: Prim a => Vector a -> Vector Int -> Vector a -> Vector a

-- | Same as (<a>//</a>) but without bounds checking.
unsafeUpd :: Prim a => Vector a -> [(Int, a)] -> Vector a

-- | Same as <a>update_</a> but without bounds checking.
unsafeUpdate_ :: Prim a => Vector a -> Vector Int -> Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <pre>
--   accum (+) &lt;5,9,2&gt; [(2,4),(1,6),(0,3),(1,7)] = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accum :: Prim a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>b</tt> from the the value vector,
--   replace the element of the initial vector at position <tt>i</tt> by
--   <tt>f a b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accumulate_ :: (Prim a, Prim b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | Same as <a>accum</a> but without bounds checking.
unsafeAccum :: Prim a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | Same as <a>accumulate_</a> but without bounds checking.
unsafeAccumulate_ :: (Prim a, Prim b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | <i>O(n)</i> Reverse a vector
reverse :: Prim a => Vector a -> Vector a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<a>!</a>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<a>!</a>) is</tt> but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: Prim a => Vector a -> Vector Int -> Vector a

-- | Same as <a>backpermute</a> but without bounds checking.
unsafeBackpermute :: Prim a => Vector a -> Vector Int -> Vector a

-- | Apply a destructive operation to a vector. The operation will be
--   performed in place if it is safe to do so and will modify a copy of
--   the vector otherwise.
--   
--   <pre>
--   modify (\v -&gt; write v 0 'x') (<a>replicate</a> 3 'a') = &lt;'x','a','a'&gt;
--   </pre>
modify :: Prim a => (forall s. MVector s a -> ST s ()) -> Vector a -> Vector a

-- | <i>O(n)</i> Map a function over a vector
map :: (Prim a, Prim b) => (a -> b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index
imap :: (Prim a, Prim b) => (Int -> a -> b) -> Vector a -> Vector b

-- | Map a function over a vector and concatenate the results.
concatMap :: (Prim a, Prim b) => (a -> Vector b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results
mapM :: (Monad m, Prim a, Prim b) => (a -> m b) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results
mapM_ :: (Monad m, Prim a) => (a -> m b) -> Vector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equivalent to <tt>flip <a>mapM</a></tt>.
forM :: (Monad m, Prim a, Prim b) => Vector a -> (a -> m b) -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: (Monad m, Prim a) => Vector a -> (a -> m b) -> m ()

-- | <i>O(min(m,n))</i> Zip two vectors with the given function.
zipWith :: (Prim a, Prim b, Prim c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors with the given function.
zipWith3 :: (Prim a, Prim b, Prim c, Prim d) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
zipWith4 :: (Prim a, Prim b, Prim c, Prim d, Prim e) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
zipWith5 :: (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f) => (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
zipWith6 :: (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f, Prim g) => (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(min(m,n))</i> Zip two vectors with a function that also takes the
--   elements' indices.
izipWith :: (Prim a, Prim b, Prim c) => (Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors and their indices with the given function.
izipWith3 :: (Prim a, Prim b, Prim c, Prim d) => (Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
izipWith4 :: (Prim a, Prim b, Prim c, Prim d, Prim e) => (Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
izipWith5 :: (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f) => (Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
izipWith6 :: (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f, Prim g) => (Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   yield a vector of results
zipWithM :: (Monad m, Prim a, Prim b, Prim c) => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   ignore the results
zipWithM_ :: (Monad m, Prim a, Prim b) => (a -> b -> m c) -> Vector a -> Vector b -> m ()

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate
filter :: Prim a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate which is
--   applied to values and their indices
ifilter :: Prim a => (Int -> a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop repeated adjacent elements.
uniq :: (Prim a, Eq a) => Vector a -> Vector a

-- | <i>O(n)</i> Drop elements when predicate returns Nothing
mapMaybe :: (Prim a, Prim b) => (a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Drop elements when predicate, applied to index and value,
--   returns Nothing
imapMaybe :: (Prim a, Prim b) => (Int -> a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Drop elements that do not satisfy the monadic predicate
filterM :: (Monad m, Prim a) => (a -> m Bool) -> Vector a -> m (Vector a)

-- | <i>O(n)</i> Yield the longest prefix of elements satisfying the
--   predicate without copying.
takeWhile :: Prim a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop the longest prefix of elements that satisfy the
--   predicate without copying.
dropWhile :: Prim a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The relative order of the elements is preserved at the
--   cost of a sometimes reduced performance compared to
--   <a>unstablePartition</a>.
partition :: Prim a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The order of the elements is not preserved but the
--   operation is often faster than <a>partition</a>.
unstablePartition :: Prim a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   satisfy the predicate and the rest without copying.
span :: Prim a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   do not satisfy the predicate and the rest without copying.
break :: Prim a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Check if the vector contains an element
elem :: (Prim a, Eq a) => a -> Vector a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>)
notElem :: (Prim a, Eq a) => a -> Vector a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
find :: Prim a => (a -> Bool) -> Vector a -> Maybe a

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: Prim a => (a -> Bool) -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of elements satisfying the predicate in
--   ascending order.
findIndices :: Prim a => (a -> Bool) -> Vector a -> Vector Int

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurence of the
--   given element or <a>Nothing</a> if the vector does not contain the
--   element. This is a specialised version of <a>findIndex</a>.
elemIndex :: (Prim a, Eq a) => a -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of all occurences of the given element
--   in ascending order. This is a specialised version of
--   <a>findIndices</a>.
elemIndices :: (Prim a, Eq a) => a -> Vector a -> Vector Int

-- | <i>O(n)</i> Left fold
foldl :: Prim b => (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors
foldl1 :: Prim a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold with strict accumulator
foldl' :: Prim b => (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator
foldl1' :: Prim a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold
foldr :: Prim a => (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors
foldr1 :: Prim a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator
foldr' :: Prim a => (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator
foldr1' :: Prim a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold (function applied to each element and its index)
ifoldl :: Prim b => (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold with strict accumulator (function applied to
--   each element and its index)
ifoldl' :: Prim b => (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Right fold (function applied to each element and its
--   index)
ifoldr :: Prim a => (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold with strict accumulator (function applied to
--   each element and its index)
ifoldr' :: Prim a => (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: Prim a => (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: Prim a => (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Compute the sum of the elements
sum :: (Prim a, Num a) => Vector a -> a

-- | <i>O(n)</i> Compute the produce of the elements
product :: (Prim a, Num a) => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector. The vector may
--   not be empty.
maximum :: (Prim a, Ord a) => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector according to the
--   given comparison function. The vector may not be empty.
maximumBy :: Prim a => (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector. The vector may
--   not be empty.
minimum :: (Prim a, Ord a) => Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector according to the
--   given comparison function. The vector may not be empty.
minimumBy :: Prim a => (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the index of the minimum element of the vector. The
--   vector may not be empty.
minIndex :: (Prim a, Ord a) => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the minimum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
minIndexBy :: Prim a => (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector. The
--   vector may not be empty.
maxIndex :: (Prim a, Ord a) => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
maxIndexBy :: Prim a => (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Monadic fold
foldM :: (Monad m, Prim b) => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator
foldM' :: (Monad m, Prim b) => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors
fold1M :: (Monad m, Prim a) => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator
fold1M' :: (Monad m, Prim a) => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result
foldM_ :: (Monad m, Prim b) => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result
foldM'_ :: (Monad m, Prim b) => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result
fold1M_ :: (Monad m, Prim a) => (a -> a -> m a) -> Vector a -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator that discards the result
fold1M'_ :: (Monad m, Prim a) => (a -> a -> m a) -> Vector a -> m ()

-- | <i>O(n)</i> Prescan
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>prescanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6&gt;</tt>
prescanl :: (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Prescan with strict accumulator
prescanl' :: (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Scan
--   
--   <pre>
--   postscanl f z = <a>tail</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>postscanl (+) 0 &lt;1,2,3,4&gt; = &lt;1,3,6,10&gt;</tt>
postscanl :: (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Scan with strict accumulator
postscanl' :: (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Haskell-style scan
--   
--   <pre>
--   scanl f z &lt;x1,...,xn&gt; = &lt;y1,...,y(n+1)&gt;
--     where y1 = z
--           yi = f y(i-1) x(i-1)
--   </pre>
--   
--   Example: <tt>scanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6,10&gt;</tt>
scanl :: (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Haskell-style scan with strict accumulator
scanl' :: (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Scan over a non-empty vector
--   
--   <pre>
--   scanl f &lt;x1,...,xn&gt; = &lt;y1,...,yn&gt;
--     where y1 = x1
--           yi = f y(i-1) xi
--   </pre>
scanl1 :: Prim a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Scan over a non-empty vector with a strict accumulator
scanl1' :: Prim a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left prescan
--   
--   <pre>
--   prescanr f z = <a>reverse</a> . <a>prescanl</a> (flip f) z . <a>reverse</a>
--   </pre>
prescanr :: (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator
prescanr' :: (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan
postscanr :: (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator
postscanr' :: (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left Haskell-style scan
scanr :: (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left Haskell-style scan with strict accumulator
scanr' :: (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector
scanr1 :: Prim a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector with a strict
--   accumulator
scanr1' :: Prim a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Convert a vector to a list
toList :: Prim a => Vector a -> [a]

-- | <i>O(n)</i> Convert a list to a vector
fromList :: Prim a => [a] -> Vector a

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector
--   
--   <pre>
--   fromListN n xs = <a>fromList</a> (<a>take</a> n xs)
--   </pre>
fromListN :: Prim a => Int -> [a] -> Vector a

-- | <i>O(n)</i> Convert different vector types
convert :: (Vector v a, Vector w a) => v a -> w a

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: (Prim a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(n)</i> Yield a mutable copy of the immutable vector.
thaw :: (Prim a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length.
copy :: (Prim a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()

-- | <i>O(1)</i> Unsafe convert a mutable vector to an immutable one
--   without copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: (Prim a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(1)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. The immutable vector may not be used after this
--   operation.
unsafeThaw :: (Prim a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length. This is not checked.
unsafeCopy :: (Prim a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()
instance Control.DeepSeq.NFData (Data.Vector.Primitive.Vector a)
instance (GHC.Show.Show a, Data.Primitive.Types.Prim a) => GHC.Show.Show (Data.Vector.Primitive.Vector a)
instance (GHC.Read.Read a, Data.Primitive.Types.Prim a) => GHC.Read.Read (Data.Vector.Primitive.Vector a)
instance (Data.Data.Data a, Data.Primitive.Types.Prim a) => Data.Data.Data (Data.Vector.Primitive.Vector a)
instance Data.Primitive.Types.Prim a => Data.Vector.Generic.Base.Vector Data.Vector.Primitive.Vector a
instance (Data.Primitive.Types.Prim a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Vector.Primitive.Vector a)
instance (Data.Primitive.Types.Prim a, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Vector.Primitive.Vector a)
instance Data.Primitive.Types.Prim a => GHC.Base.Semigroup (Data.Vector.Primitive.Vector a)
instance Data.Primitive.Types.Prim a => GHC.Base.Monoid (Data.Vector.Primitive.Vector a)
instance Data.Primitive.Types.Prim a => GHC.Exts.IsList (Data.Vector.Primitive.Vector a)


-- | Ugly internal utility functions for implementing
--   <tt>Storable</tt>-based vectors.
module Data.Vector.Storable.Internal
getPtr :: ForeignPtr a -> Ptr a
setPtr :: ForeignPtr a -> Ptr a -> ForeignPtr a
updPtr :: (Ptr a -> Ptr a) -> ForeignPtr a -> ForeignPtr a


-- | Mutable vectors based on Storable.
module Data.Vector.Storable.Mutable

-- | Mutable <a>Storable</a>-based vectors
data MVector s a
MVector :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !ForeignPtr a -> MVector s a
type IOVector = MVector RealWorld
type STVector s = MVector s

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class Storable a

-- | Length of the mutable vector.
length :: Storable a => MVector s a -> Int

-- | Check whether the vector is empty
null :: Storable a => MVector s a -> Bool

-- | Yield a part of the mutable vector without copying it.
slice :: Storable a => Int -> Int -> MVector s a -> MVector s a
init :: Storable a => MVector s a -> MVector s a
tail :: Storable a => MVector s a -> MVector s a
take :: Storable a => Int -> MVector s a -> MVector s a
drop :: Storable a => Int -> MVector s a -> MVector s a
splitAt :: Storable a => Int -> MVector s a -> (MVector s a, MVector s a)

-- | Yield a part of the mutable vector without copying it. No bounds
--   checks are performed.
unsafeSlice :: Storable a => Int -> Int -> MVector s a -> MVector s a
unsafeInit :: Storable a => MVector s a -> MVector s a
unsafeTail :: Storable a => MVector s a -> MVector s a
unsafeTake :: Storable a => Int -> MVector s a -> MVector s a
unsafeDrop :: Storable a => Int -> MVector s a -> MVector s a

-- | Check whether two vectors overlap.
overlaps :: Storable a => MVector s a -> MVector s a -> Bool

-- | Create a mutable vector of the given length.
new :: (PrimMonad m, Storable a) => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length. The memory is not
--   initialized.
unsafeNew :: (PrimMonad m, Storable a) => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with an initial value.
replicate :: (PrimMonad m, Storable a) => Int -> a -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with values produced by repeatedly executing the
--   monadic action.
replicateM :: (PrimMonad m, Storable a) => Int -> m a -> m (MVector (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> m (MVector (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   positive.
grow :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   positive but this is not checked.
unsafeGrow :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is usually a noop for unboxed
--   vectors.
clear :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> m ()

-- | Yield the element at the given position.
read :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> m a

-- | Replace the element at the given position.
write :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position.
modify :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Swap the elements at the given positions.
swap :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Yield the element at the given position. No bounds checks are
--   performed.
unsafeRead :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> m a

-- | Replace the element at the given position. No bounds checks are
--   performed.
unsafeWrite :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position. No bounds checks are
--   performed.
unsafeModify :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Swap the elements at the given positions. No bounds checks are
--   performed.
unsafeSwap :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Set all elements of the vector to the given value.
set :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap.
copy :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length.
--   
--   If the vectors do not overlap, then this is equivalent to <a>copy</a>.
--   Otherwise, the copying is performed as if the source vector were
--   copied to a temporary vector and then the temporary vector was copied
--   to the target vector.
move :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap. This is not checked.
unsafeCopy :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length, but this is not checked.
--   
--   If the vectors do not overlap, then this is equivalent to
--   <a>unsafeCopy</a>. Otherwise, the copying is performed as if the
--   source vector were copied to a temporary vector and then the temporary
--   vector was copied to the target vector.
unsafeMove :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | <i>O(1)</i> Unsafely cast a mutable vector from one element type to
--   another. The operation just changes the type of the underlying pointer
--   and does not modify the elements.
--   
--   The resulting vector contains as many elements as can fit into the
--   underlying memory block.
unsafeCast :: forall a b s. (Storable a, Storable b) => MVector s a -> MVector s b

-- | Create a mutable vector from a <a>ForeignPtr</a> with an offset and a
--   length.
--   
--   Modifying data through the <a>ForeignPtr</a> afterwards is unsafe if
--   the vector could have been frozen before the modification.
--   
--   If your offset is 0 it is more efficient to use
--   <a>unsafeFromForeignPtr0</a>.
unsafeFromForeignPtr :: Storable a => ForeignPtr a -> Int -> Int -> MVector s a

-- | <i>O(1)</i> Create a mutable vector from a <a>ForeignPtr</a> and a
--   length.
--   
--   It is assumed the pointer points directly to the data (no offset). Use
--   <a>unsafeFromForeignPtr</a> if you need to specify an offset.
--   
--   Modifying data through the <a>ForeignPtr</a> afterwards is unsafe if
--   the vector could have been frozen before the modification.
unsafeFromForeignPtr0 :: Storable a => ForeignPtr a -> Int -> MVector s a

-- | Yield the underlying <a>ForeignPtr</a> together with the offset to the
--   data and its length. Modifying the data through the <a>ForeignPtr</a>
--   is unsafe if the vector could have frozen before the modification.
unsafeToForeignPtr :: Storable a => MVector s a -> (ForeignPtr a, Int, Int)

-- | <i>O(1)</i> Yield the underlying <a>ForeignPtr</a> together with its
--   length.
--   
--   You can assume the pointer points directly to the data (no offset).
--   
--   Modifying the data through the <a>ForeignPtr</a> is unsafe if the
--   vector could have frozen before the modification.
unsafeToForeignPtr0 :: Storable a => MVector s a -> (ForeignPtr a, Int)

-- | Pass a pointer to the vector's data to the IO action. Modifying data
--   through the pointer is unsafe if the vector could have been frozen
--   before the modification.
unsafeWith :: Storable a => IOVector a -> (Ptr a -> IO b) -> IO b
instance Control.DeepSeq.NFData (Data.Vector.Storable.Mutable.MVector s a)
instance Foreign.Storable.Storable a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Storable.Mutable.MVector a


-- | <a>Storable</a>-based vectors.
module Data.Vector.Storable

-- | <a>Storable</a>-based vectors
data Vector a

-- | Mutable <a>Storable</a>-based vectors
data MVector s a
MVector :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !ForeignPtr a -> MVector s a

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class Storable a

-- | <i>O(1)</i> Yield the length of the vector
length :: Storable a => Vector a -> Int

-- | <i>O(1)</i> Test whether a vector is empty
null :: Storable a => Vector a -> Bool

-- | O(1) Indexing
(!) :: Storable a => Vector a -> Int -> a

-- | O(1) Safe indexing
(!?) :: Storable a => Vector a -> Int -> Maybe a

-- | <i>O(1)</i> First element
head :: Storable a => Vector a -> a

-- | <i>O(1)</i> Last element
last :: Storable a => Vector a -> a

-- | <i>O(1)</i> Unsafe indexing without bounds checking
unsafeIndex :: Storable a => Vector a -> Int -> a

-- | <i>O(1)</i> First element without checking if the vector is empty
unsafeHead :: Storable a => Vector a -> a

-- | <i>O(1)</i> Last element without checking if the vector is empty
unsafeLast :: Storable a => Vector a -> a

-- | <i>O(1)</i> Indexing in a monad.
--   
--   The monad allows operations to be strict in the vector when necessary.
--   Suppose vector copying is implemented like this:
--   
--   <pre>
--   copy mv v = ... write mv i (v ! i) ...
--   </pre>
--   
--   For lazy vectors, <tt>v ! i</tt> would not be evaluated which means
--   that <tt>mv</tt> would unnecessarily retain a reference to <tt>v</tt>
--   in each element written.
--   
--   With <a>indexM</a>, copying can be implemented like this instead:
--   
--   <pre>
--   copy mv v = ... do
--                     x &lt;- indexM v i
--                     write mv i x
--   </pre>
--   
--   Here, no references to <tt>v</tt> are retained because indexing (but
--   <i>not</i> the elements) is evaluated eagerly.
indexM :: (Storable a, Monad m) => Vector a -> Int -> m a

-- | <i>O(1)</i> First element of a vector in a monad. See <a>indexM</a>
--   for an explanation of why this is useful.
headM :: (Storable a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Last element of a vector in a monad. See <a>indexM</a> for
--   an explanation of why this is useful.
lastM :: (Storable a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Indexing in a monad without bounds checks. See
--   <a>indexM</a> for an explanation of why this is useful.
unsafeIndexM :: (Storable a, Monad m) => Vector a -> Int -> m a

-- | <i>O(1)</i> First element in a monad without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeHeadM :: (Storable a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Last element in a monad without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeLastM :: (Storable a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it. The vector
--   must contain at least <tt>i+n</tt> elements.
slice :: Storable a => Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty.
init :: Storable a => Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty.
tail :: Storable a => Vector a -> Vector a

-- | <i>O(1)</i> Yield at the first <tt>n</tt> elements without copying.
--   The vector may contain less than <tt>n</tt> elements in which case it
--   is returned unchanged.
take :: Storable a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector may contain less than <tt>n</tt> elements in which
--   case an empty vector is returned.
drop :: Storable a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements paired with the
--   remainder without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt> but slightly more
--   efficient.
splitAt :: Storable a => Int -> Vector a -> (Vector a, Vector a)

-- | <i>O(1)</i> Yield a slice of the vector without copying. The vector
--   must contain at least <tt>i+n</tt> elements but this is not checked.
unsafeSlice :: Storable a => Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty but this is not checked.
unsafeInit :: Storable a => Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty but this is not checked.
unsafeTail :: Storable a => Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements without copying. The
--   vector must contain at least <tt>n</tt> elements but this is not
--   checked.
unsafeTake :: Storable a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector must contain at least <tt>n</tt> elements but this
--   is not checked.
unsafeDrop :: Storable a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Empty vector
empty :: Storable a => Vector a

-- | <i>O(1)</i> Vector with exactly one element
singleton :: Storable a => a -> Vector a

-- | <i>O(n)</i> Vector of the given length with the same value in each
--   position
replicate :: Storable a => Int -> a -> Vector a

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index
generate :: Storable a => Int -> (Int -> a) -> Vector a

-- | <i>O(n)</i> Apply function n times to value. Zeroth element is
--   original value.
iterateN :: Storable a => Int -> (a -> a) -> a -> Vector a

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a vector.
replicateM :: (Monad m, Storable a) => Int -> m a -> m (Vector a)

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   monadic action to each index
generateM :: (Monad m, Storable a) => Int -> (Int -> m a) -> m (Vector a)

-- | <i>O(n)</i> Apply monadic function n times to value. Zeroth element is
--   original value.
iterateNM :: (Monad m, Storable a) => Int -> (a -> m a) -> a -> m (Vector a)

-- | Execute the monadic action and freeze the resulting vector.
--   
--   <pre>
--   create (do { v &lt;- new 2; write v 0 'a'; write v 1 'b'; return v }) = &lt;<tt>a</tt>,<tt>b</tt>&gt;
--   </pre>
create :: Storable a => (forall s. ST s (MVector s a)) -> Vector a

-- | Execute the monadic action and freeze the resulting vectors.
createT :: (Traversable f, Storable a) => (forall s. ST s (f (MVector s a))) -> f (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the generator
--   function to a seed. The generator function yields <a>Just</a> the next
--   element and the new seed or <a>Nothing</a> if there are no more
--   elements.
--   
--   <pre>
--   unfoldr (\n -&gt; if n == 0 then Nothing else Just (n,n-1)) 10
--    = &lt;10,9,8,7,6,5,4,3,2,1&gt;
--   </pre>
unfoldr :: Storable a => (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector with at most <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields <a>Just</a> the next element and the new seed or
--   <a>Nothing</a> if there are no more elements.
--   
--   <pre>
--   unfoldrN 3 (\n -&gt; Just (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrN :: Storable a => Int -> (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
unfoldrM :: (Monad m, Storable a) => (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
unfoldrNM :: (Monad m, Storable a) => Int -> (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements by repeatedly
--   applying the generator function to the already constructed part of the
--   vector.
--   
--   <pre>
--   constructN 3 f = let a = f &lt;&gt; ; b = f &lt;a&gt; ; c = f &lt;a,b&gt; in f &lt;a,b,c&gt;
--   </pre>
constructN :: Storable a => Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements from right to
--   left by repeatedly applying the generator function to the already
--   constructed part of the vector.
--   
--   <pre>
--   constructrN 3 f = let a = f &lt;&gt; ; b = f&lt;a&gt; ; c = f &lt;b,a&gt; in f &lt;c,b,a&gt;
--   </pre>
constructrN :: Storable a => Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+1</tt> etc. This operation is usually more efficient
--   than <a>enumFromTo</a>.
--   
--   <pre>
--   enumFromN 5 3 = &lt;5,6,7&gt;
--   </pre>
enumFromN :: (Storable a, Num a) => a -> Int -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc. This operations is
--   usually more efficient than <a>enumFromThenTo</a>.
--   
--   <pre>
--   enumFromStepN 1 0.1 5 = &lt;1,1.1,1.2,1.3,1.4&gt;
--   </pre>
enumFromStepN :: (Storable a, Num a) => a -> a -> Int -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If at all
--   possible, use <a>enumFromN</a> instead.
enumFromTo :: (Storable a, Enum a) => a -> a -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt> with a
--   specific step <tt>z</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromThenTo :: (Storable a, Enum a) => a -> a -> a -> Vector a

-- | <i>O(n)</i> Prepend an element
cons :: Storable a => a -> Vector a -> Vector a

-- | <i>O(n)</i> Append an element
snoc :: Storable a => Vector a -> a -> Vector a

-- | <i>O(m+n)</i> Concatenate two vectors
(++) :: Storable a => Vector a -> Vector a -> Vector a
infixr 5 ++

-- | <i>O(n)</i> Concatenate all vectors in the list
concat :: Storable a => [Vector a] -> Vector a

-- | <i>O(n)</i> Yield the argument but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: Storable a => Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list, replace the
--   vector element at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: Storable a => Vector a -> [(Int, a)] -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>a</tt> from the value vector, replace
--   the element of the initial vector at position <tt>i</tt> by
--   <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
update_ :: Storable a => Vector a -> Vector Int -> Vector a -> Vector a

-- | Same as (<a>//</a>) but without bounds checking.
unsafeUpd :: Storable a => Vector a -> [(Int, a)] -> Vector a

-- | Same as <a>update_</a> but without bounds checking.
unsafeUpdate_ :: Storable a => Vector a -> Vector Int -> Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <pre>
--   accum (+) &lt;5,9,2&gt; [(2,4),(1,6),(0,3),(1,7)] = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accum :: Storable a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>b</tt> from the the value vector,
--   replace the element of the initial vector at position <tt>i</tt> by
--   <tt>f a b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accumulate_ :: (Storable a, Storable b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | Same as <a>accum</a> but without bounds checking.
unsafeAccum :: Storable a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | Same as <a>accumulate_</a> but without bounds checking.
unsafeAccumulate_ :: (Storable a, Storable b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | <i>O(n)</i> Reverse a vector
reverse :: Storable a => Vector a -> Vector a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<a>!</a>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<a>!</a>) is</tt> but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: Storable a => Vector a -> Vector Int -> Vector a

-- | Same as <a>backpermute</a> but without bounds checking.
unsafeBackpermute :: Storable a => Vector a -> Vector Int -> Vector a

-- | Apply a destructive operation to a vector. The operation will be
--   performed in place if it is safe to do so and will modify a copy of
--   the vector otherwise.
--   
--   <pre>
--   modify (\v -&gt; write v 0 'x') (<a>replicate</a> 3 'a') = &lt;'x','a','a'&gt;
--   </pre>
modify :: Storable a => (forall s. MVector s a -> ST s ()) -> Vector a -> Vector a

-- | <i>O(n)</i> Map a function over a vector
map :: (Storable a, Storable b) => (a -> b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index
imap :: (Storable a, Storable b) => (Int -> a -> b) -> Vector a -> Vector b

-- | Map a function over a vector and concatenate the results.
concatMap :: (Storable a, Storable b) => (a -> Vector b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results
mapM :: (Monad m, Storable a, Storable b) => (a -> m b) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results
mapM_ :: (Monad m, Storable a) => (a -> m b) -> Vector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equivalent to <tt>flip <a>mapM</a></tt>.
forM :: (Monad m, Storable a, Storable b) => Vector a -> (a -> m b) -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: (Monad m, Storable a) => Vector a -> (a -> m b) -> m ()

-- | <i>O(min(m,n))</i> Zip two vectors with the given function.
zipWith :: (Storable a, Storable b, Storable c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors with the given function.
zipWith3 :: (Storable a, Storable b, Storable c, Storable d) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
zipWith4 :: (Storable a, Storable b, Storable c, Storable d, Storable e) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
zipWith5 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
zipWith6 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(min(m,n))</i> Zip two vectors with a function that also takes the
--   elements' indices.
izipWith :: (Storable a, Storable b, Storable c) => (Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors and their indices with the given function.
izipWith3 :: (Storable a, Storable b, Storable c, Storable d) => (Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
izipWith4 :: (Storable a, Storable b, Storable c, Storable d, Storable e) => (Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
izipWith5 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => (Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
izipWith6 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => (Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   yield a vector of results
zipWithM :: (Monad m, Storable a, Storable b, Storable c) => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   ignore the results
zipWithM_ :: (Monad m, Storable a, Storable b) => (a -> b -> m c) -> Vector a -> Vector b -> m ()

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate
filter :: Storable a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate which is
--   applied to values and their indices
ifilter :: Storable a => (Int -> a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop repeated adjacent elements.
uniq :: (Storable a, Eq a) => Vector a -> Vector a

-- | <i>O(n)</i> Drop elements when predicate returns Nothing
mapMaybe :: (Storable a, Storable b) => (a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Drop elements when predicate, applied to index and value,
--   returns Nothing
imapMaybe :: (Storable a, Storable b) => (Int -> a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Drop elements that do not satisfy the monadic predicate
filterM :: (Monad m, Storable a) => (a -> m Bool) -> Vector a -> m (Vector a)

-- | <i>O(n)</i> Yield the longest prefix of elements satisfying the
--   predicate without copying.
takeWhile :: Storable a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop the longest prefix of elements that satisfy the
--   predicate without copying.
dropWhile :: Storable a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The relative order of the elements is preserved at the
--   cost of a sometimes reduced performance compared to
--   <a>unstablePartition</a>.
partition :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The order of the elements is not preserved but the
--   operation is often faster than <a>partition</a>.
unstablePartition :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   satisfy the predicate and the rest without copying.
span :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   do not satisfy the predicate and the rest without copying.
break :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Check if the vector contains an element
elem :: (Storable a, Eq a) => a -> Vector a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>)
notElem :: (Storable a, Eq a) => a -> Vector a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
find :: Storable a => (a -> Bool) -> Vector a -> Maybe a

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: Storable a => (a -> Bool) -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of elements satisfying the predicate in
--   ascending order.
findIndices :: Storable a => (a -> Bool) -> Vector a -> Vector Int

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurence of the
--   given element or <a>Nothing</a> if the vector does not contain the
--   element. This is a specialised version of <a>findIndex</a>.
elemIndex :: (Storable a, Eq a) => a -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of all occurences of the given element
--   in ascending order. This is a specialised version of
--   <a>findIndices</a>.
elemIndices :: (Storable a, Eq a) => a -> Vector a -> Vector Int

-- | <i>O(n)</i> Left fold
foldl :: Storable b => (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors
foldl1 :: Storable a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold with strict accumulator
foldl' :: Storable b => (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator
foldl1' :: Storable a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold
foldr :: Storable a => (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors
foldr1 :: Storable a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator
foldr' :: Storable a => (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator
foldr1' :: Storable a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold (function applied to each element and its index)
ifoldl :: Storable b => (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold with strict accumulator (function applied to
--   each element and its index)
ifoldl' :: Storable b => (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Right fold (function applied to each element and its
--   index)
ifoldr :: Storable a => (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold with strict accumulator (function applied to
--   each element and its index)
ifoldr' :: Storable a => (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: Storable a => (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: Storable a => (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Check if all elements are <a>True</a>
and :: Vector Bool -> Bool

-- | <i>O(n)</i> Check if any element is <a>True</a>
or :: Vector Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements
sum :: (Storable a, Num a) => Vector a -> a

-- | <i>O(n)</i> Compute the produce of the elements
product :: (Storable a, Num a) => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector. The vector may
--   not be empty.
maximum :: (Storable a, Ord a) => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector according to the
--   given comparison function. The vector may not be empty.
maximumBy :: Storable a => (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector. The vector may
--   not be empty.
minimum :: (Storable a, Ord a) => Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector according to the
--   given comparison function. The vector may not be empty.
minimumBy :: Storable a => (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the index of the minimum element of the vector. The
--   vector may not be empty.
minIndex :: (Storable a, Ord a) => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the minimum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
minIndexBy :: Storable a => (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector. The
--   vector may not be empty.
maxIndex :: (Storable a, Ord a) => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
maxIndexBy :: Storable a => (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Monadic fold
foldM :: (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator
foldM' :: (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors
fold1M :: (Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator
fold1M' :: (Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result
foldM_ :: (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result
foldM'_ :: (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result
fold1M_ :: (Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator that discards the result
fold1M'_ :: (Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m ()

-- | <i>O(n)</i> Prescan
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>prescanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6&gt;</tt>
prescanl :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Prescan with strict accumulator
prescanl' :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Scan
--   
--   <pre>
--   postscanl f z = <a>tail</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>postscanl (+) 0 &lt;1,2,3,4&gt; = &lt;1,3,6,10&gt;</tt>
postscanl :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Scan with strict accumulator
postscanl' :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Haskell-style scan
--   
--   <pre>
--   scanl f z &lt;x1,...,xn&gt; = &lt;y1,...,y(n+1)&gt;
--     where y1 = z
--           yi = f y(i-1) x(i-1)
--   </pre>
--   
--   Example: <tt>scanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6,10&gt;</tt>
scanl :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Haskell-style scan with strict accumulator
scanl' :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Scan over a non-empty vector
--   
--   <pre>
--   scanl f &lt;x1,...,xn&gt; = &lt;y1,...,yn&gt;
--     where y1 = x1
--           yi = f y(i-1) xi
--   </pre>
scanl1 :: Storable a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Scan over a non-empty vector with a strict accumulator
scanl1' :: Storable a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left prescan
--   
--   <pre>
--   prescanr f z = <a>reverse</a> . <a>prescanl</a> (flip f) z . <a>reverse</a>
--   </pre>
prescanr :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator
prescanr' :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan
postscanr :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator
postscanr' :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left Haskell-style scan
scanr :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left Haskell-style scan with strict accumulator
scanr' :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector
scanr1 :: Storable a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector with a strict
--   accumulator
scanr1' :: Storable a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Convert a vector to a list
toList :: Storable a => Vector a -> [a]

-- | <i>O(n)</i> Convert a list to a vector
fromList :: Storable a => [a] -> Vector a

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector
--   
--   <pre>
--   fromListN n xs = <a>fromList</a> (<a>take</a> n xs)
--   </pre>
fromListN :: Storable a => Int -> [a] -> Vector a

-- | <i>O(n)</i> Convert different vector types
convert :: (Vector v a, Vector w a) => v a -> w a

-- | <i>O(1)</i> Unsafely cast a vector from one element type to another.
--   The operation just changes the type of the underlying pointer and does
--   not modify the elements.
--   
--   The resulting vector contains as many elements as can fit into the
--   underlying memory block.
unsafeCast :: forall a b. (Storable a, Storable b) => Vector a -> Vector b

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: (Storable a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(n)</i> Yield a mutable copy of the immutable vector.
thaw :: (Storable a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length.
copy :: (Storable a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()

-- | <i>O(1)</i> Unsafe convert a mutable vector to an immutable one
--   without copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: (Storable a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(1)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. The immutable vector may not be used after this
--   operation.
unsafeThaw :: (Storable a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length. This is not checked.
unsafeCopy :: (Storable a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()

-- | <i>O(1)</i> Create a vector from a <a>ForeignPtr</a> with an offset
--   and a length.
--   
--   The data may not be modified through the <a>ForeignPtr</a> afterwards.
--   
--   If your offset is 0 it is more efficient to use
--   <a>unsafeFromForeignPtr0</a>.
unsafeFromForeignPtr :: Storable a => ForeignPtr a -> Int -> Int -> Vector a

-- | <i>O(1)</i> Create a vector from a <a>ForeignPtr</a> and a length.
--   
--   It is assumed the pointer points directly to the data (no offset). Use
--   <a>unsafeFromForeignPtr</a> if you need to specify an offset.
--   
--   The data may not be modified through the <a>ForeignPtr</a> afterwards.
unsafeFromForeignPtr0 :: Storable a => ForeignPtr a -> Int -> Vector a

-- | <i>O(1)</i> Yield the underlying <a>ForeignPtr</a> together with the
--   offset to the data and its length. The data may not be modified
--   through the <a>ForeignPtr</a>.
unsafeToForeignPtr :: Storable a => Vector a -> (ForeignPtr a, Int, Int)

-- | <i>O(1)</i> Yield the underlying <a>ForeignPtr</a> together with its
--   length.
--   
--   You can assume the pointer points directly to the data (no offset).
--   
--   The data may not be modified through the <a>ForeignPtr</a>.
unsafeToForeignPtr0 :: Storable a => Vector a -> (ForeignPtr a, Int)

-- | Pass a pointer to the vector's data to the IO action. The data may not
--   be modified through the 'Ptr.
unsafeWith :: Storable a => Vector a -> (Ptr a -> IO b) -> IO b
instance Control.DeepSeq.NFData (Data.Vector.Storable.Vector a)
instance (GHC.Show.Show a, Foreign.Storable.Storable a) => GHC.Show.Show (Data.Vector.Storable.Vector a)
instance (GHC.Read.Read a, Foreign.Storable.Storable a) => GHC.Read.Read (Data.Vector.Storable.Vector a)
instance (Data.Data.Data a, Foreign.Storable.Storable a) => Data.Data.Data (Data.Vector.Storable.Vector a)
instance Foreign.Storable.Storable a => Data.Vector.Generic.Base.Vector Data.Vector.Storable.Vector a
instance (Foreign.Storable.Storable a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Vector.Storable.Vector a)
instance (Foreign.Storable.Storable a, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Vector.Storable.Vector a)
instance Foreign.Storable.Storable a => GHC.Base.Semigroup (Data.Vector.Storable.Vector a)
instance Foreign.Storable.Storable a => GHC.Base.Monoid (Data.Vector.Storable.Vector a)
instance Foreign.Storable.Storable a => GHC.Exts.IsList (Data.Vector.Storable.Vector a)


-- | Adaptive unboxed vectors. The implementation is based on type families
--   and picks an efficient, specialised representation for every element
--   type. In particular, unboxed vectors of pairs are represented as pairs
--   of unboxed vectors.
--   
--   Implementing unboxed vectors for new data types can be very easy. Here
--   is how the library does this for <tt>Complex</tt> by simply wrapping
--   vectors of pairs.
--   
--   <pre>
--   newtype instance <a>MVector</a> s (<tt>Complex</tt> a) = MV_Complex (<a>MVector</a> s (a,a))
--   newtype instance <a>Vector</a>    (<tt>Complex</tt> a) = V_Complex  (<a>Vector</a>    (a,a))
--   
--   instance (<a>RealFloat</a> a, <a>Unbox</a> a) =&gt; <a>MVector</a> <a>MVector</a> (<tt>Complex</tt> a) where
--     {-# INLINE basicLength #-}
--     basicLength (MV_Complex v) = <a>basicLength</a> v
--     ...
--   
--   instance (<a>RealFloat</a> a, <a>Unbox</a> a) =&gt; Data.Vector.Generic.Vector <a>Vector</a> (<tt>Complex</tt> a) where
--     {-# INLINE basicLength #-}
--     basicLength (V_Complex v) = Data.Vector.Generic.basicLength v
--     ...
--   
--   instance (<a>RealFloat</a> a, <a>Unbox</a> a) =&gt; <a>Unbox</a> (<tt>Complex</tt> a)
--   </pre>
module Data.Vector.Unboxed
data family Vector a
data family MVector s a
class (Vector Vector a, MVector MVector a) => Unbox a

-- | <i>O(1)</i> Yield the length of the vector
length :: Unbox a => Vector a -> Int

-- | <i>O(1)</i> Test whether a vector is empty
null :: Unbox a => Vector a -> Bool

-- | O(1) Indexing
(!) :: Unbox a => Vector a -> Int -> a

-- | O(1) Safe indexing
(!?) :: Unbox a => Vector a -> Int -> Maybe a

-- | <i>O(1)</i> First element
head :: Unbox a => Vector a -> a

-- | <i>O(1)</i> Last element
last :: Unbox a => Vector a -> a

-- | <i>O(1)</i> Unsafe indexing without bounds checking
unsafeIndex :: Unbox a => Vector a -> Int -> a

-- | <i>O(1)</i> First element without checking if the vector is empty
unsafeHead :: Unbox a => Vector a -> a

-- | <i>O(1)</i> Last element without checking if the vector is empty
unsafeLast :: Unbox a => Vector a -> a

-- | <i>O(1)</i> Indexing in a monad.
--   
--   The monad allows operations to be strict in the vector when necessary.
--   Suppose vector copying is implemented like this:
--   
--   <pre>
--   copy mv v = ... write mv i (v ! i) ...
--   </pre>
--   
--   For lazy vectors, <tt>v ! i</tt> would not be evaluated which means
--   that <tt>mv</tt> would unnecessarily retain a reference to <tt>v</tt>
--   in each element written.
--   
--   With <a>indexM</a>, copying can be implemented like this instead:
--   
--   <pre>
--   copy mv v = ... do
--                     x &lt;- indexM v i
--                     write mv i x
--   </pre>
--   
--   Here, no references to <tt>v</tt> are retained because indexing (but
--   <i>not</i> the elements) is evaluated eagerly.
indexM :: (Unbox a, Monad m) => Vector a -> Int -> m a

-- | <i>O(1)</i> First element of a vector in a monad. See <a>indexM</a>
--   for an explanation of why this is useful.
headM :: (Unbox a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Last element of a vector in a monad. See <a>indexM</a> for
--   an explanation of why this is useful.
lastM :: (Unbox a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Indexing in a monad without bounds checks. See
--   <a>indexM</a> for an explanation of why this is useful.
unsafeIndexM :: (Unbox a, Monad m) => Vector a -> Int -> m a

-- | <i>O(1)</i> First element in a monad without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeHeadM :: (Unbox a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Last element in a monad without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeLastM :: (Unbox a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it. The vector
--   must contain at least <tt>i+n</tt> elements.
slice :: Unbox a => Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty.
init :: Unbox a => Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty.
tail :: Unbox a => Vector a -> Vector a

-- | <i>O(1)</i> Yield at the first <tt>n</tt> elements without copying.
--   The vector may contain less than <tt>n</tt> elements in which case it
--   is returned unchanged.
take :: Unbox a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector may contain less than <tt>n</tt> elements in which
--   case an empty vector is returned.
drop :: Unbox a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements paired with the
--   remainder without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt> but slightly more
--   efficient.
splitAt :: Unbox a => Int -> Vector a -> (Vector a, Vector a)

-- | <i>O(1)</i> Yield a slice of the vector without copying. The vector
--   must contain at least <tt>i+n</tt> elements but this is not checked.
unsafeSlice :: Unbox a => Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty but this is not checked.
unsafeInit :: Unbox a => Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty but this is not checked.
unsafeTail :: Unbox a => Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements without copying. The
--   vector must contain at least <tt>n</tt> elements but this is not
--   checked.
unsafeTake :: Unbox a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector must contain at least <tt>n</tt> elements but this
--   is not checked.
unsafeDrop :: Unbox a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Empty vector
empty :: Unbox a => Vector a

-- | <i>O(1)</i> Vector with exactly one element
singleton :: Unbox a => a -> Vector a

-- | <i>O(n)</i> Vector of the given length with the same value in each
--   position
replicate :: Unbox a => Int -> a -> Vector a

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index
generate :: Unbox a => Int -> (Int -> a) -> Vector a

-- | <i>O(n)</i> Apply function n times to value. Zeroth element is
--   original value.
iterateN :: Unbox a => Int -> (a -> a) -> a -> Vector a

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a vector.
replicateM :: (Monad m, Unbox a) => Int -> m a -> m (Vector a)

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   monadic action to each index
generateM :: (Monad m, Unbox a) => Int -> (Int -> m a) -> m (Vector a)

-- | <i>O(n)</i> Apply monadic function n times to value. Zeroth element is
--   original value.
iterateNM :: (Monad m, Unbox a) => Int -> (a -> m a) -> a -> m (Vector a)

-- | Execute the monadic action and freeze the resulting vector.
--   
--   <pre>
--   create (do { v &lt;- new 2; write v 0 'a'; write v 1 'b'; return v }) = &lt;<tt>a</tt>,<tt>b</tt>&gt;
--   </pre>
create :: Unbox a => (forall s. ST s (MVector s a)) -> Vector a

-- | Execute the monadic action and freeze the resulting vectors.
createT :: (Traversable f, Unbox a) => (forall s. ST s (f (MVector s a))) -> f (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the generator
--   function to a seed. The generator function yields <a>Just</a> the next
--   element and the new seed or <a>Nothing</a> if there are no more
--   elements.
--   
--   <pre>
--   unfoldr (\n -&gt; if n == 0 then Nothing else Just (n,n-1)) 10
--    = &lt;10,9,8,7,6,5,4,3,2,1&gt;
--   </pre>
unfoldr :: Unbox a => (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector with at most <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields <a>Just</a> the next element and the new seed or
--   <a>Nothing</a> if there are no more elements.
--   
--   <pre>
--   unfoldrN 3 (\n -&gt; Just (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrN :: Unbox a => Int -> (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
unfoldrM :: (Monad m, Unbox a) => (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
unfoldrNM :: (Monad m, Unbox a) => Int -> (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements by repeatedly
--   applying the generator function to the already constructed part of the
--   vector.
--   
--   <pre>
--   constructN 3 f = let a = f &lt;&gt; ; b = f &lt;a&gt; ; c = f &lt;a,b&gt; in f &lt;a,b,c&gt;
--   </pre>
constructN :: Unbox a => Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements from right to
--   left by repeatedly applying the generator function to the already
--   constructed part of the vector.
--   
--   <pre>
--   constructrN 3 f = let a = f &lt;&gt; ; b = f&lt;a&gt; ; c = f &lt;b,a&gt; in f &lt;c,b,a&gt;
--   </pre>
constructrN :: Unbox a => Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+1</tt> etc. This operation is usually more efficient
--   than <a>enumFromTo</a>.
--   
--   <pre>
--   enumFromN 5 3 = &lt;5,6,7&gt;
--   </pre>
enumFromN :: (Unbox a, Num a) => a -> Int -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc. This operations is
--   usually more efficient than <a>enumFromThenTo</a>.
--   
--   <pre>
--   enumFromStepN 1 0.1 5 = &lt;1,1.1,1.2,1.3,1.4&gt;
--   </pre>
enumFromStepN :: (Unbox a, Num a) => a -> a -> Int -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If at all
--   possible, use <a>enumFromN</a> instead.
enumFromTo :: (Unbox a, Enum a) => a -> a -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt> with a
--   specific step <tt>z</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromThenTo :: (Unbox a, Enum a) => a -> a -> a -> Vector a

-- | <i>O(n)</i> Prepend an element
cons :: Unbox a => a -> Vector a -> Vector a

-- | <i>O(n)</i> Append an element
snoc :: Unbox a => Vector a -> a -> Vector a

-- | <i>O(m+n)</i> Concatenate two vectors
(++) :: Unbox a => Vector a -> Vector a -> Vector a
infixr 5 ++

-- | <i>O(n)</i> Concatenate all vectors in the list
concat :: Unbox a => [Vector a] -> Vector a

-- | <i>O(n)</i> Yield the argument but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: Unbox a => Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list, replace the
--   vector element at position <tt>i</tt> by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: Unbox a => Vector a -> [(Int, a)] -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the vector of
--   index/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   update &lt;5,9,2,7&gt; &lt;(2,1),(0,3),(2,8)&gt; = &lt;3,9,8,7&gt;
--   </pre>
update :: Unbox a => Vector a -> Vector (Int, a) -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>a</tt> from the value vector, replace
--   the element of the initial vector at position <tt>i</tt> by
--   <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
--   
--   The function <a>update</a> provides the same functionality and is
--   usually more convenient.
--   
--   <pre>
--   update_ xs is ys = <a>update</a> xs (<a>zip</a> is ys)
--   </pre>
update_ :: Unbox a => Vector a -> Vector Int -> Vector a -> Vector a

-- | Same as (<a>//</a>) but without bounds checking.
unsafeUpd :: Unbox a => Vector a -> [(Int, a)] -> Vector a

-- | Same as <a>update</a> but without bounds checking.
unsafeUpdate :: Unbox a => Vector a -> Vector (Int, a) -> Vector a

-- | Same as <a>update_</a> but without bounds checking.
unsafeUpdate_ :: Unbox a => Vector a -> Vector Int -> Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <pre>
--   accum (+) &lt;5,9,2&gt; [(2,4),(1,6),(0,3),(1,7)] = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accum :: Unbox a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the vector of pairs,
--   replace the vector element <tt>a</tt> at position <tt>i</tt> by <tt>f
--   a b</tt>.
--   
--   <pre>
--   accumulate (+) &lt;5,9,2&gt; &lt;(2,4),(1,6),(0,3),(1,7)&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accumulate :: (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector (Int, b) -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>b</tt> from the the value vector,
--   replace the element of the initial vector at position <tt>i</tt> by
--   <tt>f a b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
--   
--   The function <a>accumulate</a> provides the same functionality and is
--   usually more convenient.
--   
--   <pre>
--   accumulate_ f as is bs = <a>accumulate</a> f as (<a>zip</a> is bs)
--   </pre>
accumulate_ :: (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | Same as <a>accum</a> but without bounds checking.
unsafeAccum :: Unbox a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | Same as <a>accumulate</a> but without bounds checking.
unsafeAccumulate :: (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector (Int, b) -> Vector a

-- | Same as <a>accumulate_</a> but without bounds checking.
unsafeAccumulate_ :: (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | <i>O(n)</i> Reverse a vector
reverse :: Unbox a => Vector a -> Vector a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<a>!</a>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<a>!</a>) is</tt> but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: Unbox a => Vector a -> Vector Int -> Vector a

-- | Same as <a>backpermute</a> but without bounds checking.
unsafeBackpermute :: Unbox a => Vector a -> Vector Int -> Vector a

-- | Apply a destructive operation to a vector. The operation will be
--   performed in place if it is safe to do so and will modify a copy of
--   the vector otherwise.
--   
--   <pre>
--   modify (\v -&gt; write v 0 'x') (<a>replicate</a> 3 'a') = &lt;'x','a','a'&gt;
--   </pre>
modify :: Unbox a => (forall s. MVector s a -> ST s ()) -> Vector a -> Vector a

-- | <i>O(n)</i> Pair each element in a vector with its index
indexed :: Unbox a => Vector a -> Vector (Int, a)

-- | <i>O(n)</i> Map a function over a vector
map :: (Unbox a, Unbox b) => (a -> b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index
imap :: (Unbox a, Unbox b) => (Int -> a -> b) -> Vector a -> Vector b

-- | Map a function over a vector and concatenate the results.
concatMap :: (Unbox a, Unbox b) => (a -> Vector b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results
mapM :: (Monad m, Unbox a, Unbox b) => (a -> m b) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, yielding a vector of results
imapM :: (Monad m, Unbox a, Unbox b) => (Int -> a -> m b) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results
mapM_ :: (Monad m, Unbox a) => (a -> m b) -> Vector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, ignoring the results
imapM_ :: (Monad m, Unbox a) => (Int -> a -> m b) -> Vector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equivalent to <tt>flip <a>mapM</a></tt>.
forM :: (Monad m, Unbox a, Unbox b) => Vector a -> (a -> m b) -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: (Monad m, Unbox a) => Vector a -> (a -> m b) -> m ()

-- | <i>O(min(m,n))</i> Zip two vectors with the given function.
zipWith :: (Unbox a, Unbox b, Unbox c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors with the given function.
zipWith3 :: (Unbox a, Unbox b, Unbox c, Unbox d) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
zipWith4 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
zipWith5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
zipWith6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f, Unbox g) => (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(min(m,n))</i> Zip two vectors with a function that also takes the
--   elements' indices.
izipWith :: (Unbox a, Unbox b, Unbox c) => (Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors and their indices with the given function.
izipWith3 :: (Unbox a, Unbox b, Unbox c, Unbox d) => (Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
izipWith4 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => (Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
izipWith5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => (Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
izipWith6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f, Unbox g) => (Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(1)</i> Zip 2 vectors
zip :: (Unbox a, Unbox b) => Vector a -> Vector b -> Vector (a, b)

-- | <i>O(1)</i> Zip 3 vectors
zip3 :: (Unbox a, Unbox b, Unbox c) => Vector a -> Vector b -> Vector c -> Vector (a, b, c)

-- | <i>O(1)</i> Zip 4 vectors
zip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => Vector a -> Vector b -> Vector c -> Vector d -> Vector (a, b, c, d)

-- | <i>O(1)</i> Zip 5 vectors
zip5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector (a, b, c, d, e)

-- | <i>O(1)</i> Zip 6 vectors
zip6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector (a, b, c, d, e, f)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   yield a vector of results
zipWithM :: (Monad m, Unbox a, Unbox b, Unbox c) => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and yield a vector of results
izipWithM :: (Monad m, Unbox a, Unbox b, Unbox c) => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   ignore the results
zipWithM_ :: (Monad m, Unbox a, Unbox b) => (a -> b -> m c) -> Vector a -> Vector b -> m ()

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and ignore the results
izipWithM_ :: (Monad m, Unbox a, Unbox b) => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m ()

-- | <i>O(1)</i> Unzip 2 vectors
unzip :: (Unbox a, Unbox b) => Vector (a, b) -> (Vector a, Vector b)

-- | <i>O(1)</i> Unzip 3 vectors
unzip3 :: (Unbox a, Unbox b, Unbox c) => Vector (a, b, c) -> (Vector a, Vector b, Vector c)

-- | <i>O(1)</i> Unzip 4 vectors
unzip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => Vector (a, b, c, d) -> (Vector a, Vector b, Vector c, Vector d)

-- | <i>O(1)</i> Unzip 5 vectors
unzip5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Vector (a, b, c, d, e) -> (Vector a, Vector b, Vector c, Vector d, Vector e)

-- | <i>O(1)</i> Unzip 6 vectors
unzip6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => Vector (a, b, c, d, e, f) -> (Vector a, Vector b, Vector c, Vector d, Vector e, Vector f)

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate
filter :: Unbox a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate which is
--   applied to values and their indices
ifilter :: Unbox a => (Int -> a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop repeated adjacent elements.
uniq :: (Unbox a, Eq a) => Vector a -> Vector a

-- | <i>O(n)</i> Drop elements when predicate returns Nothing
mapMaybe :: (Unbox a, Unbox b) => (a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Drop elements when predicate, applied to index and value,
--   returns Nothing
imapMaybe :: (Unbox a, Unbox b) => (Int -> a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Drop elements that do not satisfy the monadic predicate
filterM :: (Monad m, Unbox a) => (a -> m Bool) -> Vector a -> m (Vector a)

-- | <i>O(n)</i> Yield the longest prefix of elements satisfying the
--   predicate without copying.
takeWhile :: Unbox a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop the longest prefix of elements that satisfy the
--   predicate without copying.
dropWhile :: Unbox a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The relative order of the elements is preserved at the
--   cost of a sometimes reduced performance compared to
--   <a>unstablePartition</a>.
partition :: Unbox a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The order of the elements is not preserved but the
--   operation is often faster than <a>partition</a>.
unstablePartition :: Unbox a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   satisfy the predicate and the rest without copying.
span :: Unbox a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   do not satisfy the predicate and the rest without copying.
break :: Unbox a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Check if the vector contains an element
elem :: (Unbox a, Eq a) => a -> Vector a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>)
notElem :: (Unbox a, Eq a) => a -> Vector a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
find :: Unbox a => (a -> Bool) -> Vector a -> Maybe a

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: Unbox a => (a -> Bool) -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of elements satisfying the predicate in
--   ascending order.
findIndices :: Unbox a => (a -> Bool) -> Vector a -> Vector Int

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurence of the
--   given element or <a>Nothing</a> if the vector does not contain the
--   element. This is a specialised version of <a>findIndex</a>.
elemIndex :: (Unbox a, Eq a) => a -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of all occurences of the given element
--   in ascending order. This is a specialised version of
--   <a>findIndices</a>.
elemIndices :: (Unbox a, Eq a) => a -> Vector a -> Vector Int

-- | <i>O(n)</i> Left fold
foldl :: Unbox b => (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors
foldl1 :: Unbox a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold with strict accumulator
foldl' :: Unbox b => (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator
foldl1' :: Unbox a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold
foldr :: Unbox a => (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors
foldr1 :: Unbox a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator
foldr' :: Unbox a => (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator
foldr1' :: Unbox a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold (function applied to each element and its index)
ifoldl :: Unbox b => (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold with strict accumulator (function applied to
--   each element and its index)
ifoldl' :: Unbox b => (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Right fold (function applied to each element and its
--   index)
ifoldr :: Unbox a => (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold with strict accumulator (function applied to
--   each element and its index)
ifoldr' :: Unbox a => (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: Unbox a => (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: Unbox a => (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Check if all elements are <a>True</a>
and :: Vector Bool -> Bool

-- | <i>O(n)</i> Check if any element is <a>True</a>
or :: Vector Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements
sum :: (Unbox a, Num a) => Vector a -> a

-- | <i>O(n)</i> Compute the produce of the elements
product :: (Unbox a, Num a) => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector. The vector may
--   not be empty.
maximum :: (Unbox a, Ord a) => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector according to the
--   given comparison function. The vector may not be empty.
maximumBy :: Unbox a => (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector. The vector may
--   not be empty.
minimum :: (Unbox a, Ord a) => Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector according to the
--   given comparison function. The vector may not be empty.
minimumBy :: Unbox a => (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the index of the minimum element of the vector. The
--   vector may not be empty.
minIndex :: (Unbox a, Ord a) => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the minimum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
minIndexBy :: Unbox a => (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector. The
--   vector may not be empty.
maxIndex :: (Unbox a, Ord a) => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
maxIndexBy :: Unbox a => (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Monadic fold
foldM :: (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold (action applied to each element and its
--   index)
ifoldM :: (Monad m, Unbox b) => (a -> Int -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator
foldM' :: (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator (action applied to
--   each element and its index)
ifoldM' :: (Monad m, Unbox b) => (a -> Int -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors
fold1M :: (Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator
fold1M' :: (Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result
foldM_ :: (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold that discards the result (action applied to
--   each element and its index)
ifoldM_ :: (Monad m, Unbox b) => (a -> Int -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result
foldM'_ :: (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result (action applied to each element and its index)
ifoldM'_ :: (Monad m, Unbox b) => (a -> Int -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result
fold1M_ :: (Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator that discards the result
fold1M'_ :: (Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m ()

-- | <i>O(n)</i> Prescan
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>prescanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6&gt;</tt>
prescanl :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Prescan with strict accumulator
prescanl' :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Scan
--   
--   <pre>
--   postscanl f z = <a>tail</a> . <a>scanl</a> f z
--   </pre>
--   
--   Example: <tt>postscanl (+) 0 &lt;1,2,3,4&gt; = &lt;1,3,6,10&gt;</tt>
postscanl :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Scan with strict accumulator
postscanl' :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Haskell-style scan
--   
--   <pre>
--   scanl f z &lt;x1,...,xn&gt; = &lt;y1,...,y(n+1)&gt;
--     where y1 = z
--           yi = f y(i-1) x(i-1)
--   </pre>
--   
--   Example: <tt>scanl (+) 0 &lt;1,2,3,4&gt; = &lt;0,1,3,6,10&gt;</tt>
scanl :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Haskell-style scan with strict accumulator
scanl' :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Scan over a non-empty vector
--   
--   <pre>
--   scanl f &lt;x1,...,xn&gt; = &lt;y1,...,yn&gt;
--     where y1 = x1
--           yi = f y(i-1) xi
--   </pre>
scanl1 :: Unbox a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Scan over a non-empty vector with a strict accumulator
scanl1' :: Unbox a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left prescan
--   
--   <pre>
--   prescanr f z = <a>reverse</a> . <a>prescanl</a> (flip f) z . <a>reverse</a>
--   </pre>
prescanr :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator
prescanr' :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan
postscanr :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator
postscanr' :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left Haskell-style scan
scanr :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left Haskell-style scan with strict accumulator
scanr' :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector
scanr1 :: Unbox a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left scan over a non-empty vector with a strict
--   accumulator
scanr1' :: Unbox a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Convert a vector to a list
toList :: Unbox a => Vector a -> [a]

-- | <i>O(n)</i> Convert a list to a vector
fromList :: Unbox a => [a] -> Vector a

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector
--   
--   <pre>
--   fromListN n xs = <a>fromList</a> (<a>take</a> n xs)
--   </pre>
fromListN :: Unbox a => Int -> [a] -> Vector a

-- | <i>O(n)</i> Convert different vector types
convert :: (Vector v a, Vector w a) => v a -> w a

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: (Unbox a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(n)</i> Yield a mutable copy of the immutable vector.
thaw :: (Unbox a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length.
copy :: (Unbox a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()

-- | <i>O(1)</i> Unsafe convert a mutable vector to an immutable one
--   without copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: (Unbox a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(1)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. The immutable vector may not be used after this
--   operation.
unsafeThaw :: (Unbox a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length. This is not checked.
unsafeCopy :: (Unbox a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Vector.Unboxed.Base.Vector a)
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Vector.Unboxed.Base.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => GHC.Base.Semigroup (Data.Vector.Unboxed.Base.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => GHC.Base.Monoid (Data.Vector.Unboxed.Base.Vector a)
instance (GHC.Show.Show a, Data.Vector.Unboxed.Base.Unbox a) => GHC.Show.Show (Data.Vector.Unboxed.Base.Vector a)
instance (GHC.Read.Read a, Data.Vector.Unboxed.Base.Unbox a) => GHC.Read.Read (Data.Vector.Unboxed.Base.Vector a)
instance Data.Vector.Unboxed.Base.Unbox e => GHC.Exts.IsList (Data.Vector.Unboxed.Base.Vector e)


-- | Mutable adaptive unboxed vectors
module Data.Vector.Unboxed.Mutable
data family MVector s a
type IOVector = MVector RealWorld
type STVector s = MVector s
class (Vector Vector a, MVector MVector a) => Unbox a

-- | Length of the mutable vector.
length :: Unbox a => MVector s a -> Int

-- | Check whether the vector is empty
null :: Unbox a => MVector s a -> Bool

-- | Yield a part of the mutable vector without copying it.
slice :: Unbox a => Int -> Int -> MVector s a -> MVector s a
init :: Unbox a => MVector s a -> MVector s a
tail :: Unbox a => MVector s a -> MVector s a
take :: Unbox a => Int -> MVector s a -> MVector s a
drop :: Unbox a => Int -> MVector s a -> MVector s a
splitAt :: Unbox a => Int -> MVector s a -> (MVector s a, MVector s a)

-- | Yield a part of the mutable vector without copying it. No bounds
--   checks are performed.
unsafeSlice :: Unbox a => Int -> Int -> MVector s a -> MVector s a
unsafeInit :: Unbox a => MVector s a -> MVector s a
unsafeTail :: Unbox a => MVector s a -> MVector s a
unsafeTake :: Unbox a => Int -> MVector s a -> MVector s a
unsafeDrop :: Unbox a => Int -> MVector s a -> MVector s a

-- | Check whether two vectors overlap.
overlaps :: Unbox a => MVector s a -> MVector s a -> Bool

-- | Create a mutable vector of the given length.
new :: (PrimMonad m, Unbox a) => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length. The memory is not
--   initialized.
unsafeNew :: (PrimMonad m, Unbox a) => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with an initial value.
replicate :: (PrimMonad m, Unbox a) => Int -> a -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with values produced by repeatedly executing the
--   monadic action.
replicateM :: (PrimMonad m, Unbox a) => Int -> m a -> m (MVector (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> m (MVector (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   positive.
grow :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   positive but this is not checked.
unsafeGrow :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is usually a noop for unboxed
--   vectors.
clear :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> m ()

-- | <i>O(1)</i> Zip 2 vectors
zip :: (Unbox a, Unbox b) => MVector s a -> MVector s b -> MVector s (a, b)

-- | <i>O(1)</i> Zip 3 vectors
zip3 :: (Unbox a, Unbox b, Unbox c) => MVector s a -> MVector s b -> MVector s c -> MVector s (a, b, c)

-- | <i>O(1)</i> Zip 4 vectors
zip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s (a, b, c, d)

-- | <i>O(1)</i> Zip 5 vectors
zip5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s e -> MVector s (a, b, c, d, e)

-- | <i>O(1)</i> Zip 6 vectors
zip6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s e -> MVector s f -> MVector s (a, b, c, d, e, f)

-- | <i>O(1)</i> Unzip 2 vectors
unzip :: (Unbox a, Unbox b) => MVector s (a, b) -> (MVector s a, MVector s b)

-- | <i>O(1)</i> Unzip 3 vectors
unzip3 :: (Unbox a, Unbox b, Unbox c) => MVector s (a, b, c) -> (MVector s a, MVector s b, MVector s c)

-- | <i>O(1)</i> Unzip 4 vectors
unzip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => MVector s (a, b, c, d) -> (MVector s a, MVector s b, MVector s c, MVector s d)

-- | <i>O(1)</i> Unzip 5 vectors
unzip5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => MVector s (a, b, c, d, e) -> (MVector s a, MVector s b, MVector s c, MVector s d, MVector s e)

-- | <i>O(1)</i> Unzip 6 vectors
unzip6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => MVector s (a, b, c, d, e, f) -> (MVector s a, MVector s b, MVector s c, MVector s d, MVector s e, MVector s f)

-- | Yield the element at the given position.
read :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> m a

-- | Replace the element at the given position.
write :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position.
modify :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Swap the elements at the given positions.
swap :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Yield the element at the given position. No bounds checks are
--   performed.
unsafeRead :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> m a

-- | Replace the element at the given position. No bounds checks are
--   performed.
unsafeWrite :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position. No bounds checks are
--   performed.
unsafeModify :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Swap the elements at the given positions. No bounds checks are
--   performed.
unsafeSwap :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Compute the next (lexicographically) permutation of given vector
--   in-place. Returns False when input is the last permtuation
nextPermutation :: (PrimMonad m, Ord e, Unbox e) => MVector (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap.
copy :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length.
--   
--   If the vectors do not overlap, then this is equivalent to <a>copy</a>.
--   Otherwise, the copying is performed as if the source vector were
--   copied to a temporary vector and then the temporary vector was copied
--   to the target vector.
move :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap. This is not checked.
unsafeCopy :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length, but this is not checked.
--   
--   If the vectors do not overlap, then this is equivalent to
--   <a>unsafeCopy</a>. Otherwise, the copying is performed as if the
--   source vector were copied to a temporary vector and then the temporary
--   vector was copied to the target vector.
unsafeMove :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
