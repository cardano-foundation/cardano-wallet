<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# Language CPP, DeriveDataTypeable #-}</span><span>
</span><a name="line-2"></a><span>
</span><a name="line-3"></a><span class="hs-cpp">#if MIN_VERSION_base(4,4,0)
#define HAS_GENERICS
</span><span class="hs-pragma">{-# Language DeriveGeneric #-}</span><span>
</span><a name="line-6"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-8"></a><span class="hs-comment">{-|
Module      : Language.Haskell.TH.Datatype
Description : Backwards-compatible interface to reified information about datatypes.
Copyright   : Eric Mertens 2017
License     : ISC
Maintainer  : emertens@gmail.com

This module provides a flattened view of information about data types
and newtypes that can be supported uniformly across multiple versions
of the template-haskell package.

Sample output for @'reifyDatatype' ''Maybe@

@
'DatatypeInfo'
 { 'datatypeContext' = []
 , 'datatypeName'    = GHC.Base.Maybe
 , 'datatypeVars'    = [ 'SigT' ('VarT' a_3530822107858468866) 'StarT' ]
 , 'datatypeVariant' = 'Datatype'
 , 'datatypeCons'    =
     [ 'ConstructorInfo'
         { 'constructorName'       = GHC.Base.Nothing
         , 'constructorVars'       = []
         , 'constructorContext'    = []
         , 'constructorFields'     = []
         , 'constructorStrictness' = []
         , 'constructorVariant'    = 'NormalConstructor'
         }
     , 'ConstructorInfo'
         { 'constructorName'       = GHC.Base.Just
         , 'constructorVars'       = []
         , 'constructorContext'    = []
         , 'constructorFields'     = [ 'VarT' a_3530822107858468866 ]
         , 'constructorStrictness' = [ 'FieldStrictness'
                                         'UnspecifiedUnpackedness'
                                         'Lazy'
                                     ]
         , 'constructorVariant'    = 'NormalConstructor'
         }
     ]
 }
@

Datatypes declared with GADT syntax are normalized to constructors with existentially
quantified type variables and equality constraints.

-}</span><span>
</span><a name="line-55"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.TH.Datatype</span><span>
</span><a name="line-56"></a><span>  </span><span class="hs-special">(</span><span>
</span><a name="line-57"></a><span>  </span><span class="hs-comment">-- * Types</span><span>
</span><a name="line-58"></a><span>    </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-59"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-60"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-61"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier hs-type">ConstructorVariant</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-62"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-63"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#Unpackedness"><span class="hs-identifier hs-type">Unpackedness</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-64"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#Strictness"><span class="hs-identifier hs-type">Strictness</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-65"></a><span>
</span><a name="line-66"></a><span>  </span><span class="hs-comment">-- * Normalization functions</span><span>
</span><a name="line-67"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#reifyDatatype"><span class="hs-identifier hs-var">reifyDatatype</span></a><span>
</span><a name="line-68"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#reifyConstructor"><span class="hs-identifier hs-var">reifyConstructor</span></a><span>
</span><a name="line-69"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#reifyRecord"><span class="hs-identifier hs-var">reifyRecord</span></a><span>
</span><a name="line-70"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeInfo"><span class="hs-identifier hs-var">normalizeInfo</span></a><span>
</span><a name="line-71"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeDec"><span class="hs-identifier hs-var">normalizeDec</span></a><span>
</span><a name="line-72"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeCon"><span class="hs-identifier hs-var">normalizeCon</span></a><span>
</span><a name="line-73"></a><span>
</span><a name="line-74"></a><span>  </span><span class="hs-comment">-- * 'DatatypeInfo' lookup functions</span><span>
</span><a name="line-75"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#lookupByConstructorName"><span class="hs-identifier hs-var">lookupByConstructorName</span></a><span>
</span><a name="line-76"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#lookupByRecordName"><span class="hs-identifier hs-var">lookupByRecordName</span></a><span>
</span><a name="line-77"></a><span>
</span><a name="line-78"></a><span>  </span><span class="hs-comment">-- * Type variable manipulation</span><span>
</span><a name="line-79"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-type">TypeSubstitution</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-80"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#quantifyType"><span class="hs-identifier hs-var">quantifyType</span></a><span>
</span><a name="line-81"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier hs-var">freeVariablesWellScoped</span></a><span>
</span><a name="line-82"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freshenFreeVariables"><span class="hs-identifier hs-var">freshenFreeVariables</span></a><span>
</span><a name="line-83"></a><span>
</span><a name="line-84"></a><span>  </span><span class="hs-comment">-- * 'Pred' functions</span><span>
</span><a name="line-85"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#equalPred"><span class="hs-identifier hs-var">equalPred</span></a><span>
</span><a name="line-86"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#classPred"><span class="hs-identifier hs-var">classPred</span></a><span>
</span><a name="line-87"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#asEqualPred"><span class="hs-identifier hs-var">asEqualPred</span></a><span>
</span><a name="line-88"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#asClassPred"><span class="hs-identifier hs-var">asClassPred</span></a><span>
</span><a name="line-89"></a><span>
</span><a name="line-90"></a><span>  </span><span class="hs-comment">-- * Backward compatible data definitions</span><span>
</span><a name="line-91"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#dataDCompat"><span class="hs-identifier hs-var">dataDCompat</span></a><span>
</span><a name="line-92"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#newtypeDCompat"><span class="hs-identifier hs-var">newtypeDCompat</span></a><span>
</span><a name="line-93"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#tySynInstDCompat"><span class="hs-identifier hs-var">tySynInstDCompat</span></a><span>
</span><a name="line-94"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#pragLineDCompat"><span class="hs-identifier hs-var">pragLineDCompat</span></a><span>
</span><a name="line-95"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#arrowKCompat"><span class="hs-identifier hs-var">arrowKCompat</span></a><span>
</span><a name="line-96"></a><span>
</span><a name="line-97"></a><span>  </span><span class="hs-comment">-- * Strictness annotations</span><span>
</span><a name="line-98"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#isStrictAnnot"><span class="hs-identifier hs-var">isStrictAnnot</span></a><span>
</span><a name="line-99"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#notStrictAnnot"><span class="hs-identifier hs-var">notStrictAnnot</span></a><span>
</span><a name="line-100"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#unpackedAnnot"><span class="hs-identifier hs-var">unpackedAnnot</span></a><span>
</span><a name="line-101"></a><span>
</span><a name="line-102"></a><span>  </span><span class="hs-comment">-- * Type simplification</span><span>
</span><a name="line-103"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a><span>
</span><a name="line-104"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var">resolveKindSynonyms</span></a><span>
</span><a name="line-105"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolvePredSynonyms"><span class="hs-identifier hs-var">resolvePredSynonyms</span></a><span>
</span><a name="line-106"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a><span>
</span><a name="line-107"></a><span>
</span><a name="line-108"></a><span>  </span><span class="hs-comment">-- * Fixities</span><span>
</span><a name="line-109"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#reifyFixityCompat"><span class="hs-identifier hs-var">reifyFixityCompat</span></a><span>
</span><a name="line-110"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#showFixity"><span class="hs-identifier hs-var">showFixity</span></a><span>
</span><a name="line-111"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier hs-var">showFixityDirection</span></a><span>
</span><a name="line-112"></a><span>
</span><a name="line-113"></a><span>  </span><span class="hs-comment">-- * Convenience functions</span><span>
</span><a name="line-114"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#unifyTypes"><span class="hs-identifier hs-var">unifyTypes</span></a><span>
</span><a name="line-115"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a><span>
</span><a name="line-116"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#tvKind"><span class="hs-identifier hs-var">tvKind</span></a><span>
</span><a name="line-117"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#datatypeType"><span class="hs-identifier hs-var">datatypeType</span></a><span>
</span><a name="line-118"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-119"></a><span>
</span><a name="line-120"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data.Data</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Data</span><span class="hs-special">)</span><span>
</span><a name="line-121"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data.Foldable</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">foldMap</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">foldl'</span><span class="hs-special">)</span><span>
</span><a name="line-122"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data.Graph</span><span>
</span><a name="line-123"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data.List</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">nub</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">find</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">union</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">\\</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-124"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data.Map</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Map</span><span class="hs-special">)</span><span>
</span><a name="line-125"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data.Map</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">Map</span><span>
</span><a name="line-126"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data.Maybe</span><span>
</span><a name="line-127"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data.Traversable</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">T</span><span>
</span><a name="line-128"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control.Monad</span><span>
</span><a name="line-129"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Language.Haskell.TH</span><span>
</span><a name="line-130"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><span>                                     </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Extension</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-132"></a><span class="hs-cpp">#endif
</span><span class="hs-keyword">import</span><span>           </span><a href="Language.Haskell.TH.Datatype.Internal.html"><span class="hs-identifier">Language.Haskell.TH.Datatype.Internal</span></a><span>
</span><a name="line-134"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Language.Haskell.TH.Lib</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">arrowK</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">starK</span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- needed for th-2.4</span><span>
</span><a name="line-135"></a><span>
</span><a name="line-136"></a><span class="hs-cpp">#ifdef HAS_GENERICS
</span><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC.Generics</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a name="line-138"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-140"></a><span class="hs-cpp">#if !MIN_VERSION_base(4,8,0)
</span><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control.Applicative</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Applicative</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator">&lt;$&gt;</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-142"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data.Monoid</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Monoid</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-143"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-145"></a><span class="hs-comment">-- | Normalized information about newtypes and data types.</span><span>
</span><a name="line-146"></a><span class="hs-comment">--</span><span>
</span><a name="line-147"></a><span class="hs-comment">-- 'datatypeVars' types will have an outermost 'SigT' to indicate the</span><span>
</span><a name="line-148"></a><span class="hs-comment">-- parameter's kind. These types will be simple variables for /ADT/s</span><span>
</span><a name="line-149"></a><span class="hs-comment">-- declared with @data@ and @newtype@, but can be more complex for</span><span>
</span><a name="line-150"></a><span class="hs-comment">-- types declared with @data instance@ and @newtype instance@.</span><span>
</span><a name="line-151"></a><span class="hs-keyword">data</span><span> </span><a name="DatatypeInfo"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier">DatatypeInfo</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="DatatypeInfo"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier">DatatypeInfo</span></a></a><span>
</span><a name="line-152"></a><span>  </span><span class="hs-special">{</span><span> </span><a name="datatypeContext"><a href="Language.Haskell.TH.Datatype.html#datatypeContext"><span class="hs-identifier">datatypeContext</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Cxt</span><span>               </span><span class="hs-comment">-- ^ Data type context (deprecated)</span><span>
</span><a name="line-153"></a><span>  </span><span class="hs-special">,</span><span> </span><a name="datatypeName"><a href="Language.Haskell.TH.Datatype.html#datatypeName"><span class="hs-identifier">datatypeName</span></a></a><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span>              </span><span class="hs-comment">-- ^ Type constructor</span><span>
</span><a name="line-154"></a><span>  </span><span class="hs-special">,</span><span> </span><a name="datatypeVars"><a href="Language.Haskell.TH.Datatype.html#datatypeVars"><span class="hs-identifier">datatypeVars</span></a></a><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span>            </span><span class="hs-comment">-- ^ Type parameters</span><span>
</span><a name="line-155"></a><span>  </span><span class="hs-special">,</span><span> </span><a name="datatypeVariant"><a href="Language.Haskell.TH.Datatype.html#datatypeVariant"><span class="hs-identifier">datatypeVariant</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a><span>   </span><span class="hs-comment">-- ^ Extra information</span><span>
</span><a name="line-156"></a><span>  </span><span class="hs-special">,</span><span> </span><a name="datatypeCons"><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier">datatypeCons</span></a></a><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span class="hs-special">]</span><span> </span><span class="hs-comment">-- ^ Normalize constructor information</span><span>
</span><a name="line-157"></a><span>  </span><span class="hs-special">}</span><span>
</span><a name="line-158"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Data</span><span>
</span><a name="line-159"></a><span class="hs-cpp">#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span class="hs-identifier hs-type">Generic</span><span>
</span><a name="line-161"></a><span class="hs-cpp">#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><a name="line-163"></a><span>
</span><a name="line-164"></a><span class="hs-comment">-- | Possible variants of data type declarations.</span><span>
</span><a name="line-165"></a><span class="hs-keyword">data</span><span> </span><a name="DatatypeVariant"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier">DatatypeVariant</span></a></a><span>
</span><a name="line-166"></a><span>  </span><span class="hs-glyph">=</span><span> </span><a name="Datatype"><a href="Language.Haskell.TH.Datatype.html#Datatype"><span class="hs-identifier">Datatype</span></a></a><span>        </span><span class="hs-comment">-- ^ Type declared with @data@</span><span>
</span><a name="line-167"></a><span>  </span><span class="hs-glyph">|</span><span> </span><a name="Newtype"><a href="Language.Haskell.TH.Datatype.html#Newtype"><span class="hs-identifier">Newtype</span></a></a><span>         </span><span class="hs-comment">-- ^ Type declared with @newtype@</span><span>
</span><a name="line-168"></a><span>  </span><span class="hs-glyph">|</span><span> </span><a name="DataInstance"><a href="Language.Haskell.TH.Datatype.html#DataInstance"><span class="hs-identifier">DataInstance</span></a></a><span>    </span><span class="hs-comment">-- ^ Type declared with @data instance@</span><span>
</span><a name="line-169"></a><span>  </span><span class="hs-glyph">|</span><span> </span><a name="NewtypeInstance"><a href="Language.Haskell.TH.Datatype.html#NewtypeInstance"><span class="hs-identifier">NewtypeInstance</span></a></a><span> </span><span class="hs-comment">-- ^ Type declared with @newtype instance@</span><span>
</span><a name="line-170"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Read</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Data</span><span>
</span><a name="line-171"></a><span class="hs-cpp">#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span class="hs-identifier hs-type">Generic</span><span>
</span><a name="line-173"></a><span class="hs-cpp">#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><a name="line-175"></a><span>
</span><a name="line-176"></a><span class="hs-comment">-- | Normalized information about constructors associated with newtypes and</span><span>
</span><a name="line-177"></a><span class="hs-comment">-- data types.</span><span>
</span><a name="line-178"></a><span class="hs-keyword">data</span><span> </span><a name="ConstructorInfo"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier">ConstructorInfo</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="ConstructorInfo"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier">ConstructorInfo</span></a></a><span>
</span><a name="line-179"></a><span>  </span><span class="hs-special">{</span><span> </span><a name="constructorName"><a href="Language.Haskell.TH.Datatype.html#constructorName"><span class="hs-identifier">constructorName</span></a></a><span>       </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span>               </span><span class="hs-comment">-- ^ Constructor name</span><span>
</span><a name="line-180"></a><span>  </span><span class="hs-special">,</span><span> </span><a name="constructorVars"><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier">constructorVars</span></a></a><span>       </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span>        </span><span class="hs-comment">-- ^ Constructor type parameters</span><span>
</span><a name="line-181"></a><span>  </span><span class="hs-special">,</span><span> </span><a name="constructorContext"><a href="Language.Haskell.TH.Datatype.html#constructorContext"><span class="hs-identifier">constructorContext</span></a></a><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Cxt</span><span>                </span><span class="hs-comment">-- ^ Constructor constraints</span><span>
</span><a name="line-182"></a><span>  </span><span class="hs-special">,</span><span> </span><a name="constructorFields"><a href="Language.Haskell.TH.Datatype.html#constructorFields"><span class="hs-identifier">constructorFields</span></a></a><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span>             </span><span class="hs-comment">-- ^ Constructor fields</span><span>
</span><a name="line-183"></a><span>  </span><span class="hs-special">,</span><span> </span><a name="constructorStrictness"><a href="Language.Haskell.TH.Datatype.html#constructorStrictness"><span class="hs-identifier">constructorStrictness</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- ^ Constructor fields' strictness</span><span>
</span><a name="line-184"></a><span>                                                </span><span class="hs-comment">--   (Invariant: has the same length</span><span>
</span><a name="line-185"></a><span>                                                </span><span class="hs-comment">--   as constructorFields)</span><span>
</span><a name="line-186"></a><span>  </span><span class="hs-special">,</span><span> </span><a name="constructorVariant"><a href="Language.Haskell.TH.Datatype.html#constructorVariant"><span class="hs-identifier">constructorVariant</span></a></a><span>    </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier hs-type">ConstructorVariant</span></a><span> </span><span class="hs-comment">-- ^ Extra information</span><span>
</span><a name="line-187"></a><span>  </span><span class="hs-special">}</span><span>
</span><a name="line-188"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Data</span><span>
</span><a name="line-189"></a><span class="hs-cpp">#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span class="hs-identifier hs-type">Generic</span><span>
</span><a name="line-191"></a><span class="hs-cpp">#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><a name="line-193"></a><span>
</span><a name="line-194"></a><span class="hs-comment">-- | Possible variants of data constructors.</span><span>
</span><a name="line-195"></a><span class="hs-keyword">data</span><span> </span><a name="ConstructorVariant"><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier">ConstructorVariant</span></a></a><span>
</span><a name="line-196"></a><span>  </span><span class="hs-glyph">=</span><span> </span><a name="NormalConstructor"><a href="Language.Haskell.TH.Datatype.html#NormalConstructor"><span class="hs-identifier">NormalConstructor</span></a></a><span>        </span><span class="hs-comment">-- ^ Constructor without field names</span><span>
</span><a name="line-197"></a><span>  </span><span class="hs-glyph">|</span><span> </span><a name="InfixConstructor"><a href="Language.Haskell.TH.Datatype.html#InfixConstructor"><span class="hs-identifier">InfixConstructor</span></a></a><span>         </span><span class="hs-comment">-- ^ Constructor without field names that is</span><span>
</span><a name="line-198"></a><span>                             </span><span class="hs-comment">--   declared infix</span><span>
</span><a name="line-199"></a><span>  </span><span class="hs-glyph">|</span><span> </span><a name="RecordConstructor"><a href="Language.Haskell.TH.Datatype.html#RecordConstructor"><span class="hs-identifier">RecordConstructor</span></a></a><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Name</span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- ^ Constructor with field names</span><span>
</span><a name="line-200"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Data</span><span>
</span><a name="line-201"></a><span class="hs-cpp">#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span class="hs-identifier hs-type">Generic</span><span>
</span><a name="line-203"></a><span class="hs-cpp">#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><a name="line-205"></a><span>
</span><a name="line-206"></a><span class="hs-comment">-- | Normalized information about a constructor field's @UNPACK@ and</span><span>
</span><a name="line-207"></a><span class="hs-comment">-- strictness annotations.</span><span>
</span><a name="line-208"></a><span class="hs-comment">--</span><span>
</span><a name="line-209"></a><span class="hs-comment">-- Note that the interface for reifying strictness in Template Haskell changed</span><span>
</span><a name="line-210"></a><span class="hs-comment">-- considerably in GHC 8.0. The presentation in this library mirrors that which</span><span>
</span><a name="line-211"></a><span class="hs-comment">-- can be found in GHC 8.0 or later, whereas previously, unpackedness and</span><span>
</span><a name="line-212"></a><span class="hs-comment">-- strictness were represented with a single data type:</span><span>
</span><a name="line-213"></a><span class="hs-comment">--</span><span>
</span><a name="line-214"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-215"></a><span class="hs-comment">-- data Strict</span><span>
</span><a name="line-216"></a><span class="hs-comment">--   = IsStrict</span><span>
</span><a name="line-217"></a><span class="hs-comment">--   | NotStrict</span><span>
</span><a name="line-218"></a><span class="hs-comment">--   | Unpacked -- On GHC 7.4 or later</span><span>
</span><a name="line-219"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-220"></a><span class="hs-comment">--</span><span>
</span><a name="line-221"></a><span class="hs-comment">-- For backwards compatibility, we retrofit these constructors onto the</span><span>
</span><a name="line-222"></a><span class="hs-comment">-- following three values, respectively:</span><span>
</span><a name="line-223"></a><span class="hs-comment">--</span><span>
</span><a name="line-224"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-225"></a><span class="hs-comment">-- 'isStrictAnnot'  = 'FieldStrictness' 'UnspecifiedUnpackedness' 'Strict'</span><span>
</span><a name="line-226"></a><span class="hs-comment">-- 'notStrictAnnot' = 'FieldStrictness' 'UnspecifiedUnpackedness' 'UnspecifiedStrictness'</span><span>
</span><a name="line-227"></a><span class="hs-comment">-- 'unpackedAnnot'  = 'FieldStrictness' 'Unpack' 'Strict'</span><span>
</span><a name="line-228"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-229"></a><span class="hs-keyword">data</span><span> </span><a name="FieldStrictness"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier">FieldStrictness</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="FieldStrictness"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier">FieldStrictness</span></a></a><span>
</span><a name="line-230"></a><span>  </span><span class="hs-special">{</span><span> </span><a name="fieldUnpackedness"><a href="Language.Haskell.TH.Datatype.html#fieldUnpackedness"><span class="hs-identifier">fieldUnpackedness</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#Unpackedness"><span class="hs-identifier hs-type">Unpackedness</span></a><span>
</span><a name="line-231"></a><span>  </span><span class="hs-special">,</span><span> </span><a name="fieldStrictness"><a href="Language.Haskell.TH.Datatype.html#fieldStrictness"><span class="hs-identifier">fieldStrictness</span></a></a><span>   </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#Strictness"><span class="hs-identifier hs-type">Strictness</span></a><span>
</span><a name="line-232"></a><span>  </span><span class="hs-special">}</span><span>
</span><a name="line-233"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Data</span><span>
</span><a name="line-234"></a><span class="hs-cpp">#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span class="hs-identifier hs-type">Generic</span><span>
</span><a name="line-236"></a><span class="hs-cpp">#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><a name="line-238"></a><span>
</span><a name="line-239"></a><span class="hs-comment">-- | Information about a constructor field's unpackedness annotation.</span><span>
</span><a name="line-240"></a><span class="hs-keyword">data</span><span> </span><a name="Unpackedness"><a href="Language.Haskell.TH.Datatype.html#Unpackedness"><span class="hs-identifier">Unpackedness</span></a></a><span>
</span><a name="line-241"></a><span>  </span><span class="hs-glyph">=</span><span> </span><a name="UnspecifiedUnpackedness"><a href="Language.Haskell.TH.Datatype.html#UnspecifiedUnpackedness"><span class="hs-identifier">UnspecifiedUnpackedness</span></a></a><span> </span><span class="hs-comment">-- ^ No annotation whatsoever</span><span>
</span><a name="line-242"></a><span>  </span><span class="hs-glyph">|</span><span> </span><a name="NoUnpack"><a href="Language.Haskell.TH.Datatype.html#NoUnpack"><span class="hs-identifier">NoUnpack</span></a></a><span>                </span><span class="hs-comment">-- ^ Annotated with @{\-\# NOUNPACK \#-\}@</span><span>
</span><a name="line-243"></a><span>  </span><span class="hs-glyph">|</span><span> </span><a name="Unpack"><a href="Language.Haskell.TH.Datatype.html#Unpack"><span class="hs-identifier">Unpack</span></a></a><span>                  </span><span class="hs-comment">-- ^ Annotated with @{\-\# UNPACK \#-\}@</span><span>
</span><a name="line-244"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Data</span><span>
</span><a name="line-245"></a><span class="hs-cpp">#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span class="hs-identifier hs-type">Generic</span><span>
</span><a name="line-247"></a><span class="hs-cpp">#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><a name="line-249"></a><span>
</span><a name="line-250"></a><span class="hs-comment">-- | Information about a constructor field's strictness annotation.</span><span>
</span><a name="line-251"></a><span class="hs-keyword">data</span><span> </span><a name="Strictness"><a href="Language.Haskell.TH.Datatype.html#Strictness"><span class="hs-identifier">Strictness</span></a></a><span>
</span><a name="line-252"></a><span>  </span><span class="hs-glyph">=</span><span> </span><a name="UnspecifiedStrictness"><a href="Language.Haskell.TH.Datatype.html#UnspecifiedStrictness"><span class="hs-identifier">UnspecifiedStrictness</span></a></a><span> </span><span class="hs-comment">-- ^ No annotation whatsoever</span><span>
</span><a name="line-253"></a><span>  </span><span class="hs-glyph">|</span><span> </span><a name="Lazy"><a href="Language.Haskell.TH.Datatype.html#Lazy"><span class="hs-identifier">Lazy</span></a></a><span>                  </span><span class="hs-comment">-- ^ Annotated with @~@</span><span>
</span><a name="line-254"></a><span>  </span><span class="hs-glyph">|</span><span> </span><a name="Strict"><a href="Language.Haskell.TH.Datatype.html#Strict"><span class="hs-identifier">Strict</span></a></a><span>                </span><span class="hs-comment">-- ^ Annotated with @!@</span><span>
</span><a name="line-255"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Typeable</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Data</span><span>
</span><a name="line-256"></a><span class="hs-cpp">#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span class="hs-identifier hs-type">Generic</span><span>
</span><a name="line-258"></a><span class="hs-cpp">#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><a name="line-260"></a><span>
</span><a name="line-261"></a><span class="hs-identifier">isStrictAnnot</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">notStrictAnnot</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">unpackedAnnot</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a><span>
</span><a name="line-262"></a><a name="isStrictAnnot"><a href="Language.Haskell.TH.Datatype.html#isStrictAnnot"><span class="hs-identifier">isStrictAnnot</span></a></a><span>  </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedUnpackedness"><span class="hs-identifier hs-var">UnspecifiedUnpackedness</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#Strict"><span class="hs-identifier hs-var">Strict</span></a><span>
</span><a name="line-263"></a><a name="notStrictAnnot"><a href="Language.Haskell.TH.Datatype.html#notStrictAnnot"><span class="hs-identifier">notStrictAnnot</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedUnpackedness"><span class="hs-identifier hs-var">UnspecifiedUnpackedness</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedStrictness"><span class="hs-identifier hs-var">UnspecifiedStrictness</span></a><span>
</span><a name="line-264"></a><a name="unpackedAnnot"><a href="Language.Haskell.TH.Datatype.html#unpackedAnnot"><span class="hs-identifier">unpackedAnnot</span></a></a><span>  </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#Unpack"><span class="hs-identifier hs-var">Unpack</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#Strict"><span class="hs-identifier hs-var">Strict</span></a><span>
</span><a name="line-265"></a><span>
</span><a name="line-266"></a><span class="hs-comment">-- | Construct a Type using the datatype's type constructor and type</span><span>
</span><a name="line-267"></a><span class="hs-comment">-- parameters. Kind signatures are removed.</span><span>
</span><a name="line-268"></a><span class="hs-identifier">datatypeType</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-269"></a><a name="datatypeType"><a href="Language.Haskell.TH.Datatype.html#datatypeType"><span class="hs-identifier">datatypeType</span></a></a><span> </span><a name="local-6989586621679053418"><a href="#local-6989586621679053418"><span class="hs-identifier">di</span></a></a><span>
</span><a name="line-270"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">foldl</span><span> </span><span class="hs-identifier hs-var">AppT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">ConT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">datatypeName</span><span> </span><a href="#local-6989586621679053418"><span class="hs-identifier hs-var">di</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-271"></a><span>  </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><a href="Language.Haskell.TH.Datatype.html#stripSigT"><span class="hs-identifier hs-var">stripSigT</span></a><span>
</span><a name="line-272"></a><span>  </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier">datatypeVars</span><span> </span><a href="#local-6989586621679053418"><span class="hs-identifier hs-var">di</span></a><span>
</span><a name="line-273"></a><span>
</span><a name="line-274"></a><span>
</span><a name="line-275"></a><span class="hs-comment">-- | Compute a normalized view of the metadata about a data type or newtype</span><span>
</span><a name="line-276"></a><span class="hs-comment">-- given a constructor.</span><span>
</span><a name="line-277"></a><span class="hs-comment">--</span><span>
</span><a name="line-278"></a><span class="hs-comment">-- This function will accept any constructor (value or type) for a type</span><span>
</span><a name="line-279"></a><span class="hs-comment">-- declared with newtype or data. Value constructors must be used to</span><span>
</span><a name="line-280"></a><span class="hs-comment">-- lookup datatype information about /data instances/ and /newtype instances/,</span><span>
</span><a name="line-281"></a><span class="hs-comment">-- as giving the type constructor of a data family is often not enough to</span><span>
</span><a name="line-282"></a><span class="hs-comment">-- determine a particular data family instance.</span><span>
</span><a name="line-283"></a><span class="hs-comment">--</span><span>
</span><a name="line-284"></a><span class="hs-comment">-- In addition, this function will also accept a record selector for a</span><span>
</span><a name="line-285"></a><span class="hs-comment">-- data type with a constructor which uses that record.</span><span>
</span><a name="line-286"></a><span class="hs-comment">--</span><span>
</span><a name="line-287"></a><span class="hs-comment">-- GADT constructors are normalized into datatypes with explicit equality</span><span>
</span><a name="line-288"></a><span class="hs-comment">-- constraints. Note that no effort is made to distinguish between equalities of</span><span>
</span><a name="line-289"></a><span class="hs-comment">-- the same (homogeneous) kind and equalities between different (heterogeneous)</span><span>
</span><a name="line-290"></a><span class="hs-comment">-- kinds. For instance, the following GADT's constructors:</span><span>
</span><a name="line-291"></a><span class="hs-comment">--</span><span>
</span><a name="line-292"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-293"></a><span class="hs-comment">-- data T (a :: k -&gt; *) where</span><span>
</span><a name="line-294"></a><span class="hs-comment">--   MkT1 :: T Proxy</span><span>
</span><a name="line-295"></a><span class="hs-comment">--   MkT2 :: T Maybe</span><span>
</span><a name="line-296"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-297"></a><span class="hs-comment">--</span><span>
</span><a name="line-298"></a><span class="hs-comment">-- will be normalized to the following equality constraints:</span><span>
</span><a name="line-299"></a><span class="hs-comment">--</span><span>
</span><a name="line-300"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-301"></a><span class="hs-comment">-- AppT (AppT EqualityT (VarT a)) (ConT Proxy) -- MkT1</span><span>
</span><a name="line-302"></a><span class="hs-comment">-- AppT (AppT EqualityT (VarT a)) (ConT Maybe) -- MkT2</span><span>
</span><a name="line-303"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-304"></a><span class="hs-comment">--</span><span>
</span><a name="line-305"></a><span class="hs-comment">-- But only the first equality constraint is well kinded, since in the second</span><span>
</span><a name="line-306"></a><span class="hs-comment">-- constraint, the kinds of @(a :: k -&gt; *)@ and @(Maybe :: * -&gt; *)@ are different.</span><span>
</span><a name="line-307"></a><span class="hs-comment">-- Trying to categorize which constraints need homogeneous or heterogeneous</span><span>
</span><a name="line-308"></a><span class="hs-comment">-- equality is tricky, so we leave that task to users of this library.</span><span>
</span><a name="line-309"></a><span class="hs-comment">--</span><span>
</span><a name="line-310"></a><span class="hs-comment">-- This function will apply various bug-fixes to the output of the underlying</span><span>
</span><a name="line-311"></a><span class="hs-comment">-- @template-haskell@ library in order to provide a view of datatypes in</span><span>
</span><a name="line-312"></a><span class="hs-comment">-- as uniform a way as possible.</span><span>
</span><a name="line-313"></a><span class="hs-identifier">reifyDatatype</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-314"></a><span>  </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-comment">{- ^ data type or constructor name -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-315"></a><span>  </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span>
</span><a name="line-316"></a><a name="reifyDatatype"><a href="Language.Haskell.TH.Datatype.html#reifyDatatype"><span class="hs-identifier">reifyDatatype</span></a></a><span> </span><a name="local-6989586621679053419"><a href="#local-6989586621679053419"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeInfo%27"><span class="hs-identifier hs-var">normalizeInfo'</span></a><span> </span><span class="hs-string">&quot;reifyDatatype&quot;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#isReified"><span class="hs-identifier hs-var">isReified</span></a><span> </span><span class="hs-operator hs-var">=&lt;&lt;</span><span> </span><span class="hs-identifier hs-var">reify</span><span> </span><a href="#local-6989586621679053419"><span class="hs-identifier hs-var">n</span></a><span>
</span><a name="line-317"></a><span>
</span><a name="line-318"></a><span class="hs-comment">-- | Compute a normalized view of the metadata about a constructor given its</span><span>
</span><a name="line-319"></a><span class="hs-comment">-- 'Name'. This is useful for scenarios when you don't care about the info for</span><span>
</span><a name="line-320"></a><span class="hs-comment">-- the enclosing data type.</span><span>
</span><a name="line-321"></a><span class="hs-identifier">reifyConstructor</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-322"></a><span>  </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-comment">{- ^ constructor name -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-323"></a><span>  </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span>
</span><a name="line-324"></a><a name="reifyConstructor"><a href="Language.Haskell.TH.Datatype.html#reifyConstructor"><span class="hs-identifier">reifyConstructor</span></a></a><span> </span><a name="local-6989586621679053420"><a href="#local-6989586621679053420"><span class="hs-identifier">conName</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-325"></a><span>  </span><a name="local-6989586621679053421"><a href="#local-6989586621679053421"><span class="hs-identifier">dataInfo</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.TH.Datatype.html#reifyDatatype"><span class="hs-identifier hs-var">reifyDatatype</span></a><span> </span><a href="#local-6989586621679053420"><span class="hs-identifier hs-var">conName</span></a><span>
</span><a name="line-326"></a><span>  </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><a href="Language.Haskell.TH.Datatype.html#lookupByConstructorName"><span class="hs-identifier hs-var">lookupByConstructorName</span></a><span> </span><a href="#local-6989586621679053420"><span class="hs-identifier hs-var">conName</span></a><span> </span><a href="#local-6989586621679053421"><span class="hs-identifier hs-var">dataInfo</span></a><span>
</span><a name="line-327"></a><span>
</span><a name="line-328"></a><span class="hs-comment">-- | Compute a normalized view of the metadata about a constructor given the</span><span>
</span><a name="line-329"></a><span class="hs-comment">-- 'Name' of one of its record selectors. This is useful for scenarios when you</span><span>
</span><a name="line-330"></a><span class="hs-comment">-- don't care about the info for the enclosing data type.</span><span>
</span><a name="line-331"></a><span class="hs-identifier">reifyRecord</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-332"></a><span>  </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-comment">{- ^ record name -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-333"></a><span>  </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span>
</span><a name="line-334"></a><a name="reifyRecord"><a href="Language.Haskell.TH.Datatype.html#reifyRecord"><span class="hs-identifier">reifyRecord</span></a></a><span> </span><a name="local-6989586621679053422"><a href="#local-6989586621679053422"><span class="hs-identifier">recordName</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-335"></a><span>  </span><a name="local-6989586621679053423"><a href="#local-6989586621679053423"><span class="hs-identifier">dataInfo</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.TH.Datatype.html#reifyDatatype"><span class="hs-identifier hs-var">reifyDatatype</span></a><span> </span><a href="#local-6989586621679053422"><span class="hs-identifier hs-var">recordName</span></a><span>
</span><a name="line-336"></a><span>  </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><a href="Language.Haskell.TH.Datatype.html#lookupByRecordName"><span class="hs-identifier hs-var">lookupByRecordName</span></a><span> </span><a href="#local-6989586621679053422"><span class="hs-identifier hs-var">recordName</span></a><span> </span><a href="#local-6989586621679053423"><span class="hs-identifier hs-var">dataInfo</span></a><span>
</span><a name="line-337"></a><span>
</span><a name="line-338"></a><span class="hs-comment">-- | Given a 'DatatypeInfo', find the 'ConstructorInfo' corresponding to the</span><span>
</span><a name="line-339"></a><span class="hs-comment">-- 'Name' of one of its constructors.</span><span>
</span><a name="line-340"></a><span class="hs-identifier">lookupByConstructorName</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-341"></a><span>  </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-comment">{- ^ constructor name -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-342"></a><span>  </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span> </span><span class="hs-comment">{- ^ info for the datatype which has that constructor -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-343"></a><span>  </span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span>
</span><a name="line-344"></a><a name="lookupByConstructorName"><a href="Language.Haskell.TH.Datatype.html#lookupByConstructorName"><span class="hs-identifier">lookupByConstructorName</span></a></a><span> </span><a name="local-6989586621679053424"><a href="#local-6989586621679053424"><span class="hs-identifier">conName</span></a></a><span> </span><a name="local-6989586621679053425"><a href="#local-6989586621679053425"><span class="hs-identifier">dataInfo</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-345"></a><span>  </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier hs-var">find</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator hs-var">==</span><span> </span><a href="#local-6989586621679053424"><span class="hs-identifier hs-var">conName</span></a><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier">constructorName</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">datatypeCons</span><span> </span><a href="#local-6989586621679053425"><span class="hs-identifier hs-var">dataInfo</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-346"></a><span>    </span><span class="hs-identifier hs-var">Just</span><span> </span><a name="local-6989586621679053426"><a href="#local-6989586621679053426"><span class="hs-identifier">conInfo</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053426"><span class="hs-identifier hs-var">conInfo</span></a><span>
</span><a name="line-347"></a><span>    </span><span class="hs-identifier hs-var">Nothing</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">error</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-string">&quot;Datatype &quot;</span><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-identifier hs-var">nameBase</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">datatypeName</span><span> </span><a href="#local-6989586621679053425"><span class="hs-identifier hs-var">dataInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-348"></a><span>                         </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-string">&quot; does not have a constructor named &quot;</span><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-identifier hs-var">nameBase</span><span> </span><a href="#local-6989586621679053424"><span class="hs-identifier hs-var">conName</span></a><span>
</span><a name="line-349"></a><span class="hs-comment">-- | Given a 'DatatypeInfo', find the 'ConstructorInfo' corresponding to the</span><span>
</span><a name="line-350"></a><span class="hs-comment">-- 'Name' of one of its constructors.</span><span>
</span><a name="line-351"></a><span class="hs-identifier">lookupByRecordName</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-352"></a><span>  </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-comment">{- ^ record name -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-353"></a><span>  </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span> </span><span class="hs-comment">{- ^ info for the datatype which has that constructor -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-354"></a><span>  </span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span>
</span><a name="line-355"></a><a name="lookupByRecordName"><a href="Language.Haskell.TH.Datatype.html#lookupByRecordName"><span class="hs-identifier">lookupByRecordName</span></a></a><span> </span><a name="local-6989586621679053441"><a href="#local-6989586621679053441"><span class="hs-identifier">recordName</span></a></a><span> </span><a name="local-6989586621679053442"><a href="#local-6989586621679053442"><span class="hs-identifier">dataInfo</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-356"></a><span>  </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier hs-var">find</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#conHasRecord"><span class="hs-identifier hs-var">conHasRecord</span></a><span> </span><a href="#local-6989586621679053441"><span class="hs-identifier hs-var">recordName</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">datatypeCons</span><span> </span><a href="#local-6989586621679053442"><span class="hs-identifier hs-var">dataInfo</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-357"></a><span>    </span><span class="hs-identifier hs-var">Just</span><span> </span><a name="local-6989586621679053443"><a href="#local-6989586621679053443"><span class="hs-identifier">conInfo</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053443"><span class="hs-identifier hs-var">conInfo</span></a><span>
</span><a name="line-358"></a><span>    </span><span class="hs-identifier hs-var">Nothing</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">error</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-string">&quot;Datatype &quot;</span><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-identifier hs-var">nameBase</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">datatypeName</span><span> </span><a href="#local-6989586621679053442"><span class="hs-identifier hs-var">dataInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-359"></a><span>                         </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-string">&quot; does not have any constructors with a &quot;</span><span>
</span><a name="line-360"></a><span>                         </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-string">&quot;record selector named &quot;</span><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-identifier hs-var">nameBase</span><span> </span><a href="#local-6989586621679053441"><span class="hs-identifier hs-var">recordName</span></a><span>
</span><a name="line-361"></a><span>
</span><a name="line-362"></a><span class="hs-comment">-- | Normalize 'Info' for a newtype or datatype into a 'DatatypeInfo'.</span><span>
</span><a name="line-363"></a><span class="hs-comment">-- Fail in 'Q' otherwise.</span><span>
</span><a name="line-364"></a><span class="hs-identifier">normalizeInfo</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Info</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span>
</span><a name="line-365"></a><a name="normalizeInfo"><a href="Language.Haskell.TH.Datatype.html#normalizeInfo"><span class="hs-identifier">normalizeInfo</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeInfo%27"><span class="hs-identifier hs-var">normalizeInfo'</span></a><span> </span><span class="hs-string">&quot;normalizeInfo&quot;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#isn%27tReified"><span class="hs-identifier hs-var">isn'tReified</span></a><span>
</span><a name="line-366"></a><span>
</span><a name="line-367"></a><span class="hs-identifier">normalizeInfo'</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Info</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span>
</span><a name="line-368"></a><a name="normalizeInfo%27"><a href="Language.Haskell.TH.Datatype.html#normalizeInfo%27"><span class="hs-identifier">normalizeInfo'</span></a></a><span> </span><a name="local-6989586621679053444"><a href="#local-6989586621679053444"><span class="hs-identifier">entry</span></a></a><span> </span><a name="local-6989586621679053445"><a href="#local-6989586621679053445"><span class="hs-identifier">reifiedDec</span></a></a><span> </span><a name="local-6989586621679053446"><a href="#local-6989586621679053446"><span class="hs-identifier">i</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-369"></a><span>  </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679053446"><span class="hs-identifier hs-var">i</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-370"></a><span>    </span><span class="hs-identifier hs-var">PrimTyConI</span><span class="hs-special">{</span><span class="hs-special">}</span><span>                      </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053447"><span class="hs-identifier hs-var">bad</span></a><span> </span><span class="hs-string">&quot;Primitive type not supported&quot;</span><span>
</span><a name="line-371"></a><span>    </span><span class="hs-identifier hs-var">ClassI</span><span class="hs-special">{</span><span class="hs-special">}</span><span>                          </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053447"><span class="hs-identifier hs-var">bad</span></a><span> </span><span class="hs-string">&quot;Class not supported&quot;</span><span>
</span><a name="line-372"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="hs-identifier hs-var">FamilyI</span><span> </span><span class="hs-identifier hs-var">DataFamilyD</span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-identifier">_</span><span>           </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-374"></a><span class="hs-cpp">#elif MIN_VERSION_template_haskell(2,7,0)
</span><span>    </span><span class="hs-identifier">FamilyI</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">DataFam</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-376"></a><span class="hs-cpp">#else
</span><span>    </span><span class="hs-identifier">TyConI</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">DataFam</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-378"></a><span class="hs-cpp">#endif
</span><span>                                         </span><a href="#local-6989586621679053447"><span class="hs-identifier hs-var">bad</span></a><span> </span><span class="hs-string">&quot;Use a value constructor to reify a data family instance&quot;</span><span>
</span><a name="line-380"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,7,0)
</span><span>    </span><span class="hs-identifier hs-var">FamilyI</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053447"><span class="hs-identifier hs-var">bad</span></a><span> </span><span class="hs-string">&quot;Type families not supported&quot;</span><span>
</span><a name="line-382"></a><span class="hs-cpp">#endif
</span><span>    </span><span class="hs-identifier hs-var">TyConI</span><span> </span><a name="local-6989586621679053449"><a href="#local-6989586621679053449"><span class="hs-identifier">dec</span></a></a><span>                        </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var">normalizeDecFor</span></a><span> </span><a href="#local-6989586621679053445"><span class="hs-identifier hs-var">reifiedDec</span></a><span> </span><a href="#local-6989586621679053449"><span class="hs-identifier hs-var">dec</span></a><span>
</span><a name="line-384"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="hs-identifier hs-var">DataConI</span><span> </span><a name="local-6989586621679053450"><a href="#local-6989586621679053450"><span class="hs-identifier">name</span></a></a><span> </span><span class="hs-identifier">_</span><span> </span><a name="local-6989586621679053451"><a href="#local-6989586621679053451"><span class="hs-identifier">parent</span></a></a><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#reifyParent"><span class="hs-identifier hs-var">reifyParent</span></a><span> </span><a href="#local-6989586621679053450"><span class="hs-identifier hs-var">name</span></a><span> </span><a href="#local-6989586621679053451"><span class="hs-identifier hs-var">parent</span></a><span>
</span><a name="line-386"></a><span>                                         </span><span class="hs-comment">-- NB: We do not pass the IsReifiedDec information here</span><span>
</span><a name="line-387"></a><span>                                         </span><span class="hs-comment">-- because there's no point. We have no choice but to</span><span>
</span><a name="line-388"></a><span>                                         </span><span class="hs-comment">-- call reify here, since we need to determine the</span><span>
</span><a name="line-389"></a><span>                                         </span><span class="hs-comment">-- parent data type/family.</span><span>
</span><a name="line-390"></a><span class="hs-cpp">#else
</span><span>    </span><span class="hs-identifier">DataConI</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">parent</span><span> </span><span class="hs-identifier">_</span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">reifyParent</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">parent</span><span>
</span><a name="line-392"></a><span class="hs-cpp">#endif
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="hs-identifier hs-var">VarI</span><span> </span><a name="local-6989586621679053452"><a href="#local-6989586621679053452"><span class="hs-identifier">recName</span></a></a><span> </span><a name="local-6989586621679053453"><a href="#local-6989586621679053453"><span class="hs-identifier">recTy</span></a></a><span> </span><span class="hs-identifier">_</span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#reifyRecordType"><span class="hs-identifier hs-var">reifyRecordType</span></a><span> </span><a href="#local-6989586621679053452"><span class="hs-identifier hs-var">recName</span></a><span> </span><a href="#local-6989586621679053453"><span class="hs-identifier hs-var">recTy</span></a><span>
</span><a name="line-395"></a><span>                                         </span><span class="hs-comment">-- NB: Similarly, we do not pass the IsReifiedDec</span><span>
</span><a name="line-396"></a><span>                                         </span><span class="hs-comment">-- information here.</span><span>
</span><a name="line-397"></a><span class="hs-cpp">#else
</span><span>    </span><span class="hs-identifier">VarI</span><span> </span><span class="hs-identifier">recName</span><span> </span><span class="hs-identifier">recTy</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">reifyRecordType</span><span> </span><span class="hs-identifier">recName</span><span> </span><span class="hs-identifier">recTy</span><span>
</span><a name="line-399"></a><span class="hs-cpp">#endif
</span><span>    </span><span class="hs-identifier">_</span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053447"><span class="hs-identifier hs-var">bad</span></a><span> </span><span class="hs-string">&quot;Expected a type constructor&quot;</span><span>
</span><a name="line-401"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-402"></a><span>    </span><a name="local-6989586621679053447"><a href="#local-6989586621679053447"><span class="hs-identifier">bad</span></a></a><span> </span><a name="local-6989586621679053448"><a href="#local-6989586621679053448"><span class="hs-identifier">msg</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">fail</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053444"><span class="hs-identifier hs-var">entry</span></a><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-string">&quot;: &quot;</span><span> </span><span class="hs-operator hs-var">++</span><span> </span><a href="#local-6989586621679053448"><span class="hs-identifier hs-var">msg</span></a><span class="hs-special">)</span><span>
</span><a name="line-403"></a><span>
</span><a name="line-404"></a><span>
</span><a name="line-405"></a><span class="hs-identifier">reifyParent</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span>
</span><a name="line-406"></a><a name="reifyParent"><a href="Language.Haskell.TH.Datatype.html#reifyParent"><span class="hs-identifier">reifyParent</span></a></a><span> </span><a name="local-6989586621679053454"><a href="#local-6989586621679053454"><span class="hs-identifier">con</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#reifyParentWith"><span class="hs-identifier hs-var">reifyParentWith</span></a><span> </span><span class="hs-string">&quot;reifyParent&quot;</span><span> </span><a href="#local-6989586621679053455"><span class="hs-identifier hs-var">p</span></a><span>
</span><a name="line-407"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-408"></a><span>    </span><span class="hs-identifier">p</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Bool</span><span>
</span><a name="line-409"></a><span>    </span><a name="local-6989586621679053455"><a href="#local-6989586621679053455"><span class="hs-identifier">p</span></a></a><span> </span><a name="local-6989586621679053456"><a href="#local-6989586621679053456"><span class="hs-identifier">info</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053454"><span class="hs-identifier hs-var">con</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">elem</span><span class="hs-special">`</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-identifier">constructorName</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">datatypeCons</span><span> </span><a href="#local-6989586621679053456"><span class="hs-identifier hs-var">info</span></a><span class="hs-special">)</span><span>
</span><a name="line-410"></a><span>
</span><a name="line-411"></a><span class="hs-identifier">reifyRecordType</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span>
</span><a name="line-412"></a><a name="reifyRecordType"><a href="Language.Haskell.TH.Datatype.html#reifyRecordType"><span class="hs-identifier">reifyRecordType</span></a></a><span> </span><a name="local-6989586621679053457"><a href="#local-6989586621679053457"><span class="hs-identifier">recName</span></a></a><span> </span><a name="local-6989586621679053458"><a href="#local-6989586621679053458"><span class="hs-identifier">recTy</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-413"></a><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span> </span><a name="local-6989586621679053466"><a href="#local-6989586621679053466"><span class="hs-identifier">argTys</span></a></a><span> </span><a href="Language.Haskell.TH.Datatype.html#%3A%7C-"><span class="hs-operator hs-var">:|-</span></a><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#uncurryType"><span class="hs-identifier hs-var">uncurryType</span></a><span> </span><a href="#local-6989586621679053458"><span class="hs-identifier hs-var">recTy</span></a><span>
</span><a name="line-414"></a><span>  </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679053466"><span class="hs-identifier hs-var">argTys</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-415"></a><span>       </span><a name="local-6989586621679053467"><a href="#local-6989586621679053467"><span class="hs-identifier">dataTy</span></a></a><span class="hs-glyph">:</span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053459"><span class="hs-identifier hs-var">decomposeDataType</span></a><span> </span><a href="#local-6989586621679053467"><span class="hs-identifier hs-var">dataTy</span></a><span>
</span><a name="line-416"></a><span>       </span><span class="hs-identifier">_</span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053460"><span class="hs-identifier hs-var">notRecSelFailure</span></a><span>
</span><a name="line-417"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-418"></a><span>    </span><span class="hs-identifier">decomposeDataType</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span>
</span><a name="line-419"></a><span>    </span><a name="local-6989586621679053459"><a href="#local-6989586621679053459"><span class="hs-identifier">decomposeDataType</span></a></a><span> </span><a name="local-6989586621679053463"><a href="#local-6989586621679053463"><span class="hs-identifier">ty</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-420"></a><span>      </span><span class="hs-keyword">do</span><span> </span><span class="hs-keyword">case</span><span> </span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a><span> </span><a href="#local-6989586621679053463"><span class="hs-identifier hs-var">ty</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-421"></a><span>           </span><span class="hs-identifier hs-var">ConT</span><span> </span><a name="local-6989586621679053464"><a href="#local-6989586621679053464"><span class="hs-identifier">parent</span></a></a><span> </span><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-var">:|</span></a><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#reifyParentWith"><span class="hs-identifier hs-var">reifyParentWith</span></a><span> </span><span class="hs-string">&quot;reifyRecordType&quot;</span><span> </span><a href="#local-6989586621679053461"><span class="hs-identifier hs-var">p</span></a><span> </span><a href="#local-6989586621679053464"><span class="hs-identifier hs-var">parent</span></a><span>
</span><a name="line-422"></a><span>           </span><span class="hs-identifier">_</span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053460"><span class="hs-identifier hs-var">notRecSelFailure</span></a><span>
</span><a name="line-423"></a><span>
</span><a name="line-424"></a><span>    </span><span class="hs-identifier">notRecSelFailure</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="#local-6989586621679053462"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-425"></a><span>    </span><a name="local-6989586621679053460"><a href="#local-6989586621679053460"><span class="hs-identifier">notRecSelFailure</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">fail</span><span> </span><span class="hs-operator hs-var">$</span><span>
</span><a name="line-426"></a><span>      </span><span class="hs-string">&quot;reifyRecordType: Not a record selector type: &quot;</span><span> </span><span class="hs-operator hs-var">++</span><span>
</span><a name="line-427"></a><span>      </span><span class="hs-identifier hs-var">nameBase</span><span> </span><a href="#local-6989586621679053457"><span class="hs-identifier hs-var">recName</span></a><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-string">&quot; :: &quot;</span><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-identifier hs-var">show</span><span> </span><a href="#local-6989586621679053458"><span class="hs-identifier hs-var">recTy</span></a><span>
</span><a name="line-428"></a><span>
</span><a name="line-429"></a><span>    </span><span class="hs-identifier">p</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Bool</span><span>
</span><a name="line-430"></a><span>    </span><a name="local-6989586621679053461"><a href="#local-6989586621679053461"><span class="hs-identifier">p</span></a></a><span> </span><a name="local-6989586621679053465"><a href="#local-6989586621679053465"><span class="hs-identifier">info</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">any</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#conHasRecord"><span class="hs-identifier hs-var">conHasRecord</span></a><span> </span><a href="#local-6989586621679053457"><span class="hs-identifier hs-var">recName</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">datatypeCons</span><span> </span><a href="#local-6989586621679053465"><span class="hs-identifier hs-var">info</span></a><span class="hs-special">)</span><span>
</span><a name="line-431"></a><span>
</span><a name="line-432"></a><span class="hs-identifier">reifyParentWith</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-433"></a><span>  </span><span class="hs-identifier hs-type">String</span><span>                 </span><span class="hs-comment">{- ^ prefix for error messages -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-434"></a><span>  </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Bool</span><span class="hs-special">)</span><span> </span><span class="hs-comment">{- ^ predicate for finding the right
                              data family instance -}</span><span>      </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-436"></a><span>  </span><span class="hs-identifier hs-type">Name</span><span>                   </span><span class="hs-comment">{- ^ parent data type name -}</span><span>     </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-437"></a><span>  </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span>
</span><a name="line-438"></a><a name="reifyParentWith"><a href="Language.Haskell.TH.Datatype.html#reifyParentWith"><span class="hs-identifier">reifyParentWith</span></a></a><span> </span><a name="local-6989586621679053468"><a href="#local-6989586621679053468"><span class="hs-identifier">prefix</span></a></a><span> </span><a name="local-6989586621679053469"><a href="#local-6989586621679053469"><span class="hs-identifier">p</span></a></a><span> </span><a name="local-6989586621679053470"><a href="#local-6989586621679053470"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-439"></a><span>  </span><span class="hs-keyword">do</span><span> </span><a name="local-6989586621679053476"><a href="#local-6989586621679053476"><span class="hs-identifier">info</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">reify</span><span> </span><a href="#local-6989586621679053470"><span class="hs-identifier hs-var">n</span></a><span>
</span><a name="line-440"></a><span>     </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679053476"><span class="hs-identifier hs-var">info</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-441"></a><span class="hs-cpp">#if !(MIN_VERSION_template_haskell(2,11,0))
</span><span>       </span><span class="hs-comment">-- This unusual combination of Info and Dec is only possible to reify on</span><span>
</span><a name="line-443"></a><span>       </span><span class="hs-comment">-- GHC 7.0 and 7.2, when you try to reify a data family. Because there's</span><span>
</span><a name="line-444"></a><span>       </span><span class="hs-comment">-- no way to reify the data family *instances* on these versions of GHC,</span><span>
</span><a name="line-445"></a><span>       </span><span class="hs-comment">-- we have no choice but to fail.</span><span>
</span><a name="line-446"></a><span>       </span><span class="hs-identifier">TyConI</span><span> </span><span class="hs-identifier">FamilyD</span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">dataFamiliesOnOldGHCsError</span><span>
</span><a name="line-447"></a><span class="hs-cpp">#endif
</span><span>       </span><span class="hs-identifier hs-var">TyConI</span><span> </span><a name="local-6989586621679053477"><a href="#local-6989586621679053477"><span class="hs-identifier">dec</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var">normalizeDecFor</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#isReified"><span class="hs-identifier hs-var">isReified</span></a><span> </span><a href="#local-6989586621679053477"><span class="hs-identifier hs-var">dec</span></a><span>
</span><a name="line-449"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,7,0)
</span><span>       </span><span class="hs-identifier hs-var">FamilyI</span><span> </span><a name="local-6989586621679053478"><a href="#local-6989586621679053478"><span class="hs-identifier">dec</span></a></a><span> </span><a name="local-6989586621679053479"><a href="#local-6989586621679053479"><span class="hs-identifier">instances</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-451"></a><span>         </span><span class="hs-keyword">do</span><span> </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679053480"><a href="#local-6989586621679053480"><span class="hs-identifier">instances1</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#repairDataFam"><span class="hs-identifier hs-var">repairDataFam</span></a><span> </span><a href="#local-6989586621679053478"><span class="hs-identifier hs-var">dec</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053479"><span class="hs-identifier hs-var">instances</span></a><span>
</span><a name="line-452"></a><span>            </span><a name="local-6989586621679053481"><a href="#local-6989586621679053481"><span class="hs-identifier">instances2</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">mapM</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var">normalizeDecFor</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#isReified"><span class="hs-identifier hs-var">isReified</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053480"><span class="hs-identifier hs-var">instances1</span></a><span>
</span><a name="line-453"></a><span>            </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier hs-var">find</span><span> </span><a href="#local-6989586621679053469"><span class="hs-identifier hs-var">p</span></a><span> </span><a href="#local-6989586621679053481"><span class="hs-identifier hs-var">instances2</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-454"></a><span>              </span><span class="hs-identifier hs-var">Just</span><span> </span><a name="local-6989586621679053482"><a href="#local-6989586621679053482"><span class="hs-identifier">inst</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><a href="#local-6989586621679053482"><span class="hs-identifier hs-var">inst</span></a><span>
</span><a name="line-455"></a><span>              </span><span class="hs-identifier hs-var">Nothing</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053472"><span class="hs-identifier hs-var">panic</span></a><span> </span><span class="hs-string">&quot;lost the instance&quot;</span><span>
</span><a name="line-456"></a><span class="hs-cpp">#endif
</span><span>       </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053472"><span class="hs-identifier hs-var">panic</span></a><span> </span><span class="hs-string">&quot;unexpected parent&quot;</span><span>
</span><a name="line-458"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-459"></a><span>    </span><span class="hs-identifier">dataFamiliesOnOldGHCsError</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="#local-6989586621679053473"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-460"></a><span>    </span><a name="local-6989586621679053471"><a href="#local-6989586621679053471"><span class="hs-identifier">dataFamiliesOnOldGHCsError</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">fail</span><span> </span><span class="hs-operator hs-var">$</span><span>
</span><a name="line-461"></a><span>      </span><a href="#local-6989586621679053468"><span class="hs-identifier hs-var">prefix</span></a><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-string">&quot;: Data family instances can only be reified with GHC 7.4 or later&quot;</span><span>
</span><a name="line-462"></a><span>
</span><a name="line-463"></a><span>    </span><span class="hs-identifier">panic</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="#local-6989586621679053474"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-464"></a><span>    </span><a name="local-6989586621679053472"><a href="#local-6989586621679053472"><span class="hs-identifier">panic</span></a></a><span> </span><a name="local-6989586621679053475"><a href="#local-6989586621679053475"><span class="hs-identifier">message</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">fail</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-string">&quot;PANIC: &quot;</span><span> </span><span class="hs-operator hs-var">++</span><span> </span><a href="#local-6989586621679053468"><span class="hs-identifier hs-var">prefix</span></a><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-string">&quot; &quot;</span><span> </span><span class="hs-operator hs-var">++</span><span> </span><a href="#local-6989586621679053475"><span class="hs-identifier hs-var">message</span></a><span>
</span><a name="line-465"></a><span>
</span><a name="line-466"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,8,0) &amp;&amp; (!MIN_VERSION_template_haskell(2,10,0))
</span><span>
</span><a name="line-468"></a><span class="hs-comment">-- A GHC 7.6-specific bug requires us to replace all occurrences of</span><span>
</span><a name="line-469"></a><span class="hs-comment">-- (ConT GHC.Prim.*) with StarT, or else Template Haskell will reject it.</span><span>
</span><a name="line-470"></a><span class="hs-comment">-- Luckily, (ConT GHC.Prim.*) only seems to occur in this one spot.</span><span>
</span><a name="line-471"></a><span class="hs-identifier">sanitizeStars</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Kind</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Kind</span><span>
</span><a name="line-472"></a><span class="hs-identifier">sanitizeStars</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">go</span><span>
</span><a name="line-473"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-474"></a><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Kind</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Kind</span><span>
</span><a name="line-475"></a><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">AppT</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-identifier">t2</span><span class="hs-special">)</span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">AppT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">t1</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">t2</span><span class="hs-special">)</span><span>
</span><a name="line-476"></a><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">SigT</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-identifier">k</span><span class="hs-special">)</span><span>                   </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">SigT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">t</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">k</span><span class="hs-special">)</span><span>
</span><a name="line-477"></a><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ConT</span><span> </span><span class="hs-identifier">n</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">starKindName</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">StarT</span><span>
</span><a name="line-478"></a><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">t</span><span>                            </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">t</span><span>
</span><a name="line-479"></a><span>
</span><a name="line-480"></a><span class="hs-comment">-- A version of repairVarKindsWith that does much more extra work to</span><span>
</span><a name="line-481"></a><span class="hs-comment">-- (1) eta-expand missing type patterns, and (2) ensure that the kind</span><span>
</span><a name="line-482"></a><span class="hs-comment">-- signatures for these new type patterns match accordingly.</span><span>
</span><a name="line-483"></a><span class="hs-identifier">repairVarKindsWith'</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">TyVarBndr</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Type</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Type</span><span class="hs-special">]</span><span>
</span><a name="line-484"></a><span class="hs-identifier">repairVarKindsWith'</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-485"></a><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">kindVars</span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">map</span><span> </span><span class="hs-identifier">kindPart</span><span>
</span><a name="line-486"></a><span>      </span><span class="hs-identifier">kindPart</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">KindedTV</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">k</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">k</span><span class="hs-special">]</span><span>
</span><a name="line-487"></a><span>      </span><span class="hs-identifier">kindPart</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">PlainTV</span><span>  </span><span class="hs-identifier">_</span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><a name="line-488"></a><span>
</span><a name="line-489"></a><span>      </span><span class="hs-identifier">nparams</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">length</span><span> </span><span class="hs-identifier">dvars</span><span>
</span><a name="line-490"></a><span>      </span><span class="hs-identifier">kparams</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">kindVars</span><span> </span><span class="hs-identifier">dvars</span><span>
</span><a name="line-491"></a><span>      </span><span class="hs-special">(</span><span class="hs-identifier">tsKinds</span><span class="hs-special">,</span><span class="hs-identifier">tsNoKinds</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">splitAt</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">length</span><span> </span><span class="hs-identifier">kparams</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">ts</span><span>
</span><a name="line-492"></a><span>      </span><span class="hs-identifier">tsKinds'</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">map</span><span> </span><span class="hs-identifier">sanitizeStars</span><span> </span><span class="hs-identifier">tsKinds</span><span>
</span><a name="line-493"></a><span>      </span><span class="hs-identifier">extraTys</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">drop</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">length</span><span> </span><span class="hs-identifier">tsNoKinds</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">bndrParams</span><span> </span><span class="hs-identifier">dvars</span><span class="hs-special">)</span><span>
</span><a name="line-494"></a><span>      </span><span class="hs-identifier">ts'</span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">tsNoKinds</span><span> </span><span class="hs-operator">++</span><span> </span><span class="hs-identifier">extraTys</span><span> </span><span class="hs-comment">-- eta-expand</span><span>
</span><a name="line-495"></a><span>  </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Map.fromList</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">zip</span><span> </span><span class="hs-identifier">kparams</span><span> </span><span class="hs-identifier">tsKinds'</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-operator">$</span><span>
</span><a name="line-496"></a><span>     </span><span class="hs-identifier">repairVarKindsWith</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">ts'</span><span>
</span><a name="line-497"></a><span>
</span><a name="line-498"></a><span>
</span><a name="line-499"></a><span class="hs-comment">-- Sadly, Template Haskell's treatment of data family instances leaves much</span><span>
</span><a name="line-500"></a><span class="hs-comment">-- to be desired. Here are some problems that we have to work around:</span><span>
</span><a name="line-501"></a><span class="hs-comment">--</span><span>
</span><a name="line-502"></a><span class="hs-comment">-- 1. On all versions of GHC, TH leaves off the kind signatures on the</span><span>
</span><a name="line-503"></a><span class="hs-comment">--    type patterns of data family instances where a kind signature isn't</span><span>
</span><a name="line-504"></a><span class="hs-comment">--    specified explicitly. Here, we can use the parent data family's</span><span>
</span><a name="line-505"></a><span class="hs-comment">--    type variable binders to reconstruct the kind signatures if they</span><span>
</span><a name="line-506"></a><span class="hs-comment">--    are missing.</span><span>
</span><a name="line-507"></a><span class="hs-comment">-- 2. On GHC 7.6 and 7.8, TH will eta-reduce data instances. We can find</span><span>
</span><a name="line-508"></a><span class="hs-comment">--    the missing type variables on the data constructor.</span><span>
</span><a name="line-509"></a><span class="hs-comment">--</span><span>
</span><a name="line-510"></a><span class="hs-comment">-- We opt to avoid propagating these new type variables through to the</span><span>
</span><a name="line-511"></a><span class="hs-comment">-- constructor now, but we will return to this task in normalizeCon.</span><span>
</span><a name="line-512"></a><span class="hs-identifier">repairDataFam</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-513"></a><span>  </span><span class="hs-identifier">Dec</span><span> </span><span class="hs-comment">{- ^ family declaration   -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-514"></a><span>  </span><span class="hs-identifier">Dec</span><span> </span><span class="hs-comment">{- ^ instance declaration -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-515"></a><span>  </span><span class="hs-identifier">Dec</span><span> </span><span class="hs-comment">{- ^ instance declaration -}</span><span>
</span><a name="line-516"></a><span>
</span><a name="line-517"></a><span class="hs-identifier">repairDataFam</span><span>
</span><a name="line-518"></a><span>  </span><span class="hs-special">(</span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>
</span><a name="line-519"></a><span>  </span><span class="hs-special">(</span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">deriv</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-520"></a><span>    </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">repairVarKindsWith'</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">deriv</span><span>
</span><a name="line-521"></a><span class="hs-identifier">repairDataFam</span><span>
</span><a name="line-522"></a><span>  </span><span class="hs-special">(</span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>
</span><a name="line-523"></a><span>  </span><span class="hs-special">(</span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">deriv</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-524"></a><span>    </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">repairVarKindsWith'</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">deriv</span><span>
</span><a name="line-525"></a><span class="hs-cpp">#else
</span><a name="repairDataFam"><a href="Language.Haskell.TH.Datatype.html#repairDataFam"><span class="hs-identifier">repairDataFam</span></a></a><span> </span><a name="local-6989586621679053483"><a href="#local-6989586621679053483"><span class="hs-identifier">famD</span></a></a><span> </span><a name="local-6989586621679053484"><a href="#local-6989586621679053484"><span class="hs-identifier">instD</span></a></a><span>
</span><a name="line-527"></a><span class="hs-cpp"># if MIN_VERSION_template_haskell(2,11,0)
</span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">DataFamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><a name="local-6989586621679053485"><a href="#local-6989586621679053485"><span class="hs-identifier">dvars</span></a></a><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="#local-6989586621679053483"><span class="hs-identifier hs-var">famD</span></a><span>
</span><a name="line-529"></a><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">NewtypeInstD</span><span> </span><a name="local-6989586621679053486"><a href="#local-6989586621679053486"><span class="hs-identifier">cx</span></a></a><span> </span><a name="local-6989586621679053487"><a href="#local-6989586621679053487"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679053488"><a href="#local-6989586621679053488"><span class="hs-identifier">ts</span></a></a><span> </span><a name="local-6989586621679053489"><a href="#local-6989586621679053489"><span class="hs-identifier">k</span></a></a><span> </span><a name="local-6989586621679053490"><a href="#local-6989586621679053490"><span class="hs-identifier">c</span></a></a><span> </span><a name="local-6989586621679053491"><a href="#local-6989586621679053491"><span class="hs-identifier">deriv</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="#local-6989586621679053484"><span class="hs-identifier hs-var">instD</span></a><span>
</span><a name="line-530"></a><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">NewtypeInstD</span><span> </span><a href="#local-6989586621679053486"><span class="hs-identifier hs-var">cx</span></a><span> </span><a href="#local-6989586621679053487"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#repairVarKindsWith"><span class="hs-identifier hs-var">repairVarKindsWith</span></a><span> </span><a href="#local-6989586621679053485"><span class="hs-identifier hs-var">dvars</span></a><span> </span><a href="#local-6989586621679053488"><span class="hs-identifier hs-var">ts</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053489"><span class="hs-identifier hs-var">k</span></a><span> </span><a href="#local-6989586621679053490"><span class="hs-identifier hs-var">c</span></a><span> </span><a href="#local-6989586621679053491"><span class="hs-identifier hs-var">deriv</span></a><span>
</span><a name="line-531"></a><span>
</span><a name="line-532"></a><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">DataFamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><a name="local-6989586621679053492"><a href="#local-6989586621679053492"><span class="hs-identifier">dvars</span></a></a><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="#local-6989586621679053483"><span class="hs-identifier hs-var">famD</span></a><span>
</span><a name="line-533"></a><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">DataInstD</span><span> </span><a name="local-6989586621679053493"><a href="#local-6989586621679053493"><span class="hs-identifier">cx</span></a></a><span> </span><a name="local-6989586621679053494"><a href="#local-6989586621679053494"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679053495"><a href="#local-6989586621679053495"><span class="hs-identifier">ts</span></a></a><span> </span><a name="local-6989586621679053496"><a href="#local-6989586621679053496"><span class="hs-identifier">k</span></a></a><span> </span><a name="local-6989586621679053497"><a href="#local-6989586621679053497"><span class="hs-identifier">c</span></a></a><span> </span><a name="local-6989586621679053498"><a href="#local-6989586621679053498"><span class="hs-identifier">deriv</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="#local-6989586621679053484"><span class="hs-identifier hs-var">instD</span></a><span>
</span><a name="line-534"></a><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">DataInstD</span><span> </span><a href="#local-6989586621679053493"><span class="hs-identifier hs-var">cx</span></a><span> </span><a href="#local-6989586621679053494"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#repairVarKindsWith"><span class="hs-identifier hs-var">repairVarKindsWith</span></a><span> </span><a href="#local-6989586621679053492"><span class="hs-identifier hs-var">dvars</span></a><span> </span><a href="#local-6989586621679053495"><span class="hs-identifier hs-var">ts</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053496"><span class="hs-identifier hs-var">k</span></a><span> </span><a href="#local-6989586621679053497"><span class="hs-identifier hs-var">c</span></a><span> </span><a href="#local-6989586621679053498"><span class="hs-identifier hs-var">deriv</span></a><span>
</span><a name="line-535"></a><span class="hs-cpp"># else
</span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">famD</span><span>
</span><a name="line-537"></a><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">instD</span><span>
</span><a name="line-538"></a><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">repairVarKindsWith</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span>
</span><a name="line-539"></a><span>
</span><a name="line-540"></a><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">famD</span><span>
</span><a name="line-541"></a><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">instD</span><span>
</span><a name="line-542"></a><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">repairVarKindsWith</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span>
</span><a name="line-543"></a><span class="hs-cpp"># endif
#endif
</span><span class="hs-identifier">repairDataFam</span><span> </span><span class="hs-identifier">_</span><span> </span><a name="local-6989586621679053499"><a href="#local-6989586621679053499"><span class="hs-identifier">instD</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053499"><span class="hs-identifier hs-var">instD</span></a><span>
</span><a name="line-546"></a><span>
</span><a name="line-547"></a><span class="hs-identifier">repairVarKindsWith</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span>
</span><a name="line-548"></a><a name="repairVarKindsWith"><a href="Language.Haskell.TH.Datatype.html#repairVarKindsWith"><span class="hs-identifier">repairVarKindsWith</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">zipWith</span><span> </span><a href="Language.Haskell.TH.Datatype.html#stealKindForType"><span class="hs-identifier hs-var">stealKindForType</span></a><span>
</span><a name="line-549"></a><span>
</span><a name="line-550"></a><span class="hs-comment">-- If a VarT is missing an explicit kind signature, steal it from a TyVarBndr.</span><span>
</span><a name="line-551"></a><span class="hs-identifier">stealKindForType</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">TyVarBndr</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-552"></a><a name="stealKindForType"><a href="Language.Haskell.TH.Datatype.html#stealKindForType"><span class="hs-identifier">stealKindForType</span></a></a><span> </span><a name="local-6989586621679053684"><a href="#local-6989586621679053684"><span class="hs-identifier">tvb</span></a></a><span> </span><a name="local-6989586621679053685"><a href="#local-6989586621679053685"><span class="hs-identifier">t</span></a></a><span class="hs-glyph">@</span><span class="hs-identifier hs-var">VarT</span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">SigT</span><span> </span><a href="#local-6989586621679053685"><span class="hs-identifier hs-var">t</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#tvKind"><span class="hs-identifier hs-var">tvKind</span></a><span> </span><a href="#local-6989586621679053684"><span class="hs-identifier hs-var">tvb</span></a><span class="hs-special">)</span><span>
</span><a name="line-553"></a><span class="hs-identifier">stealKindForType</span><span> </span><span class="hs-identifier">_</span><span>   </span><a name="local-6989586621679053686"><a href="#local-6989586621679053686"><span class="hs-identifier">t</span></a></a><span>        </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053686"><span class="hs-identifier hs-var">t</span></a><span>
</span><a name="line-554"></a><span>
</span><a name="line-555"></a><span class="hs-comment">-- | Normalize 'Dec' for a newtype or datatype into a 'DatatypeInfo'.</span><span>
</span><a name="line-556"></a><span class="hs-comment">-- Fail in 'Q' otherwise.</span><span>
</span><a name="line-557"></a><span class="hs-comment">--</span><span>
</span><a name="line-558"></a><span class="hs-comment">-- Beware: 'normalizeDec' can have surprising behavior when it comes to fixity.</span><span>
</span><a name="line-559"></a><span class="hs-comment">-- For instance, if you have this quasiquoted data declaration:</span><span>
</span><a name="line-560"></a><span class="hs-comment">--</span><span>
</span><a name="line-561"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-562"></a><span class="hs-comment">-- [d| infix 5 :^^:</span><span>
</span><a name="line-563"></a><span class="hs-comment">--     data Foo where</span><span>
</span><a name="line-564"></a><span class="hs-comment">--       (:^^:) :: Int -&gt; Int -&gt; Foo |]</span><span>
</span><a name="line-565"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-566"></a><span class="hs-comment">--</span><span>
</span><a name="line-567"></a><span class="hs-comment">-- Then if you pass the 'Dec' for @Foo@ to 'normalizeDec' without splicing it</span><span>
</span><a name="line-568"></a><span class="hs-comment">-- in a previous Template Haskell splice, then @(:^^:)@ will be labeled a 'NormalConstructor'</span><span>
</span><a name="line-569"></a><span class="hs-comment">-- instead of an 'InfixConstructor'. This is because Template Haskell has no way to</span><span>
</span><a name="line-570"></a><span class="hs-comment">-- reify the fixity declaration for @(:^^:)@, so it must assume there isn't one. To</span><span>
</span><a name="line-571"></a><span class="hs-comment">-- work around this behavior, use 'reifyDatatype' instead.</span><span>
</span><a name="line-572"></a><span class="hs-identifier">normalizeDec</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Dec</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span>
</span><a name="line-573"></a><a name="normalizeDec"><a href="Language.Haskell.TH.Datatype.html#normalizeDec"><span class="hs-identifier">normalizeDec</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var">normalizeDecFor</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#isn%27tReified"><span class="hs-identifier hs-var">isn'tReified</span></a><span>
</span><a name="line-574"></a><span>
</span><a name="line-575"></a><span class="hs-identifier">normalizeDecFor</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Dec</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span>
</span><a name="line-576"></a><a name="normalizeDecFor"><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier">normalizeDecFor</span></a></a><span> </span><a name="local-6989586621679053687"><a href="#local-6989586621679053687"><span class="hs-identifier">isReified</span></a></a><span> </span><a name="local-6989586621679053688"><a href="#local-6989586621679053688"><span class="hs-identifier">dec</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-577"></a><span>  </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679053688"><span class="hs-identifier hs-var">dec</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-578"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,12,0)
</span><span>    </span><span class="hs-identifier hs-var">NewtypeD</span><span> </span><a name="local-6989586621679053690"><a href="#local-6989586621679053690"><span class="hs-identifier">context</span></a></a><span> </span><a name="local-6989586621679053691"><a href="#local-6989586621679053691"><span class="hs-identifier">name</span></a></a><span> </span><a name="local-6989586621679053692"><a href="#local-6989586621679053692"><span class="hs-identifier">tyvars</span></a></a><span> </span><a name="local-6989586621679053693"><a href="#local-6989586621679053693"><span class="hs-identifier">_kind</span></a></a><span> </span><a name="local-6989586621679053694"><a href="#local-6989586621679053694"><span class="hs-identifier">con</span></a></a><span> </span><a name="local-6989586621679053695"><a href="#local-6989586621679053695"><span class="hs-identifier">_derives</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-580"></a><span>      </span><a href="Language.Haskell.TH.Datatype.html#giveTypesStarKinds"><span class="hs-identifier hs-var">giveTypesStarKinds</span></a><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeDec%27"><span class="hs-identifier hs-var">normalizeDec'</span></a><span> </span><a href="#local-6989586621679053687"><span class="hs-identifier hs-var">isReified</span></a><span> </span><a href="#local-6989586621679053690"><span class="hs-identifier hs-var">context</span></a><span> </span><a href="#local-6989586621679053691"><span class="hs-identifier hs-var">name</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#bndrParams"><span class="hs-identifier hs-var">bndrParams</span></a><span> </span><a href="#local-6989586621679053692"><span class="hs-identifier hs-var">tyvars</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679053694"><span class="hs-identifier hs-var">con</span></a><span class="hs-special">]</span><span> </span><a href="Language.Haskell.TH.Datatype.html#Newtype"><span class="hs-identifier hs-var">Newtype</span></a><span>
</span><a name="line-581"></a><span>    </span><span class="hs-identifier hs-var">DataD</span><span> </span><a name="local-6989586621679053696"><a href="#local-6989586621679053696"><span class="hs-identifier">context</span></a></a><span> </span><a name="local-6989586621679053697"><a href="#local-6989586621679053697"><span class="hs-identifier">name</span></a></a><span> </span><a name="local-6989586621679053698"><a href="#local-6989586621679053698"><span class="hs-identifier">tyvars</span></a></a><span> </span><a name="local-6989586621679053699"><a href="#local-6989586621679053699"><span class="hs-identifier">_kind</span></a></a><span> </span><a name="local-6989586621679053700"><a href="#local-6989586621679053700"><span class="hs-identifier">cons</span></a></a><span> </span><a name="local-6989586621679053701"><a href="#local-6989586621679053701"><span class="hs-identifier">_derives</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-582"></a><span>      </span><a href="Language.Haskell.TH.Datatype.html#giveTypesStarKinds"><span class="hs-identifier hs-var">giveTypesStarKinds</span></a><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeDec%27"><span class="hs-identifier hs-var">normalizeDec'</span></a><span> </span><a href="#local-6989586621679053687"><span class="hs-identifier hs-var">isReified</span></a><span> </span><a href="#local-6989586621679053696"><span class="hs-identifier hs-var">context</span></a><span> </span><a href="#local-6989586621679053697"><span class="hs-identifier hs-var">name</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#bndrParams"><span class="hs-identifier hs-var">bndrParams</span></a><span> </span><a href="#local-6989586621679053698"><span class="hs-identifier hs-var">tyvars</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053700"><span class="hs-identifier hs-var">cons</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#Datatype"><span class="hs-identifier hs-var">Datatype</span></a><span>
</span><a name="line-583"></a><span>    </span><span class="hs-identifier hs-var">NewtypeInstD</span><span> </span><a name="local-6989586621679053702"><a href="#local-6989586621679053702"><span class="hs-identifier">context</span></a></a><span> </span><a name="local-6989586621679053703"><a href="#local-6989586621679053703"><span class="hs-identifier">name</span></a></a><span> </span><a name="local-6989586621679053704"><a href="#local-6989586621679053704"><span class="hs-identifier">params</span></a></a><span> </span><a name="local-6989586621679053705"><a href="#local-6989586621679053705"><span class="hs-identifier">_kind</span></a></a><span> </span><a name="local-6989586621679053706"><a href="#local-6989586621679053706"><span class="hs-identifier">con</span></a></a><span> </span><a name="local-6989586621679053707"><a href="#local-6989586621679053707"><span class="hs-identifier">_derives</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-584"></a><span>      </span><a href="#local-6989586621679053689"><span class="hs-identifier hs-var">repair13618'</span></a><span> </span><span class="hs-operator hs-var">.</span><span> </span><a href="Language.Haskell.TH.Datatype.html#giveTypesStarKinds"><span class="hs-identifier hs-var">giveTypesStarKinds</span></a><span> </span><span class="hs-operator hs-var">=&lt;&lt;</span><span>
</span><a name="line-585"></a><span>      </span><a href="Language.Haskell.TH.Datatype.html#normalizeDec%27"><span class="hs-identifier hs-var">normalizeDec'</span></a><span> </span><a href="#local-6989586621679053687"><span class="hs-identifier hs-var">isReified</span></a><span> </span><a href="#local-6989586621679053702"><span class="hs-identifier hs-var">context</span></a><span> </span><a href="#local-6989586621679053703"><span class="hs-identifier hs-var">name</span></a><span> </span><a href="#local-6989586621679053704"><span class="hs-identifier hs-var">params</span></a><span> </span><span class="hs-special">[</span><a href="#local-6989586621679053706"><span class="hs-identifier hs-var">con</span></a><span class="hs-special">]</span><span> </span><a href="Language.Haskell.TH.Datatype.html#NewtypeInstance"><span class="hs-identifier hs-var">NewtypeInstance</span></a><span>
</span><a name="line-586"></a><span>    </span><span class="hs-identifier hs-var">DataInstD</span><span> </span><a name="local-6989586621679053708"><a href="#local-6989586621679053708"><span class="hs-identifier">context</span></a></a><span> </span><a name="local-6989586621679053709"><a href="#local-6989586621679053709"><span class="hs-identifier">name</span></a></a><span> </span><a name="local-6989586621679053710"><a href="#local-6989586621679053710"><span class="hs-identifier">params</span></a></a><span> </span><a name="local-6989586621679053711"><a href="#local-6989586621679053711"><span class="hs-identifier">_kind</span></a></a><span> </span><a name="local-6989586621679053712"><a href="#local-6989586621679053712"><span class="hs-identifier">cons</span></a></a><span> </span><a name="local-6989586621679053713"><a href="#local-6989586621679053713"><span class="hs-identifier">_derives</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-587"></a><span>      </span><a href="#local-6989586621679053689"><span class="hs-identifier hs-var">repair13618'</span></a><span> </span><span class="hs-operator hs-var">.</span><span> </span><a href="Language.Haskell.TH.Datatype.html#giveTypesStarKinds"><span class="hs-identifier hs-var">giveTypesStarKinds</span></a><span> </span><span class="hs-operator hs-var">=&lt;&lt;</span><span>
</span><a name="line-588"></a><span>      </span><a href="Language.Haskell.TH.Datatype.html#normalizeDec%27"><span class="hs-identifier hs-var">normalizeDec'</span></a><span> </span><a href="#local-6989586621679053687"><span class="hs-identifier hs-var">isReified</span></a><span> </span><a href="#local-6989586621679053708"><span class="hs-identifier hs-var">context</span></a><span> </span><a href="#local-6989586621679053709"><span class="hs-identifier hs-var">name</span></a><span> </span><a href="#local-6989586621679053710"><span class="hs-identifier hs-var">params</span></a><span> </span><a href="#local-6989586621679053712"><span class="hs-identifier hs-var">cons</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#DataInstance"><span class="hs-identifier hs-var">DataInstance</span></a><span>
</span><a name="line-589"></a><span class="hs-cpp">#elif MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="hs-identifier">NewtypeD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">_kind</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-591"></a><span>      </span><span class="hs-identifier">giveTypesStarKinds</span><span> </span><span class="hs-operator">&lt;$&gt;</span><span> </span><span class="hs-identifier">normalizeDec'</span><span> </span><span class="hs-identifier">isReified</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">bndrParams</span><span> </span><span class="hs-identifier">tyvars</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">con</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">Newtype</span><span>
</span><a name="line-592"></a><span>    </span><span class="hs-identifier">DataD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">_kind</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-593"></a><span>      </span><span class="hs-identifier">giveTypesStarKinds</span><span> </span><span class="hs-operator">&lt;$&gt;</span><span> </span><span class="hs-identifier">normalizeDec'</span><span> </span><span class="hs-identifier">isReified</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">bndrParams</span><span> </span><span class="hs-identifier">tyvars</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">Datatype</span><span>
</span><a name="line-594"></a><span>    </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">params</span><span> </span><span class="hs-identifier">_kind</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-595"></a><span>      </span><span class="hs-identifier">repair13618'</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">giveTypesStarKinds</span><span> </span><span class="hs-operator">=&lt;&lt;</span><span>
</span><a name="line-596"></a><span>      </span><span class="hs-identifier">normalizeDec'</span><span> </span><span class="hs-identifier">isReified</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">params</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">con</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">NewtypeInstance</span><span>
</span><a name="line-597"></a><span>    </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">params</span><span> </span><span class="hs-identifier">_kind</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-598"></a><span>      </span><span class="hs-identifier">repair13618'</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">giveTypesStarKinds</span><span> </span><span class="hs-operator">=&lt;&lt;</span><span>
</span><a name="line-599"></a><span>      </span><span class="hs-identifier">normalizeDec'</span><span> </span><span class="hs-identifier">isReified</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">params</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">DataInstance</span><span>
</span><a name="line-600"></a><span class="hs-cpp">#else
</span><span>    </span><span class="hs-identifier">NewtypeD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-602"></a><span>      </span><span class="hs-identifier">giveTypesStarKinds</span><span> </span><span class="hs-operator">&lt;$&gt;</span><span> </span><span class="hs-identifier">normalizeDec'</span><span> </span><span class="hs-identifier">isReified</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">bndrParams</span><span> </span><span class="hs-identifier">tyvars</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">con</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">Newtype</span><span>
</span><a name="line-603"></a><span>    </span><span class="hs-identifier">DataD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-604"></a><span>      </span><span class="hs-identifier">giveTypesStarKinds</span><span> </span><span class="hs-operator">&lt;$&gt;</span><span> </span><span class="hs-identifier">normalizeDec'</span><span> </span><span class="hs-identifier">isReified</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">bndrParams</span><span> </span><span class="hs-identifier">tyvars</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">Datatype</span><span>
</span><a name="line-605"></a><span>    </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">params</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-606"></a><span>      </span><span class="hs-identifier">repair13618'</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">giveTypesStarKinds</span><span> </span><span class="hs-operator">=&lt;&lt;</span><span>
</span><a name="line-607"></a><span>      </span><span class="hs-identifier">normalizeDec'</span><span> </span><span class="hs-identifier">isReified</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">params</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">con</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">NewtypeInstance</span><span>
</span><a name="line-608"></a><span>    </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">params</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-609"></a><span>      </span><span class="hs-identifier">repair13618'</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">giveTypesStarKinds</span><span> </span><span class="hs-operator">=&lt;&lt;</span><span>
</span><a name="line-610"></a><span>      </span><span class="hs-identifier">normalizeDec'</span><span> </span><span class="hs-identifier">isReified</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">params</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">DataInstance</span><span>
</span><a name="line-611"></a><span class="hs-cpp">#endif
</span><span>    </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">fail</span><span> </span><span class="hs-string">&quot;normalizeDecFor: DataD or NewtypeD required&quot;</span><span>
</span><a name="line-613"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-614"></a><span>    </span><a name="local-6989586621679053689"><a href="#local-6989586621679053689"><span class="hs-identifier">repair13618'</span></a></a><span> </span><span class="hs-glyph">|</span><span> </span><a href="#local-6989586621679053687"><span class="hs-identifier hs-var">isReified</span></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#repair13618"><span class="hs-identifier hs-var">repair13618</span></a><span>
</span><a name="line-615"></a><span>                 </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">otherwise</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">return</span><span>
</span><a name="line-616"></a><span>
</span><a name="line-617"></a><span class="hs-identifier">bndrParams</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span>
</span><a name="line-618"></a><a name="bndrParams"><a href="Language.Haskell.TH.Datatype.html#bndrParams"><span class="hs-identifier">bndrParams</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-glyph">\</span><a name="local-6989586621679053714"><a href="#local-6989586621679053714"><span class="hs-identifier">bndr</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-619"></a><span>  </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679053714"><span class="hs-identifier hs-var">bndr</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-620"></a><span>    </span><span class="hs-identifier hs-var">KindedTV</span><span> </span><a name="local-6989586621679053715"><a href="#local-6989586621679053715"><span class="hs-identifier">t</span></a></a><span> </span><a name="local-6989586621679053716"><a href="#local-6989586621679053716"><span class="hs-identifier">k</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">SigT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">VarT</span><span> </span><a href="#local-6989586621679053715"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053716"><span class="hs-identifier hs-var">k</span></a><span>
</span><a name="line-621"></a><span>    </span><span class="hs-identifier hs-var">PlainTV</span><span>  </span><a name="local-6989586621679053717"><a href="#local-6989586621679053717"><span class="hs-identifier">t</span></a></a><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">VarT</span><span> </span><a href="#local-6989586621679053717"><span class="hs-identifier hs-var">t</span></a><span>
</span><a name="line-622"></a><span>
</span><a name="line-623"></a><span class="hs-comment">-- | Extract the kind from a 'TyVarBndr'. Assumes 'PlainTV' has kind @*@.</span><span>
</span><a name="line-624"></a><span class="hs-identifier">tvKind</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">TyVarBndr</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Kind</span><span>
</span><a name="line-625"></a><a name="tvKind"><a href="Language.Haskell.TH.Datatype.html#tvKind"><span class="hs-identifier">tvKind</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">PlainTV</span><span>  </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">starK</span><span>
</span><a name="line-626"></a><span class="hs-identifier">tvKind</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">KindedTV</span><span> </span><span class="hs-identifier">_</span><span> </span><a name="local-6989586621679053718"><a href="#local-6989586621679053718"><span class="hs-identifier">k</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053718"><span class="hs-identifier hs-var">k</span></a><span>
</span><a name="line-627"></a><span>
</span><a name="line-628"></a><span class="hs-comment">-- | Remove the outermost 'SigT'.</span><span>
</span><a name="line-629"></a><span class="hs-identifier">stripSigT</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-630"></a><a name="stripSigT"><a href="Language.Haskell.TH.Datatype.html#stripSigT"><span class="hs-identifier">stripSigT</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">SigT</span><span> </span><a name="local-6989586621679053719"><a href="#local-6989586621679053719"><span class="hs-identifier">t</span></a></a><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053719"><span class="hs-identifier hs-var">t</span></a><span>
</span><a name="line-631"></a><span class="hs-identifier">stripSigT</span><span> </span><a name="local-6989586621679053720"><a href="#local-6989586621679053720"><span class="hs-identifier">t</span></a></a><span>          </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053720"><span class="hs-identifier hs-var">t</span></a><span>
</span><a name="line-632"></a><span>
</span><a name="line-633"></a><span>
</span><a name="line-634"></a><span class="hs-identifier">normalizeDec'</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-635"></a><span>  </span><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a><span>    </span><span class="hs-comment">{- ^ Is this a reified 'Dec'? -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-636"></a><span>  </span><span class="hs-identifier hs-type">Cxt</span><span>             </span><span class="hs-comment">{- ^ Datatype context         -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-637"></a><span>  </span><span class="hs-identifier hs-type">Name</span><span>            </span><span class="hs-comment">{- ^ Type constructor         -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-638"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span>          </span><span class="hs-comment">{- ^ Type parameters          -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-639"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Con</span><span class="hs-special">]</span><span>           </span><span class="hs-comment">{- ^ Constructors             -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-640"></a><span>  </span><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a><span> </span><span class="hs-comment">{- ^ Extra information        -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-641"></a><span>  </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span>
</span><a name="line-642"></a><a name="normalizeDec%27"><a href="Language.Haskell.TH.Datatype.html#normalizeDec%27"><span class="hs-identifier">normalizeDec'</span></a></a><span> </span><a name="local-6989586621679053721"><a href="#local-6989586621679053721"><span class="hs-identifier">reifiedDec</span></a></a><span> </span><a name="local-6989586621679053722"><a href="#local-6989586621679053722"><span class="hs-identifier">context</span></a></a><span> </span><a name="local-6989586621679053723"><a href="#local-6989586621679053723"><span class="hs-identifier">name</span></a></a><span> </span><a name="local-6989586621679053724"><a href="#local-6989586621679053724"><span class="hs-identifier">params</span></a></a><span> </span><a name="local-6989586621679053725"><a href="#local-6989586621679053725"><span class="hs-identifier">cons</span></a></a><span> </span><a name="local-6989586621679053726"><a href="#local-6989586621679053726"><span class="hs-identifier">variant</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-643"></a><span>  </span><span class="hs-keyword">do</span><span> </span><a name="local-6989586621679053727"><a href="#local-6989586621679053727"><span class="hs-identifier">cons'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">concat</span><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><span class="hs-identifier hs-var">mapM</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#normalizeConFor"><span class="hs-identifier hs-var">normalizeConFor</span></a><span> </span><a href="#local-6989586621679053721"><span class="hs-identifier hs-var">reifiedDec</span></a><span> </span><a href="#local-6989586621679053723"><span class="hs-identifier hs-var">name</span></a><span> </span><a href="#local-6989586621679053724"><span class="hs-identifier hs-var">params</span></a><span> </span><a href="#local-6989586621679053726"><span class="hs-identifier hs-var">variant</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053725"><span class="hs-identifier hs-var">cons</span></a><span>
</span><a name="line-644"></a><span>     </span><span class="hs-identifier hs-var">return</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-var">DatatypeInfo</span></a><span>
</span><a name="line-645"></a><span>       </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">datatypeContext</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053722"><span class="hs-identifier hs-var">context</span></a><span>
</span><a name="line-646"></a><span>       </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">datatypeName</span><span>    </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053723"><span class="hs-identifier hs-var">name</span></a><span>
</span><a name="line-647"></a><span>       </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">datatypeVars</span><span>    </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053724"><span class="hs-identifier hs-var">params</span></a><span>
</span><a name="line-648"></a><span>       </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">datatypeCons</span><span>    </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053727"><span class="hs-identifier hs-var">cons'</span></a><span>
</span><a name="line-649"></a><span>       </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">datatypeVariant</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053726"><span class="hs-identifier hs-var">variant</span></a><span>
</span><a name="line-650"></a><span>       </span><span class="hs-special">}</span><span>
</span><a name="line-651"></a><span>
</span><a name="line-652"></a><span class="hs-comment">-- | Normalize a 'Con' into a 'ConstructorInfo'. This requires knowledge of</span><span>
</span><a name="line-653"></a><span class="hs-comment">-- the type and parameters of the constructor, as well as whether the constructor</span><span>
</span><a name="line-654"></a><span class="hs-comment">-- is for a data family instance, as extracted from the outer</span><span>
</span><a name="line-655"></a><span class="hs-comment">-- 'Dec'.</span><span>
</span><a name="line-656"></a><span class="hs-identifier">normalizeCon</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-657"></a><span>  </span><span class="hs-identifier hs-type">Name</span><span>            </span><span class="hs-comment">{- ^ Type constructor  -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-658"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span>          </span><span class="hs-comment">{- ^ Type parameters   -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-659"></a><span>  </span><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a><span> </span><span class="hs-comment">{- ^ Extra information -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-660"></a><span>  </span><span class="hs-identifier hs-type">Con</span><span>             </span><span class="hs-comment">{- ^ Constructor       -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-661"></a><span>  </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span class="hs-special">]</span><span>
</span><a name="line-662"></a><a name="normalizeCon"><a href="Language.Haskell.TH.Datatype.html#normalizeCon"><span class="hs-identifier">normalizeCon</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeConFor"><span class="hs-identifier hs-var">normalizeConFor</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#isn%27tReified"><span class="hs-identifier hs-var">isn'tReified</span></a><span>
</span><a name="line-663"></a><span>
</span><a name="line-664"></a><span class="hs-identifier">normalizeConFor</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-665"></a><span>  </span><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a><span>    </span><span class="hs-comment">{- ^ Is this a reified 'Dec'? -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-666"></a><span>  </span><span class="hs-identifier hs-type">Name</span><span>            </span><span class="hs-comment">{- ^ Type constructor         -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-667"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span>          </span><span class="hs-comment">{- ^ Type parameters          -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-668"></a><span>  </span><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a><span> </span><span class="hs-comment">{- ^ Extra information        -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-669"></a><span>  </span><span class="hs-identifier hs-type">Con</span><span>             </span><span class="hs-comment">{- ^ Constructor              -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-670"></a><span>  </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span class="hs-special">]</span><span>
</span><a name="line-671"></a><a name="normalizeConFor"><a href="Language.Haskell.TH.Datatype.html#normalizeConFor"><span class="hs-identifier">normalizeConFor</span></a></a><span> </span><a name="local-6989586621679053728"><a href="#local-6989586621679053728"><span class="hs-identifier">reifiedDec</span></a></a><span> </span><a name="local-6989586621679053729"><a href="#local-6989586621679053729"><span class="hs-identifier">typename</span></a></a><span> </span><a name="local-6989586621679053730"><a href="#local-6989586621679053730"><span class="hs-identifier">params</span></a></a><span> </span><a name="local-6989586621679053731"><a href="#local-6989586621679053731"><span class="hs-identifier">variant</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">fmap</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">map</span><span> </span><a href="Language.Haskell.TH.Datatype.html#giveTyVarBndrsStarKinds"><span class="hs-identifier hs-var">giveTyVarBndrsStarKinds</span></a><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><a href="#local-6989586621679053734"><span class="hs-identifier hs-var">dispatch</span></a><span>
</span><a name="line-672"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-673"></a><span>    </span><span class="hs-comment">-- A GADT constructor is declared infix when:</span><span>
</span><a name="line-674"></a><span>    </span><span class="hs-comment">--</span><span>
</span><a name="line-675"></a><span>    </span><span class="hs-comment">-- 1. Its name uses operator syntax (e.g., (:*:))</span><span>
</span><a name="line-676"></a><span>    </span><span class="hs-comment">-- 2. It has exactly two fields</span><span>
</span><a name="line-677"></a><span>    </span><span class="hs-comment">-- 3. It has a programmer-supplied fixity declaration</span><span>
</span><a name="line-678"></a><span>    </span><span class="hs-identifier">checkGadtFixity</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier hs-type">ConstructorVariant</span></a><span>
</span><a name="line-679"></a><span>    </span><a name="local-6989586621679053732"><a href="#local-6989586621679053732"><span class="hs-identifier">checkGadtFixity</span></a></a><span> </span><a name="local-6989586621679053735"><a href="#local-6989586621679053735"><span class="hs-identifier">ts</span></a></a><span> </span><a name="local-6989586621679053736"><a href="#local-6989586621679053736"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-680"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><span>      </span><span class="hs-comment">-- Don't call reifyFixityCompat here! We need to be able to distinguish</span><span>
</span><a name="line-682"></a><span>      </span><span class="hs-comment">-- between a default fixity and an explicit @infixl 9@.</span><span>
</span><a name="line-683"></a><span>      </span><a name="local-6989586621679053737"><a href="#local-6989586621679053737"><span class="hs-identifier">mbFi</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-identifier hs-var">Nothing</span><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">recover</span><span class="hs-special">`</span><span> </span><span class="hs-identifier hs-var">reifyFixity</span><span> </span><a href="#local-6989586621679053736"><span class="hs-identifier hs-var">n</span></a><span>
</span><a name="line-684"></a><span>      </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679053738"><a href="#local-6989586621679053738"><span class="hs-identifier">userSuppliedFixity</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">isJust</span><span> </span><a href="#local-6989586621679053737"><span class="hs-identifier hs-var">mbFi</span></a><span>
</span><a name="line-685"></a><span class="hs-cpp">#else
</span><span>      </span><span class="hs-comment">-- On old GHCs, there is a bug where infix GADT constructors will</span><span>
</span><a name="line-687"></a><span>      </span><span class="hs-comment">-- mistakenly be marked as (ForallC (NormalC ...)) instead of</span><span>
</span><a name="line-688"></a><span>      </span><span class="hs-comment">-- (ForallC (InfixC ...)). This is especially annoying since on these</span><span>
</span><a name="line-689"></a><span>      </span><span class="hs-comment">-- versions of GHC, Template Haskell doesn't grant the ability to query</span><span>
</span><a name="line-690"></a><span>      </span><span class="hs-comment">-- whether a constructor was given a user-supplied fixity declaration.</span><span>
</span><a name="line-691"></a><span>      </span><span class="hs-comment">-- Rather, you can only check the fixity that GHC ultimately decides on</span><span>
</span><a name="line-692"></a><span>      </span><span class="hs-comment">-- for a constructor, regardless of whether it was a default fixity or</span><span>
</span><a name="line-693"></a><span>      </span><span class="hs-comment">-- it was user-supplied.</span><span>
</span><a name="line-694"></a><span>      </span><span class="hs-comment">--</span><span>
</span><a name="line-695"></a><span>      </span><span class="hs-comment">-- We can approximate whether a fixity was user-supplied by checking if</span><span>
</span><a name="line-696"></a><span>      </span><span class="hs-comment">-- it is not equal to defaultFixity (infixl 9). Unfortunately,</span><span>
</span><a name="line-697"></a><span>      </span><span class="hs-comment">-- there is no way to distinguish between a user-supplied fixity of</span><span>
</span><a name="line-698"></a><span>      </span><span class="hs-comment">-- infixl 9 and the fixity that GHC defaults to, so we cannot properly</span><span>
</span><a name="line-699"></a><span>      </span><span class="hs-comment">-- handle that case.</span><span>
</span><a name="line-700"></a><span>      </span><span class="hs-identifier">mbFi</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">reifyFixityCompat</span><span> </span><span class="hs-identifier">n</span><span>
</span><a name="line-701"></a><span>      </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">userSuppliedFixity</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">isJust</span><span> </span><span class="hs-identifier">mbFi</span><span> </span><span class="hs-operator">&amp;&amp;</span><span> </span><span class="hs-identifier">mbFi</span><span> </span><span class="hs-operator">/=</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">defaultFixity</span><span>
</span><a name="line-702"></a><span class="hs-cpp">#endif
</span><span>      </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-keyword">if</span><span> </span><a href="#local-6989586621679053733"><span class="hs-identifier hs-var">isInfixDataCon</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">nameBase</span><span> </span><a href="#local-6989586621679053736"><span class="hs-identifier hs-var">n</span></a><span class="hs-special">)</span><span>
</span><a name="line-704"></a><span>                  </span><span class="hs-operator hs-var">&amp;&amp;</span><span> </span><span class="hs-identifier hs-var">length</span><span> </span><a href="#local-6989586621679053735"><span class="hs-identifier hs-var">ts</span></a><span> </span><span class="hs-operator hs-var">==</span><span> </span><span class="hs-number">2</span><span>
</span><a name="line-705"></a><span>                  </span><span class="hs-operator hs-var">&amp;&amp;</span><span> </span><a href="#local-6989586621679053738"><span class="hs-identifier hs-var">userSuppliedFixity</span></a><span>
</span><a name="line-706"></a><span>               </span><span class="hs-keyword">then</span><span> </span><a href="Language.Haskell.TH.Datatype.html#InfixConstructor"><span class="hs-identifier hs-var">InfixConstructor</span></a><span>
</span><a name="line-707"></a><span>               </span><span class="hs-keyword">else</span><span> </span><a href="Language.Haskell.TH.Datatype.html#NormalConstructor"><span class="hs-identifier hs-var">NormalConstructor</span></a><span>
</span><a name="line-708"></a><span>
</span><a name="line-709"></a><span>    </span><span class="hs-comment">-- Checks if a String names a valid Haskell infix data</span><span>
</span><a name="line-710"></a><span>    </span><span class="hs-comment">-- constructor (i.e., does it begin with a colon?).</span><span>
</span><a name="line-711"></a><span>    </span><span class="hs-identifier">isInfixDataCon</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Bool</span><span>
</span><a name="line-712"></a><span>    </span><a name="local-6989586621679053733"><a href="#local-6989586621679053733"><span class="hs-identifier">isInfixDataCon</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-char">':'</span><span class="hs-glyph">:</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">True</span><span>
</span><a name="line-713"></a><span>    </span><span class="hs-identifier">isInfixDataCon</span><span> </span><span class="hs-identifier">_</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">False</span><span>
</span><a name="line-714"></a><span>
</span><a name="line-715"></a><span>    </span><span class="hs-identifier">dispatch</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Con</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span class="hs-special">]</span><span>
</span><a name="line-716"></a><span>    </span><a name="local-6989586621679053734"><a href="#local-6989586621679053734"><span class="hs-identifier">dispatch</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-717"></a><span>      </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">defaultCase</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Con</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span class="hs-special">]</span><span>
</span><a name="line-718"></a><span>          </span><a name="local-6989586621679053739"><a href="#local-6989586621679053739"><span class="hs-identifier">defaultCase</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053740"><span class="hs-identifier hs-var">go</span></a><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-identifier hs-var">False</span><span>
</span><a name="line-719"></a><span>            </span><span class="hs-keyword">where</span><span>
</span><a name="line-720"></a><span>              </span><span class="hs-identifier">go</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span>
</span><a name="line-721"></a><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Cxt</span><span>
</span><a name="line-722"></a><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Bool</span><span> </span><span class="hs-comment">-- Is this a GADT? (see the documentation for</span><span>
</span><a name="line-723"></a><span>                         </span><span class="hs-comment">-- for checkGadtFixity)</span><span>
</span><a name="line-724"></a><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Con</span><span>
</span><a name="line-725"></a><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span class="hs-special">]</span><span>
</span><a name="line-726"></a><span>              </span><a name="local-6989586621679053740"><a href="#local-6989586621679053740"><span class="hs-identifier">go</span></a></a><span> </span><a name="local-6989586621679053741"><a href="#local-6989586621679053741"><span class="hs-identifier">tyvars</span></a></a><span> </span><a name="local-6989586621679053742"><a href="#local-6989586621679053742"><span class="hs-identifier">context</span></a></a><span> </span><a name="local-6989586621679053743"><a href="#local-6989586621679053743"><span class="hs-identifier">gadt</span></a></a><span> </span><a name="local-6989586621679053744"><a href="#local-6989586621679053744"><span class="hs-identifier">c</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-727"></a><span>                </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679053744"><span class="hs-identifier hs-var">c</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-728"></a><span>                  </span><span class="hs-identifier hs-var">NormalC</span><span> </span><a name="local-6989586621679053746"><a href="#local-6989586621679053746"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679053747"><a href="#local-6989586621679053747"><span class="hs-identifier">xs</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-729"></a><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><a name="local-6989586621679053748"><a href="#local-6989586621679053748"><span class="hs-identifier">bangs</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679053749"><a href="#local-6989586621679053749"><span class="hs-identifier">ts</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">unzip</span><span> </span><a href="#local-6989586621679053747"><span class="hs-identifier hs-var">xs</span></a><span>
</span><a name="line-730"></a><span>                        </span><a name="local-6989586621679053750"><a href="#local-6989586621679053750"><span class="hs-identifier">stricts</span></a></a><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-var">normalizeStrictness</span></a><span> </span><a href="#local-6989586621679053748"><span class="hs-identifier hs-var">bangs</span></a><span>
</span><a name="line-731"></a><span>                    </span><a name="local-6989586621679053751"><a href="#local-6989586621679053751"><span class="hs-identifier">fi</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-keyword">if</span><span> </span><a href="#local-6989586621679053743"><span class="hs-identifier hs-var">gadt</span></a><span>
</span><a name="line-732"></a><span>                             </span><span class="hs-keyword">then</span><span> </span><a href="#local-6989586621679053732"><span class="hs-identifier hs-var">checkGadtFixity</span></a><span> </span><a href="#local-6989586621679053749"><span class="hs-identifier hs-var">ts</span></a><span> </span><a href="#local-6989586621679053746"><span class="hs-identifier hs-var">n</span></a><span>
</span><a name="line-733"></a><span>                             </span><span class="hs-keyword">else</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><a href="Language.Haskell.TH.Datatype.html#NormalConstructor"><span class="hs-identifier hs-var">NormalConstructor</span></a><span>
</span><a name="line-734"></a><span>                    </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a><span> </span><a href="#local-6989586621679053746"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679053741"><span class="hs-identifier hs-var">tyvars</span></a><span> </span><a href="#local-6989586621679053742"><span class="hs-identifier hs-var">context</span></a><span> </span><a href="#local-6989586621679053749"><span class="hs-identifier hs-var">ts</span></a><span> </span><a href="#local-6989586621679053750"><span class="hs-identifier hs-var">stricts</span></a><span> </span><a href="#local-6989586621679053751"><span class="hs-identifier hs-var">fi</span></a><span class="hs-special">]</span><span>
</span><a name="line-735"></a><span>                  </span><span class="hs-identifier hs-var">InfixC</span><span> </span><a name="local-6989586621679053752"><a href="#local-6989586621679053752"><span class="hs-identifier">l</span></a></a><span> </span><a name="local-6989586621679053753"><a href="#local-6989586621679053753"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679053754"><a href="#local-6989586621679053754"><span class="hs-identifier">r</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-736"></a><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><a name="local-6989586621679053755"><a href="#local-6989586621679053755"><span class="hs-identifier">bangs</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679053756"><a href="#local-6989586621679053756"><span class="hs-identifier">ts</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">unzip</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679053752"><span class="hs-identifier hs-var">l</span></a><span class="hs-special">,</span><a href="#local-6989586621679053754"><span class="hs-identifier hs-var">r</span></a><span class="hs-special">]</span><span>
</span><a name="line-737"></a><span>                        </span><a name="local-6989586621679053757"><a href="#local-6989586621679053757"><span class="hs-identifier">stricts</span></a></a><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-var">normalizeStrictness</span></a><span> </span><a href="#local-6989586621679053755"><span class="hs-identifier hs-var">bangs</span></a><span> </span><span class="hs-keyword">in</span><span>
</span><a name="line-738"></a><span>                    </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a><span> </span><a href="#local-6989586621679053753"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679053741"><span class="hs-identifier hs-var">tyvars</span></a><span> </span><a href="#local-6989586621679053742"><span class="hs-identifier hs-var">context</span></a><span> </span><a href="#local-6989586621679053756"><span class="hs-identifier hs-var">ts</span></a><span> </span><a href="#local-6989586621679053757"><span class="hs-identifier hs-var">stricts</span></a><span>
</span><a name="line-739"></a><span>                                            </span><a href="Language.Haskell.TH.Datatype.html#InfixConstructor"><span class="hs-identifier hs-var">InfixConstructor</span></a><span class="hs-special">]</span><span>
</span><a name="line-740"></a><span>                  </span><span class="hs-identifier hs-var">RecC</span><span> </span><a name="local-6989586621679053758"><a href="#local-6989586621679053758"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679053759"><a href="#local-6989586621679053759"><span class="hs-identifier">xs</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-741"></a><span>                    </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679053760"><a href="#local-6989586621679053760"><span class="hs-identifier">fns</span></a></a><span>     </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#takeFieldNames"><span class="hs-identifier hs-var">takeFieldNames</span></a><span> </span><a href="#local-6989586621679053759"><span class="hs-identifier hs-var">xs</span></a><span>
</span><a name="line-742"></a><span>                        </span><a name="local-6989586621679053761"><a href="#local-6989586621679053761"><span class="hs-identifier">stricts</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#takeFieldStrictness"><span class="hs-identifier hs-var">takeFieldStrictness</span></a><span> </span><a href="#local-6989586621679053759"><span class="hs-identifier hs-var">xs</span></a><span> </span><span class="hs-keyword">in</span><span>
</span><a name="line-743"></a><span>                    </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a><span> </span><a href="#local-6989586621679053758"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679053741"><span class="hs-identifier hs-var">tyvars</span></a><span> </span><a href="#local-6989586621679053742"><span class="hs-identifier hs-var">context</span></a><span>
</span><a name="line-744"></a><span>                              </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#takeFieldTypes"><span class="hs-identifier hs-var">takeFieldTypes</span></a><span> </span><a href="#local-6989586621679053759"><span class="hs-identifier hs-var">xs</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053761"><span class="hs-identifier hs-var">stricts</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#RecordConstructor"><span class="hs-identifier hs-var">RecordConstructor</span></a><span> </span><a href="#local-6989586621679053760"><span class="hs-identifier hs-var">fns</span></a><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><a name="line-745"></a><span>                  </span><span class="hs-identifier hs-var">ForallC</span><span> </span><a name="local-6989586621679053762"><a href="#local-6989586621679053762"><span class="hs-identifier">tyvars'</span></a></a><span> </span><a name="local-6989586621679053763"><a href="#local-6989586621679053763"><span class="hs-identifier">context'</span></a></a><span> </span><a name="local-6989586621679053764"><a href="#local-6989586621679053764"><span class="hs-identifier">c'</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-746"></a><span>                    </span><a href="#local-6989586621679053740"><span class="hs-identifier hs-var">go</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053762"><span class="hs-identifier hs-var">tyvars'</span></a><span class="hs-operator hs-var">++</span><a href="#local-6989586621679053741"><span class="hs-identifier hs-var">tyvars</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053763"><span class="hs-identifier hs-var">context'</span></a><span class="hs-operator hs-var">++</span><a href="#local-6989586621679053742"><span class="hs-identifier hs-var">context</span></a><span class="hs-special">)</span><span> </span><span class="hs-identifier hs-var">True</span><span> </span><a href="#local-6989586621679053764"><span class="hs-identifier hs-var">c'</span></a><span>
</span><a name="line-747"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><span>                  </span><span class="hs-identifier hs-var">GadtC</span><span> </span><a name="local-6989586621679053765"><a href="#local-6989586621679053765"><span class="hs-identifier">ns</span></a></a><span> </span><a name="local-6989586621679053766"><a href="#local-6989586621679053766"><span class="hs-identifier">xs</span></a></a><span> </span><a name="local-6989586621679053767"><a href="#local-6989586621679053767"><span class="hs-identifier">innerType</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-749"></a><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><a name="local-6989586621679053768"><a href="#local-6989586621679053768"><span class="hs-identifier">bangs</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679053769"><a href="#local-6989586621679053769"><span class="hs-identifier">ts</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">unzip</span><span> </span><a href="#local-6989586621679053766"><span class="hs-identifier hs-var">xs</span></a><span>
</span><a name="line-750"></a><span>                        </span><a name="local-6989586621679053770"><a href="#local-6989586621679053770"><span class="hs-identifier">stricts</span></a></a><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-var">normalizeStrictness</span></a><span> </span><a href="#local-6989586621679053768"><span class="hs-identifier hs-var">bangs</span></a><span> </span><span class="hs-keyword">in</span><span>
</span><a name="line-751"></a><span>                    </span><a href="#local-6989586621679053745"><span class="hs-identifier hs-var">gadtCase</span></a><span> </span><a href="#local-6989586621679053765"><span class="hs-identifier hs-var">ns</span></a><span> </span><a href="#local-6989586621679053767"><span class="hs-identifier hs-var">innerType</span></a><span> </span><a href="#local-6989586621679053769"><span class="hs-identifier hs-var">ts</span></a><span> </span><a href="#local-6989586621679053770"><span class="hs-identifier hs-var">stricts</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053732"><span class="hs-identifier hs-var">checkGadtFixity</span></a><span> </span><a href="#local-6989586621679053769"><span class="hs-identifier hs-var">ts</span></a><span class="hs-special">)</span><span>
</span><a name="line-752"></a><span>                  </span><span class="hs-identifier hs-var">RecGadtC</span><span> </span><a name="local-6989586621679053771"><a href="#local-6989586621679053771"><span class="hs-identifier">ns</span></a></a><span> </span><a name="local-6989586621679053772"><a href="#local-6989586621679053772"><span class="hs-identifier">xs</span></a></a><span> </span><a name="local-6989586621679053773"><a href="#local-6989586621679053773"><span class="hs-identifier">innerType</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-753"></a><span>                    </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679053774"><a href="#local-6989586621679053774"><span class="hs-identifier">fns</span></a></a><span>     </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#takeFieldNames"><span class="hs-identifier hs-var">takeFieldNames</span></a><span> </span><a href="#local-6989586621679053772"><span class="hs-identifier hs-var">xs</span></a><span>
</span><a name="line-754"></a><span>                        </span><a name="local-6989586621679053775"><a href="#local-6989586621679053775"><span class="hs-identifier">stricts</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#takeFieldStrictness"><span class="hs-identifier hs-var">takeFieldStrictness</span></a><span> </span><a href="#local-6989586621679053772"><span class="hs-identifier hs-var">xs</span></a><span> </span><span class="hs-keyword">in</span><span>
</span><a name="line-755"></a><span>                    </span><a href="#local-6989586621679053745"><span class="hs-identifier hs-var">gadtCase</span></a><span> </span><a href="#local-6989586621679053771"><span class="hs-identifier hs-var">ns</span></a><span> </span><a href="#local-6989586621679053773"><span class="hs-identifier hs-var">innerType</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#takeFieldTypes"><span class="hs-identifier hs-var">takeFieldTypes</span></a><span> </span><a href="#local-6989586621679053772"><span class="hs-identifier hs-var">xs</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053775"><span class="hs-identifier hs-var">stricts</span></a><span>
</span><a name="line-756"></a><span>                             </span><span class="hs-special">(</span><span class="hs-identifier hs-var">const</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><a href="Language.Haskell.TH.Datatype.html#RecordConstructor"><span class="hs-identifier hs-var">RecordConstructor</span></a><span> </span><a href="#local-6989586621679053774"><span class="hs-identifier hs-var">fns</span></a><span class="hs-special">)</span><span>
</span><a name="line-757"></a><span>                </span><span class="hs-keyword">where</span><span>
</span><a name="line-758"></a><span>                  </span><a name="local-6989586621679053745"><a href="#local-6989586621679053745"><span class="hs-identifier">gadtCase</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#normalizeGadtC"><span class="hs-identifier hs-var">normalizeGadtC</span></a><span> </span><a href="#local-6989586621679053729"><span class="hs-identifier hs-var">typename</span></a><span> </span><a href="#local-6989586621679053730"><span class="hs-identifier hs-var">params</span></a><span> </span><a href="#local-6989586621679053741"><span class="hs-identifier hs-var">tyvars</span></a><span> </span><a href="#local-6989586621679053742"><span class="hs-identifier hs-var">context</span></a><span>
</span><a name="line-759"></a><span class="hs-cpp">#endif
#if MIN_VERSION_template_haskell(2,8,0) &amp;&amp; (!MIN_VERSION_template_haskell(2,10,0))
</span><span>          </span><span class="hs-identifier">dataFamCompatCase</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Con</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Q</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">ConstructorInfo</span><span class="hs-special">]</span><span>
</span><a name="line-762"></a><span>          </span><span class="hs-identifier">dataFamCompatCase</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><a name="line-763"></a><span>            </span><span class="hs-keyword">where</span><span>
</span><a name="line-764"></a><span>              </span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-765"></a><span>                </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-766"></a><span>                  </span><span class="hs-identifier">NormalC</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-767"></a><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">map</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">fst</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-keyword">in</span><span>
</span><a name="line-768"></a><span>                    </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-identifier">NormalConstructor</span><span>
</span><a name="line-769"></a><span>                  </span><span class="hs-identifier">InfixC</span><span> </span><span class="hs-identifier">l</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">r</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-770"></a><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">map</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">fst</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">l</span><span class="hs-special">,</span><span class="hs-identifier">r</span><span class="hs-special">]</span><span> </span><span class="hs-keyword">in</span><span>
</span><a name="line-771"></a><span>                    </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-identifier">InfixConstructor</span><span>
</span><a name="line-772"></a><span>                  </span><span class="hs-identifier">RecC</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-773"></a><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">takeFieldStrictness</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-keyword">in</span><span>
</span><a name="line-774"></a><span>                    </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">stricts</span><span>
</span><a name="line-775"></a><span>                                 </span><span class="hs-special">(</span><span class="hs-identifier">RecordConstructor</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">takeFieldNames</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-776"></a><span>                  </span><span class="hs-identifier">ForallC</span><span> </span><span class="hs-identifier">tyvars'</span><span> </span><span class="hs-identifier">context'</span><span> </span><span class="hs-identifier">c'</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-777"></a><span>                    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">tyvars'</span><span class="hs-operator">++</span><span class="hs-identifier">tyvars</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">c'</span><span>
</span><a name="line-778"></a><span>
</span><a name="line-779"></a><span>          </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">TyVarBndr</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">FieldStrictness</span><span class="hs-special">]</span><span>
</span><a name="line-780"></a><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">ConstructorVariant</span><span>
</span><a name="line-781"></a><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Q</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">ConstructorInfo</span><span class="hs-special">]</span><span>
</span><a name="line-782"></a><span>          </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-identifier">variant</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-783"></a><span>            </span><span class="hs-identifier">mbInfo</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">reifyMaybe</span><span> </span><span class="hs-identifier">n</span><span>
</span><a name="line-784"></a><span>            </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">mbInfo</span><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-785"></a><span>              </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">DataConI</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">ty</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-786"></a><span>                </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">context</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">argTys</span><span> </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">returnTy</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">uncurryType</span><span> </span><span class="hs-identifier">ty</span><span>
</span><a name="line-787"></a><span>                </span><span class="hs-identifier">returnTy'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">resolveTypeSynonyms</span><span> </span><span class="hs-identifier">returnTy</span><span>
</span><a name="line-788"></a><span>                </span><span class="hs-comment">-- Notice that we've ignored the Cxt and argument Types from the</span><span>
</span><a name="line-789"></a><span>                </span><span class="hs-comment">-- Con argument above, as they might be scoped over eta-reduced</span><span>
</span><a name="line-790"></a><span>                </span><span class="hs-comment">-- variables. Instead of trying to figure out what the</span><span>
</span><a name="line-791"></a><span>                </span><span class="hs-comment">-- eta-reduced variables should be substituted with post facto,</span><span>
</span><a name="line-792"></a><span>                </span><span class="hs-comment">-- we opt for the simpler approach of using the context and</span><span>
</span><a name="line-793"></a><span>                </span><span class="hs-comment">-- argument types from the reified constructor Info, which will</span><span>
</span><a name="line-794"></a><span>                </span><span class="hs-comment">-- at least be correctly scoped. This will make the task of</span><span>
</span><a name="line-795"></a><span>                </span><span class="hs-comment">-- substituting those types with the variables we put in</span><span>
</span><a name="line-796"></a><span>                </span><span class="hs-comment">-- place of the eta-reduced variables (in normalizeDec)</span><span>
</span><a name="line-797"></a><span>                </span><span class="hs-comment">-- much easier.</span><span>
</span><a name="line-798"></a><span>                </span><span class="hs-identifier">normalizeGadtC</span><span> </span><span class="hs-identifier">typename</span><span> </span><span class="hs-identifier">params</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">n</span><span class="hs-special">]</span><span>
</span><a name="line-799"></a><span>                               </span><span class="hs-identifier">returnTy'</span><span> </span><span class="hs-identifier">argTys</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">const</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-identifier">variant</span><span class="hs-special">)</span><span>
</span><a name="line-800"></a><span>              </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">fail</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">unlines</span><span>
</span><a name="line-801"></a><span>                     </span><span class="hs-special">[</span><span> </span><span class="hs-string">&quot;normalizeCon: Cannot reify constructor &quot;</span><span> </span><span class="hs-operator">++</span><span> </span><span class="hs-identifier">nameBase</span><span> </span><span class="hs-identifier">n</span><span>
</span><a name="line-802"></a><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;You are likely calling normalizeDec on GHC 7.6 or 7.8 on a data family&quot;</span><span>
</span><a name="line-803"></a><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;whose type variables have been eta-reduced due to GHC Trac #9692.&quot;</span><span>
</span><a name="line-804"></a><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;Unfortunately, without being able to reify the constructor's type,&quot;</span><span>
</span><a name="line-805"></a><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;there is no way to recover the eta-reduced type variables in general.&quot;</span><span>
</span><a name="line-806"></a><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;A recommended workaround is to use reifyDatatype instead.&quot;</span><span>
</span><a name="line-807"></a><span>                     </span><span class="hs-special">]</span><span>
</span><a name="line-808"></a><span>
</span><a name="line-809"></a><span>          </span><span class="hs-comment">-- A very ad hoc way of determining if we need to perform some extra passes</span><span>
</span><a name="line-810"></a><span>          </span><span class="hs-comment">-- to repair an eta-reduction bug for data family instances that only occurs</span><span>
</span><a name="line-811"></a><span>          </span><span class="hs-comment">-- with GHC 7.6 and 7.8. We want to avoid doing these passes if at all possible,</span><span>
</span><a name="line-812"></a><span>          </span><span class="hs-comment">-- since they require reifying extra information, and reifying during</span><span>
</span><a name="line-813"></a><span>          </span><span class="hs-comment">-- normalization can be problematic for locally declared Template Haskell</span><span>
</span><a name="line-814"></a><span>          </span><span class="hs-comment">-- splices (see ##22).</span><span>
</span><a name="line-815"></a><span>          </span><span class="hs-identifier">mightHaveBeenEtaReduced</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Type</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Bool</span><span>
</span><a name="line-816"></a><span>          </span><span class="hs-identifier">mightHaveBeenEtaReduced</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-817"></a><span>            </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-818"></a><span>              </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">False</span><span>
</span><a name="line-819"></a><span>              </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">initTs</span><span> </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">lastT</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-820"></a><span>                </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-identifier">lastT</span><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-821"></a><span>                  </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">False</span><span>
</span><a name="line-822"></a><span>                  </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">n</span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">not</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">n</span><span> </span><span class="hs-special">`</span><span class="hs-identifier">elem</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">initTs</span><span class="hs-special">)</span><span>
</span><a name="line-823"></a><span>
</span><a name="line-824"></a><span>          </span><span class="hs-comment">-- If the list is empty returns 'Nothing', otherwise returns the</span><span>
</span><a name="line-825"></a><span>          </span><span class="hs-comment">-- 'init' and the 'last'.</span><span>
</span><a name="line-826"></a><span>          </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">a</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Maybe</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">NonEmptySnoc</span><span> </span><span class="hs-identifier">a</span><span class="hs-special">)</span><span>
</span><a name="line-827"></a><span>          </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Nothing</span><span>
</span><a name="line-828"></a><span>          </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">x</span><span class="hs-glyph">:</span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-829"></a><span>            </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">b</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-identifier">x</span><span class="hs-glyph">:</span><span class="hs-identifier">a</span><span class="hs-special">)</span><span> </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">b</span><span class="hs-special">)</span><span>
</span><a name="line-830"></a><span>            </span><span class="hs-identifier">Nothing</span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span>    </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">x</span><span class="hs-special">)</span><span>
</span><a name="line-831"></a><span>
</span><a name="line-832"></a><span>          </span><span class="hs-comment">-- If a Type is a VarT, find Just its Name. Otherwise, return Nothing.</span><span>
</span><a name="line-833"></a><span>          </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Maybe</span><span> </span><span class="hs-identifier">Name</span><span>
</span><a name="line-834"></a><span>          </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">SigT</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-identifier">t</span><span>
</span><a name="line-835"></a><span>          </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">VarT</span><span> </span><span class="hs-identifier">n</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">n</span><span>
</span><a name="line-836"></a><span>          </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-identifier">_</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Nothing</span><span>
</span><a name="line-837"></a><span>
</span><a name="line-838"></a><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">variant</span><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-839"></a><span>           </span><span class="hs-comment">-- On GHC 7.6 and 7.8, there's quite a bit of post-processing that</span><span>
</span><a name="line-840"></a><span>           </span><span class="hs-comment">-- needs to be performed to work around an old bug that eta-reduces the</span><span>
</span><a name="line-841"></a><span>           </span><span class="hs-comment">-- type patterns of data families (but only for reified data family instances).</span><span>
</span><a name="line-842"></a><span>           </span><span class="hs-identifier">DataInstance</span><span>
</span><a name="line-843"></a><span>             </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">reifiedDec</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">mightHaveBeenEtaReduced</span><span> </span><span class="hs-identifier">params</span><span>
</span><a name="line-844"></a><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">dataFamCompatCase</span><span>
</span><a name="line-845"></a><span>           </span><span class="hs-identifier">NewtypeInstance</span><span>
</span><a name="line-846"></a><span>             </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">reifiedDec</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">mightHaveBeenEtaReduced</span><span> </span><span class="hs-identifier">params</span><span>
</span><a name="line-847"></a><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">dataFamCompatCase</span><span>
</span><a name="line-848"></a><span>           </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">defaultCase</span><span>
</span><a name="line-849"></a><span class="hs-cpp">#else
</span><span>      </span><span class="hs-keyword">in</span><span> </span><a href="#local-6989586621679053739"><span class="hs-identifier hs-var">defaultCase</span></a><span>
</span><a name="line-851"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-853"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Bang</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a><span>
</span><a name="line-855"></a><a name="normalizeStrictness"><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier">normalizeStrictness</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Bang</span><span> </span><a name="local-6989586621679053776"><a href="#local-6989586621679053776"><span class="hs-identifier">upk</span></a></a><span> </span><a name="local-6989586621679053777"><a href="#local-6989586621679053777"><span class="hs-identifier">str</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-856"></a><span>  </span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053778"><span class="hs-identifier hs-var">normalizeSourceUnpackedness</span></a><span> </span><a href="#local-6989586621679053776"><span class="hs-identifier hs-var">upk</span></a><span class="hs-special">)</span><span>
</span><a name="line-857"></a><span>                  </span><span class="hs-special">(</span><a href="#local-6989586621679053779"><span class="hs-identifier hs-var">normalizeSourceStrictness</span></a><span> </span><a href="#local-6989586621679053777"><span class="hs-identifier hs-var">str</span></a><span class="hs-special">)</span><span>
</span><a name="line-858"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-859"></a><span>    </span><span class="hs-identifier">normalizeSourceUnpackedness</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">SourceUnpackedness</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#Unpackedness"><span class="hs-identifier hs-type">Unpackedness</span></a><span>
</span><a name="line-860"></a><span>    </span><a name="local-6989586621679053778"><a href="#local-6989586621679053778"><span class="hs-identifier">normalizeSourceUnpackedness</span></a></a><span> </span><span class="hs-identifier hs-var">NoSourceUnpackedness</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedUnpackedness"><span class="hs-identifier hs-var">UnspecifiedUnpackedness</span></a><span>
</span><a name="line-861"></a><span>    </span><span class="hs-identifier">normalizeSourceUnpackedness</span><span> </span><span class="hs-identifier hs-var">SourceNoUnpack</span><span>       </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#NoUnpack"><span class="hs-identifier hs-var">NoUnpack</span></a><span>
</span><a name="line-862"></a><span>    </span><span class="hs-identifier">normalizeSourceUnpackedness</span><span> </span><span class="hs-identifier hs-var">SourceUnpack</span><span>         </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#Unpack"><span class="hs-identifier hs-var">Unpack</span></a><span>
</span><a name="line-863"></a><span>
</span><a name="line-864"></a><span>    </span><span class="hs-identifier">normalizeSourceStrictness</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">SourceStrictness</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#Strictness"><span class="hs-identifier hs-type">Strictness</span></a><span>
</span><a name="line-865"></a><span>    </span><a name="local-6989586621679053779"><a href="#local-6989586621679053779"><span class="hs-identifier">normalizeSourceStrictness</span></a></a><span> </span><span class="hs-identifier hs-var">NoSourceStrictness</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedStrictness"><span class="hs-identifier hs-var">UnspecifiedStrictness</span></a><span>
</span><a name="line-866"></a><span>    </span><span class="hs-identifier">normalizeSourceStrictness</span><span> </span><span class="hs-identifier hs-var">SourceLazy</span><span>         </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#Lazy"><span class="hs-identifier hs-var">Lazy</span></a><span>
</span><a name="line-867"></a><span>    </span><span class="hs-identifier">normalizeSourceStrictness</span><span> </span><span class="hs-identifier hs-var">SourceStrict</span><span>       </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#Strict"><span class="hs-identifier hs-var">Strict</span></a><span>
</span><a name="line-868"></a><span class="hs-cpp">#else
</span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Strict</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">FieldStrictness</span><span>
</span><a name="line-870"></a><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-identifier">IsStrict</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">isStrictAnnot</span><span>
</span><a name="line-871"></a><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-identifier">NotStrict</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">notStrictAnnot</span><span>
</span><a name="line-872"></a><span class="hs-cpp"># if MIN_VERSION_template_haskell(2,7,0)
</span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-identifier">Unpacked</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">unpackedAnnot</span><span>
</span><a name="line-874"></a><span class="hs-cpp"># endif
#endif
</span><span>
</span><a name="line-877"></a><span class="hs-identifier">normalizeGadtC</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-878"></a><span>  </span><span class="hs-identifier hs-type">Name</span><span>              </span><span class="hs-comment">{- ^ Type constructor             -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-879"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span>            </span><span class="hs-comment">{- ^ Type parameters              -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-880"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span>       </span><span class="hs-comment">{- ^ Constructor parameters       -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-881"></a><span>  </span><span class="hs-identifier hs-type">Cxt</span><span>               </span><span class="hs-comment">{- ^ Constructor context          -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-882"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Name</span><span class="hs-special">]</span><span>            </span><span class="hs-comment">{- ^ Constructor names            -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-883"></a><span>  </span><span class="hs-identifier hs-type">Type</span><span>              </span><span class="hs-comment">{- ^ Declared type of constructor -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-884"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span>            </span><span class="hs-comment">{- ^ Constructor field types      -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-885"></a><span>  </span><span class="hs-special">[</span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ Constructor field strictness -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-886"></a><span>  </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier hs-type">ConstructorVariant</span></a><span class="hs-special">)</span><span>
</span><a name="line-887"></a><span>                    </span><span class="hs-comment">{- ^ Determine a constructor variant
                         from its 'Name' -}</span><span>              </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-889"></a><span>  </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span class="hs-special">]</span><span>
</span><a name="line-890"></a><a name="normalizeGadtC"><a href="Language.Haskell.TH.Datatype.html#normalizeGadtC"><span class="hs-identifier">normalizeGadtC</span></a></a><span> </span><a name="local-6989586621679053780"><a href="#local-6989586621679053780"><span class="hs-identifier">typename</span></a></a><span> </span><a name="local-6989586621679053781"><a href="#local-6989586621679053781"><span class="hs-identifier">params</span></a></a><span> </span><a name="local-6989586621679053782"><a href="#local-6989586621679053782"><span class="hs-identifier">tyvars</span></a></a><span> </span><a name="local-6989586621679053783"><a href="#local-6989586621679053783"><span class="hs-identifier">context</span></a></a><span> </span><a name="local-6989586621679053784"><a href="#local-6989586621679053784"><span class="hs-identifier">names</span></a></a><span> </span><a name="local-6989586621679053785"><a href="#local-6989586621679053785"><span class="hs-identifier">innerType</span></a></a><span>
</span><a name="line-891"></a><span>               </span><a name="local-6989586621679053786"><a href="#local-6989586621679053786"><span class="hs-identifier">fields</span></a></a><span> </span><a name="local-6989586621679053787"><a href="#local-6989586621679053787"><span class="hs-identifier">stricts</span></a></a><span> </span><a name="local-6989586621679053788"><a href="#local-6989586621679053788"><span class="hs-identifier">getVariant</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-892"></a><span>  </span><span class="hs-keyword">do</span><span> </span><span class="hs-comment">-- Due to GHC Trac #13885, it's possible that the type variables bound by</span><span>
</span><a name="line-893"></a><span>     </span><span class="hs-comment">-- a GADT constructor will shadow those that are bound by the data type.</span><span>
</span><a name="line-894"></a><span>     </span><span class="hs-comment">-- This function assumes this isn't the case in certain parts (e.g., when</span><span>
</span><a name="line-895"></a><span>     </span><span class="hs-comment">-- mergeArguments is invoked), so we do an alpha-renaming of the</span><span>
</span><a name="line-896"></a><span>     </span><span class="hs-comment">-- constructor-bound variables before proceeding. See #36 for an example</span><span>
</span><a name="line-897"></a><span>     </span><span class="hs-comment">-- of what can go wrong if this isn't done.</span><span>
</span><a name="line-898"></a><span>     </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679053789"><a href="#local-6989586621679053789"><span class="hs-identifier">conBoundNames</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-899"></a><span>           </span><span class="hs-identifier hs-var">concatMap</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><a name="local-6989586621679053790"><a href="#local-6989586621679053790"><span class="hs-identifier">tvb</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a><span> </span><a href="#local-6989586621679053790"><span class="hs-identifier hs-var">tvb</span></a><span class="hs-glyph">:</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#tvKind"><span class="hs-identifier hs-var">tvKind</span></a><span> </span><a href="#local-6989586621679053790"><span class="hs-identifier hs-var">tvb</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053782"><span class="hs-identifier hs-var">tyvars</span></a><span>
</span><a name="line-900"></a><span>     </span><a name="local-6989586621679053792"><a href="#local-6989586621679053792"><span class="hs-identifier">conSubst</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">T.sequence</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">Map.fromList</span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053791"><span class="hs-identifier hs-var">n</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">newName</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">nameBase</span><span> </span><a href="#local-6989586621679053791"><span class="hs-identifier hs-var">n</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-901"></a><span>                                           </span><span class="hs-glyph">|</span><span> </span><a name="local-6989586621679053791"><a href="#local-6989586621679053791"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="#local-6989586621679053789"><span class="hs-identifier hs-var">conBoundNames</span></a><span> </span><span class="hs-special">]</span><span>
</span><a name="line-902"></a><span>     </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679053793"><a href="#local-6989586621679053793"><span class="hs-identifier">conSubst'</span></a></a><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">fmap</span><span> </span><span class="hs-identifier hs-var">VarT</span><span> </span><a href="#local-6989586621679053792"><span class="hs-identifier hs-var">conSubst</span></a><span>
</span><a name="line-903"></a><span>         </span><a name="local-6989586621679053794"><a href="#local-6989586621679053794"><span class="hs-identifier">renamedTyvars</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-904"></a><span>           </span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><a name="local-6989586621679053798"><a href="#local-6989586621679053798"><span class="hs-identifier">tvb</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679053798"><span class="hs-identifier hs-var">tvb</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-905"></a><span>                          </span><span class="hs-identifier hs-var">PlainTV</span><span> </span><a name="local-6989586621679053799"><a href="#local-6989586621679053799"><span class="hs-identifier">n</span></a></a><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">PlainTV</span><span>  </span><span class="hs-special">(</span><a href="#local-6989586621679053792"><span class="hs-identifier hs-var">conSubst</span></a><span> </span><span class="hs-operator hs-var">Map.!</span><span> </span><a href="#local-6989586621679053799"><span class="hs-identifier hs-var">n</span></a><span class="hs-special">)</span><span>
</span><a name="line-906"></a><span>                          </span><span class="hs-identifier hs-var">KindedTV</span><span> </span><a name="local-6989586621679053800"><a href="#local-6989586621679053800"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679053801"><a href="#local-6989586621679053801"><span class="hs-identifier">k</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">KindedTV</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053792"><span class="hs-identifier hs-var">conSubst</span></a><span> </span><span class="hs-operator hs-var">Map.!</span><span> </span><a href="#local-6989586621679053800"><span class="hs-identifier hs-var">n</span></a><span class="hs-special">)</span><span>
</span><a name="line-907"></a><span>                                                   </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679053793"><span class="hs-identifier hs-var">conSubst'</span></a><span> </span><a href="#local-6989586621679053801"><span class="hs-identifier hs-var">k</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053782"><span class="hs-identifier hs-var">tyvars</span></a><span>
</span><a name="line-908"></a><span>         </span><a name="local-6989586621679053795"><a href="#local-6989586621679053795"><span class="hs-identifier">renamedContext</span></a></a><span>   </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679053793"><span class="hs-identifier hs-var">conSubst'</span></a><span> </span><a href="#local-6989586621679053783"><span class="hs-identifier hs-var">context</span></a><span>
</span><a name="line-909"></a><span>         </span><a name="local-6989586621679053796"><a href="#local-6989586621679053796"><span class="hs-identifier">renamedInnerType</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679053793"><span class="hs-identifier hs-var">conSubst'</span></a><span> </span><a href="#local-6989586621679053785"><span class="hs-identifier hs-var">innerType</span></a><span>
</span><a name="line-910"></a><span>         </span><a name="local-6989586621679053797"><a href="#local-6989586621679053797"><span class="hs-identifier">renamedFields</span></a></a><span>    </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679053793"><span class="hs-identifier hs-var">conSubst'</span></a><span> </span><a href="#local-6989586621679053786"><span class="hs-identifier hs-var">fields</span></a><span>
</span><a name="line-911"></a><span>
</span><a name="line-912"></a><span>     </span><a name="local-6989586621679053802"><a href="#local-6989586621679053802"><span class="hs-identifier">innerType'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a><span> </span><a href="#local-6989586621679053796"><span class="hs-identifier hs-var">renamedInnerType</span></a><span>
</span><a name="line-913"></a><span>     </span><span class="hs-keyword">case</span><span> </span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a><span> </span><a href="#local-6989586621679053802"><span class="hs-identifier hs-var">innerType'</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-914"></a><span>       </span><span class="hs-identifier hs-var">ConT</span><span> </span><a name="local-6989586621679053803"><a href="#local-6989586621679053803"><span class="hs-identifier">innerTyCon</span></a></a><span> </span><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-var">:|</span></a><span> </span><a name="local-6989586621679053804"><a href="#local-6989586621679053804"><span class="hs-identifier">ts</span></a></a><span> </span><span class="hs-glyph">|</span><span> </span><a href="#local-6989586621679053780"><span class="hs-identifier hs-var">typename</span></a><span> </span><span class="hs-operator hs-var">==</span><span> </span><a href="#local-6989586621679053803"><span class="hs-identifier hs-var">innerTyCon</span></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-915"></a><span>
</span><a name="line-916"></a><span>         </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><a name="local-6989586621679053805"><a href="#local-6989586621679053805"><span class="hs-identifier">substName</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679053806"><a href="#local-6989586621679053806"><span class="hs-identifier">context1</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-917"></a><span>               </span><a href="Language.Haskell.TH.Datatype.html#closeOverKinds"><span class="hs-identifier hs-var">closeOverKinds</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTvbs"><span class="hs-identifier hs-var">kindsOfFVsOfTvbs</span></a><span> </span><a href="#local-6989586621679053794"><span class="hs-identifier hs-var">renamedTyvars</span></a><span class="hs-special">)</span><span>
</span><a name="line-918"></a><span>                              </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTypes"><span class="hs-identifier hs-var">kindsOfFVsOfTypes</span></a><span> </span><a href="#local-6989586621679053781"><span class="hs-identifier hs-var">params</span></a><span class="hs-special">)</span><span>
</span><a name="line-919"></a><span>                              </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#mergeArguments"><span class="hs-identifier hs-var">mergeArguments</span></a><span> </span><a href="#local-6989586621679053781"><span class="hs-identifier hs-var">params</span></a><span> </span><a href="#local-6989586621679053804"><span class="hs-identifier hs-var">ts</span></a><span class="hs-special">)</span><span>
</span><a name="line-920"></a><span>             </span><a name="local-6989586621679053807"><a href="#local-6989586621679053807"><span class="hs-identifier">subst</span></a></a><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">VarT</span><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><a href="#local-6989586621679053805"><span class="hs-identifier hs-var">substName</span></a><span>
</span><a name="line-921"></a><span>             </span><a name="local-6989586621679053808"><a href="#local-6989586621679053808"><span class="hs-identifier">exTyvars</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span> </span><a href="#local-6989586621679053812"><span class="hs-identifier hs-var">tv</span></a><span> </span><span class="hs-glyph">|</span><span> </span><a name="local-6989586621679053812"><a href="#local-6989586621679053812"><span class="hs-identifier">tv</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="#local-6989586621679053794"><span class="hs-identifier hs-var">renamedTyvars</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">Map.notMember</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a><span> </span><a href="#local-6989586621679053812"><span class="hs-identifier hs-var">tv</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053807"><span class="hs-identifier hs-var">subst</span></a><span> </span><span class="hs-special">]</span><span>
</span><a name="line-922"></a><span>
</span><a name="line-923"></a><span>             </span><a name="local-6989586621679053809"><a href="#local-6989586621679053809"><span class="hs-identifier">exTyvars'</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrs"><span class="hs-identifier hs-var">substTyVarBndrs</span></a><span>   </span><a href="#local-6989586621679053807"><span class="hs-identifier hs-var">subst</span></a><span> </span><a href="#local-6989586621679053808"><span class="hs-identifier hs-var">exTyvars</span></a><span>
</span><a name="line-924"></a><span>             </span><a name="local-6989586621679053810"><a href="#local-6989586621679053810"><span class="hs-identifier">context2</span></a></a><span>  </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679053807"><span class="hs-identifier hs-var">subst</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053806"><span class="hs-identifier hs-var">context1</span></a><span> </span><span class="hs-operator hs-var">++</span><span> </span><a href="#local-6989586621679053795"><span class="hs-identifier hs-var">renamedContext</span></a><span class="hs-special">)</span><span>
</span><a name="line-925"></a><span>             </span><a name="local-6989586621679053811"><a href="#local-6989586621679053811"><span class="hs-identifier">fields'</span></a></a><span>   </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679053807"><span class="hs-identifier hs-var">subst</span></a><span> </span><a href="#local-6989586621679053797"><span class="hs-identifier hs-var">renamedFields</span></a><span>
</span><a name="line-926"></a><span>         </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier hs-var">sequence</span><span> </span><span class="hs-special">[</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a><span> </span><a href="#local-6989586621679053813"><span class="hs-identifier hs-var">name</span></a><span> </span><a href="#local-6989586621679053809"><span class="hs-identifier hs-var">exTyvars'</span></a><span> </span><a href="#local-6989586621679053810"><span class="hs-identifier hs-var">context2</span></a><span>
</span><a name="line-927"></a><span>                                       </span><a href="#local-6989586621679053811"><span class="hs-identifier hs-var">fields'</span></a><span> </span><a href="#local-6989586621679053787"><span class="hs-identifier hs-var">stricts</span></a><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><a href="#local-6989586621679053814"><span class="hs-identifier hs-var">variantQ</span></a><span>
</span><a name="line-928"></a><span>                     </span><span class="hs-glyph">|</span><span> </span><a name="local-6989586621679053813"><a href="#local-6989586621679053813"><span class="hs-identifier">name</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="#local-6989586621679053784"><span class="hs-identifier hs-var">names</span></a><span>
</span><a name="line-929"></a><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679053814"><a href="#local-6989586621679053814"><span class="hs-identifier">variantQ</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053788"><span class="hs-identifier hs-var">getVariant</span></a><span> </span><a href="#local-6989586621679053813"><span class="hs-identifier hs-var">name</span></a><span>
</span><a name="line-930"></a><span>                     </span><span class="hs-special">]</span><span>
</span><a name="line-931"></a><span>
</span><a name="line-932"></a><span>       </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">fail</span><span> </span><span class="hs-string">&quot;normalizeGadtC: Expected type constructor application&quot;</span><span>
</span><a name="line-933"></a><span>
</span><a name="line-934"></a><span class="hs-comment">{-
Extend a type variable renaming subtitution and a list of equality
predicates by looking into kind information as much as possible.

Why is this necessary? Consider the following example:

  data (a1 :: k1) :~: (b1 :: k1) where
    Refl :: forall k2 (a2 :: k2). a2 :~: a2

After an initial call to mergeArguments, we will have the following
substitution and context:

* Substitution: [a2 :-&gt; a1]
* Context: (a2 ~ b1)

We shouldn't stop there, however! We determine the existentially quantified
type variables of a constructor by filtering out those constructor-bound
variables which do not appear in the substitution that mergeArguments
returns. In this example, Refl's bound variables are k2 and a2. a2 appears
in the returned substitution, but k2 does not, which means that we would
mistakenly conclude that k2 is existential!

Although we don't have the full power of kind inference to guide us here, we
can at least do the next best thing. Generally, the datatype-bound type
variables and the constructor type variable binders contain all of the kind
information we need, so we proceed as follows:

1. Construct a map from each constructor-bound variable to its kind. (Do the
   same for each datatype-bound variable). These maps are the first and second
   arguments to closeOverKinds, respectively.
2. Call mergeArguments once on the GADT return type and datatype-bound types,
   and pass that in as the third argument to closeOverKinds.
3. For each name-name pair in the supplied substitution, check if the first and
   second names map to kinds in the first and second kind maps in
   closeOverKinds, respectively. If so, associate the first kind with the
   second kind.
4. For each kind association discovered in part (3), call mergeArguments
   on the lists of kinds. This will yield a kind substitution and kind
   equality context.
5. If the kind substitution is non-empty, then go back to step (3) and repeat
   the process on the new kind substitution and context.

   Otherwise, if the kind substitution is empty, then we have reached a fixed-
   point (i.e., we have closed over the kinds), so proceed.
6. Union up all of the substitutions and contexts, and return those.

This algorithm is not perfect, as it will only catch everything if all of
the kinds are explicitly mentioned somewhere (and not left quantified
implicitly). Thankfully, reifying data types via Template Haskell tends to
yield a healthy amount of kind signatures, so this works quite well in
practice.
-}</span><span>
</span><a name="line-986"></a><span class="hs-identifier">closeOverKinds</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Kind</span><span>
</span><a name="line-987"></a><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Kind</span><span>
</span><a name="line-988"></a><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Name</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Cxt</span><span class="hs-special">)</span><span>
</span><a name="line-989"></a><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Name</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Cxt</span><span class="hs-special">)</span><span>
</span><a name="line-990"></a><a name="closeOverKinds"><a href="Language.Haskell.TH.Datatype.html#closeOverKinds"><span class="hs-identifier">closeOverKinds</span></a></a><span> </span><a name="local-6989586621679053815"><a href="#local-6989586621679053815"><span class="hs-identifier">domainFVKinds</span></a></a><span> </span><a name="local-6989586621679053816"><a href="#local-6989586621679053816"><span class="hs-identifier">rangeFVKinds</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053817"><span class="hs-identifier hs-var">go</span></a><span>
</span><a name="line-991"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-992"></a><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Name</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Cxt</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Name</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Cxt</span><span class="hs-special">)</span><span>
</span><a name="line-993"></a><span>    </span><a name="local-6989586621679053817"><a href="#local-6989586621679053817"><span class="hs-identifier">go</span></a></a><span> </span><span class="hs-special">(</span><a name="local-6989586621679053818"><a href="#local-6989586621679053818"><span class="hs-identifier">subst</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679053819"><a href="#local-6989586621679053819"><span class="hs-identifier">context</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-994"></a><span>      </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679053820"><a href="#local-6989586621679053820"><span class="hs-identifier">substList</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Map.toList</span><span> </span><a href="#local-6989586621679053818"><span class="hs-identifier hs-var">subst</span></a><span>
</span><a name="line-995"></a><span>          </span><span class="hs-special">(</span><a name="local-6989586621679053821"><a href="#local-6989586621679053821"><span class="hs-identifier">kindsInner</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679053822"><a href="#local-6989586621679053822"><span class="hs-identifier">kindsOuter</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-996"></a><span>            </span><span class="hs-identifier hs-var">unzip</span><span> </span><span class="hs-operator hs-var">$</span><span>
</span><a name="line-997"></a><span>            </span><span class="hs-identifier hs-var">mapMaybe</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><a name="local-6989586621679053829"><a href="#local-6989586621679053829"><span class="hs-identifier">d</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679053830"><a href="#local-6989586621679053830"><span class="hs-identifier">r</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><a name="local-6989586621679053831"><a href="#local-6989586621679053831"><span class="hs-identifier">d'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">Map.lookup</span><span> </span><a href="#local-6989586621679053829"><span class="hs-identifier hs-var">d</span></a><span> </span><a href="#local-6989586621679053815"><span class="hs-identifier hs-var">domainFVKinds</span></a><span>
</span><a name="line-998"></a><span>                                    </span><a name="local-6989586621679053832"><a href="#local-6989586621679053832"><span class="hs-identifier">r'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">Map.lookup</span><span> </span><a href="#local-6989586621679053830"><span class="hs-identifier hs-var">r</span></a><span> </span><a href="#local-6989586621679053816"><span class="hs-identifier hs-var">rangeFVKinds</span></a><span>
</span><a name="line-999"></a><span>                                    </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053831"><span class="hs-identifier hs-var">d'</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679053832"><span class="hs-identifier hs-var">r'</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-1000"></a><span>                     </span><a href="#local-6989586621679053820"><span class="hs-identifier hs-var">substList</span></a><span>
</span><a name="line-1001"></a><span>          </span><span class="hs-special">(</span><a name="local-6989586621679053823"><a href="#local-6989586621679053823"><span class="hs-identifier">kindSubst</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679053824"><a href="#local-6989586621679053824"><span class="hs-identifier">kindContext</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#mergeArgumentKinds"><span class="hs-identifier hs-var">mergeArgumentKinds</span></a><span> </span><a href="#local-6989586621679053822"><span class="hs-identifier hs-var">kindsOuter</span></a><span> </span><a href="#local-6989586621679053821"><span class="hs-identifier hs-var">kindsInner</span></a><span>
</span><a name="line-1002"></a><span>          </span><span class="hs-special">(</span><a name="local-6989586621679053825"><a href="#local-6989586621679053825"><span class="hs-identifier">restSubst</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679053826"><a href="#local-6989586621679053826"><span class="hs-identifier">restContext</span></a></a><span class="hs-special">)</span><span>
</span><a name="line-1003"></a><span>            </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier hs-var">Map.null</span><span> </span><a href="#local-6989586621679053823"><span class="hs-identifier hs-var">kindSubst</span></a><span> </span><span class="hs-comment">-- Fixed-point calculation</span><span>
</span><a name="line-1004"></a><span>                 </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Map.empty</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><a name="line-1005"></a><span>                 </span><span class="hs-keyword">else</span><span> </span><a href="#local-6989586621679053817"><span class="hs-identifier hs-var">go</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053823"><span class="hs-identifier hs-var">kindSubst</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679053824"><span class="hs-identifier hs-var">kindContext</span></a><span class="hs-special">)</span><span>
</span><a name="line-1006"></a><span>          </span><a name="local-6989586621679053827"><a href="#local-6989586621679053827"><span class="hs-identifier">finalSubst</span></a></a><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Map.unions</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679053818"><span class="hs-identifier hs-var">subst</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679053823"><span class="hs-identifier hs-var">kindSubst</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679053825"><span class="hs-identifier hs-var">restSubst</span></a><span class="hs-special">]</span><span>
</span><a name="line-1007"></a><span>          </span><a name="local-6989586621679053828"><a href="#local-6989586621679053828"><span class="hs-identifier">finalContext</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">nub</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">concat</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679053819"><span class="hs-identifier hs-var">context</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679053824"><span class="hs-identifier hs-var">kindContext</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679053826"><span class="hs-identifier hs-var">restContext</span></a><span class="hs-special">]</span><span>
</span><a name="line-1008"></a><span>            </span><span class="hs-comment">-- Use `nub` here in an effort to minimize the number of</span><span>
</span><a name="line-1009"></a><span>            </span><span class="hs-comment">-- redundant equality constraints in the returned context.</span><span>
</span><a name="line-1010"></a><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053827"><span class="hs-identifier hs-var">finalSubst</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679053828"><span class="hs-identifier hs-var">finalContext</span></a><span class="hs-special">)</span><span>
</span><a name="line-1011"></a><span>
</span><a name="line-1012"></a><span class="hs-comment">-- Look into a list of types and map each free variable name to its kind.</span><span>
</span><a name="line-1013"></a><span class="hs-identifier">kindsOfFVsOfTypes</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Kind</span><span>
</span><a name="line-1014"></a><a name="kindsOfFVsOfTypes"><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTypes"><span class="hs-identifier">kindsOfFVsOfTypes</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">foldMap</span><span> </span><a href="#local-6989586621679053833"><span class="hs-identifier hs-var">go</span></a><span>
</span><a name="line-1015"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-1016"></a><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Kind</span><span>
</span><a name="line-1017"></a><span>    </span><a name="local-6989586621679053833"><a href="#local-6989586621679053833"><span class="hs-identifier">go</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">ForallT</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">error</span><span> </span><span class="hs-string">&quot;`forall` type used in data family pattern&quot;</span><span>
</span><a name="line-1018"></a><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">AppT</span><span> </span><a name="local-6989586621679053834"><a href="#local-6989586621679053834"><span class="hs-identifier">t1</span></a></a><span> </span><a name="local-6989586621679053835"><a href="#local-6989586621679053835"><span class="hs-identifier">t2</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053833"><span class="hs-identifier hs-var">go</span></a><span> </span><a href="#local-6989586621679053834"><span class="hs-identifier hs-var">t1</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">Map.union</span><span class="hs-special">`</span><span> </span><a href="#local-6989586621679053833"><span class="hs-identifier hs-var">go</span></a><span> </span><a href="#local-6989586621679053835"><span class="hs-identifier hs-var">t2</span></a><span>
</span><a name="line-1019"></a><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">SigT</span><span> </span><a name="local-6989586621679053836"><a href="#local-6989586621679053836"><span class="hs-identifier">t</span></a></a><span> </span><a name="local-6989586621679053837"><a href="#local-6989586621679053837"><span class="hs-identifier">k</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1020"></a><span>      </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679053838"><a href="#local-6989586621679053838"><span class="hs-identifier">kSigs</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1021"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,8,0)
</span><span>                  </span><a href="#local-6989586621679053833"><span class="hs-identifier hs-var">go</span></a><span> </span><a href="#local-6989586621679053837"><span class="hs-identifier hs-var">k</span></a><span>
</span><a name="line-1023"></a><span class="hs-cpp">#else
</span><span>                  </span><span class="hs-identifier">Map.empty</span><span>
</span><a name="line-1025"></a><span class="hs-cpp">#endif
</span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679053836"><span class="hs-identifier hs-var">t</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1027"></a><span>           </span><span class="hs-identifier hs-var">VarT</span><span> </span><a name="local-6989586621679053839"><a href="#local-6989586621679053839"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">Map.insert</span><span> </span><a href="#local-6989586621679053839"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679053837"><span class="hs-identifier hs-var">k</span></a><span> </span><a href="#local-6989586621679053838"><span class="hs-identifier hs-var">kSigs</span></a><span>
</span><a name="line-1028"></a><span>           </span><span class="hs-identifier">_</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053833"><span class="hs-identifier hs-var">go</span></a><span> </span><a href="#local-6989586621679053836"><span class="hs-identifier hs-var">t</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">Map.union</span><span class="hs-special">`</span><span> </span><a href="#local-6989586621679053838"><span class="hs-identifier hs-var">kSigs</span></a><span>
</span><a name="line-1029"></a><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Map.empty</span><span>
</span><a name="line-1030"></a><span>
</span><a name="line-1031"></a><span class="hs-comment">-- Look into a list of type variable binder and map each free variable name</span><span>
</span><a name="line-1032"></a><span class="hs-comment">-- to its kind (also map the names that KindedTVs bind to their respective</span><span>
</span><a name="line-1033"></a><span class="hs-comment">-- kinds). This function considers the kind of a PlainTV to be *.</span><span>
</span><a name="line-1034"></a><span class="hs-identifier">kindsOfFVsOfTvbs</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Kind</span><span>
</span><a name="line-1035"></a><a name="kindsOfFVsOfTvbs"><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTvbs"><span class="hs-identifier">kindsOfFVsOfTvbs</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">foldMap</span><span> </span><a href="#local-6989586621679053840"><span class="hs-identifier hs-var">go</span></a><span>
</span><a name="line-1036"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-1037"></a><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">TyVarBndr</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Kind</span><span>
</span><a name="line-1038"></a><span>    </span><a name="local-6989586621679053840"><a href="#local-6989586621679053840"><span class="hs-identifier">go</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">PlainTV</span><span> </span><a name="local-6989586621679053841"><a href="#local-6989586621679053841"><span class="hs-identifier">n</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Map.singleton</span><span> </span><a href="#local-6989586621679053841"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-identifier hs-var">starK</span><span>
</span><a name="line-1039"></a><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">KindedTV</span><span> </span><a name="local-6989586621679053842"><a href="#local-6989586621679053842"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679053843"><a href="#local-6989586621679053843"><span class="hs-identifier">k</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1040"></a><span>      </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679053844"><a href="#local-6989586621679053844"><span class="hs-identifier">kSigs</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1041"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,8,0)
</span><span>                  </span><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTypes"><span class="hs-identifier hs-var">kindsOfFVsOfTypes</span></a><span> </span><span class="hs-special">[</span><a href="#local-6989586621679053843"><span class="hs-identifier hs-var">k</span></a><span class="hs-special">]</span><span>
</span><a name="line-1043"></a><span class="hs-cpp">#else
</span><span>                  </span><span class="hs-identifier">Map.empty</span><span>
</span><a name="line-1045"></a><span class="hs-cpp">#endif
</span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier hs-var">Map.insert</span><span> </span><a href="#local-6989586621679053842"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679053843"><span class="hs-identifier hs-var">k</span></a><span> </span><a href="#local-6989586621679053844"><span class="hs-identifier hs-var">kSigs</span></a><span>
</span><a name="line-1047"></a><span>
</span><a name="line-1048"></a><span class="hs-identifier">mergeArguments</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-1049"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ outer parameters                    -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1050"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ inner parameters (specializations ) -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1051"></a><span>  </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Name</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Cxt</span><span class="hs-special">)</span><span>
</span><a name="line-1052"></a><a name="mergeArguments"><a href="Language.Haskell.TH.Datatype.html#mergeArguments"><span class="hs-identifier">mergeArguments</span></a></a><span> </span><a name="local-6989586621679053845"><a href="#local-6989586621679053845"><span class="hs-identifier">ns</span></a></a><span> </span><a name="local-6989586621679053846"><a href="#local-6989586621679053846"><span class="hs-identifier">ts</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">foldr</span><span> </span><a href="#local-6989586621679053847"><span class="hs-identifier hs-var">aux</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Map.empty</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">zip</span><span> </span><a href="#local-6989586621679053845"><span class="hs-identifier hs-var">ns</span></a><span> </span><a href="#local-6989586621679053846"><span class="hs-identifier hs-var">ts</span></a><span class="hs-special">)</span><span>
</span><a name="line-1053"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-1054"></a><span>
</span><a name="line-1055"></a><span>    </span><a name="local-6989586621679053847"><a href="#local-6989586621679053847"><span class="hs-identifier">aux</span></a></a><span> </span><span class="hs-special">(</span><a name="local-6989586621679053848"><a href="#local-6989586621679053848"><span class="hs-identifier">f</span></a></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">AppT</span><span class="hs-special">`</span><span> </span><a name="local-6989586621679053849"><a href="#local-6989586621679053849"><span class="hs-identifier">x</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679053850"><a href="#local-6989586621679053850"><span class="hs-identifier">g</span></a></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">AppT</span><span class="hs-special">`</span><span> </span><a name="local-6989586621679053851"><a href="#local-6989586621679053851"><span class="hs-identifier">y</span></a></a><span class="hs-special">)</span><span> </span><a name="local-6989586621679053852"><a href="#local-6989586621679053852"><span class="hs-identifier">sc</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1056"></a><span>      </span><a href="#local-6989586621679053847"><span class="hs-identifier hs-var">aux</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053849"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">,</span><a href="#local-6989586621679053851"><span class="hs-identifier hs-var">y</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053847"><span class="hs-identifier hs-var">aux</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053848"><span class="hs-identifier hs-var">f</span></a><span class="hs-special">,</span><a href="#local-6989586621679053850"><span class="hs-identifier hs-var">g</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053852"><span class="hs-identifier hs-var">sc</span></a><span class="hs-special">)</span><span>
</span><a name="line-1057"></a><span>
</span><a name="line-1058"></a><span>    </span><span class="hs-identifier">aux</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">VarT</span><span> </span><a name="local-6989586621679053853"><a href="#local-6989586621679053853"><span class="hs-identifier">n</span></a></a><span class="hs-special">,</span><a name="local-6989586621679053854"><a href="#local-6989586621679053854"><span class="hs-identifier">p</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><a name="local-6989586621679053855"><a href="#local-6989586621679053855"><span class="hs-identifier">subst</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679053856"><a href="#local-6989586621679053856"><span class="hs-identifier">context</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1059"></a><span>      </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679053854"><span class="hs-identifier hs-var">p</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1060"></a><span>        </span><span class="hs-identifier hs-var">VarT</span><span> </span><a name="local-6989586621679053857"><a href="#local-6989586621679053857"><span class="hs-identifier">m</span></a></a><span> </span><span class="hs-glyph">|</span><span> </span><a href="#local-6989586621679053857"><span class="hs-identifier hs-var">m</span></a><span> </span><span class="hs-operator hs-var">==</span><span> </span><a href="#local-6989586621679053853"><span class="hs-identifier hs-var">n</span></a><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053855"><span class="hs-identifier hs-var">subst</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679053856"><span class="hs-identifier hs-var">context</span></a><span class="hs-special">)</span><span>
</span><a name="line-1061"></a><span>                   </span><span class="hs-comment">-- If the two variables are the same, don't bother extending</span><span>
</span><a name="line-1062"></a><span>                   </span><span class="hs-comment">-- the substitution. (This is purely an optimization.)</span><span>
</span><a name="line-1063"></a><span>               </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">Just</span><span> </span><a name="local-6989586621679053858"><a href="#local-6989586621679053858"><span class="hs-identifier">n'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">Map.lookup</span><span> </span><a href="#local-6989586621679053857"><span class="hs-identifier hs-var">m</span></a><span> </span><a href="#local-6989586621679053855"><span class="hs-identifier hs-var">subst</span></a><span>
</span><a name="line-1064"></a><span>               </span><span class="hs-special">,</span><span> </span><a href="#local-6989586621679053853"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-operator hs-var">==</span><span> </span><a href="#local-6989586621679053858"><span class="hs-identifier hs-var">n'</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053855"><span class="hs-identifier hs-var">subst</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679053856"><span class="hs-identifier hs-var">context</span></a><span class="hs-special">)</span><span>
</span><a name="line-1065"></a><span>                   </span><span class="hs-comment">-- If a variable is already in a substitution and it maps</span><span>
</span><a name="line-1066"></a><span>                   </span><span class="hs-comment">-- to the variable that we are trying to unify with, then</span><span>
</span><a name="line-1067"></a><span>                   </span><span class="hs-comment">-- leave the context alone. (Not doing so caused #46.)</span><span>
</span><a name="line-1068"></a><span>               </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">Map.notMember</span><span> </span><a href="#local-6989586621679053857"><span class="hs-identifier hs-var">m</span></a><span> </span><a href="#local-6989586621679053855"><span class="hs-identifier hs-var">subst</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Map.insert</span><span> </span><a href="#local-6989586621679053857"><span class="hs-identifier hs-var">m</span></a><span> </span><a href="#local-6989586621679053853"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679053855"><span class="hs-identifier hs-var">subst</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679053856"><span class="hs-identifier hs-var">context</span></a><span class="hs-special">)</span><span>
</span><a name="line-1069"></a><span>        </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053855"><span class="hs-identifier hs-var">subst</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#equalPred"><span class="hs-identifier hs-var">equalPred</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">VarT</span><span> </span><a href="#local-6989586621679053853"><span class="hs-identifier hs-var">n</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053854"><span class="hs-identifier hs-var">p</span></a><span> </span><span class="hs-glyph">:</span><span> </span><a href="#local-6989586621679053856"><span class="hs-identifier hs-var">context</span></a><span class="hs-special">)</span><span>
</span><a name="line-1070"></a><span>
</span><a name="line-1071"></a><span>    </span><span class="hs-identifier">aux</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">SigT</span><span> </span><a name="local-6989586621679053859"><a href="#local-6989586621679053859"><span class="hs-identifier">x</span></a></a><span> </span><span class="hs-identifier">_</span><span class="hs-special">,</span><span> </span><a name="local-6989586621679053860"><a href="#local-6989586621679053860"><span class="hs-identifier">y</span></a></a><span class="hs-special">)</span><span> </span><a name="local-6989586621679053861"><a href="#local-6989586621679053861"><span class="hs-identifier">sc</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053847"><span class="hs-identifier hs-var">aux</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053859"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">,</span><a href="#local-6989586621679053860"><span class="hs-identifier hs-var">y</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053861"><span class="hs-identifier hs-var">sc</span></a><span> </span><span class="hs-comment">-- learn about kinds??</span><span>
</span><a name="line-1072"></a><span>    </span><span class="hs-comment">-- This matches *after* VarT so that we can compute a substitution</span><span>
</span><a name="line-1073"></a><span>    </span><span class="hs-comment">-- that includes the kind signature.</span><span>
</span><a name="line-1074"></a><span>    </span><span class="hs-identifier">aux</span><span> </span><span class="hs-special">(</span><a name="local-6989586621679053862"><a href="#local-6989586621679053862"><span class="hs-identifier">x</span></a></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">SigT</span><span> </span><a name="local-6989586621679053863"><a href="#local-6989586621679053863"><span class="hs-identifier">y</span></a></a><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><a name="local-6989586621679053864"><a href="#local-6989586621679053864"><span class="hs-identifier">sc</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053847"><span class="hs-identifier hs-var">aux</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053862"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">,</span><a href="#local-6989586621679053863"><span class="hs-identifier hs-var">y</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053864"><span class="hs-identifier hs-var">sc</span></a><span>
</span><a name="line-1075"></a><span>
</span><a name="line-1076"></a><span>    </span><span class="hs-identifier">aux</span><span> </span><span class="hs-identifier">_</span><span> </span><a name="local-6989586621679053865"><a href="#local-6989586621679053865"><span class="hs-identifier">sc</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053865"><span class="hs-identifier hs-var">sc</span></a><span>
</span><a name="line-1077"></a><span>
</span><a name="line-1078"></a><span class="hs-comment">-- | A specialization of 'mergeArguments' to 'Kind'.</span><span>
</span><a name="line-1079"></a><span class="hs-comment">-- Needed only for backwards compatibility with older versions of</span><span>
</span><a name="line-1080"></a><span class="hs-comment">-- @template-haskell@.</span><span>
</span><a name="line-1081"></a><span class="hs-identifier">mergeArgumentKinds</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-1082"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Kind</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1083"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Kind</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1084"></a><span>  </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Name</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Cxt</span><span class="hs-special">)</span><span>
</span><a name="line-1085"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,8,0)
</span><a name="mergeArgumentKinds"><a href="Language.Haskell.TH.Datatype.html#mergeArgumentKinds"><span class="hs-identifier">mergeArgumentKinds</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#mergeArguments"><span class="hs-identifier hs-var">mergeArguments</span></a><span>
</span><a name="line-1087"></a><span class="hs-cpp">#else
</span><span class="hs-identifier">mergeArgumentKinds</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Map.empty</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><a name="line-1089"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1091"></a><span class="hs-comment">-- | Expand all of the type synonyms in a type.</span><span>
</span><a name="line-1092"></a><span class="hs-comment">--</span><span>
</span><a name="line-1093"></a><span class="hs-comment">-- Note that this function will drop parentheses as a side effect.</span><span>
</span><a name="line-1094"></a><span class="hs-identifier">resolveTypeSynonyms</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-1095"></a><a name="resolveTypeSynonyms"><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier">resolveTypeSynonyms</span></a></a><span> </span><a name="local-6989586621679053866"><a href="#local-6989586621679053866"><span class="hs-identifier">t</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1096"></a><span>  </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679053867"><a href="#local-6989586621679053867"><span class="hs-identifier">f</span></a></a><span> </span><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-var">:|</span></a><span> </span><a name="local-6989586621679053868"><a href="#local-6989586621679053868"><span class="hs-identifier">xs</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a><span> </span><a href="#local-6989586621679053866"><span class="hs-identifier hs-var">t</span></a><span>
</span><a name="line-1097"></a><span>
</span><a name="line-1098"></a><span>      </span><span class="hs-identifier">notTypeSynCase</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-1099"></a><span>      </span><a name="local-6989586621679053869"><a href="#local-6989586621679053869"><span class="hs-identifier">notTypeSynCase</span></a></a><span> </span><a name="local-6989586621679053871"><a href="#local-6989586621679053871"><span class="hs-identifier">ty</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">foldl</span><span> </span><span class="hs-identifier hs-var">AppT</span><span> </span><a href="#local-6989586621679053871"><span class="hs-identifier hs-var">ty</span></a><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><span class="hs-identifier hs-var">mapM</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a><span> </span><a href="#local-6989586621679053868"><span class="hs-identifier hs-var">xs</span></a><span>
</span><a name="line-1100"></a><span>
</span><a name="line-1101"></a><span>      </span><span class="hs-identifier">expandCon</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-comment">-- The Name to check whether it is a type synonym or not</span><span>
</span><a name="line-1102"></a><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-comment">-- The argument type to fall back on if the supplied</span><span>
</span><a name="line-1103"></a><span>                        </span><span class="hs-comment">-- Name isn't a type synonym</span><span>
</span><a name="line-1104"></a><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-1105"></a><span>      </span><a name="local-6989586621679053870"><a href="#local-6989586621679053870"><span class="hs-identifier">expandCon</span></a></a><span> </span><a name="local-6989586621679053872"><a href="#local-6989586621679053872"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679053873"><a href="#local-6989586621679053873"><span class="hs-identifier">ty</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-1106"></a><span>        </span><a name="local-6989586621679053874"><a href="#local-6989586621679053874"><span class="hs-identifier">mbInfo</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.TH.Datatype.html#reifyMaybe"><span class="hs-identifier hs-var">reifyMaybe</span></a><span> </span><a href="#local-6989586621679053872"><span class="hs-identifier hs-var">n</span></a><span>
</span><a name="line-1107"></a><span>        </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679053874"><span class="hs-identifier hs-var">mbInfo</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1108"></a><span>          </span><span class="hs-identifier hs-var">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">TyConI</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">TySynD</span><span> </span><span class="hs-identifier">_</span><span> </span><a name="local-6989586621679053875"><a href="#local-6989586621679053875"><span class="hs-identifier">synvars</span></a></a><span> </span><a name="local-6989586621679053876"><a href="#local-6989586621679053876"><span class="hs-identifier">def</span></a></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-1109"></a><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a><span> </span><span class="hs-operator hs-var">$</span><span> </span><a href="Language.Haskell.TH.Datatype.html#expandSynonymRHS"><span class="hs-identifier hs-var">expandSynonymRHS</span></a><span> </span><a href="#local-6989586621679053875"><span class="hs-identifier hs-var">synvars</span></a><span> </span><a href="#local-6989586621679053868"><span class="hs-identifier hs-var">xs</span></a><span> </span><a href="#local-6989586621679053876"><span class="hs-identifier hs-var">def</span></a><span>
</span><a name="line-1110"></a><span>          </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053869"><span class="hs-identifier hs-var">notTypeSynCase</span></a><span> </span><a href="#local-6989586621679053873"><span class="hs-identifier hs-var">ty</span></a><span>
</span><a name="line-1111"></a><span>
</span><a name="line-1112"></a><span>  </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679053867"><span class="hs-identifier hs-var">f</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1113"></a><span>       </span><span class="hs-identifier hs-var">ForallT</span><span> </span><a name="local-6989586621679053877"><a href="#local-6989586621679053877"><span class="hs-identifier">tvbs</span></a></a><span> </span><a name="local-6989586621679053878"><a href="#local-6989586621679053878"><span class="hs-identifier">ctxt</span></a></a><span> </span><a name="local-6989586621679053879"><a href="#local-6989586621679053879"><span class="hs-identifier">body</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1114"></a><span>         </span><span class="hs-identifier hs-var">ForallT</span><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">fmap</span><span class="hs-special">`</span><span> </span><span class="hs-identifier hs-var">mapM</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolve_tvb_syns"><span class="hs-identifier hs-var">resolve_tvb_syns</span></a><span> </span><a href="#local-6989586621679053877"><span class="hs-identifier hs-var">tvbs</span></a><span>
</span><a name="line-1115"></a><span>                   </span><span class="hs-special">`</span><span class="hs-identifier hs-var">ap</span><span class="hs-special">`</span><span> </span><span class="hs-identifier hs-var">mapM</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolvePredSynonyms"><span class="hs-identifier hs-var">resolvePredSynonyms</span></a><span> </span><a href="#local-6989586621679053878"><span class="hs-identifier hs-var">ctxt</span></a><span>
</span><a name="line-1116"></a><span>                   </span><span class="hs-special">`</span><span class="hs-identifier hs-var">ap</span><span class="hs-special">`</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a><span> </span><a href="#local-6989586621679053879"><span class="hs-identifier hs-var">body</span></a><span>
</span><a name="line-1117"></a><span>       </span><span class="hs-identifier hs-var">SigT</span><span> </span><a name="local-6989586621679053880"><a href="#local-6989586621679053880"><span class="hs-identifier">ty</span></a></a><span> </span><a name="local-6989586621679053881"><a href="#local-6989586621679053881"><span class="hs-identifier">ki</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-1118"></a><span>         </span><a name="local-6989586621679053882"><a href="#local-6989586621679053882"><span class="hs-identifier">ty'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a><span> </span><a href="#local-6989586621679053880"><span class="hs-identifier hs-var">ty</span></a><span>
</span><a name="line-1119"></a><span>         </span><a name="local-6989586621679053883"><a href="#local-6989586621679053883"><span class="hs-identifier">ki'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var">resolveKindSynonyms</span></a><span> </span><a href="#local-6989586621679053881"><span class="hs-identifier hs-var">ki</span></a><span>
</span><a name="line-1120"></a><span>         </span><a href="#local-6989586621679053869"><span class="hs-identifier hs-var">notTypeSynCase</span></a><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">SigT</span><span> </span><a href="#local-6989586621679053882"><span class="hs-identifier hs-var">ty'</span></a><span> </span><a href="#local-6989586621679053883"><span class="hs-identifier hs-var">ki'</span></a><span>
</span><a name="line-1121"></a><span>       </span><span class="hs-identifier hs-var">ConT</span><span> </span><a name="local-6989586621679053884"><a href="#local-6989586621679053884"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053870"><span class="hs-identifier hs-var">expandCon</span></a><span> </span><a href="#local-6989586621679053884"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">ConT</span><span> </span><a href="#local-6989586621679053884"><span class="hs-identifier hs-var">n</span></a><span class="hs-special">)</span><span>
</span><a name="line-1122"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><span>       </span><span class="hs-identifier hs-var">InfixT</span><span> </span><a name="local-6989586621679053885"><a href="#local-6989586621679053885"><span class="hs-identifier">t1</span></a></a><span> </span><a name="local-6989586621679053886"><a href="#local-6989586621679053886"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679053887"><a href="#local-6989586621679053887"><span class="hs-identifier">t2</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-1124"></a><span>         </span><a name="local-6989586621679053888"><a href="#local-6989586621679053888"><span class="hs-identifier">t1'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a><span> </span><a href="#local-6989586621679053885"><span class="hs-identifier hs-var">t1</span></a><span>
</span><a name="line-1125"></a><span>         </span><a name="local-6989586621679053889"><a href="#local-6989586621679053889"><span class="hs-identifier">t2'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a><span> </span><a href="#local-6989586621679053887"><span class="hs-identifier hs-var">t2</span></a><span>
</span><a name="line-1126"></a><span>         </span><a href="#local-6989586621679053870"><span class="hs-identifier hs-var">expandCon</span></a><span> </span><a href="#local-6989586621679053886"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">InfixT</span><span> </span><a href="#local-6989586621679053888"><span class="hs-identifier hs-var">t1'</span></a><span> </span><a href="#local-6989586621679053886"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679053889"><span class="hs-identifier hs-var">t2'</span></a><span class="hs-special">)</span><span>
</span><a name="line-1127"></a><span>       </span><span class="hs-identifier hs-var">UInfixT</span><span> </span><a name="local-6989586621679053890"><a href="#local-6989586621679053890"><span class="hs-identifier">t1</span></a></a><span> </span><a name="local-6989586621679053891"><a href="#local-6989586621679053891"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679053892"><a href="#local-6989586621679053892"><span class="hs-identifier">t2</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-1128"></a><span>         </span><a name="local-6989586621679053893"><a href="#local-6989586621679053893"><span class="hs-identifier">t1'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a><span> </span><a href="#local-6989586621679053890"><span class="hs-identifier hs-var">t1</span></a><span>
</span><a name="line-1129"></a><span>         </span><a name="local-6989586621679053894"><a href="#local-6989586621679053894"><span class="hs-identifier">t2'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a><span> </span><a href="#local-6989586621679053892"><span class="hs-identifier hs-var">t2</span></a><span>
</span><a name="line-1130"></a><span>         </span><a href="#local-6989586621679053870"><span class="hs-identifier hs-var">expandCon</span></a><span> </span><a href="#local-6989586621679053891"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">UInfixT</span><span> </span><a href="#local-6989586621679053893"><span class="hs-identifier hs-var">t1'</span></a><span> </span><a href="#local-6989586621679053891"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679053894"><span class="hs-identifier hs-var">t2'</span></a><span class="hs-special">)</span><span>
</span><a name="line-1131"></a><span class="hs-cpp">#endif
</span><span>       </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053869"><span class="hs-identifier hs-var">notTypeSynCase</span></a><span> </span><a href="#local-6989586621679053867"><span class="hs-identifier hs-var">f</span></a><span>
</span><a name="line-1133"></a><span>
</span><a name="line-1134"></a><span class="hs-comment">-- | Expand all of the type synonyms in a 'Kind'.</span><span>
</span><a name="line-1135"></a><span class="hs-identifier">resolveKindSynonyms</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Kind</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-identifier hs-type">Kind</span><span>
</span><a name="line-1136"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,8,0)
</span><a name="resolveKindSynonyms"><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier">resolveKindSynonyms</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a><span>
</span><a name="line-1138"></a><span class="hs-cpp">#else
</span><span class="hs-identifier">resolveKindSynonyms</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-comment">-- One simply couldn't put type synonyms into</span><span>
</span><a name="line-1140"></a><span>                             </span><span class="hs-comment">-- kinds on old versions of GHC.</span><span>
</span><a name="line-1141"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1143"></a><span class="hs-comment">-- | Expand all of the type synonyms in a the kind of a 'TyVarBndr'.</span><span>
</span><a name="line-1144"></a><span class="hs-identifier">resolve_tvb_syns</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">TyVarBndr</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-identifier hs-type">TyVarBndr</span><span>
</span><a name="line-1145"></a><a name="resolve_tvb_syns"><a href="Language.Haskell.TH.Datatype.html#resolve_tvb_syns"><span class="hs-identifier">resolve_tvb_syns</span></a></a><span> </span><a name="local-6989586621679053895"><a href="#local-6989586621679053895"><span class="hs-identifier">tvb</span></a></a><span class="hs-glyph">@</span><span class="hs-identifier hs-var">PlainTV</span><span class="hs-special">{</span><span class="hs-special">}</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><a href="#local-6989586621679053895"><span class="hs-identifier hs-var">tvb</span></a><span>
</span><a name="line-1146"></a><span class="hs-identifier">resolve_tvb_syns</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">KindedTV</span><span> </span><a name="local-6989586621679053896"><a href="#local-6989586621679053896"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679053897"><a href="#local-6989586621679053897"><span class="hs-identifier">k</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">KindedTV</span><span> </span><a href="#local-6989586621679053896"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var">resolveKindSynonyms</span></a><span> </span><a href="#local-6989586621679053897"><span class="hs-identifier hs-var">k</span></a><span>
</span><a name="line-1147"></a><span>
</span><a name="line-1148"></a><span class="hs-identifier">expandSynonymRHS</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-1149"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ Substitute these variables... -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1150"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span>      </span><span class="hs-comment">{- ^ ...with these types... -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1151"></a><span>  </span><span class="hs-identifier hs-type">Type</span><span>        </span><span class="hs-comment">{- ^ ...inside of this type. -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1152"></a><span>  </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-1153"></a><a name="expandSynonymRHS"><a href="Language.Haskell.TH.Datatype.html#expandSynonymRHS"><span class="hs-identifier">expandSynonymRHS</span></a></a><span> </span><a name="local-6989586621679053898"><a href="#local-6989586621679053898"><span class="hs-identifier">synvars</span></a></a><span> </span><a name="local-6989586621679053899"><a href="#local-6989586621679053899"><span class="hs-identifier">ts</span></a></a><span> </span><a name="local-6989586621679053900"><a href="#local-6989586621679053900"><span class="hs-identifier">def</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1154"></a><span>  </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679053901"><a href="#local-6989586621679053901"><span class="hs-identifier">argNames</span></a></a><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a><span> </span><a href="#local-6989586621679053898"><span class="hs-identifier hs-var">synvars</span></a><span>
</span><a name="line-1155"></a><span>      </span><span class="hs-special">(</span><a name="local-6989586621679053902"><a href="#local-6989586621679053902"><span class="hs-identifier">args</span></a></a><span class="hs-special">,</span><a name="local-6989586621679053903"><a href="#local-6989586621679053903"><span class="hs-identifier">rest</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">splitAt</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">length</span><span> </span><a href="#local-6989586621679053901"><span class="hs-identifier hs-var">argNames</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053899"><span class="hs-identifier hs-var">ts</span></a><span>
</span><a name="line-1156"></a><span>      </span><a name="local-6989586621679053904"><a href="#local-6989586621679053904"><span class="hs-identifier">subst</span></a></a><span>       </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Map.fromList</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">zip</span><span> </span><a href="#local-6989586621679053901"><span class="hs-identifier hs-var">argNames</span></a><span> </span><a href="#local-6989586621679053902"><span class="hs-identifier hs-var">args</span></a><span class="hs-special">)</span><span>
</span><a name="line-1157"></a><span>  </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier hs-var">foldl</span><span> </span><span class="hs-identifier hs-var">AppT</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679053904"><span class="hs-identifier hs-var">subst</span></a><span> </span><a href="#local-6989586621679053900"><span class="hs-identifier hs-var">def</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053903"><span class="hs-identifier hs-var">rest</span></a><span>
</span><a name="line-1158"></a><span>
</span><a name="line-1159"></a><span class="hs-comment">-- | Expand all of the type synonyms in a 'Pred'.</span><span>
</span><a name="line-1160"></a><span class="hs-identifier">resolvePredSynonyms</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Pred</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-identifier hs-type">Pred</span><span>
</span><a name="line-1161"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,10,0)
</span><a name="resolvePredSynonyms"><a href="Language.Haskell.TH.Datatype.html#resolvePredSynonyms"><span class="hs-identifier">resolvePredSynonyms</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a><span>
</span><a name="line-1163"></a><span class="hs-cpp">#else
</span><span class="hs-identifier">resolvePredSynonyms</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-1165"></a><span>  </span><span class="hs-identifier">mbInfo</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">reifyMaybe</span><span> </span><span class="hs-identifier">n</span><span>
</span><a name="line-1166"></a><span>  </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">mbInfo</span><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1167"></a><span>    </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">TyConI</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">TySynD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">synvars</span><span> </span><span class="hs-identifier">def</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-1168"></a><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">resolvePredSynonyms</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">typeToPred</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">expandSynonymRHS</span><span> </span><span class="hs-identifier">synvars</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">def</span><span>
</span><a name="line-1169"></a><span>    </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-operator">&lt;$&gt;</span><span> </span><span class="hs-identifier">mapM</span><span> </span><span class="hs-identifier">resolveTypeSynonyms</span><span> </span><span class="hs-identifier">ts</span><span>
</span><a name="line-1170"></a><span class="hs-identifier">resolvePredSynonyms</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-identifier">t2</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-1171"></a><span>  </span><span class="hs-identifier">t1'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">resolveTypeSynonyms</span><span> </span><span class="hs-identifier">t1</span><span>
</span><a name="line-1172"></a><span>  </span><span class="hs-identifier">t2'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">resolveTypeSynonyms</span><span> </span><span class="hs-identifier">t2</span><span>
</span><a name="line-1173"></a><span>  </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">t1'</span><span> </span><span class="hs-identifier">t2'</span><span class="hs-special">)</span><span>
</span><a name="line-1174"></a><span>
</span><a name="line-1175"></a><span class="hs-identifier">typeToPred</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Pred</span><span>
</span><a name="line-1176"></a><span class="hs-identifier">typeToPred</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1177"></a><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">f</span><span> </span><span class="hs-operator">:|</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">decomposeType</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-keyword">in</span><span>
</span><a name="line-1178"></a><span>  </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">f</span><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1179"></a><span>    </span><span class="hs-identifier">ConT</span><span> </span><span class="hs-identifier">n</span><span>
</span><a name="line-1180"></a><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">eqTypeName</span><span>
</span><a name="line-1181"></a><span class="hs-cpp"># if __GLASGOW_HASKELL__ == 704
</span><span>        </span><span class="hs-comment">-- There's an unfortunate bug in GHC 7.4 where the (~) type is reified</span><span>
</span><a name="line-1183"></a><span>        </span><span class="hs-comment">-- with an explicit kind argument. To work around this, we ignore it.</span><span>
</span><a name="line-1184"></a><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span class="hs-identifier">t1</span><span class="hs-special">,</span><span class="hs-identifier">t2</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">xs</span><span>
</span><a name="line-1185"></a><span class="hs-cpp"># else
</span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">t1</span><span class="hs-special">,</span><span class="hs-identifier">t2</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">xs</span><span>
</span><a name="line-1187"></a><span class="hs-cpp"># endif
</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-identifier">t2</span><span>
</span><a name="line-1189"></a><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">otherwise</span><span>
</span><a name="line-1190"></a><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">xs</span><span>
</span><a name="line-1191"></a><span>    </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">error</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-string">&quot;typeToPred: Can't handle type &quot;</span><span> </span><span class="hs-operator">++</span><span> </span><span class="hs-identifier">show</span><span> </span><span class="hs-identifier">t</span><span>
</span><a name="line-1192"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1194"></a><span class="hs-comment">-- | Decompose a type into a list of it's outermost applications. This process</span><span>
</span><a name="line-1195"></a><span class="hs-comment">-- forgets about infix application and explicit parentheses.</span><span>
</span><a name="line-1196"></a><span class="hs-comment">--</span><span>
</span><a name="line-1197"></a><span class="hs-comment">-- This operation should be used after all 'UInfixT' cases have been resolved</span><span>
</span><a name="line-1198"></a><span class="hs-comment">-- by 'resolveFixities' if the argument is being user generated.</span><span>
</span><a name="line-1199"></a><span class="hs-comment">--</span><span>
</span><a name="line-1200"></a><span class="hs-comment">-- &gt; t ~= foldl1 AppT (decomposeType t)</span><span>
</span><a name="line-1201"></a><span class="hs-identifier">decomposeType</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#NonEmpty"><span class="hs-identifier hs-type">NonEmpty</span></a><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-1202"></a><a name="decomposeType"><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier">decomposeType</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053905"><span class="hs-identifier hs-var">go</span></a><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><a name="line-1203"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-1204"></a><span>    </span><a name="local-6989586621679053905"><a href="#local-6989586621679053905"><span class="hs-identifier">go</span></a></a><span> </span><a name="local-6989586621679053906"><a href="#local-6989586621679053906"><span class="hs-identifier">args</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">AppT</span><span> </span><a name="local-6989586621679053907"><a href="#local-6989586621679053907"><span class="hs-identifier">f</span></a></a><span> </span><a name="local-6989586621679053908"><a href="#local-6989586621679053908"><span class="hs-identifier">x</span></a></a><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053905"><span class="hs-identifier hs-var">go</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053908"><span class="hs-identifier hs-var">x</span></a><span class="hs-glyph">:</span><a href="#local-6989586621679053906"><span class="hs-identifier hs-var">args</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053907"><span class="hs-identifier hs-var">f</span></a><span>
</span><a name="line-1205"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="hs-identifier">go</span><span> </span><a name="local-6989586621679053909"><a href="#local-6989586621679053909"><span class="hs-identifier">args</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">ParensT</span><span> </span><a name="local-6989586621679053910"><a href="#local-6989586621679053910"><span class="hs-identifier">t</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053905"><span class="hs-identifier hs-var">go</span></a><span> </span><a href="#local-6989586621679053909"><span class="hs-identifier hs-var">args</span></a><span> </span><a href="#local-6989586621679053910"><span class="hs-identifier hs-var">t</span></a><span>
</span><a name="line-1207"></a><span class="hs-cpp">#endif
</span><span>    </span><span class="hs-identifier">go</span><span> </span><a name="local-6989586621679053911"><a href="#local-6989586621679053911"><span class="hs-identifier">args</span></a></a><span> </span><a name="local-6989586621679053912"><a href="#local-6989586621679053912"><span class="hs-identifier">t</span></a></a><span>           </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053912"><span class="hs-identifier hs-var">t</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-var">:|</span></a><span> </span><a href="#local-6989586621679053911"><span class="hs-identifier hs-var">args</span></a><span>
</span><a name="line-1209"></a><span>
</span><a name="line-1210"></a><span class="hs-comment">-- 'NonEmpty' didn't move into base until recently. Reimplementing it locally</span><span>
</span><a name="line-1211"></a><span class="hs-comment">-- saves dependencies for supporting older GHCs</span><span>
</span><a name="line-1212"></a><span class="hs-keyword">data</span><span> </span><a name="NonEmpty"><a href="Language.Haskell.TH.Datatype.html#NonEmpty"><span class="hs-identifier">NonEmpty</span></a></a><span> </span><a name="local-6989586621679046221"><a href="#local-6989586621679046221"><span class="hs-identifier">a</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679046221"><span class="hs-identifier hs-type">a</span></a><span> </span><a name="%3A%7C"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator">:|</span></a></a><span> </span><span class="hs-special">[</span><a href="#local-6989586621679046221"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">]</span><span>
</span><a name="line-1213"></a><span>
</span><a name="line-1214"></a><span class="hs-keyword">data</span><span> </span><a name="NonEmptySnoc"><a href="Language.Haskell.TH.Datatype.html#NonEmptySnoc"><span class="hs-identifier">NonEmptySnoc</span></a></a><span> </span><a name="local-6989586621679046220"><a href="#local-6989586621679046220"><span class="hs-identifier">a</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679046220"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">]</span><span> </span><a name="%3A%7C-"><a href="Language.Haskell.TH.Datatype.html#%3A%7C-"><span class="hs-operator">:|-</span></a></a><span> </span><a href="#local-6989586621679046220"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-1215"></a><span>
</span><a name="line-1216"></a><span class="hs-comment">-- Decompose a function type into its context, argument types,</span><span>
</span><a name="line-1217"></a><span class="hs-comment">-- and return types. For instance, this</span><span>
</span><a name="line-1218"></a><span class="hs-comment">--</span><span>
</span><a name="line-1219"></a><span class="hs-comment">--   (Show a, b ~ Int) =&gt; (a -&gt; b) -&gt; Char -&gt; Int</span><span>
</span><a name="line-1220"></a><span class="hs-comment">--</span><span>
</span><a name="line-1221"></a><span class="hs-comment">-- becomes</span><span>
</span><a name="line-1222"></a><span class="hs-comment">--</span><span>
</span><a name="line-1223"></a><span class="hs-comment">--   ([Show a, b ~ Int], [a -&gt; b, Char] :|- Int)</span><span>
</span><a name="line-1224"></a><span class="hs-identifier">uncurryType</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Cxt</span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.TH.Datatype.html#NonEmptySnoc"><span class="hs-identifier hs-type">NonEmptySnoc</span></a><span> </span><span class="hs-identifier hs-type">Type</span><span class="hs-special">)</span><span>
</span><a name="line-1225"></a><a name="uncurryType"><a href="Language.Haskell.TH.Datatype.html#uncurryType"><span class="hs-identifier">uncurryType</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053913"><span class="hs-identifier hs-var">go</span></a><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><a name="line-1226"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-1227"></a><span>    </span><a name="local-6989586621679053913"><a href="#local-6989586621679053913"><span class="hs-identifier">go</span></a></a><span> </span><a name="local-6989586621679053914"><a href="#local-6989586621679053914"><span class="hs-identifier">ctxt</span></a></a><span> </span><a name="local-6989586621679053915"><a href="#local-6989586621679053915"><span class="hs-identifier">args</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">AppT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">AppT</span><span> </span><span class="hs-identifier hs-var">ArrowT</span><span> </span><a name="local-6989586621679053916"><a href="#local-6989586621679053916"><span class="hs-identifier">t1</span></a></a><span class="hs-special">)</span><span> </span><a name="local-6989586621679053917"><a href="#local-6989586621679053917"><span class="hs-identifier">t2</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053913"><span class="hs-identifier hs-var">go</span></a><span> </span><a href="#local-6989586621679053914"><span class="hs-identifier hs-var">ctxt</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053916"><span class="hs-identifier hs-var">t1</span></a><span class="hs-glyph">:</span><a href="#local-6989586621679053915"><span class="hs-identifier hs-var">args</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053917"><span class="hs-identifier hs-var">t2</span></a><span>
</span><a name="line-1228"></a><span>    </span><span class="hs-identifier">go</span><span> </span><a name="local-6989586621679053918"><a href="#local-6989586621679053918"><span class="hs-identifier">ctxt</span></a></a><span> </span><a name="local-6989586621679053919"><a href="#local-6989586621679053919"><span class="hs-identifier">args</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">ForallT</span><span> </span><span class="hs-identifier">_</span><span> </span><a name="local-6989586621679053920"><a href="#local-6989586621679053920"><span class="hs-identifier">ctxt'</span></a></a><span> </span><a name="local-6989586621679053921"><a href="#local-6989586621679053921"><span class="hs-identifier">t</span></a></a><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053913"><span class="hs-identifier hs-var">go</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053918"><span class="hs-identifier hs-var">ctxt</span></a><span class="hs-operator hs-var">++</span><a href="#local-6989586621679053920"><span class="hs-identifier hs-var">ctxt'</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053919"><span class="hs-identifier hs-var">args</span></a><span> </span><a href="#local-6989586621679053921"><span class="hs-identifier hs-var">t</span></a><span>
</span><a name="line-1229"></a><span>    </span><span class="hs-identifier">go</span><span> </span><a name="local-6989586621679053922"><a href="#local-6989586621679053922"><span class="hs-identifier">ctxt</span></a></a><span> </span><a name="local-6989586621679053923"><a href="#local-6989586621679053923"><span class="hs-identifier">args</span></a></a><span> </span><a name="local-6989586621679053924"><a href="#local-6989586621679053924"><span class="hs-identifier">t</span></a></a><span>                          </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053922"><span class="hs-identifier hs-var">ctxt</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">reverse</span><span> </span><a href="#local-6989586621679053923"><span class="hs-identifier hs-var">args</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#%3A%7C-"><span class="hs-operator hs-var">:|-</span></a><span> </span><a href="#local-6989586621679053924"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">)</span><span>
</span><a name="line-1230"></a><span>
</span><a name="line-1231"></a><span class="hs-comment">-- | Resolve any infix type application in a type using the fixities that</span><span>
</span><a name="line-1232"></a><span class="hs-comment">-- are currently available. Starting in `template-haskell-2.11` types could</span><span>
</span><a name="line-1233"></a><span class="hs-comment">-- contain unresolved infix applications.</span><span>
</span><a name="line-1234"></a><span class="hs-identifier">resolveInfixT</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-1235"></a><span>
</span><a name="line-1236"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><a name="resolveInfixT"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier">resolveInfixT</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">ForallT</span><span> </span><a name="local-6989586621679053925"><a href="#local-6989586621679053925"><span class="hs-identifier">vs</span></a></a><span> </span><a name="local-6989586621679053926"><a href="#local-6989586621679053926"><span class="hs-identifier">cx</span></a></a><span> </span><a name="local-6989586621679053927"><a href="#local-6989586621679053927"><span class="hs-identifier">t</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">forallT</span><span> </span><a href="#local-6989586621679053925"><span class="hs-identifier hs-var">vs</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">mapM</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a><span> </span><a href="#local-6989586621679053926"><span class="hs-identifier hs-var">cx</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a><span> </span><a href="#local-6989586621679053927"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">)</span><span>
</span><a name="line-1238"></a><span class="hs-identifier">resolveInfixT</span><span> </span><span class="hs-special">(</span><a name="local-6989586621679053928"><a href="#local-6989586621679053928"><span class="hs-identifier">f</span></a></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">AppT</span><span class="hs-special">`</span><span> </span><a name="local-6989586621679053929"><a href="#local-6989586621679053929"><span class="hs-identifier">x</span></a></a><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a><span> </span><a href="#local-6989586621679053928"><span class="hs-identifier hs-var">f</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">appT</span><span class="hs-special">`</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a><span> </span><a href="#local-6989586621679053929"><span class="hs-identifier hs-var">x</span></a><span>
</span><a name="line-1239"></a><span class="hs-identifier">resolveInfixT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">ParensT</span><span> </span><a name="local-6989586621679053930"><a href="#local-6989586621679053930"><span class="hs-identifier">t</span></a></a><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a><span> </span><a href="#local-6989586621679053930"><span class="hs-identifier hs-var">t</span></a><span>
</span><a name="line-1240"></a><span class="hs-identifier">resolveInfixT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">InfixT</span><span> </span><a name="local-6989586621679053931"><a href="#local-6989586621679053931"><span class="hs-identifier">l</span></a></a><span> </span><a name="local-6989586621679053932"><a href="#local-6989586621679053932"><span class="hs-identifier">o</span></a></a><span> </span><a name="local-6989586621679053933"><a href="#local-6989586621679053933"><span class="hs-identifier">r</span></a></a><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">conT</span><span> </span><a href="#local-6989586621679053932"><span class="hs-identifier hs-var">o</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">appT</span><span class="hs-special">`</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a><span> </span><a href="#local-6989586621679053931"><span class="hs-identifier hs-var">l</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">appT</span><span class="hs-special">`</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a><span> </span><a href="#local-6989586621679053933"><span class="hs-identifier hs-var">r</span></a><span>
</span><a name="line-1241"></a><span class="hs-identifier">resolveInfixT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">SigT</span><span> </span><a name="local-6989586621679053934"><a href="#local-6989586621679053934"><span class="hs-identifier">t</span></a></a><span> </span><a name="local-6989586621679053935"><a href="#local-6989586621679053935"><span class="hs-identifier">k</span></a></a><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">SigT</span><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a><span> </span><a href="#local-6989586621679053934"><span class="hs-identifier hs-var">t</span></a><span> </span><span class="hs-operator hs-var">&lt;*&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a><span> </span><a href="#local-6989586621679053935"><span class="hs-identifier hs-var">k</span></a><span>
</span><a name="line-1242"></a><span class="hs-identifier">resolveInfixT</span><span> </span><a name="local-6989586621679053936"><a href="#local-6989586621679053936"><span class="hs-identifier">t</span></a></a><span class="hs-glyph">@</span><span class="hs-identifier hs-var">UInfixT</span><span class="hs-special">{</span><span class="hs-special">}</span><span>       </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a><span> </span><span class="hs-operator hs-var">=&lt;&lt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT1"><span class="hs-identifier hs-var">resolveInfixT1</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a><span> </span><a href="#local-6989586621679053936"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">)</span><span>
</span><a name="line-1243"></a><span class="hs-identifier">resolveInfixT</span><span> </span><a name="local-6989586621679053937"><a href="#local-6989586621679053937"><span class="hs-identifier">t</span></a></a><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><a href="#local-6989586621679053937"><span class="hs-identifier hs-var">t</span></a><span>
</span><a name="line-1244"></a><span>
</span><a name="line-1245"></a><span class="hs-identifier">gatherUInfixT</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a><span>
</span><a name="line-1246"></a><a name="gatherUInfixT"><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier">gatherUInfixT</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">UInfixT</span><span> </span><a name="local-6989586621679053938"><a href="#local-6989586621679053938"><span class="hs-identifier">l</span></a></a><span> </span><a name="local-6989586621679053939"><a href="#local-6989586621679053939"><span class="hs-identifier">o</span></a></a><span> </span><a name="local-6989586621679053940"><a href="#local-6989586621679053940"><span class="hs-identifier">r</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ilAppend"><span class="hs-identifier hs-var">ilAppend</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a><span> </span><a href="#local-6989586621679053938"><span class="hs-identifier hs-var">l</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053939"><span class="hs-identifier hs-var">o</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a><span> </span><a href="#local-6989586621679053940"><span class="hs-identifier hs-var">r</span></a><span class="hs-special">)</span><span>
</span><a name="line-1247"></a><span class="hs-identifier">gatherUInfixT</span><span> </span><a name="local-6989586621679053941"><a href="#local-6989586621679053941"><span class="hs-identifier">t</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ILNil"><span class="hs-identifier hs-var">ILNil</span></a><span> </span><a href="#local-6989586621679053941"><span class="hs-identifier hs-var">t</span></a><span>
</span><a name="line-1248"></a><span>
</span><a name="line-1249"></a><span class="hs-comment">-- This can fail due to incompatible fixities</span><span>
</span><a name="line-1250"></a><span class="hs-identifier">resolveInfixT1</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TypeQ</span><span>
</span><a name="line-1251"></a><a name="resolveInfixT1"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT1"><span class="hs-identifier">resolveInfixT1</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053942"><span class="hs-identifier hs-var">go</span></a><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><a name="line-1252"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-1253"></a><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Name</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Fixity</span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TypeQ</span><span>
</span><a name="line-1254"></a><span>    </span><a name="local-6989586621679053942"><a href="#local-6989586621679053942"><span class="hs-identifier">go</span></a></a><span> </span><a name="local-6989586621679053945"><a href="#local-6989586621679053945"><span class="hs-identifier">ts</span></a></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#ILNil"><span class="hs-identifier hs-var">ILNil</span></a><span> </span><a name="local-6989586621679053946"><a href="#local-6989586621679053946"><span class="hs-identifier">u</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">foldl</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><a name="local-6989586621679053947"><a href="#local-6989586621679053947"><span class="hs-identifier">acc</span></a></a><span> </span><span class="hs-special">(</span><a name="local-6989586621679053948"><a href="#local-6989586621679053948"><span class="hs-identifier">l</span></a></a><span class="hs-special">,</span><a name="local-6989586621679053949"><a href="#local-6989586621679053949"><span class="hs-identifier">o</span></a></a><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">ConT</span><span> </span><a href="#local-6989586621679053949"><span class="hs-identifier hs-var">o</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">AppT</span><span class="hs-special">`</span><span> </span><a href="#local-6989586621679053948"><span class="hs-identifier hs-var">l</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">AppT</span><span class="hs-special">`</span><span> </span><a href="#local-6989586621679053947"><span class="hs-identifier hs-var">acc</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053946"><span class="hs-identifier hs-var">u</span></a><span> </span><a href="#local-6989586621679053945"><span class="hs-identifier hs-var">ts</span></a><span class="hs-special">)</span><span>
</span><a name="line-1255"></a><span>    </span><span class="hs-identifier">go</span><span> </span><a name="local-6989586621679053950"><a href="#local-6989586621679053950"><span class="hs-identifier">ts</span></a></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier hs-var">ILCons</span></a><span> </span><a name="local-6989586621679053951"><a href="#local-6989586621679053951"><span class="hs-identifier">l</span></a></a><span> </span><a name="local-6989586621679053952"><a href="#local-6989586621679053952"><span class="hs-identifier">o</span></a></a><span> </span><a name="local-6989586621679053953"><a href="#local-6989586621679053953"><span class="hs-identifier">r</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1256"></a><span>      </span><span class="hs-keyword">do</span><span> </span><a name="local-6989586621679053954"><a href="#local-6989586621679053954"><span class="hs-identifier">ofx</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">fromMaybe</span><span> </span><span class="hs-identifier hs-var">defaultFixity</span><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#reifyFixityCompat"><span class="hs-identifier hs-var">reifyFixityCompat</span></a><span> </span><a href="#local-6989586621679053952"><span class="hs-identifier hs-var">o</span></a><span>
</span><a name="line-1257"></a><span>         </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679053955"><a href="#local-6989586621679053955"><span class="hs-identifier">push</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053942"><span class="hs-identifier hs-var">go</span></a><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><a href="#local-6989586621679053951"><span class="hs-identifier hs-var">l</span></a><span class="hs-special">,</span><a href="#local-6989586621679053952"><span class="hs-identifier hs-var">o</span></a><span class="hs-special">,</span><a href="#local-6989586621679053954"><span class="hs-identifier hs-var">ofx</span></a><span class="hs-special">)</span><span class="hs-glyph">:</span><a href="#local-6989586621679053950"><span class="hs-identifier hs-var">ts</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053953"><span class="hs-identifier hs-var">r</span></a><span>
</span><a name="line-1258"></a><span>         </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679053950"><span class="hs-identifier hs-var">ts</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1259"></a><span>           </span><span class="hs-special">(</span><a name="local-6989586621679053956"><a href="#local-6989586621679053956"><span class="hs-identifier">l1</span></a></a><span class="hs-special">,</span><a name="local-6989586621679053957"><a href="#local-6989586621679053957"><span class="hs-identifier">o1</span></a></a><span class="hs-special">,</span><a name="local-6989586621679053958"><a href="#local-6989586621679053958"><span class="hs-identifier">o1fx</span></a></a><span class="hs-special">)</span><span class="hs-glyph">:</span><a name="local-6989586621679053959"><a href="#local-6989586621679053959"><span class="hs-identifier">ts'</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1260"></a><span>             </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679053943"><span class="hs-identifier hs-var">compareFixity</span></a><span> </span><a href="#local-6989586621679053958"><span class="hs-identifier hs-var">o1fx</span></a><span> </span><a href="#local-6989586621679053954"><span class="hs-identifier hs-var">ofx</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1261"></a><span>               </span><span class="hs-identifier hs-var">Just</span><span> </span><span class="hs-identifier hs-var">True</span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053942"><span class="hs-identifier hs-var">go</span></a><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-identifier hs-var">ConT</span><span> </span><a href="#local-6989586621679053957"><span class="hs-identifier hs-var">o1</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">AppT</span><span class="hs-special">`</span><span> </span><a href="#local-6989586621679053956"><span class="hs-identifier hs-var">l1</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">AppT</span><span class="hs-special">`</span><span> </span><a href="#local-6989586621679053951"><span class="hs-identifier hs-var">l</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679053952"><span class="hs-identifier hs-var">o</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679053954"><span class="hs-identifier hs-var">ofx</span></a><span class="hs-special">)</span><span class="hs-glyph">:</span><a href="#local-6989586621679053959"><span class="hs-identifier hs-var">ts'</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053953"><span class="hs-identifier hs-var">r</span></a><span>
</span><a name="line-1262"></a><span>               </span><span class="hs-identifier hs-var">Just</span><span> </span><span class="hs-identifier hs-var">False</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053955"><span class="hs-identifier hs-var">push</span></a><span>
</span><a name="line-1263"></a><span>               </span><span class="hs-identifier hs-var">Nothing</span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">fail</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053944"><span class="hs-identifier hs-var">precedenceError</span></a><span> </span><a href="#local-6989586621679053957"><span class="hs-identifier hs-var">o1</span></a><span> </span><a href="#local-6989586621679053958"><span class="hs-identifier hs-var">o1fx</span></a><span> </span><a href="#local-6989586621679053952"><span class="hs-identifier hs-var">o</span></a><span> </span><a href="#local-6989586621679053954"><span class="hs-identifier hs-var">ofx</span></a><span class="hs-special">)</span><span>
</span><a name="line-1264"></a><span>           </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053955"><span class="hs-identifier hs-var">push</span></a><span>
</span><a name="line-1265"></a><span>
</span><a name="line-1266"></a><span>    </span><span class="hs-identifier">compareFixity</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Fixity</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Fixity</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-identifier hs-type">Bool</span><span>
</span><a name="line-1267"></a><span>    </span><a name="local-6989586621679053943"><a href="#local-6989586621679053943"><span class="hs-identifier">compareFixity</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Fixity</span><span> </span><a name="local-6989586621679053960"><a href="#local-6989586621679053960"><span class="hs-identifier">n1</span></a></a><span> </span><span class="hs-identifier hs-var">InfixL</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Fixity</span><span> </span><a name="local-6989586621679053961"><a href="#local-6989586621679053961"><span class="hs-identifier">n2</span></a></a><span> </span><span class="hs-identifier hs-var">InfixL</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Just</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053960"><span class="hs-identifier hs-var">n1</span></a><span> </span><span class="hs-operator hs-var">&gt;=</span><span> </span><a href="#local-6989586621679053961"><span class="hs-identifier hs-var">n2</span></a><span class="hs-special">)</span><span>
</span><a name="line-1268"></a><span>    </span><span class="hs-identifier">compareFixity</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Fixity</span><span> </span><a name="local-6989586621679053962"><a href="#local-6989586621679053962"><span class="hs-identifier">n1</span></a></a><span> </span><span class="hs-identifier hs-var">InfixR</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Fixity</span><span> </span><a name="local-6989586621679053963"><a href="#local-6989586621679053963"><span class="hs-identifier">n2</span></a></a><span> </span><span class="hs-identifier hs-var">InfixR</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Just</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053962"><span class="hs-identifier hs-var">n1</span></a><span> </span><span class="hs-operator hs-var">&gt;</span><span>  </span><a href="#local-6989586621679053963"><span class="hs-identifier hs-var">n2</span></a><span class="hs-special">)</span><span>
</span><a name="line-1269"></a><span>    </span><span class="hs-identifier">compareFixity</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Fixity</span><span> </span><a name="local-6989586621679053964"><a href="#local-6989586621679053964"><span class="hs-identifier">n1</span></a></a><span> </span><span class="hs-identifier">_</span><span>     </span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Fixity</span><span> </span><a name="local-6989586621679053965"><a href="#local-6989586621679053965"><span class="hs-identifier">n2</span></a></a><span> </span><span class="hs-identifier">_</span><span>     </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1270"></a><span>      </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier hs-var">compare</span><span> </span><a href="#local-6989586621679053964"><span class="hs-identifier hs-var">n1</span></a><span> </span><a href="#local-6989586621679053965"><span class="hs-identifier hs-var">n2</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1271"></a><span>        </span><span class="hs-identifier hs-var">GT</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">Just</span><span> </span><span class="hs-identifier hs-var">True</span><span>
</span><a name="line-1272"></a><span>        </span><span class="hs-identifier hs-var">LT</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">Just</span><span> </span><span class="hs-identifier hs-var">False</span><span>
</span><a name="line-1273"></a><span>        </span><span class="hs-identifier hs-var">EQ</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">Nothing</span><span>
</span><a name="line-1274"></a><span>
</span><a name="line-1275"></a><span>    </span><span class="hs-identifier">precedenceError</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Fixity</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Fixity</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span>
</span><a name="line-1276"></a><span>    </span><a name="local-6989586621679053944"><a href="#local-6989586621679053944"><span class="hs-identifier">precedenceError</span></a></a><span> </span><a name="local-6989586621679053966"><a href="#local-6989586621679053966"><span class="hs-identifier">o1</span></a></a><span> </span><a name="local-6989586621679053967"><a href="#local-6989586621679053967"><span class="hs-identifier">ofx1</span></a></a><span> </span><a name="local-6989586621679053968"><a href="#local-6989586621679053968"><span class="hs-identifier">o2</span></a></a><span> </span><a name="local-6989586621679053969"><a href="#local-6989586621679053969"><span class="hs-identifier">ofx2</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1277"></a><span>      </span><span class="hs-string">&quot;Precedence parsing error: cannot mix &#8216;&quot;</span><span> </span><span class="hs-operator hs-var">++</span><span>
</span><a name="line-1278"></a><span>      </span><span class="hs-identifier hs-var">nameBase</span><span> </span><a href="#local-6989586621679053966"><span class="hs-identifier hs-var">o1</span></a><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-string">&quot;&#8217; [&quot;</span><span> </span><span class="hs-operator hs-var">++</span><span> </span><a href="Language.Haskell.TH.Datatype.html#showFixity"><span class="hs-identifier hs-var">showFixity</span></a><span> </span><a href="#local-6989586621679053967"><span class="hs-identifier hs-var">ofx1</span></a><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-string">&quot;] and &#8216;&quot;</span><span> </span><span class="hs-operator hs-var">++</span><span>
</span><a name="line-1279"></a><span>      </span><span class="hs-identifier hs-var">nameBase</span><span> </span><a href="#local-6989586621679053968"><span class="hs-identifier hs-var">o2</span></a><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-string">&quot;&#8217; [&quot;</span><span> </span><span class="hs-operator hs-var">++</span><span> </span><a href="Language.Haskell.TH.Datatype.html#showFixity"><span class="hs-identifier hs-var">showFixity</span></a><span> </span><a href="#local-6989586621679053969"><span class="hs-identifier hs-var">ofx2</span></a><span> </span><span class="hs-operator hs-var">++</span><span>
</span><a name="line-1280"></a><span>      </span><span class="hs-string">&quot;] in the same infix type expression&quot;</span><span>
</span><a name="line-1281"></a><span>
</span><a name="line-1282"></a><span class="hs-keyword">data</span><span> </span><a name="InfixList"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier">InfixList</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="ILCons"><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier">ILCons</span></a></a><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a><span> </span><span class="hs-glyph">|</span><span> </span><a name="ILNil"><a href="Language.Haskell.TH.Datatype.html#ILNil"><span class="hs-identifier">ILNil</span></a></a><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-1283"></a><span>
</span><a name="line-1284"></a><span class="hs-identifier">ilAppend</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a><span>
</span><a name="line-1285"></a><a name="ilAppend"><a href="Language.Haskell.TH.Datatype.html#ilAppend"><span class="hs-identifier">ilAppend</span></a></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#ILNil"><span class="hs-identifier hs-var">ILNil</span></a><span> </span><a name="local-6989586621679053970"><a href="#local-6989586621679053970"><span class="hs-identifier">l</span></a></a><span class="hs-special">)</span><span>         </span><a name="local-6989586621679053971"><a href="#local-6989586621679053971"><span class="hs-identifier">o</span></a></a><span> </span><a name="local-6989586621679053972"><a href="#local-6989586621679053972"><span class="hs-identifier">r</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier hs-var">ILCons</span></a><span> </span><a href="#local-6989586621679053970"><span class="hs-identifier hs-var">l</span></a><span> </span><a href="#local-6989586621679053971"><span class="hs-identifier hs-var">o</span></a><span> </span><a href="#local-6989586621679053972"><span class="hs-identifier hs-var">r</span></a><span>
</span><a name="line-1286"></a><span class="hs-identifier">ilAppend</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier hs-var">ILCons</span></a><span> </span><a name="local-6989586621679053973"><a href="#local-6989586621679053973"><span class="hs-identifier">l1</span></a></a><span> </span><a name="local-6989586621679053974"><a href="#local-6989586621679053974"><span class="hs-identifier">o1</span></a></a><span> </span><a name="local-6989586621679053975"><a href="#local-6989586621679053975"><span class="hs-identifier">r1</span></a></a><span class="hs-special">)</span><span> </span><a name="local-6989586621679053976"><a href="#local-6989586621679053976"><span class="hs-identifier">o</span></a></a><span> </span><a name="local-6989586621679053977"><a href="#local-6989586621679053977"><span class="hs-identifier">r</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier hs-var">ILCons</span></a><span> </span><a href="#local-6989586621679053973"><span class="hs-identifier hs-var">l1</span></a><span> </span><a href="#local-6989586621679053974"><span class="hs-identifier hs-var">o1</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#ilAppend"><span class="hs-identifier hs-var">ilAppend</span></a><span> </span><a href="#local-6989586621679053975"><span class="hs-identifier hs-var">r1</span></a><span> </span><a href="#local-6989586621679053976"><span class="hs-identifier hs-var">o</span></a><span> </span><a href="#local-6989586621679053977"><span class="hs-identifier hs-var">r</span></a><span class="hs-special">)</span><span>
</span><a name="line-1287"></a><span>
</span><a name="line-1288"></a><span class="hs-cpp">#else
</span><span class="hs-comment">-- older template-haskell packages don't have UInfixT</span><span>
</span><a name="line-1290"></a><span class="hs-identifier">resolveInfixT</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">return</span><span>
</span><a name="line-1291"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1293"></a><span>
</span><a name="line-1294"></a><span class="hs-comment">-- | Render a 'Fixity' as it would appear in Haskell source.</span><span>
</span><a name="line-1295"></a><span class="hs-comment">--</span><span>
</span><a name="line-1296"></a><span class="hs-comment">-- Example: @infixl 5@</span><span>
</span><a name="line-1297"></a><span class="hs-identifier">showFixity</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Fixity</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span>
</span><a name="line-1298"></a><a name="showFixity"><a href="Language.Haskell.TH.Datatype.html#showFixity"><span class="hs-identifier">showFixity</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Fixity</span><span> </span><a name="local-6989586621679053978"><a href="#local-6989586621679053978"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679053979"><a href="#local-6989586621679053979"><span class="hs-identifier">d</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier hs-var">showFixityDirection</span></a><span> </span><a href="#local-6989586621679053979"><span class="hs-identifier hs-var">d</span></a><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-string">&quot; &quot;</span><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-identifier hs-var">show</span><span> </span><a href="#local-6989586621679053978"><span class="hs-identifier hs-var">n</span></a><span>
</span><a name="line-1299"></a><span>
</span><a name="line-1300"></a><span>
</span><a name="line-1301"></a><span class="hs-comment">-- | Render a 'FixityDirection' like it would appear in Haskell source.</span><span>
</span><a name="line-1302"></a><span class="hs-comment">--</span><span>
</span><a name="line-1303"></a><span class="hs-comment">-- Examples: @infixl@ @infixr@ @infix@</span><span>
</span><a name="line-1304"></a><span class="hs-identifier">showFixityDirection</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">FixityDirection</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span>
</span><a name="line-1305"></a><a name="showFixityDirection"><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier">showFixityDirection</span></a></a><span> </span><span class="hs-identifier hs-var">InfixL</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-string">&quot;infixl&quot;</span><span>
</span><a name="line-1306"></a><span class="hs-identifier">showFixityDirection</span><span> </span><span class="hs-identifier hs-var">InfixR</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-string">&quot;infixr&quot;</span><span>
</span><a name="line-1307"></a><span class="hs-identifier">showFixityDirection</span><span> </span><span class="hs-identifier hs-var">InfixN</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-string">&quot;infix&quot;</span><span>
</span><a name="line-1308"></a><span>
</span><a name="line-1309"></a><span>
</span><a name="line-1310"></a><span class="hs-comment">-- | Extract the type variable name from a 'TyVarBndr' ignoring the</span><span>
</span><a name="line-1311"></a><span class="hs-comment">-- kind signature if one exists.</span><span>
</span><a name="line-1312"></a><span class="hs-identifier">tvName</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">TyVarBndr</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Name</span><span>
</span><a name="line-1313"></a><a name="tvName"><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier">tvName</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">PlainTV</span><span>  </span><a name="local-6989586621679053980"><a href="#local-6989586621679053980"><span class="hs-identifier">name</span></a></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053980"><span class="hs-identifier hs-var">name</span></a><span>
</span><a name="line-1314"></a><span class="hs-identifier">tvName</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">KindedTV</span><span> </span><a name="local-6989586621679053981"><a href="#local-6989586621679053981"><span class="hs-identifier">name</span></a></a><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053981"><span class="hs-identifier hs-var">name</span></a><span>
</span><a name="line-1315"></a><span>
</span><a name="line-1316"></a><span class="hs-identifier">takeFieldNames</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="hs-identifier hs-type">Name</span><span class="hs-special">,</span><a href="#local-6989586621679053416"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">,</span><a href="#local-6989586621679053417"><span class="hs-identifier hs-type">b</span></a><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Name</span><span class="hs-special">]</span><span>
</span><a name="line-1317"></a><a name="takeFieldNames"><a href="Language.Haskell.TH.Datatype.html#takeFieldNames"><span class="hs-identifier">takeFieldNames</span></a></a><span> </span><a name="local-6989586621679053982"><a href="#local-6989586621679053982"><span class="hs-identifier">xs</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679053983"><span class="hs-identifier hs-var">a</span></a><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><a name="local-6989586621679053983"><a href="#local-6989586621679053983"><span class="hs-identifier">a</span></a></a><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="#local-6989586621679053982"><span class="hs-identifier hs-var">xs</span></a><span class="hs-special">]</span><span>
</span><a name="line-1318"></a><span>
</span><a name="line-1319"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><span class="hs-identifier">takeFieldStrictness</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><a href="#local-6989586621679053414"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">,</span><span class="hs-identifier hs-type">Bang</span><span class="hs-special">,</span><a href="#local-6989586621679053415"><span class="hs-identifier hs-type">b</span></a><span class="hs-special">)</span><span class="hs-special">]</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a><span class="hs-special">]</span><span>
</span><a name="line-1321"></a><span class="hs-cpp">#else
</span><span class="hs-identifier">takeFieldStrictness</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="hs-identifier">a</span><span class="hs-special">,</span><span class="hs-identifier">Strict</span><span class="hs-special">,</span><span class="hs-identifier">b</span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">FieldStrictness</span><span class="hs-special">]</span><span>
</span><a name="line-1323"></a><span class="hs-cpp">#endif
</span><a name="takeFieldStrictness"><a href="Language.Haskell.TH.Datatype.html#takeFieldStrictness"><span class="hs-identifier">takeFieldStrictness</span></a></a><span> </span><a name="local-6989586621679053984"><a href="#local-6989586621679053984"><span class="hs-identifier">xs</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-var">normalizeStrictness</span></a><span> </span><a href="#local-6989586621679053985"><span class="hs-identifier hs-var">a</span></a><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><a name="local-6989586621679053985"><a href="#local-6989586621679053985"><span class="hs-identifier">a</span></a></a><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="#local-6989586621679053984"><span class="hs-identifier hs-var">xs</span></a><span class="hs-special">]</span><span>
</span><a name="line-1325"></a><span>
</span><a name="line-1326"></a><span class="hs-identifier">takeFieldTypes</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><a href="#local-6989586621679053412"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">,</span><a href="#local-6989586621679053413"><span class="hs-identifier hs-type">b</span></a><span class="hs-special">,</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span>
</span><a name="line-1327"></a><a name="takeFieldTypes"><a href="Language.Haskell.TH.Datatype.html#takeFieldTypes"><span class="hs-identifier">takeFieldTypes</span></a></a><span> </span><a name="local-6989586621679053986"><a href="#local-6989586621679053986"><span class="hs-identifier">xs</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679053987"><span class="hs-identifier hs-var">a</span></a><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">,</span><a name="local-6989586621679053987"><a href="#local-6989586621679053987"><span class="hs-identifier">a</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="#local-6989586621679053986"><span class="hs-identifier hs-var">xs</span></a><span class="hs-special">]</span><span>
</span><a name="line-1328"></a><span>
</span><a name="line-1329"></a><span class="hs-identifier">conHasRecord</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Bool</span><span>
</span><a name="line-1330"></a><a name="conHasRecord"><a href="Language.Haskell.TH.Datatype.html#conHasRecord"><span class="hs-identifier">conHasRecord</span></a></a><span> </span><a name="local-6989586621679053988"><a href="#local-6989586621679053988"><span class="hs-identifier">recName</span></a></a><span> </span><a name="local-6989586621679053989"><a href="#local-6989586621679053989"><span class="hs-identifier">info</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1331"></a><span>  </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">constructorVariant</span><span> </span><a href="#local-6989586621679053989"><span class="hs-identifier hs-var">info</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1332"></a><span>    </span><a href="Language.Haskell.TH.Datatype.html#NormalConstructor"><span class="hs-identifier hs-var">NormalConstructor</span></a><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">False</span><span>
</span><a name="line-1333"></a><span>    </span><a href="Language.Haskell.TH.Datatype.html#InfixConstructor"><span class="hs-identifier hs-var">InfixConstructor</span></a><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">False</span><span>
</span><a name="line-1334"></a><span>    </span><a href="Language.Haskell.TH.Datatype.html#RecordConstructor"><span class="hs-identifier hs-var">RecordConstructor</span></a><span> </span><a name="local-6989586621679053990"><a href="#local-6989586621679053990"><span class="hs-identifier">fields</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679053988"><span class="hs-identifier hs-var">recName</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">elem</span><span class="hs-special">`</span><span> </span><a href="#local-6989586621679053990"><span class="hs-identifier hs-var">fields</span></a><span>
</span><a name="line-1335"></a><span>
</span><a name="line-1336"></a><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><a name="line-1337"></a><span>
</span><a name="line-1338"></a><span class="hs-comment">-- | Add universal quantifier for all free variables in the type. This is</span><span>
</span><a name="line-1339"></a><span class="hs-comment">-- useful when constructing a type signature for a declaration.</span><span>
</span><a name="line-1340"></a><span class="hs-comment">-- This code is careful to ensure that the order of the variables quantified</span><span>
</span><a name="line-1341"></a><span class="hs-comment">-- is determined by their order of appearance in the type signature. (In</span><span>
</span><a name="line-1342"></a><span class="hs-comment">-- contrast with being dependent upon the Ord instance for 'Name')</span><span>
</span><a name="line-1343"></a><span class="hs-identifier">quantifyType</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-1344"></a><a name="quantifyType"><a href="Language.Haskell.TH.Datatype.html#quantifyType"><span class="hs-identifier">quantifyType</span></a></a><span> </span><a name="local-6989586621679053991"><a href="#local-6989586621679053991"><span class="hs-identifier">t</span></a></a><span>
</span><a name="line-1345"></a><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">null</span><span> </span><a href="#local-6989586621679053992"><span class="hs-identifier hs-var">tvbs</span></a><span>
</span><a name="line-1346"></a><span>  </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679053991"><span class="hs-identifier hs-var">t</span></a><span>
</span><a name="line-1347"></a><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">ForallT</span><span> </span><a name="local-6989586621679053993"><a href="#local-6989586621679053993"><span class="hs-identifier">tvbs'</span></a></a><span> </span><a name="local-6989586621679053994"><a href="#local-6989586621679053994"><span class="hs-identifier">ctxt'</span></a></a><span> </span><a name="local-6989586621679053995"><a href="#local-6989586621679053995"><span class="hs-identifier">t'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="#local-6989586621679053991"><span class="hs-identifier hs-var">t</span></a><span> </span><span class="hs-comment">-- Collapse two consecutive foralls (#63)</span><span>
</span><a name="line-1348"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">ForallT</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679053992"><span class="hs-identifier hs-var">tvbs</span></a><span> </span><span class="hs-operator hs-var">++</span><span> </span><a href="#local-6989586621679053993"><span class="hs-identifier hs-var">tvbs'</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679053994"><span class="hs-identifier hs-var">ctxt'</span></a><span> </span><a href="#local-6989586621679053995"><span class="hs-identifier hs-var">t'</span></a><span>
</span><a name="line-1349"></a><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">otherwise</span><span>
</span><a name="line-1350"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">ForallT</span><span> </span><a href="#local-6989586621679053992"><span class="hs-identifier hs-var">tvbs</span></a><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><a href="#local-6989586621679053991"><span class="hs-identifier hs-var">t</span></a><span>
</span><a name="line-1351"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-1352"></a><span>    </span><a name="local-6989586621679053992"><a href="#local-6989586621679053992"><span class="hs-identifier">tvbs</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier hs-var">freeVariablesWellScoped</span></a><span> </span><span class="hs-special">[</span><a href="#local-6989586621679053991"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">]</span><span>
</span><a name="line-1353"></a><span>
</span><a name="line-1354"></a><span class="hs-comment">-- | Take a list of 'Type's, find their free variables, and sort them</span><span>
</span><a name="line-1355"></a><span class="hs-comment">-- according to dependency order.</span><span>
</span><a name="line-1356"></a><span class="hs-comment">--</span><span>
</span><a name="line-1357"></a><span class="hs-comment">-- As an example of how this function works, consider the following type:</span><span>
</span><a name="line-1358"></a><span class="hs-comment">--</span><span>
</span><a name="line-1359"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-1360"></a><span class="hs-comment">-- Proxy (a :: k)</span><span>
</span><a name="line-1361"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-1362"></a><span class="hs-comment">--</span><span>
</span><a name="line-1363"></a><span class="hs-comment">-- Calling 'freeVariables' on this type would yield @[a, k]@, since that is</span><span>
</span><a name="line-1364"></a><span class="hs-comment">-- the order in which those variables appear in a left-to-right fashion. But</span><span>
</span><a name="line-1365"></a><span class="hs-comment">-- this order does not preserve the fact that @k@ is the kind of @a@. Moreover,</span><span>
</span><a name="line-1366"></a><span class="hs-comment">-- if you tried writing the type @forall a k. Proxy (a :: k)@, GHC would reject</span><span>
</span><a name="line-1367"></a><span class="hs-comment">-- this, since GHC would demand that @k@ come before @a@.</span><span>
</span><a name="line-1368"></a><span class="hs-comment">--</span><span>
</span><a name="line-1369"></a><span class="hs-comment">-- 'freeVariablesWellScoped' orders the free variables of a type in a way that</span><span>
</span><a name="line-1370"></a><span class="hs-comment">-- preserves this dependency ordering. If one were to call</span><span>
</span><a name="line-1371"></a><span class="hs-comment">-- 'freeVariablesWellScoped' on the type above, it would return</span><span>
</span><a name="line-1372"></a><span class="hs-comment">-- @[k, (a :: k)]@. (This is why 'freeVariablesWellScoped' returns a list of</span><span>
</span><a name="line-1373"></a><span class="hs-comment">-- 'TyVarBndr's instead of 'Name's, since it must make it explicit that @k@</span><span>
</span><a name="line-1374"></a><span class="hs-comment">-- is the kind of @a@.)</span><span>
</span><a name="line-1375"></a><span class="hs-comment">--</span><span>
</span><a name="line-1376"></a><span class="hs-comment">-- On older GHCs, this takes measures to avoid returning explicitly bound</span><span>
</span><a name="line-1377"></a><span class="hs-comment">-- kind variables, which was not possible before @TypeInType@.</span><span>
</span><a name="line-1378"></a><span class="hs-identifier">freeVariablesWellScoped</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span>
</span><a name="line-1379"></a><a name="freeVariablesWellScoped"><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier">freeVariablesWellScoped</span></a></a><span> </span><a name="local-6989586621679053996"><a href="#local-6989586621679053996"><span class="hs-identifier">tys</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1380"></a><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">fvs</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Name</span><span class="hs-special">]</span><span>
</span><a name="line-1381"></a><span>      </span><a name="local-6989586621679053997"><a href="#local-6989586621679053997"><span class="hs-identifier">fvs</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679053996"><span class="hs-identifier hs-var">tys</span></a><span>
</span><a name="line-1382"></a><span>
</span><a name="line-1383"></a><span>      </span><span class="hs-identifier">varKindSigs</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Kind</span><span>
</span><a name="line-1384"></a><span>      </span><a name="local-6989586621679053998"><a href="#local-6989586621679053998"><span class="hs-identifier">varKindSigs</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">foldMap</span><span> </span><a href="#local-6989586621679054005"><span class="hs-identifier hs-var">go_ty</span></a><span> </span><a href="#local-6989586621679053996"><span class="hs-identifier hs-var">tys</span></a><span>
</span><a name="line-1385"></a><span>        </span><span class="hs-keyword">where</span><span>
</span><a name="line-1386"></a><span>          </span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Kind</span><span>
</span><a name="line-1387"></a><span>          </span><a name="local-6989586621679054005"><a href="#local-6989586621679054005"><span class="hs-identifier">go_ty</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">ForallT</span><span> </span><a name="local-6989586621679054007"><a href="#local-6989586621679054007"><span class="hs-identifier">tvbs</span></a></a><span> </span><a name="local-6989586621679054008"><a href="#local-6989586621679054008"><span class="hs-identifier">ctxt</span></a></a><span> </span><a name="local-6989586621679054009"><a href="#local-6989586621679054009"><span class="hs-identifier">t</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1388"></a><span>            </span><span class="hs-identifier hs-var">foldr</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><a name="local-6989586621679054010"><a href="#local-6989586621679054010"><span class="hs-identifier">tvb</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">Map.delete</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a><span> </span><a href="#local-6989586621679054010"><span class="hs-identifier hs-var">tvb</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-1389"></a><span>                  </span><span class="hs-special">(</span><span class="hs-identifier hs-var">foldMap</span><span> </span><a href="#local-6989586621679054006"><span class="hs-identifier hs-var">go_pred</span></a><span> </span><a href="#local-6989586621679054008"><span class="hs-identifier hs-var">ctxt</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">mappend</span><span class="hs-special">`</span><span> </span><a href="#local-6989586621679054005"><span class="hs-identifier hs-var">go_ty</span></a><span> </span><a href="#local-6989586621679054009"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679054007"><span class="hs-identifier hs-var">tvbs</span></a><span>
</span><a name="line-1390"></a><span>          </span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">AppT</span><span> </span><a name="local-6989586621679054011"><a href="#local-6989586621679054011"><span class="hs-identifier">t1</span></a></a><span> </span><a name="local-6989586621679054012"><a href="#local-6989586621679054012"><span class="hs-identifier">t2</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679054005"><span class="hs-identifier hs-var">go_ty</span></a><span> </span><a href="#local-6989586621679054011"><span class="hs-identifier hs-var">t1</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">mappend</span><span class="hs-special">`</span><span> </span><a href="#local-6989586621679054005"><span class="hs-identifier hs-var">go_ty</span></a><span> </span><a href="#local-6989586621679054012"><span class="hs-identifier hs-var">t2</span></a><span>
</span><a name="line-1391"></a><span>          </span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">SigT</span><span> </span><a name="local-6989586621679054013"><a href="#local-6989586621679054013"><span class="hs-identifier">t</span></a></a><span> </span><a name="local-6989586621679054014"><a href="#local-6989586621679054014"><span class="hs-identifier">k</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1392"></a><span>            </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679054015"><a href="#local-6989586621679054015"><span class="hs-identifier">kSigs</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1393"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,8,0)
</span><span>                  </span><a href="#local-6989586621679054005"><span class="hs-identifier hs-var">go_ty</span></a><span> </span><a href="#local-6989586621679054014"><span class="hs-identifier hs-var">k</span></a><span>
</span><a name="line-1395"></a><span class="hs-cpp">#else
</span><span>                  </span><span class="hs-identifier">mempty</span><span>
</span><a name="line-1397"></a><span class="hs-cpp">#endif
</span><span>            </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679054013"><span class="hs-identifier hs-var">t</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1399"></a><span>                 </span><span class="hs-identifier hs-var">VarT</span><span> </span><a name="local-6989586621679054016"><a href="#local-6989586621679054016"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">Map.insert</span><span> </span><a href="#local-6989586621679054016"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679054014"><span class="hs-identifier hs-var">k</span></a><span> </span><a href="#local-6989586621679054015"><span class="hs-identifier hs-var">kSigs</span></a><span>
</span><a name="line-1400"></a><span>                 </span><span class="hs-identifier">_</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679054005"><span class="hs-identifier hs-var">go_ty</span></a><span> </span><a href="#local-6989586621679054013"><span class="hs-identifier hs-var">t</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">mappend</span><span class="hs-special">`</span><span> </span><a href="#local-6989586621679054015"><span class="hs-identifier hs-var">kSigs</span></a><span>
</span><a name="line-1401"></a><span>          </span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mempty</span><span>
</span><a name="line-1402"></a><span>
</span><a name="line-1403"></a><span>          </span><span class="hs-identifier">go_pred</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Pred</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Kind</span><span>
</span><a name="line-1404"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,10,0)
</span><span>          </span><a name="local-6989586621679054006"><a href="#local-6989586621679054006"><span class="hs-identifier">go_pred</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679054005"><span class="hs-identifier hs-var">go_ty</span></a><span>
</span><a name="line-1406"></a><span class="hs-cpp">#else
</span><span>          </span><span class="hs-identifier">go_pred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">foldMap</span><span> </span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-identifier">ts</span><span>
</span><a name="line-1408"></a><span>          </span><span class="hs-identifier">go_pred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-identifier">t2</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-special">`</span><span class="hs-identifier">mappend</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-identifier">t2</span><span>
</span><a name="line-1409"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1411"></a><span>      </span><span class="hs-special">(</span><a name="local-6989586621679053999"><a href="#local-6989586621679053999"><span class="hs-identifier">g</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679054000"><a href="#local-6989586621679054000"><span class="hs-identifier">gLookup</span></a></a><span class="hs-special">,</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>
</span><a name="line-1412"></a><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">graphFromEdges</span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679054017"><span class="hs-identifier hs-var">fv</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679054017"><span class="hs-identifier hs-var">fv</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679054018"><span class="hs-identifier hs-var">kindVars</span></a><span class="hs-special">)</span><span>
</span><a name="line-1413"></a><span>                         </span><span class="hs-glyph">|</span><span> </span><a name="local-6989586621679054017"><a href="#local-6989586621679054017"><span class="hs-identifier">fv</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="#local-6989586621679053997"><span class="hs-identifier hs-var">fvs</span></a><span>
</span><a name="line-1414"></a><span>                         </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679054018"><a href="#local-6989586621679054018"><span class="hs-identifier">kindVars</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1415"></a><span>                                 </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier hs-var">Map.lookup</span><span> </span><a href="#local-6989586621679054017"><span class="hs-identifier hs-var">fv</span></a><span> </span><a href="#local-6989586621679053998"><span class="hs-identifier hs-var">varKindSigs</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1416"></a><span>                                   </span><span class="hs-identifier hs-var">Nothing</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><a name="line-1417"></a><span>                                   </span><span class="hs-identifier hs-var">Just</span><span> </span><a name="local-6989586621679054019"><a href="#local-6989586621679054019"><span class="hs-identifier">ks</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679054019"><span class="hs-identifier hs-var">ks</span></a><span>
</span><a name="line-1418"></a><span>                         </span><span class="hs-special">]</span><span>
</span><a name="line-1419"></a><span>      </span><a name="local-6989586621679054001"><a href="#local-6989586621679054001"><span class="hs-identifier">tg</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">reverse</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">topSort</span><span> </span><a href="#local-6989586621679053999"><span class="hs-identifier hs-var">g</span></a><span>
</span><a name="line-1420"></a><span>
</span><a name="line-1421"></a><span>      </span><a name="local-6989586621679054002"><a href="#local-6989586621679054002"><span class="hs-identifier">lookupVertex</span></a></a><span> </span><a name="local-6989586621679054020"><a href="#local-6989586621679054020"><span class="hs-identifier">x</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1422"></a><span>        </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679054000"><span class="hs-identifier hs-var">gLookup</span></a><span> </span><a href="#local-6989586621679054020"><span class="hs-identifier hs-var">x</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1423"></a><span>          </span><span class="hs-special">(</span><a name="local-6989586621679054021"><a href="#local-6989586621679054021"><span class="hs-identifier">n</span></a></a><span class="hs-special">,</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679054021"><span class="hs-identifier hs-var">n</span></a><span>
</span><a name="line-1424"></a><span>
</span><a name="line-1425"></a><span>      </span><a name="local-6989586621679054003"><a href="#local-6989586621679054003"><span class="hs-identifier">ascribeWithKind</span></a></a><span> </span><a name="local-6989586621679054022"><a href="#local-6989586621679054022"><span class="hs-identifier">n</span></a></a><span>
</span><a name="line-1426"></a><span>        </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">Just</span><span> </span><a name="local-6989586621679054023"><a href="#local-6989586621679054023"><span class="hs-identifier">k</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">Map.lookup</span><span> </span><a href="#local-6989586621679054022"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679053998"><span class="hs-identifier hs-var">varKindSigs</span></a><span>
</span><a name="line-1427"></a><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">KindedTV</span><span> </span><a href="#local-6989586621679054022"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679054023"><span class="hs-identifier hs-var">k</span></a><span>
</span><a name="line-1428"></a><span>        </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">otherwise</span><span>
</span><a name="line-1429"></a><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">PlainTV</span><span> </span><a href="#local-6989586621679054022"><span class="hs-identifier hs-var">n</span></a><span>
</span><a name="line-1430"></a><span>
</span><a name="line-1431"></a><span>      </span><span class="hs-comment">-- An annoying wrinkle: GHCs before 8.0 don't support explicitly</span><span>
</span><a name="line-1432"></a><span>      </span><span class="hs-comment">-- quantifying kinds, so something like @forall k (a :: k)@ would be</span><span>
</span><a name="line-1433"></a><span>      </span><span class="hs-comment">-- rejected. To work around this, we filter out any binders whose names</span><span>
</span><a name="line-1434"></a><span>      </span><span class="hs-comment">-- also appear in a kind on old GHCs.</span><span>
</span><a name="line-1435"></a><span>      </span><a name="local-6989586621679054004"><a href="#local-6989586621679054004"><span class="hs-identifier">isKindBinderOnOldGHCs</span></a></a><span>
</span><a name="line-1436"></a><span class="hs-cpp">#if __GLASGOW_HASKELL__ &gt;= 800
</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">const</span><span> </span><span class="hs-identifier hs-var">False</span><span>
</span><a name="line-1438"></a><span class="hs-cpp">#else
</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">`</span><span class="hs-identifier">elem</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">kindVars</span><span class="hs-special">)</span><span>
</span><a name="line-1440"></a><span>          </span><span class="hs-keyword">where</span><span>
</span><a name="line-1441"></a><span>            </span><span class="hs-identifier">kindVars</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">Map.elems</span><span> </span><span class="hs-identifier">varKindSigs</span><span>
</span><a name="line-1442"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1444"></a><span>  </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><a href="#local-6989586621679054003"><span class="hs-identifier hs-var">ascribeWithKind</span></a><span> </span><span class="hs-operator hs-var">$</span><span>
</span><a name="line-1445"></a><span>     </span><span class="hs-identifier hs-var">filter</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">not</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><a href="#local-6989586621679054004"><span class="hs-identifier hs-var">isKindBinderOnOldGHCs</span></a><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">$</span><span>
</span><a name="line-1446"></a><span>     </span><span class="hs-identifier hs-var">map</span><span> </span><a href="#local-6989586621679054002"><span class="hs-identifier hs-var">lookupVertex</span></a><span> </span><a href="#local-6989586621679054001"><span class="hs-identifier hs-var">tg</span></a><span>
</span><a name="line-1447"></a><span>
</span><a name="line-1448"></a><span class="hs-comment">-- | Substitute all of the free variables in a type with fresh ones</span><span>
</span><a name="line-1449"></a><span class="hs-identifier">freshenFreeVariables</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-1450"></a><a name="freshenFreeVariables"><a href="Language.Haskell.TH.Datatype.html#freshenFreeVariables"><span class="hs-identifier">freshenFreeVariables</span></a></a><span> </span><a name="local-6989586621679054024"><a href="#local-6989586621679054024"><span class="hs-identifier">t</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1451"></a><span>  </span><span class="hs-keyword">do</span><span> </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679054025"><a href="#local-6989586621679054025"><span class="hs-identifier">xs</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679054026"><span class="hs-identifier hs-var">n</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">VarT</span><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><span class="hs-identifier hs-var">newName</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">nameBase</span><span> </span><a href="#local-6989586621679054026"><span class="hs-identifier hs-var">n</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><a name="local-6989586621679054026"><a href="#local-6989586621679054026"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679054024"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">]</span><span>
</span><a name="line-1452"></a><span>     </span><a name="local-6989586621679054027"><a href="#local-6989586621679054027"><span class="hs-identifier">subst</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">T.sequence</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Map.fromList</span><span> </span><a href="#local-6989586621679054025"><span class="hs-identifier hs-var">xs</span></a><span class="hs-special">)</span><span>
</span><a name="line-1453"></a><span>     </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679054027"><span class="hs-identifier hs-var">subst</span></a><span> </span><a href="#local-6989586621679054024"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">)</span><span>
</span><a name="line-1454"></a><span>
</span><a name="line-1455"></a><span>
</span><a name="line-1456"></a><span class="hs-comment">-- | Class for types that support type variable substitution.</span><span>
</span><a name="line-1457"></a><span class="hs-keyword">class</span><span> </span><a name="TypeSubstitution"><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier">TypeSubstitution</span></a></a><span> </span><a name="local-6989586621679046219"><a href="#local-6989586621679046219"><span class="hs-identifier">a</span></a></a><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-1458"></a><span>  </span><span class="hs-comment">-- | Apply a type variable substitution.</span><span>
</span><a name="line-1459"></a><span>  </span><span class="hs-comment">--</span><span>
</span><a name="line-1460"></a><span>  </span><span class="hs-comment">-- Note that 'applySubstitution' is /not/ capture-avoiding. To illustrate</span><span>
</span><a name="line-1461"></a><span>  </span><span class="hs-comment">-- this, observe that if you call this function with the following</span><span>
</span><a name="line-1462"></a><span>  </span><span class="hs-comment">-- substitution:</span><span>
</span><a name="line-1463"></a><span>  </span><span class="hs-comment">--</span><span>
</span><a name="line-1464"></a><span>  </span><span class="hs-comment">-- * @b :-&gt; a@</span><span>
</span><a name="line-1465"></a><span>  </span><span class="hs-comment">--</span><span>
</span><a name="line-1466"></a><span>  </span><span class="hs-comment">-- On the following 'Type':</span><span>
</span><a name="line-1467"></a><span>  </span><span class="hs-comment">--</span><span>
</span><a name="line-1468"></a><span>  </span><span class="hs-comment">-- * @forall a. b@</span><span>
</span><a name="line-1469"></a><span>  </span><span class="hs-comment">--</span><span>
</span><a name="line-1470"></a><span>  </span><span class="hs-comment">-- Then it will return:</span><span>
</span><a name="line-1471"></a><span>  </span><span class="hs-comment">--</span><span>
</span><a name="line-1472"></a><span>  </span><span class="hs-comment">-- * @forall a. a@</span><span>
</span><a name="line-1473"></a><span>  </span><span class="hs-comment">--</span><span>
</span><a name="line-1474"></a><span>  </span><span class="hs-comment">-- However, because the same @a@ type variable was used in the range of the</span><span>
</span><a name="line-1475"></a><span>  </span><span class="hs-comment">-- substitution as was bound by the @forall@, the substituted @a@ is now</span><span>
</span><a name="line-1476"></a><span>  </span><span class="hs-comment">-- captured by the @forall@, resulting in a completely different function.</span><span>
</span><a name="line-1477"></a><span>  </span><span class="hs-comment">--</span><span>
</span><a name="line-1478"></a><span>  </span><span class="hs-comment">-- For @th-abstraction@'s purposes, this is acceptable, as it usually only</span><span>
</span><a name="line-1479"></a><span>  </span><span class="hs-comment">-- deals with globally unique type variable 'Name's. If you use</span><span>
</span><a name="line-1480"></a><span>  </span><span class="hs-comment">-- 'applySubstitution' in a context where the 'Name's aren't globally unique,</span><span>
</span><a name="line-1481"></a><span>  </span><span class="hs-comment">-- however, be aware of this potential problem.</span><span>
</span><a name="line-1482"></a><span>  </span><a name="applySubstitution"><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier">applySubstitution</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679046219"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679046219"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-1483"></a><span>  </span><span class="hs-comment">-- | Compute the free type variables</span><span>
</span><a name="line-1484"></a><span>  </span><a name="freeVariables"><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier">freeVariables</span></a></a><span>     </span><span class="hs-glyph">::</span><span> </span><a href="#local-6989586621679046219"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Name</span><span class="hs-special">]</span><span>
</span><a name="line-1485"></a><span>
</span><a name="line-1486"></a><span class="hs-keyword">instance</span><span> </span><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-type">TypeSubstitution</span></a><span> </span><a href="#local-6989586621679052583"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">=&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-type">TypeSubstitution</span></a><span> </span><span class="hs-special">[</span><a href="#local-6989586621679052583"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">]</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-1487"></a><span>  </span><a name="local-8214565720323821013"><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier">freeVariables</span></a></a><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">nub</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">concat</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span>
</span><a name="line-1488"></a><span>  </span><a name="local-8214565720323821012"><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier">applySubstitution</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">fmap</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span>
</span><a name="line-1489"></a><span>
</span><a name="line-1490"></a><span class="hs-keyword">instance</span><span> </span><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-type">TypeSubstitution</span></a><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-1491"></a><span>  </span><a name="local-8214565720323821012"><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier">applySubstitution</span></a></a><span> </span><a name="local-6989586621679052544"><a href="#local-6989586621679052544"><span class="hs-identifier">subst</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679052545"><span class="hs-identifier hs-var">go</span></a><span>
</span><a name="line-1492"></a><span>    </span><span class="hs-keyword">where</span><span>
</span><a name="line-1493"></a><span>      </span><a name="local-6989586621679052545"><a href="#local-6989586621679052545"><span class="hs-identifier">go</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">ForallT</span><span> </span><a name="local-6989586621679052546"><a href="#local-6989586621679052546"><span class="hs-identifier">tvs</span></a></a><span> </span><a name="local-6989586621679052547"><a href="#local-6989586621679052547"><span class="hs-identifier">context</span></a></a><span> </span><a name="local-6989586621679052548"><a href="#local-6989586621679052548"><span class="hs-identifier">t</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1494"></a><span>        </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679052549"><a href="#local-6989586621679052549"><span class="hs-identifier">subst'</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">foldl'</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">flip</span><span> </span><span class="hs-identifier hs-var">Map.delete</span><span class="hs-special">)</span><span> </span><a href="#local-6989586621679052544"><span class="hs-identifier hs-var">subst</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">map</span><span> </span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a><span> </span><a href="#local-6989586621679052546"><span class="hs-identifier hs-var">tvs</span></a><span class="hs-special">)</span><span>
</span><a name="line-1495"></a><span>
</span><a name="line-1496"></a><span>            </span><span class="hs-identifier">mapTvbKind</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Kind</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Kind</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TyVarBndr</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TyVarBndr</span><span>
</span><a name="line-1497"></a><span>            </span><a name="local-6989586621679052550"><a href="#local-6989586621679052550"><span class="hs-identifier">mapTvbKind</span></a></a><span> </span><a name="local-6989586621679052551"><a href="#local-6989586621679052551"><span class="hs-identifier">f</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">PlainTV</span><span> </span><a name="local-6989586621679052552"><a href="#local-6989586621679052552"><span class="hs-identifier">n</span></a></a><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">PlainTV</span><span> </span><a href="#local-6989586621679052552"><span class="hs-identifier hs-var">n</span></a><span>
</span><a name="line-1498"></a><span>            </span><span class="hs-identifier">mapTvbKind</span><span> </span><a name="local-6989586621679052553"><a href="#local-6989586621679052553"><span class="hs-identifier">f</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">KindedTV</span><span> </span><a name="local-6989586621679052554"><a href="#local-6989586621679052554"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679052555"><a href="#local-6989586621679052555"><span class="hs-identifier">k</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">KindedTV</span><span> </span><a href="#local-6989586621679052554"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679052553"><span class="hs-identifier hs-var">f</span></a><span> </span><a href="#local-6989586621679052555"><span class="hs-identifier hs-var">k</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">in</span><span>
</span><a name="line-1499"></a><span>        </span><span class="hs-identifier hs-var">ForallT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679052550"><span class="hs-identifier hs-var">mapTvbKind</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679052549"><span class="hs-identifier hs-var">subst'</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><a href="#local-6989586621679052546"><span class="hs-identifier hs-var">tvs</span></a><span class="hs-special">)</span><span>
</span><a name="line-1500"></a><span>                </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679052549"><span class="hs-identifier hs-var">subst'</span></a><span> </span><a href="#local-6989586621679052547"><span class="hs-identifier hs-var">context</span></a><span class="hs-special">)</span><span>
</span><a name="line-1501"></a><span>                </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679052549"><span class="hs-identifier hs-var">subst'</span></a><span> </span><a href="#local-6989586621679052548"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">)</span><span>
</span><a name="line-1502"></a><span>      </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">AppT</span><span> </span><a name="local-6989586621679052556"><a href="#local-6989586621679052556"><span class="hs-identifier">f</span></a></a><span> </span><a name="local-6989586621679052557"><a href="#local-6989586621679052557"><span class="hs-identifier">x</span></a></a><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">AppT</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679052545"><span class="hs-identifier hs-var">go</span></a><span> </span><a href="#local-6989586621679052556"><span class="hs-identifier hs-var">f</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679052545"><span class="hs-identifier hs-var">go</span></a><span> </span><a href="#local-6989586621679052557"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">)</span><span>
</span><a name="line-1503"></a><span>      </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">SigT</span><span> </span><a name="local-6989586621679052558"><a href="#local-6989586621679052558"><span class="hs-identifier">t</span></a></a><span> </span><a name="local-6989586621679052559"><a href="#local-6989586621679052559"><span class="hs-identifier">k</span></a></a><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">SigT</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679052545"><span class="hs-identifier hs-var">go</span></a><span> </span><a href="#local-6989586621679052558"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679052544"><span class="hs-identifier hs-var">subst</span></a><span> </span><a href="#local-6989586621679052559"><span class="hs-identifier hs-var">k</span></a><span class="hs-special">)</span><span> </span><span class="hs-comment">-- k could be Kind</span><span>
</span><a name="line-1504"></a><span>      </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">VarT</span><span> </span><a name="local-6989586621679052560"><a href="#local-6989586621679052560"><span class="hs-identifier">v</span></a></a><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Map.findWithDefault</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">VarT</span><span> </span><a href="#local-6989586621679052560"><span class="hs-identifier hs-var">v</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679052560"><span class="hs-identifier hs-var">v</span></a><span> </span><a href="#local-6989586621679052544"><span class="hs-identifier hs-var">subst</span></a><span>
</span><a name="line-1505"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><span>      </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">InfixT</span><span> </span><a name="local-6989586621679052561"><a href="#local-6989586621679052561"><span class="hs-identifier">l</span></a></a><span> </span><a name="local-6989586621679052562"><a href="#local-6989586621679052562"><span class="hs-identifier">c</span></a></a><span> </span><a name="local-6989586621679052563"><a href="#local-6989586621679052563"><span class="hs-identifier">r</span></a></a><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">InfixT</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679052545"><span class="hs-identifier hs-var">go</span></a><span> </span><a href="#local-6989586621679052561"><span class="hs-identifier hs-var">l</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679052562"><span class="hs-identifier hs-var">c</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679052545"><span class="hs-identifier hs-var">go</span></a><span> </span><a href="#local-6989586621679052563"><span class="hs-identifier hs-var">r</span></a><span class="hs-special">)</span><span>
</span><a name="line-1507"></a><span>      </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">UInfixT</span><span> </span><a name="local-6989586621679052564"><a href="#local-6989586621679052564"><span class="hs-identifier">l</span></a></a><span> </span><a name="local-6989586621679052565"><a href="#local-6989586621679052565"><span class="hs-identifier">c</span></a></a><span> </span><a name="local-6989586621679052566"><a href="#local-6989586621679052566"><span class="hs-identifier">r</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">UInfixT</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679052545"><span class="hs-identifier hs-var">go</span></a><span> </span><a href="#local-6989586621679052564"><span class="hs-identifier hs-var">l</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679052565"><span class="hs-identifier hs-var">c</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679052545"><span class="hs-identifier hs-var">go</span></a><span> </span><a href="#local-6989586621679052566"><span class="hs-identifier hs-var">r</span></a><span class="hs-special">)</span><span>
</span><a name="line-1508"></a><span>      </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">ParensT</span><span> </span><a name="local-6989586621679052567"><a href="#local-6989586621679052567"><span class="hs-identifier">t</span></a></a><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">ParensT</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679052545"><span class="hs-identifier hs-var">go</span></a><span> </span><a href="#local-6989586621679052567"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">)</span><span>
</span><a name="line-1509"></a><span class="hs-cpp">#endif
</span><span>      </span><span class="hs-identifier">go</span><span> </span><a name="local-6989586621679052568"><a href="#local-6989586621679052568"><span class="hs-identifier">t</span></a></a><span>               </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679052568"><span class="hs-identifier hs-var">t</span></a><span>
</span><a name="line-1511"></a><span>
</span><a name="line-1512"></a><span>  </span><a name="local-8214565720323821013"><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier">freeVariables</span></a></a><span> </span><a name="local-6989586621679052569"><a href="#local-6989586621679052569"><span class="hs-identifier">t</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1513"></a><span>    </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679052569"><span class="hs-identifier hs-var">t</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1514"></a><span>      </span><span class="hs-identifier hs-var">ForallT</span><span> </span><a name="local-6989586621679052570"><a href="#local-6989586621679052570"><span class="hs-identifier">tvs</span></a></a><span> </span><a name="local-6989586621679052571"><a href="#local-6989586621679052571"><span class="hs-identifier">context</span></a></a><span> </span><a name="local-6989586621679052572"><a href="#local-6989586621679052572"><span class="hs-identifier">t'</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1515"></a><span>          </span><span class="hs-special">(</span><span class="hs-identifier hs-var">concatMap</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><span class="hs-operator hs-var">.</span><span> </span><a href="Language.Haskell.TH.Datatype.html#tvKind"><span class="hs-identifier hs-var">tvKind</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679052570"><span class="hs-identifier hs-var">tvs</span></a><span>
</span><a name="line-1516"></a><span>              </span><span class="hs-special">`</span><span class="hs-identifier hs-var">union</span><span class="hs-special">`</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679052571"><span class="hs-identifier hs-var">context</span></a><span>
</span><a name="line-1517"></a><span>              </span><span class="hs-special">`</span><span class="hs-identifier hs-var">union</span><span class="hs-special">`</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679052572"><span class="hs-identifier hs-var">t'</span></a><span class="hs-special">)</span><span>
</span><a name="line-1518"></a><span>          </span><span class="hs-operator hs-var">\\</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a><span> </span><a href="#local-6989586621679052570"><span class="hs-identifier hs-var">tvs</span></a><span>
</span><a name="line-1519"></a><span>      </span><span class="hs-identifier hs-var">AppT</span><span> </span><a name="local-6989586621679052573"><a href="#local-6989586621679052573"><span class="hs-identifier">f</span></a></a><span> </span><a name="local-6989586621679052574"><a href="#local-6989586621679052574"><span class="hs-identifier">x</span></a></a><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679052573"><span class="hs-identifier hs-var">f</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">union</span><span class="hs-special">`</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679052574"><span class="hs-identifier hs-var">x</span></a><span>
</span><a name="line-1520"></a><span>      </span><span class="hs-identifier hs-var">SigT</span><span> </span><a name="local-6989586621679052575"><a href="#local-6989586621679052575"><span class="hs-identifier">t'</span></a></a><span> </span><a name="local-6989586621679052576"><a href="#local-6989586621679052576"><span class="hs-identifier">k</span></a></a><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679052575"><span class="hs-identifier hs-var">t'</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">union</span><span class="hs-special">`</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679052576"><span class="hs-identifier hs-var">k</span></a><span>
</span><a name="line-1521"></a><span>      </span><span class="hs-identifier hs-var">VarT</span><span> </span><a name="local-6989586621679052577"><a href="#local-6989586621679052577"><span class="hs-identifier">v</span></a></a><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679052577"><span class="hs-identifier hs-var">v</span></a><span class="hs-special">]</span><span>
</span><a name="line-1522"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><span>      </span><span class="hs-identifier hs-var">InfixT</span><span> </span><a name="local-6989586621679052578"><a href="#local-6989586621679052578"><span class="hs-identifier">l</span></a></a><span> </span><span class="hs-identifier">_</span><span> </span><a name="local-6989586621679052579"><a href="#local-6989586621679052579"><span class="hs-identifier">r</span></a></a><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679052578"><span class="hs-identifier hs-var">l</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">union</span><span class="hs-special">`</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679052579"><span class="hs-identifier hs-var">r</span></a><span>
</span><a name="line-1524"></a><span>      </span><span class="hs-identifier hs-var">UInfixT</span><span> </span><a name="local-6989586621679052580"><a href="#local-6989586621679052580"><span class="hs-identifier">l</span></a></a><span> </span><span class="hs-identifier">_</span><span> </span><a name="local-6989586621679052581"><a href="#local-6989586621679052581"><span class="hs-identifier">r</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679052580"><span class="hs-identifier hs-var">l</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">union</span><span class="hs-special">`</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679052581"><span class="hs-identifier hs-var">r</span></a><span>
</span><a name="line-1525"></a><span>      </span><span class="hs-identifier hs-var">ParensT</span><span> </span><a name="local-6989586621679052582"><a href="#local-6989586621679052582"><span class="hs-identifier">t'</span></a></a><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679052582"><span class="hs-identifier hs-var">t'</span></a><span>
</span><a name="line-1526"></a><span class="hs-cpp">#endif
</span><span>      </span><span class="hs-identifier">_</span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><a name="line-1528"></a><span>
</span><a name="line-1529"></a><span class="hs-keyword">instance</span><span> </span><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-type">TypeSubstitution</span></a><span> </span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-1530"></a><span>  </span><a name="local-8214565720323821013"><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier">freeVariables</span></a></a><span> </span><a name="local-6989586621679052368"><a href="#local-6989586621679052368"><span class="hs-identifier">ci</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1531"></a><span>      </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">constructorContext</span><span> </span><a href="#local-6989586621679052368"><span class="hs-identifier hs-var">ci</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">union</span><span class="hs-special">`</span><span>
</span><a name="line-1532"></a><span>       </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">constructorFields</span><span> </span><a href="#local-6989586621679052368"><span class="hs-identifier hs-var">ci</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-1533"></a><span>      </span><span class="hs-operator hs-var">\\</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><span class="hs-identifier">constructorVars</span><span> </span><a href="#local-6989586621679052368"><span class="hs-identifier hs-var">ci</span></a><span class="hs-special">)</span><span>
</span><a name="line-1534"></a><span>
</span><a name="line-1535"></a><span>  </span><a name="local-8214565720323821012"><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier">applySubstitution</span></a></a><span> </span><a name="local-6989586621679052541"><a href="#local-6989586621679052541"><span class="hs-identifier">subst</span></a></a><span> </span><a name="local-6989586621679052542"><a href="#local-6989586621679052542"><span class="hs-identifier">ci</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1536"></a><span>    </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679052543"><a href="#local-6989586621679052543"><span class="hs-identifier">subst'</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">foldl'</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">flip</span><span> </span><span class="hs-identifier hs-var">Map.delete</span><span class="hs-special">)</span><span> </span><a href="#local-6989586621679052541"><span class="hs-identifier hs-var">subst</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">map</span><span> </span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">constructorVars</span><span> </span><a href="#local-6989586621679052542"><span class="hs-identifier hs-var">ci</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">in</span><span>
</span><a name="line-1537"></a><span>    </span><a href="#local-6989586621679052542"><span class="hs-identifier hs-var">ci</span></a><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">constructorContext</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679052543"><span class="hs-identifier hs-var">subst'</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">constructorContext</span><span> </span><a href="#local-6989586621679052542"><span class="hs-identifier hs-var">ci</span></a><span class="hs-special">)</span><span>
</span><a name="line-1538"></a><span>       </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">constructorFields</span><span>  </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679052543"><span class="hs-identifier hs-var">subst'</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">constructorFields</span><span> </span><a href="#local-6989586621679052542"><span class="hs-identifier hs-var">ci</span></a><span class="hs-special">)</span><span>
</span><a name="line-1539"></a><span>       </span><span class="hs-special">}</span><span>
</span><a name="line-1540"></a><span>
</span><a name="line-1541"></a><span class="hs-comment">-- 'Pred' became a type synonym for 'Type'</span><span>
</span><a name="line-1542"></a><span class="hs-cpp">#if !MIN_VERSION_template_haskell(2,10,0)
</span><span class="hs-keyword">instance</span><span> </span><span class="hs-identifier">TypeSubstitution</span><span> </span><span class="hs-identifier">Pred</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-1544"></a><span>  </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">xs</span><span>
</span><a name="line-1545"></a><span>  </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-identifier">y</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-special">`</span><span class="hs-identifier">union</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">y</span><span>
</span><a name="line-1546"></a><span>
</span><a name="line-1547"></a><span>  </span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span>
</span><a name="line-1548"></a><span>  </span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-identifier">y</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-identifier">x</span><span class="hs-special">)</span><span>
</span><a name="line-1549"></a><span>                                            </span><span class="hs-special">(</span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-identifier">y</span><span class="hs-special">)</span><span>
</span><a name="line-1550"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1552"></a><span class="hs-comment">-- 'Kind' became a type synonym for 'Type'. Previously there were no kind variables</span><span>
</span><a name="line-1553"></a><span class="hs-cpp">#if !MIN_VERSION_template_haskell(2,8,0)
</span><span class="hs-keyword">instance</span><span> </span><span class="hs-identifier">TypeSubstitution</span><span> </span><span class="hs-identifier">Kind</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-1555"></a><span>  </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><a name="line-1556"></a><span>  </span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">k</span><span>
</span><a name="line-1557"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1559"></a><span class="hs-comment">-- | Substitutes into the kinds of type variable binders.</span><span>
</span><a name="line-1560"></a><span class="hs-comment">-- Not capture-avoiding.</span><span>
</span><a name="line-1561"></a><span class="hs-identifier">substTyVarBndrs</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span>
</span><a name="line-1562"></a><a name="substTyVarBndrs"><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrs"><span class="hs-identifier">substTyVarBndrs</span></a></a><span> </span><a name="local-6989586621679054028"><a href="#local-6989586621679054028"><span class="hs-identifier">subst</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><a href="#local-6989586621679054029"><span class="hs-identifier hs-var">go</span></a><span>
</span><a name="line-1563"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-1564"></a><span>    </span><a name="local-6989586621679054029"><a href="#local-6989586621679054029"><span class="hs-identifier">go</span></a></a><span> </span><a name="local-6989586621679054030"><a href="#local-6989586621679054030"><span class="hs-identifier">tvb</span></a></a><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="hs-identifier hs-var">PlainTV</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679054030"><span class="hs-identifier hs-var">tvb</span></a><span>
</span><a name="line-1565"></a><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">KindedTV</span><span> </span><a name="local-6989586621679054031"><a href="#local-6989586621679054031"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679054032"><a href="#local-6989586621679054032"><span class="hs-identifier">k</span></a></a><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">KindedTV</span><span> </span><a href="#local-6989586621679054031"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679054028"><span class="hs-identifier hs-var">subst</span></a><span> </span><a href="#local-6989586621679054032"><span class="hs-identifier hs-var">k</span></a><span class="hs-special">)</span><span>
</span><a name="line-1566"></a><span>
</span><a name="line-1567"></a><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><a name="line-1568"></a><span>
</span><a name="line-1569"></a><span class="hs-identifier">combineSubstitutions</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-1570"></a><a name="combineSubstitutions"><a href="Language.Haskell.TH.Datatype.html#combineSubstitutions"><span class="hs-identifier">combineSubstitutions</span></a></a><span> </span><a name="local-6989586621679054033"><a href="#local-6989586621679054033"><span class="hs-identifier">x</span></a></a><span> </span><a name="local-6989586621679054034"><a href="#local-6989586621679054034"><span class="hs-identifier">y</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Map.union</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">fmap</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679054034"><span class="hs-identifier hs-var">y</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679054033"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679054034"><span class="hs-identifier hs-var">y</span></a><span>
</span><a name="line-1571"></a><span>
</span><a name="line-1572"></a><span class="hs-comment">-- | Compute the type variable substitution that unifies a list of types,</span><span>
</span><a name="line-1573"></a><span class="hs-comment">-- or fail in 'Q'.</span><span>
</span><a name="line-1574"></a><span class="hs-comment">--</span><span>
</span><a name="line-1575"></a><span class="hs-comment">-- All infix issue should be resolved before using 'unifyTypes'</span><span>
</span><a name="line-1576"></a><span class="hs-comment">--</span><span>
</span><a name="line-1577"></a><span class="hs-comment">-- Alpha equivalent quantified types are not unified.</span><span>
</span><a name="line-1578"></a><span class="hs-identifier">unifyTypes</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Type</span><span class="hs-special">)</span><span>
</span><a name="line-1579"></a><a name="unifyTypes"><a href="Language.Haskell.TH.Datatype.html#unifyTypes"><span class="hs-identifier">unifyTypes</span></a></a><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-identifier hs-var">Map.empty</span><span>
</span><a name="line-1580"></a><span class="hs-identifier">unifyTypes</span><span> </span><span class="hs-special">(</span><a name="local-6989586621679054035"><a href="#local-6989586621679054035"><span class="hs-identifier">t</span></a></a><span class="hs-glyph">:</span><a name="local-6989586621679054036"><a href="#local-6989586621679054036"><span class="hs-identifier">ts</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1581"></a><span>  </span><span class="hs-keyword">do</span><span> </span><a name="local-6989586621679054037"><a href="#local-6989586621679054037"><span class="hs-identifier">t'</span></a></a><span class="hs-glyph">:</span><a name="local-6989586621679054038"><a href="#local-6989586621679054038"><span class="hs-identifier">ts'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">mapM</span><span> </span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679054035"><span class="hs-identifier hs-var">t</span></a><span class="hs-glyph">:</span><a href="#local-6989586621679054036"><span class="hs-identifier hs-var">ts</span></a><span class="hs-special">)</span><span>
</span><a name="line-1582"></a><span>     </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679054039"><a href="#local-6989586621679054039"><span class="hs-identifier">aux</span></a></a><span> </span><a name="local-6989586621679054040"><a href="#local-6989586621679054040"><span class="hs-identifier">sub</span></a></a><span> </span><a name="local-6989586621679054041"><a href="#local-6989586621679054041"><span class="hs-identifier">u</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1583"></a><span>           </span><span class="hs-keyword">do</span><span> </span><a name="local-6989586621679054042"><a href="#local-6989586621679054042"><span class="hs-identifier">sub'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679054040"><span class="hs-identifier hs-var">sub</span></a><span> </span><a href="#local-6989586621679054037"><span class="hs-identifier hs-var">t'</span></a><span class="hs-special">)</span><span>
</span><a name="line-1584"></a><span>                             </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679054040"><span class="hs-identifier hs-var">sub</span></a><span> </span><a href="#local-6989586621679054041"><span class="hs-identifier hs-var">u</span></a><span class="hs-special">)</span><span>
</span><a name="line-1585"></a><span>              </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#combineSubstitutions"><span class="hs-identifier hs-var">combineSubstitutions</span></a><span> </span><a href="#local-6989586621679054040"><span class="hs-identifier hs-var">sub</span></a><span> </span><a href="#local-6989586621679054042"><span class="hs-identifier hs-var">sub'</span></a><span class="hs-special">)</span><span>
</span><a name="line-1586"></a><span>
</span><a name="line-1587"></a><span>     </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier hs-var">foldM</span><span> </span><a href="#local-6989586621679054039"><span class="hs-identifier hs-var">aux</span></a><span> </span><span class="hs-identifier hs-var">Map.empty</span><span> </span><a href="#local-6989586621679054038"><span class="hs-identifier hs-var">ts'</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1588"></a><span>       </span><span class="hs-identifier hs-var">Right</span><span> </span><a name="local-6989586621679054043"><a href="#local-6989586621679054043"><span class="hs-identifier">m</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><a href="#local-6989586621679054043"><span class="hs-identifier hs-var">m</span></a><span>
</span><a name="line-1589"></a><span>       </span><span class="hs-identifier hs-var">Left</span><span> </span><span class="hs-special">(</span><a name="local-6989586621679054044"><a href="#local-6989586621679054044"><span class="hs-identifier">x</span></a></a><span class="hs-special">,</span><a name="local-6989586621679054045"><a href="#local-6989586621679054045"><span class="hs-identifier">y</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1590"></a><span>         </span><span class="hs-identifier hs-var">fail</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">showString</span><span> </span><span class="hs-string">&quot;Unable to unify types &quot;</span><span>
</span><a name="line-1591"></a><span>              </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">showsPrec</span><span> </span><span class="hs-number">11</span><span> </span><a href="#local-6989586621679054044"><span class="hs-identifier hs-var">x</span></a><span>
</span><a name="line-1592"></a><span>              </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">showString</span><span> </span><span class="hs-string">&quot; and &quot;</span><span>
</span><a name="line-1593"></a><span>              </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">showsPrec</span><span> </span><span class="hs-number">11</span><span> </span><a href="#local-6989586621679054045"><span class="hs-identifier hs-var">y</span></a><span>
</span><a name="line-1594"></a><span>              </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-string">&quot;&quot;</span><span>
</span><a name="line-1595"></a><span>
</span><a name="line-1596"></a><span class="hs-identifier">unify'</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Either</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-identifier hs-type">Type</span><span class="hs-special">)</span><span>
</span><a name="line-1597"></a><span>
</span><a name="line-1598"></a><a name="unify%27"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier">unify'</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">VarT</span><span> </span><a name="local-6989586621679054046"><a href="#local-6989586621679054046"><span class="hs-identifier">n</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">VarT</span><span> </span><a name="local-6989586621679054047"><a href="#local-6989586621679054047"><span class="hs-identifier">m</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><a href="#local-6989586621679054046"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-operator hs-var">==</span><span> </span><a href="#local-6989586621679054047"><span class="hs-identifier hs-var">m</span></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">pure</span><span> </span><span class="hs-identifier hs-var">Map.empty</span><span>
</span><a name="line-1599"></a><span class="hs-identifier">unify'</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">VarT</span><span> </span><a name="local-6989586621679054048"><a href="#local-6989586621679054048"><span class="hs-identifier">n</span></a></a><span class="hs-special">)</span><span> </span><a name="local-6989586621679054049"><a href="#local-6989586621679054049"><span class="hs-identifier">t</span></a></a><span> </span><span class="hs-glyph">|</span><span> </span><a href="#local-6989586621679054048"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">elem</span><span class="hs-special">`</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679054049"><span class="hs-identifier hs-var">t</span></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Left</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">VarT</span><span> </span><a href="#local-6989586621679054048"><span class="hs-identifier hs-var">n</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679054049"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">)</span><span>
</span><a name="line-1600"></a><span>                  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">otherwise</span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Right</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Map.singleton</span><span> </span><a href="#local-6989586621679054048"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679054049"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">)</span><span>
</span><a name="line-1601"></a><span class="hs-identifier">unify'</span><span> </span><a name="local-6989586621679054050"><a href="#local-6989586621679054050"><span class="hs-identifier">t</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">VarT</span><span> </span><a name="local-6989586621679054051"><a href="#local-6989586621679054051"><span class="hs-identifier">n</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><a href="#local-6989586621679054051"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">elem</span><span class="hs-special">`</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><a href="#local-6989586621679054050"><span class="hs-identifier hs-var">t</span></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Left</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">VarT</span><span> </span><a href="#local-6989586621679054051"><span class="hs-identifier hs-var">n</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679054050"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">)</span><span>
</span><a name="line-1602"></a><span>                  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">otherwise</span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Right</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Map.singleton</span><span> </span><a href="#local-6989586621679054051"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679054050"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">)</span><span>
</span><a name="line-1603"></a><span>
</span><a name="line-1604"></a><span class="hs-identifier">unify'</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">AppT</span><span> </span><a name="local-6989586621679054052"><a href="#local-6989586621679054052"><span class="hs-identifier">f1</span></a></a><span> </span><a name="local-6989586621679054053"><a href="#local-6989586621679054053"><span class="hs-identifier">x1</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">AppT</span><span> </span><a name="local-6989586621679054054"><a href="#local-6989586621679054054"><span class="hs-identifier">f2</span></a></a><span> </span><a name="local-6989586621679054055"><a href="#local-6989586621679054055"><span class="hs-identifier">x2</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1605"></a><span>  </span><span class="hs-keyword">do</span><span> </span><a name="local-6989586621679054056"><a href="#local-6989586621679054056"><span class="hs-identifier">sub1</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a><span> </span><a href="#local-6989586621679054052"><span class="hs-identifier hs-var">f1</span></a><span> </span><a href="#local-6989586621679054054"><span class="hs-identifier hs-var">f2</span></a><span>
</span><a name="line-1606"></a><span>     </span><a name="local-6989586621679054057"><a href="#local-6989586621679054057"><span class="hs-identifier">sub2</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679054056"><span class="hs-identifier hs-var">sub1</span></a><span> </span><a href="#local-6989586621679054053"><span class="hs-identifier hs-var">x1</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679054056"><span class="hs-identifier hs-var">sub1</span></a><span> </span><a href="#local-6989586621679054055"><span class="hs-identifier hs-var">x2</span></a><span class="hs-special">)</span><span>
</span><a name="line-1607"></a><span>     </span><span class="hs-identifier hs-var">Right</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.TH.Datatype.html#combineSubstitutions"><span class="hs-identifier hs-var">combineSubstitutions</span></a><span> </span><a href="#local-6989586621679054056"><span class="hs-identifier hs-var">sub1</span></a><span> </span><a href="#local-6989586621679054057"><span class="hs-identifier hs-var">sub2</span></a><span class="hs-special">)</span><span>
</span><a name="line-1608"></a><span>
</span><a name="line-1609"></a><span class="hs-comment">-- Doesn't unify kind signatures</span><span>
</span><a name="line-1610"></a><span class="hs-identifier">unify'</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">SigT</span><span> </span><a name="local-6989586621679054058"><a href="#local-6989586621679054058"><span class="hs-identifier">t</span></a></a><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><a name="local-6989586621679054059"><a href="#local-6989586621679054059"><span class="hs-identifier">u</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a><span> </span><a href="#local-6989586621679054058"><span class="hs-identifier hs-var">t</span></a><span> </span><a href="#local-6989586621679054059"><span class="hs-identifier hs-var">u</span></a><span>
</span><a name="line-1611"></a><span class="hs-identifier">unify'</span><span> </span><a name="local-6989586621679054060"><a href="#local-6989586621679054060"><span class="hs-identifier">t</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">SigT</span><span> </span><a name="local-6989586621679054061"><a href="#local-6989586621679054061"><span class="hs-identifier">u</span></a></a><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a><span> </span><a href="#local-6989586621679054060"><span class="hs-identifier hs-var">t</span></a><span> </span><a href="#local-6989586621679054061"><span class="hs-identifier hs-var">u</span></a><span>
</span><a name="line-1612"></a><span>
</span><a name="line-1613"></a><span class="hs-comment">-- only non-recursive cases should remain at this point</span><span>
</span><a name="line-1614"></a><span class="hs-identifier">unify'</span><span> </span><a name="local-6989586621679054062"><a href="#local-6989586621679054062"><span class="hs-identifier">t</span></a></a><span> </span><a name="local-6989586621679054063"><a href="#local-6989586621679054063"><span class="hs-identifier">u</span></a></a><span>
</span><a name="line-1615"></a><span>  </span><span class="hs-glyph">|</span><span> </span><a href="#local-6989586621679054062"><span class="hs-identifier hs-var">t</span></a><span> </span><span class="hs-operator hs-var">==</span><span> </span><a href="#local-6989586621679054063"><span class="hs-identifier hs-var">u</span></a><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Right</span><span> </span><span class="hs-identifier hs-var">Map.empty</span><span>
</span><a name="line-1616"></a><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">otherwise</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Left</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679054062"><span class="hs-identifier hs-var">t</span></a><span class="hs-special">,</span><a href="#local-6989586621679054063"><span class="hs-identifier hs-var">u</span></a><span class="hs-special">)</span><span>
</span><a name="line-1617"></a><span>
</span><a name="line-1618"></a><span>
</span><a name="line-1619"></a><span class="hs-comment">-- | Construct an equality constraint. The implementation of 'Pred' varies</span><span>
</span><a name="line-1620"></a><span class="hs-comment">-- across versions of Template Haskell.</span><span>
</span><a name="line-1621"></a><span class="hs-identifier">equalPred</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Pred</span><span>
</span><a name="line-1622"></a><a name="equalPred"><a href="Language.Haskell.TH.Datatype.html#equalPred"><span class="hs-identifier">equalPred</span></a></a><span> </span><a name="local-6989586621679054064"><a href="#local-6989586621679054064"><span class="hs-identifier">x</span></a></a><span> </span><a name="local-6989586621679054065"><a href="#local-6989586621679054065"><span class="hs-identifier">y</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1623"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,10,0)
</span><span>  </span><span class="hs-identifier hs-var">AppT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">AppT</span><span> </span><span class="hs-identifier hs-var">EqualityT</span><span> </span><a href="#local-6989586621679054064"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679054065"><span class="hs-identifier hs-var">y</span></a><span>
</span><a name="line-1625"></a><span class="hs-cpp">#else
</span><span>  </span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-identifier">y</span><span>
</span><a name="line-1627"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1629"></a><span class="hs-comment">-- | Construct a typeclass constraint. The implementation of 'Pred' varies</span><span>
</span><a name="line-1630"></a><span class="hs-comment">-- across versions of Template Haskell.</span><span>
</span><a name="line-1631"></a><span class="hs-identifier">classPred</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-comment">{- ^ class -}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ parameters -}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Pred</span><span>
</span><a name="line-1632"></a><a name="classPred"><a href="Language.Haskell.TH.Datatype.html#classPred"><span class="hs-identifier">classPred</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1633"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,10,0)
</span><span>  </span><span class="hs-identifier hs-var">foldl</span><span> </span><span class="hs-identifier hs-var">AppT</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">ConT</span><span>
</span><a name="line-1635"></a><span class="hs-cpp">#else
</span><span>  </span><span class="hs-identifier">ClassP</span><span>
</span><a name="line-1637"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1639"></a><span class="hs-comment">-- | Match a 'Pred' representing an equality constraint. Returns</span><span>
</span><a name="line-1640"></a><span class="hs-comment">-- arguments to the equality constraint if successful.</span><span>
</span><a name="line-1641"></a><span class="hs-identifier">asEqualPred</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Pred</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">)</span><span>
</span><a name="line-1642"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,10,0)
</span><a name="asEqualPred"><a href="Language.Haskell.TH.Datatype.html#asEqualPred"><span class="hs-identifier">asEqualPred</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">EqualityT</span><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">AppT</span><span class="hs-special">`</span><span> </span><a name="local-6989586621679054066"><a href="#local-6989586621679054066"><span class="hs-identifier">x</span></a></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">AppT</span><span class="hs-special">`</span><span> </span><a name="local-6989586621679054067"><a href="#local-6989586621679054067"><span class="hs-identifier">y</span></a></a><span class="hs-special">)</span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Just</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679054066"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">,</span><a href="#local-6989586621679054067"><span class="hs-identifier hs-var">y</span></a><span class="hs-special">)</span><span>
</span><a name="line-1644"></a><span class="hs-identifier">asEqualPred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">ConT</span><span> </span><a name="local-6989586621679054068"><a href="#local-6989586621679054068"><span class="hs-identifier">eq</span></a></a><span>   </span><span class="hs-special">`</span><span class="hs-identifier hs-var">AppT</span><span class="hs-special">`</span><span> </span><a name="local-6989586621679054069"><a href="#local-6989586621679054069"><span class="hs-identifier">x</span></a></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">AppT</span><span class="hs-special">`</span><span> </span><a name="local-6989586621679054070"><a href="#local-6989586621679054070"><span class="hs-identifier">y</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><a href="#local-6989586621679054068"><span class="hs-identifier hs-var">eq</span></a><span> </span><span class="hs-operator hs-var">==</span><span> </span><a href="Language.Haskell.TH.Datatype.Internal.html#eqTypeName"><span class="hs-identifier hs-var">eqTypeName</span></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Just</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679054069"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">,</span><a href="#local-6989586621679054070"><span class="hs-identifier hs-var">y</span></a><span class="hs-special">)</span><span>
</span><a name="line-1645"></a><span class="hs-cpp">#else
</span><span class="hs-identifier">asEqualPred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span>            </span><span class="hs-identifier">x</span><span>        </span><span class="hs-identifier">y</span><span class="hs-special">)</span><span>                   </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">x</span><span class="hs-special">,</span><span class="hs-identifier">y</span><span class="hs-special">)</span><span>
</span><a name="line-1647"></a><span class="hs-cpp">#endif
</span><span class="hs-identifier">asEqualPred</span><span> </span><span class="hs-identifier">_</span><span>                                                </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Nothing</span><span>
</span><a name="line-1649"></a><span>
</span><a name="line-1650"></a><span class="hs-comment">-- | Match a 'Pred' representing a class constraint.</span><span>
</span><a name="line-1651"></a><span class="hs-comment">-- Returns the classname and parameters if successful.</span><span>
</span><a name="line-1652"></a><span class="hs-identifier">asClassPred</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Pred</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Name</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><a name="line-1653"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,10,0)
</span><a name="asClassPred"><a href="Language.Haskell.TH.Datatype.html#asClassPred"><span class="hs-identifier">asClassPred</span></a></a><span> </span><a name="local-6989586621679054071"><a href="#local-6989586621679054071"><span class="hs-identifier">t</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1655"></a><span>  </span><span class="hs-keyword">case</span><span> </span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a><span> </span><a href="#local-6989586621679054071"><span class="hs-identifier hs-var">t</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1656"></a><span>    </span><span class="hs-identifier hs-var">ConT</span><span> </span><a name="local-6989586621679054072"><a href="#local-6989586621679054072"><span class="hs-identifier">f</span></a></a><span> </span><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-var">:|</span></a><span> </span><a name="local-6989586621679054073"><a href="#local-6989586621679054073"><span class="hs-identifier">xs</span></a></a><span> </span><span class="hs-glyph">|</span><span> </span><a href="#local-6989586621679054072"><span class="hs-identifier hs-var">f</span></a><span> </span><span class="hs-operator hs-var">/=</span><span> </span><a href="Language.Haskell.TH.Datatype.Internal.html#eqTypeName"><span class="hs-identifier hs-var">eqTypeName</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">Just</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679054072"><span class="hs-identifier hs-var">f</span></a><span class="hs-special">,</span><a href="#local-6989586621679054073"><span class="hs-identifier hs-var">xs</span></a><span class="hs-special">)</span><span>
</span><a name="line-1657"></a><span>    </span><span class="hs-identifier">_</span><span>                              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">Nothing</span><span>
</span><a name="line-1658"></a><span class="hs-cpp">#else
</span><span class="hs-identifier">asClassPred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">f</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">f</span><span class="hs-special">,</span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span>
</span><a name="line-1660"></a><span class="hs-identifier">asClassPred</span><span> </span><span class="hs-identifier">_</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Nothing</span><span>
</span><a name="line-1661"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1663"></a><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><a name="line-1664"></a><span>
</span><a name="line-1665"></a><span class="hs-comment">-- | If we are working with a 'Dec' obtained via 'reify' (as opposed to one</span><span>
</span><a name="line-1666"></a><span class="hs-comment">-- created from, say, [d| ... |] quotes), then we need to apply more hacks than</span><span>
</span><a name="line-1667"></a><span class="hs-comment">-- we otherwise would to sanitize the 'Dec'. See #28.</span><span>
</span><a name="line-1668"></a><span class="hs-keyword">type</span><span> </span><a name="IsReifiedDec"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier">IsReifiedDec</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-type">Bool</span><span>
</span><a name="line-1669"></a><span>
</span><a name="line-1670"></a><span class="hs-identifier">isReified</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">isn'tReified</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a><span>
</span><a name="line-1671"></a><a name="isReified"><a href="Language.Haskell.TH.Datatype.html#isReified"><span class="hs-identifier">isReified</span></a></a><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">True</span><span>
</span><a name="line-1672"></a><a name="isn%27tReified"><a href="Language.Haskell.TH.Datatype.html#isn%27tReified"><span class="hs-identifier">isn'tReified</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">False</span><span>
</span><a name="line-1673"></a><span>
</span><a name="line-1674"></a><span class="hs-comment">-- On old versions of GHC, reify would not give you kind signatures for</span><span>
</span><a name="line-1675"></a><span class="hs-comment">-- GADT type variables of kind *. To work around this, we insert the kinds</span><span>
</span><a name="line-1676"></a><span class="hs-comment">-- manually on any types without a signature.</span><span>
</span><a name="line-1677"></a><span>
</span><a name="line-1678"></a><span class="hs-identifier">giveTypesStarKinds</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span>
</span><a name="line-1679"></a><a name="giveTypesStarKinds"><a href="Language.Haskell.TH.Datatype.html#giveTypesStarKinds"><span class="hs-identifier">giveTypesStarKinds</span></a></a><span> </span><a name="local-6989586621679054074"><a href="#local-6989586621679054074"><span class="hs-identifier">info</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1680"></a><span>  </span><a href="#local-6989586621679054074"><span class="hs-identifier hs-var">info</span></a><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">datatypeVars</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679054075"><span class="hs-identifier hs-var">annotateVars</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">datatypeVars</span><span> </span><a href="#local-6989586621679054074"><span class="hs-identifier hs-var">info</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><a name="line-1681"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-1682"></a><span>    </span><span class="hs-identifier">annotateVars</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Type</span><span class="hs-special">]</span><span>
</span><a name="line-1683"></a><span>    </span><a name="local-6989586621679054075"><a href="#local-6989586621679054075"><span class="hs-identifier">annotateVars</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-glyph">\</span><a name="local-6989586621679054076"><a href="#local-6989586621679054076"><span class="hs-identifier">t</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1684"></a><span>      </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679054076"><span class="hs-identifier hs-var">t</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1685"></a><span>        </span><span class="hs-identifier hs-var">VarT</span><span> </span><a name="local-6989586621679054077"><a href="#local-6989586621679054077"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">SigT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">VarT</span><span> </span><a href="#local-6989586621679054077"><span class="hs-identifier hs-var">n</span></a><span class="hs-special">)</span><span> </span><span class="hs-identifier hs-var">starK</span><span>
</span><a name="line-1686"></a><span>        </span><span class="hs-identifier">_</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679054076"><span class="hs-identifier hs-var">t</span></a><span>
</span><a name="line-1687"></a><span>
</span><a name="line-1688"></a><span class="hs-identifier">giveTyVarBndrsStarKinds</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a><span>
</span><a name="line-1689"></a><a name="giveTyVarBndrsStarKinds"><a href="Language.Haskell.TH.Datatype.html#giveTyVarBndrsStarKinds"><span class="hs-identifier">giveTyVarBndrsStarKinds</span></a></a><span> </span><a name="local-6989586621679054078"><a href="#local-6989586621679054078"><span class="hs-identifier">info</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1690"></a><span>  </span><a href="#local-6989586621679054078"><span class="hs-identifier hs-var">info</span></a><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">constructorVars</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679054079"><span class="hs-identifier hs-var">annotateVars</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">constructorVars</span><span> </span><a href="#local-6989586621679054078"><span class="hs-identifier hs-var">info</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><a name="line-1691"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-1692"></a><span>    </span><span class="hs-identifier">annotateVars</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span>
</span><a name="line-1693"></a><span>    </span><a name="local-6989586621679054079"><a href="#local-6989586621679054079"><span class="hs-identifier">annotateVars</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-glyph">\</span><a name="local-6989586621679054080"><a href="#local-6989586621679054080"><span class="hs-identifier">tvb</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1694"></a><span>      </span><span class="hs-keyword">case</span><span> </span><a href="#local-6989586621679054080"><span class="hs-identifier hs-var">tvb</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1695"></a><span>        </span><span class="hs-identifier hs-var">PlainTV</span><span> </span><a name="local-6989586621679054081"><a href="#local-6989586621679054081"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">KindedTV</span><span> </span><a href="#local-6989586621679054081"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-identifier hs-var">starK</span><span>
</span><a name="line-1696"></a><span>        </span><span class="hs-identifier">_</span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679054080"><span class="hs-identifier hs-var">tvb</span></a><span>
</span><a name="line-1697"></a><span>
</span><a name="line-1698"></a><span class="hs-comment">-- | Prior to GHC 8.2.1, reify was broken for data instances and newtype</span><span>
</span><a name="line-1699"></a><span class="hs-comment">-- instances. This code attempts to detect the problem and repair it if</span><span>
</span><a name="line-1700"></a><span class="hs-comment">-- possible.</span><span>
</span><a name="line-1701"></a><span class="hs-comment">--</span><span>
</span><a name="line-1702"></a><span class="hs-comment">-- The particular problem is that the type variables used in the patterns</span><span>
</span><a name="line-1703"></a><span class="hs-comment">-- while defining a data family instance do not completely match those</span><span>
</span><a name="line-1704"></a><span class="hs-comment">-- used when defining the fields of the value constructors beyond the</span><span>
</span><a name="line-1705"></a><span class="hs-comment">-- base names. This code attempts to recover the relationship between the</span><span>
</span><a name="line-1706"></a><span class="hs-comment">-- type variables.</span><span>
</span><a name="line-1707"></a><span class="hs-comment">--</span><span>
</span><a name="line-1708"></a><span class="hs-comment">-- It is possible, however, to generate these kinds of declarations by</span><span>
</span><a name="line-1709"></a><span class="hs-comment">-- means other than reify. In these cases the name bases might not be</span><span>
</span><a name="line-1710"></a><span class="hs-comment">-- unique and the declarations might be well formed. In such a case this</span><span>
</span><a name="line-1711"></a><span class="hs-comment">-- code attempts to avoid altering the declaration.</span><span>
</span><a name="line-1712"></a><span class="hs-comment">--</span><span>
</span><a name="line-1713"></a><span class="hs-comment">-- https://ghc.haskell.org/trac/ghc/ticket/13618</span><span>
</span><a name="line-1714"></a><span class="hs-identifier">repair13618</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a><span>
</span><a name="line-1715"></a><a name="repair13618"><a href="Language.Haskell.TH.Datatype.html#repair13618"><span class="hs-identifier">repair13618</span></a></a><span> </span><a name="local-6989586621679054082"><a href="#local-6989586621679054082"><span class="hs-identifier">info</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1716"></a><span>  </span><span class="hs-keyword">do</span><span> </span><a name="local-6989586621679054094"><a href="#local-6989586621679054094"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">T.sequence</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Map.fromList</span><span> </span><a href="#local-6989586621679054086"><span class="hs-identifier hs-var">substList</span></a><span class="hs-special">)</span><span>
</span><a name="line-1717"></a><span>     </span><span class="hs-identifier hs-var">return</span><span> </span><a href="#local-6989586621679054082"><span class="hs-identifier hs-var">info</span></a><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">datatypeCons</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a><span> </span><a href="#local-6989586621679054094"><span class="hs-identifier hs-var">s</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">datatypeCons</span><span> </span><a href="#local-6989586621679054082"><span class="hs-identifier hs-var">info</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><a name="line-1718"></a><span>
</span><a name="line-1719"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-1720"></a><span>    </span><a name="local-6989586621679054083"><a href="#local-6989586621679054083"><span class="hs-identifier">used</span></a></a><span>  </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">datatypeCons</span><span> </span><a href="#local-6989586621679054082"><span class="hs-identifier hs-var">info</span></a><span class="hs-special">)</span><span>
</span><a name="line-1721"></a><span>    </span><a name="local-6989586621679054084"><a href="#local-6989586621679054084"><span class="hs-identifier">bound</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">datatypeVars</span><span> </span><a href="#local-6989586621679054082"><span class="hs-identifier hs-var">info</span></a><span class="hs-special">)</span><span>
</span><a name="line-1722"></a><span>    </span><a name="local-6989586621679054085"><a href="#local-6989586621679054085"><span class="hs-identifier">free</span></a></a><span>  </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679054083"><span class="hs-identifier hs-var">used</span></a><span> </span><span class="hs-operator hs-var">\\</span><span> </span><a href="#local-6989586621679054084"><span class="hs-identifier hs-var">bound</span></a><span>
</span><a name="line-1723"></a><span>
</span><a name="line-1724"></a><span>    </span><a name="local-6989586621679054086"><a href="#local-6989586621679054086"><span class="hs-identifier">substList</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1725"></a><span>      </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679054088"><span class="hs-identifier hs-var">u</span></a><span class="hs-special">,</span><span> </span><a href="#local-6989586621679054087"><span class="hs-identifier hs-var">substEntry</span></a><span> </span><a href="#local-6989586621679054088"><span class="hs-identifier hs-var">u</span></a><span> </span><a href="#local-6989586621679054089"><span class="hs-identifier hs-var">vs</span></a><span class="hs-special">)</span><span>
</span><a name="line-1726"></a><span>      </span><span class="hs-glyph">|</span><span> </span><a name="local-6989586621679054088"><a href="#local-6989586621679054088"><span class="hs-identifier">u</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="#local-6989586621679054085"><span class="hs-identifier hs-var">free</span></a><span>
</span><a name="line-1727"></a><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679054089"><a href="#local-6989586621679054089"><span class="hs-identifier">vs</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679054090"><span class="hs-identifier hs-var">v</span></a><span> </span><span class="hs-glyph">|</span><span> </span><a name="local-6989586621679054090"><a href="#local-6989586621679054090"><span class="hs-identifier">v</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="#local-6989586621679054084"><span class="hs-identifier hs-var">bound</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">nameBase</span><span> </span><a href="#local-6989586621679054090"><span class="hs-identifier hs-var">v</span></a><span> </span><span class="hs-operator hs-var">==</span><span> </span><span class="hs-identifier hs-var">nameBase</span><span> </span><a href="#local-6989586621679054088"><span class="hs-identifier hs-var">u</span></a><span class="hs-special">]</span><span>
</span><a name="line-1728"></a><span>      </span><span class="hs-special">]</span><span>
</span><a name="line-1729"></a><span>
</span><a name="line-1730"></a><span>    </span><a name="local-6989586621679054087"><a href="#local-6989586621679054087"><span class="hs-identifier">substEntry</span></a></a><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-special">[</span><a name="local-6989586621679054091"><a href="#local-6989586621679054091"><span class="hs-identifier">v</span></a></a><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">varT</span><span> </span><a href="#local-6989586621679054091"><span class="hs-identifier hs-var">v</span></a><span>
</span><a name="line-1731"></a><span>    </span><span class="hs-identifier">substEntry</span><span> </span><a name="local-6989586621679054092"><a href="#local-6989586621679054092"><span class="hs-identifier">u</span></a></a><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">fail</span><span> </span><span class="hs-special">(</span><span class="hs-string">&quot;Impossible free variable: &quot;</span><span> </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-identifier hs-var">show</span><span> </span><a href="#local-6989586621679054092"><span class="hs-identifier hs-var">u</span></a><span class="hs-special">)</span><span>
</span><a name="line-1732"></a><span>    </span><span class="hs-identifier">substEntry</span><span> </span><a name="local-6989586621679054093"><a href="#local-6989586621679054093"><span class="hs-identifier">u</span></a></a><span> </span><span class="hs-identifier">_</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">fail</span><span> </span><span class="hs-special">(</span><span class="hs-string">&quot;Ambiguous free variable: &quot;</span><span>  </span><span class="hs-operator hs-var">++</span><span> </span><span class="hs-identifier hs-var">show</span><span> </span><a href="#local-6989586621679054093"><span class="hs-identifier hs-var">u</span></a><span class="hs-special">)</span><span>
</span><a name="line-1733"></a><span>
</span><a name="line-1734"></a><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><a name="line-1735"></a><span>
</span><a name="line-1736"></a><span class="hs-comment">-- | Backward compatible version of 'dataD'</span><span>
</span><a name="line-1737"></a><span class="hs-identifier">dataDCompat</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-1738"></a><span>  </span><span class="hs-identifier hs-type">CxtQ</span><span>        </span><span class="hs-comment">{- ^ context                 -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1739"></a><span>  </span><span class="hs-identifier hs-type">Name</span><span>        </span><span class="hs-comment">{- ^ type constructor        -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1740"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ type parameters         -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1741"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">ConQ</span><span class="hs-special">]</span><span>      </span><span class="hs-comment">{- ^ constructor definitions -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1742"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Name</span><span class="hs-special">]</span><span>      </span><span class="hs-comment">{- ^ derived class names     -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1743"></a><span>  </span><span class="hs-identifier hs-type">DecQ</span><span>
</span><a name="line-1744"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,12,0)
</span><a name="dataDCompat"><a href="Language.Haskell.TH.Datatype.html#dataDCompat"><span class="hs-identifier">dataDCompat</span></a></a><span> </span><a name="local-6989586621679054095"><a href="#local-6989586621679054095"><span class="hs-identifier">c</span></a></a><span> </span><a name="local-6989586621679054096"><a href="#local-6989586621679054096"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679054097"><a href="#local-6989586621679054097"><span class="hs-identifier">ts</span></a></a><span> </span><a name="local-6989586621679054098"><a href="#local-6989586621679054098"><span class="hs-identifier">cs</span></a></a><span> </span><a name="local-6989586621679054099"><a href="#local-6989586621679054099"><span class="hs-identifier">ds</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1746"></a><span>  </span><span class="hs-identifier hs-var">dataD</span><span> </span><a href="#local-6989586621679054095"><span class="hs-identifier hs-var">c</span></a><span> </span><a href="#local-6989586621679054096"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679054097"><span class="hs-identifier hs-var">ts</span></a><span> </span><span class="hs-identifier hs-var">Nothing</span><span> </span><a href="#local-6989586621679054098"><span class="hs-identifier hs-var">cs</span></a><span>
</span><a name="line-1747"></a><span>    </span><span class="hs-special">(</span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier hs-var">null</span><span> </span><a href="#local-6989586621679054099"><span class="hs-identifier hs-var">ds</span></a><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-var">derivClause</span><span> </span><span class="hs-identifier hs-var">Nothing</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-identifier hs-var">conT</span><span> </span><a href="#local-6989586621679054099"><span class="hs-identifier hs-var">ds</span></a><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><a name="line-1748"></a><span class="hs-cpp">#elif MIN_VERSION_template_haskell(2,11,0)
</span><span class="hs-identifier">dataDCompat</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">cs</span><span> </span><span class="hs-identifier">ds</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1750"></a><span>  </span><span class="hs-identifier">dataD</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-identifier">cs</span><span>
</span><a name="line-1751"></a><span>    </span><span class="hs-special">(</span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">map</span><span> </span><span class="hs-identifier">ConT</span><span> </span><span class="hs-identifier">ds</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-1752"></a><span class="hs-cpp">#else
</span><span class="hs-identifier">dataDCompat</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">dataD</span><span>
</span><a name="line-1754"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1756"></a><span class="hs-comment">-- | Backward compatible version of 'newtypeD'</span><span>
</span><a name="line-1757"></a><span class="hs-identifier">newtypeDCompat</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-1758"></a><span>  </span><span class="hs-identifier hs-type">CxtQ</span><span>        </span><span class="hs-comment">{- ^ context                 -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1759"></a><span>  </span><span class="hs-identifier hs-type">Name</span><span>        </span><span class="hs-comment">{- ^ type constructor        -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1760"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TyVarBndr</span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ type parameters         -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1761"></a><span>  </span><span class="hs-identifier hs-type">ConQ</span><span>        </span><span class="hs-comment">{- ^ constructor definition  -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1762"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Name</span><span class="hs-special">]</span><span>      </span><span class="hs-comment">{- ^ derived class names     -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1763"></a><span>  </span><span class="hs-identifier hs-type">DecQ</span><span>
</span><a name="line-1764"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,12,0)
</span><a name="newtypeDCompat"><a href="Language.Haskell.TH.Datatype.html#newtypeDCompat"><span class="hs-identifier">newtypeDCompat</span></a></a><span> </span><a name="local-6989586621679054100"><a href="#local-6989586621679054100"><span class="hs-identifier">c</span></a></a><span> </span><a name="local-6989586621679054101"><a href="#local-6989586621679054101"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679054102"><a href="#local-6989586621679054102"><span class="hs-identifier">ts</span></a></a><span> </span><a name="local-6989586621679054103"><a href="#local-6989586621679054103"><span class="hs-identifier">cs</span></a></a><span> </span><a name="local-6989586621679054104"><a href="#local-6989586621679054104"><span class="hs-identifier">ds</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1766"></a><span>  </span><span class="hs-identifier hs-var">newtypeD</span><span> </span><a href="#local-6989586621679054100"><span class="hs-identifier hs-var">c</span></a><span> </span><a href="#local-6989586621679054101"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="#local-6989586621679054102"><span class="hs-identifier hs-var">ts</span></a><span> </span><span class="hs-identifier hs-var">Nothing</span><span> </span><a href="#local-6989586621679054103"><span class="hs-identifier hs-var">cs</span></a><span>
</span><a name="line-1767"></a><span>    </span><span class="hs-special">(</span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier hs-var">null</span><span> </span><a href="#local-6989586621679054104"><span class="hs-identifier hs-var">ds</span></a><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-var">derivClause</span><span> </span><span class="hs-identifier hs-var">Nothing</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-identifier hs-var">conT</span><span> </span><a href="#local-6989586621679054104"><span class="hs-identifier hs-var">ds</span></a><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><a name="line-1768"></a><span class="hs-cpp">#elif MIN_VERSION_template_haskell(2,11,0)
</span><span class="hs-identifier">newtypeDCompat</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">cs</span><span> </span><span class="hs-identifier">ds</span><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-1770"></a><span>  </span><span class="hs-identifier">newtypeD</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-identifier">cs</span><span>
</span><a name="line-1771"></a><span>    </span><span class="hs-special">(</span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">map</span><span> </span><span class="hs-identifier">ConT</span><span> </span><span class="hs-identifier">ds</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-1772"></a><span class="hs-cpp">#else
</span><span class="hs-identifier">newtypeDCompat</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">newtypeD</span><span>
</span><a name="line-1774"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1776"></a><span class="hs-comment">-- | Backward compatible version of 'tySynInstD'</span><span>
</span><a name="line-1777"></a><span class="hs-identifier">tySynInstDCompat</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-1778"></a><span>  </span><span class="hs-identifier hs-type">Name</span><span>    </span><span class="hs-comment">{- ^ type family name    -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1779"></a><span>  </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TypeQ</span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ instance parameters -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1780"></a><span>  </span><span class="hs-identifier hs-type">TypeQ</span><span>   </span><span class="hs-comment">{- ^ instance result     -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1781"></a><span>  </span><span class="hs-identifier hs-type">DecQ</span><span>
</span><a name="line-1782"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,9,0)
</span><a name="tySynInstDCompat"><a href="Language.Haskell.TH.Datatype.html#tySynInstDCompat"><span class="hs-identifier">tySynInstDCompat</span></a></a><span> </span><a name="local-6989586621679054105"><a href="#local-6989586621679054105"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679054106"><a href="#local-6989586621679054106"><span class="hs-identifier">ps</span></a></a><span> </span><a name="local-6989586621679054107"><a href="#local-6989586621679054107"><span class="hs-identifier">r</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">TySynInstD</span><span> </span><a href="#local-6989586621679054105"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">TySynEqn</span><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><span class="hs-identifier hs-var">sequence</span><span> </span><a href="#local-6989586621679054106"><span class="hs-identifier hs-var">ps</span></a><span> </span><span class="hs-operator hs-var">&lt;*&gt;</span><span> </span><a href="#local-6989586621679054107"><span class="hs-identifier hs-var">r</span></a><span class="hs-special">)</span><span>
</span><a name="line-1784"></a><span class="hs-cpp">#else
</span><span class="hs-identifier">tySynInstDCompat</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">tySynInstD</span><span>
</span><a name="line-1786"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1788"></a><span class="hs-comment">-- | Backward compatible version of 'pragLineD'. Returns</span><span>
</span><a name="line-1789"></a><span class="hs-comment">-- 'Nothing' if line pragmas are not suported.</span><span>
</span><a name="line-1790"></a><span class="hs-identifier">pragLineDCompat</span><span> </span><span class="hs-glyph">::</span><span>
</span><a name="line-1791"></a><span>  </span><span class="hs-identifier hs-type">Int</span><span>     </span><span class="hs-comment">{- ^ line number -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1792"></a><span>  </span><span class="hs-identifier hs-type">String</span><span>  </span><span class="hs-comment">{- ^ file name   -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-1793"></a><span>  </span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-identifier hs-type">DecQ</span><span>
</span><a name="line-1794"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,10,0)
</span><a name="pragLineDCompat"><a href="Language.Haskell.TH.Datatype.html#pragLineDCompat"><span class="hs-identifier">pragLineDCompat</span></a></a><span> </span><a name="local-6989586621679054108"><a href="#local-6989586621679054108"><span class="hs-identifier">ln</span></a></a><span> </span><a name="local-6989586621679054109"><a href="#local-6989586621679054109"><span class="hs-identifier">fn</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">pragLineD</span><span> </span><a href="#local-6989586621679054108"><span class="hs-identifier hs-var">ln</span></a><span> </span><a href="#local-6989586621679054109"><span class="hs-identifier hs-var">fn</span></a><span class="hs-special">)</span><span>
</span><a name="line-1796"></a><span class="hs-cpp">#else
</span><span class="hs-identifier">pragLineDCompat</span><span> </span><span class="hs-identifier">_</span><span>  </span><span class="hs-identifier">_</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Nothing</span><span>
</span><a name="line-1798"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1800"></a><span class="hs-identifier">arrowKCompat</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Kind</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Kind</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Kind</span><span>
</span><a name="line-1801"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,8,0)
</span><a name="arrowKCompat"><a href="Language.Haskell.TH.Datatype.html#arrowKCompat"><span class="hs-identifier">arrowKCompat</span></a></a><span> </span><a name="local-6989586621679054110"><a href="#local-6989586621679054110"><span class="hs-identifier">x</span></a></a><span> </span><a name="local-6989586621679054111"><a href="#local-6989586621679054111"><span class="hs-identifier">y</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">arrowK</span><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">appK</span><span class="hs-special">`</span><span> </span><a href="#local-6989586621679054110"><span class="hs-identifier hs-var">x</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">appK</span><span class="hs-special">`</span><span> </span><a href="#local-6989586621679054111"><span class="hs-identifier hs-var">y</span></a><span>
</span><a name="line-1803"></a><span class="hs-cpp">#else
</span><span class="hs-identifier">arrowKCompat</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">arrowK</span><span>
</span><a name="line-1805"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1807"></a><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><a name="line-1808"></a><span>
</span><a name="line-1809"></a><span class="hs-comment">-- | Backwards compatibility wrapper for 'Fixity' lookup.</span><span>
</span><a name="line-1810"></a><span class="hs-comment">--</span><span>
</span><a name="line-1811"></a><span class="hs-comment">-- In @template-haskell-2.11.0.0@ and later, the answer will always</span><span>
</span><a name="line-1812"></a><span class="hs-comment">-- be 'Just' of a fixity.</span><span>
</span><a name="line-1813"></a><span class="hs-comment">--</span><span>
</span><a name="line-1814"></a><span class="hs-comment">-- Before @template-haskell-2.11.0.0@ it was only possible to determine</span><span>
</span><a name="line-1815"></a><span class="hs-comment">-- fixity information for variables, class methods, and data constructors.</span><span>
</span><a name="line-1816"></a><span class="hs-comment">-- In this case for type operators the answer could be 'Nothing', which</span><span>
</span><a name="line-1817"></a><span class="hs-comment">-- indicates that the answer is unavailable.</span><span>
</span><a name="line-1818"></a><span class="hs-identifier">reifyFixityCompat</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-identifier hs-type">Fixity</span><span class="hs-special">)</span><span>
</span><a name="line-1819"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><a name="reifyFixityCompat"><a href="Language.Haskell.TH.Datatype.html#reifyFixityCompat"><span class="hs-identifier">reifyFixityCompat</span></a></a><span> </span><a name="local-6989586621679054112"><a href="#local-6989586621679054112"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">recover</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-identifier hs-var">Nothing</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">`</span><span class="hs-identifier hs-var">mplus</span><span class="hs-special">`</span><span> </span><span class="hs-identifier hs-var">Just</span><span> </span><span class="hs-identifier hs-var">defaultFixity</span><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><span class="hs-identifier hs-var">reifyFixity</span><span> </span><a href="#local-6989586621679054112"><span class="hs-identifier hs-var">n</span></a><span class="hs-special">)</span><span>
</span><a name="line-1821"></a><span class="hs-cpp">#else
</span><span class="hs-identifier">reifyFixityCompat</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">recover</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">return</span><span> </span><span class="hs-identifier">Nothing</span><span class="hs-special">)</span><span> </span><span class="hs-operator">$</span><span>
</span><a name="line-1823"></a><span>  </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">info</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">reify</span><span> </span><span class="hs-identifier">n</span><span>
</span><a name="line-1824"></a><span>     </span><span class="hs-identifier">return</span><span> </span><span class="hs-operator">$!</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">info</span><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-1825"></a><span>       </span><span class="hs-identifier">ClassOpI</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">fixity</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">fixity</span><span>
</span><a name="line-1826"></a><span>       </span><span class="hs-identifier">DataConI</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">fixity</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">fixity</span><span>
</span><a name="line-1827"></a><span>       </span><span class="hs-identifier">VarI</span><span>     </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">fixity</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">fixity</span><span>
</span><a name="line-1828"></a><span>       </span><span class="hs-identifier">_</span><span>                     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Nothing</span><span>
</span><a name="line-1829"></a><span class="hs-cpp">#endif
</span><span>
</span><a name="line-1831"></a><span class="hs-comment">-- | Call 'reify' and return @'Just' info@ if successful or 'Nothing' if</span><span>
</span><a name="line-1832"></a><span class="hs-comment">-- reification failed.</span><span>
</span><a name="line-1833"></a><span class="hs-identifier">reifyMaybe</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-identifier hs-type">Info</span><span class="hs-special">)</span><span>
</span><a name="line-1834"></a><a name="reifyMaybe"><a href="Language.Haskell.TH.Datatype.html#reifyMaybe"><span class="hs-identifier">reifyMaybe</span></a></a><span> </span><a name="local-6989586621679054113"><a href="#local-6989586621679054113"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-identifier hs-var">Nothing</span><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">recover</span><span class="hs-special">`</span><span> </span><span class="hs-identifier hs-var">fmap</span><span> </span><span class="hs-identifier hs-var">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">reify</span><span> </span><a href="#local-6989586621679054113"><span class="hs-identifier hs-var">n</span></a><span class="hs-special">)</span><span>
</span><a name="line-1835"></a></pre></body></html>