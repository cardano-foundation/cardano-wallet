-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Automatic derivation of querying functions for servant
--   
--   This library lets you derive automatically Haskell functions that let
--   you query each endpoint of a <a>servant</a> webservice.
--   
--   See <a>the client section of the tutorial</a>.
--   
--   <a>CHANGELOG</a>
@package servant-client
@version 0.15

module Servant.Client.Internal.HttpClient

-- | The environment in which a request is run.
data ClientEnv
ClientEnv :: Manager -> BaseUrl -> Maybe (TVar CookieJar) -> ClientEnv
[manager] :: ClientEnv -> Manager
[baseUrl] :: ClientEnv -> BaseUrl
[cookieJar] :: ClientEnv -> Maybe (TVar CookieJar)

-- | <a>ClientEnv</a> smart constructor.
mkClientEnv :: Manager -> BaseUrl -> ClientEnv

-- | Generates a set of client functions for an API.
--   
--   Example:
--   
--   <pre>
--   type API = Capture "no" Int :&gt; Get '[JSON] Int
--          :&lt;|&gt; Get '[JSON] [Bool]
--   
--   api :: Proxy API
--   api = Proxy
--   
--   getInt :: Int -&gt; ClientM Int
--   getBools :: ClientM [Bool]
--   getInt :&lt;|&gt; getBools = client api
--   </pre>
client :: HasClient ClientM api => Proxy api -> Client ClientM api

-- | Change the monad the client functions live in, by supplying a
--   conversion function (a natural transformation to be precise).
--   
--   For example, assuming you have some <tt>manager ::
--   <tt>Manager</tt></tt> and <tt>baseurl :: <a>BaseUrl</a></tt> around:
--   
--   <pre>
--   type API = Get '[JSON] Int :&lt;|&gt; Capture "n" Int :&gt; Post '[JSON] Int
--   api :: Proxy API
--   api = Proxy
--   getInt :: IO Int
--   postInt :: Int -&gt; IO Int
--   getInt :&lt;|&gt; postInt = hoistClient api (flip runClientM cenv) (client api)
--     where cenv = mkClientEnv manager baseurl
--   </pre>
hoistClient :: HasClient ClientM api => Proxy api -> (forall a. m a -> n a) -> Client m api -> Client n api

-- | <tt>ClientM</tt> is the monad in which client functions run. Contains
--   the <a>Manager</a> and <a>BaseUrl</a> used for requests in the reader
--   environment.
newtype ClientM a
ClientM :: ReaderT ClientEnv (ExceptT ServantError IO) a -> ClientM a
[unClientM] :: ClientM a -> ReaderT ClientEnv (ExceptT ServantError IO) a
runClientM :: ClientM a -> ClientEnv -> IO (Either ServantError a)
performRequest :: Request -> ClientM Response
clientResponseToResponse :: Response a -> GenResponse a
requestToClientRequest :: BaseUrl -> Request -> Request
catchConnectionError :: IO a -> IO (Either ServantError a)
instance Control.Monad.Catch.MonadCatch Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Catch.MonadThrow Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Error.Class.MonadError Servant.Client.Core.Internal.Request.ServantError Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Reader.Class.MonadReader Servant.Client.Internal.HttpClient.ClientEnv Servant.Client.Internal.HttpClient.ClientM
instance GHC.Generics.Generic (Servant.Client.Internal.HttpClient.ClientM a)
instance Control.Monad.IO.Class.MonadIO Servant.Client.Internal.HttpClient.ClientM
instance GHC.Base.Monad Servant.Client.Internal.HttpClient.ClientM
instance GHC.Base.Applicative Servant.Client.Internal.HttpClient.ClientM
instance GHC.Base.Functor Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Base.MonadBase GHC.Types.IO Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO Servant.Client.Internal.HttpClient.ClientM
instance Data.Functor.Alt.Alt Servant.Client.Internal.HttpClient.ClientM
instance Servant.Client.Core.Internal.RunClient.RunClient Servant.Client.Internal.HttpClient.ClientM
instance Servant.Client.Core.Internal.Generic.ClientLike (Servant.Client.Internal.HttpClient.ClientM a) (Servant.Client.Internal.HttpClient.ClientM a)


-- | This module provides <a>client</a> which can automatically generate
--   querying functions for each endpoint just from the type representing
--   your API.
module Servant.Client

-- | Generates a set of client functions for an API.
--   
--   Example:
--   
--   <pre>
--   type API = Capture "no" Int :&gt; Get '[JSON] Int
--          :&lt;|&gt; Get '[JSON] [Bool]
--   
--   api :: Proxy API
--   api = Proxy
--   
--   getInt :: Int -&gt; ClientM Int
--   getBools :: ClientM [Bool]
--   getInt :&lt;|&gt; getBools = client api
--   </pre>
client :: HasClient ClientM api => Proxy api -> Client ClientM api

-- | <tt>ClientM</tt> is the monad in which client functions run. Contains
--   the <a>Manager</a> and <a>BaseUrl</a> used for requests in the reader
--   environment.
data ClientM a
runClientM :: ClientM a -> ClientEnv -> IO (Either ServantError a)

-- | The environment in which a request is run.
data ClientEnv
ClientEnv :: Manager -> BaseUrl -> Maybe (TVar CookieJar) -> ClientEnv
[manager] :: ClientEnv -> Manager
[baseUrl] :: ClientEnv -> BaseUrl
[cookieJar] :: ClientEnv -> Maybe (TVar CookieJar)

-- | <a>ClientEnv</a> smart constructor.
mkClientEnv :: Manager -> BaseUrl -> ClientEnv

-- | Change the monad the client functions live in, by supplying a
--   conversion function (a natural transformation to be precise).
--   
--   For example, assuming you have some <tt>manager ::
--   <tt>Manager</tt></tt> and <tt>baseurl :: <a>BaseUrl</a></tt> around:
--   
--   <pre>
--   type API = Get '[JSON] Int :&lt;|&gt; Capture "n" Int :&gt; Post '[JSON] Int
--   api :: Proxy API
--   api = Proxy
--   getInt :: IO Int
--   postInt :: Int -&gt; IO Int
--   getInt :&lt;|&gt; postInt = hoistClient api (flip runClientM cenv) (client api)
--     where cenv = mkClientEnv manager baseurl
--   </pre>
hoistClient :: HasClient ClientM api => Proxy api -> (forall a. m a -> n a) -> Client m api -> Client n api

module Servant.Client.Internal.HttpClient.Streaming

-- | <tt>ClientM</tt> is the monad in which client functions run. Contains
--   the <a>Manager</a> and <a>BaseUrl</a> used for requests in the reader
--   environment.
newtype ClientM a
ClientM :: ReaderT ClientEnv (ExceptT ServantError (Codensity IO)) a -> ClientM a
[unClientM] :: ClientM a -> ReaderT ClientEnv (ExceptT ServantError (Codensity IO)) a

-- | Generates a set of client functions for an API.
--   
--   Example:
--   
--   <pre>
--   type API = Capture "no" Int :&gt; Get '[JSON] Int
--          :&lt;|&gt; Get '[JSON] [Bool]
--   
--   api :: Proxy API
--   api = Proxy
--   
--   getInt :: Int -&gt; ClientM Int
--   getBools :: ClientM [Bool]
--   getInt :&lt;|&gt; getBools = client api
--   </pre>
client :: HasClient ClientM api => Proxy api -> Client ClientM api

-- | Change the monad the client functions live in, by supplying a
--   conversion function (a natural transformation to be precise).
--   
--   For example, assuming you have some <tt>manager ::
--   <tt>Manager</tt></tt> and <tt>baseurl :: <a>BaseUrl</a></tt> around:
--   
--   <pre>
--   type API = Get '[JSON] Int :&lt;|&gt; Capture "n" Int :&gt; Post '[JSON] Int
--   api :: Proxy API
--   api = Proxy
--   getInt :: IO Int
--   postInt :: Int -&gt; IO Int
--   getInt :&lt;|&gt; postInt = hoistClient api (flip runClientM cenv) (client api)
--     where cenv = mkClientEnv manager baseurl
--   </pre>
hoistClient :: HasClient ClientM api => Proxy api -> (forall a. m a -> n a) -> Client m api -> Client n api
withClientM :: ClientM a -> ClientEnv -> (Either ServantError a -> IO b) -> IO b

-- | A <a>runClientM</a> variant for streaming client.
--   
--   It allows using this module's <a>ClientM</a> in a direct style. The
--   <a>NFData</a> constraint however prevents using this function with
--   genuine streaming response types (<tt>SourceT</tt>, <tt>Conduit</tt>,
--   pipes <a>Proxy</a> or <tt>Machine</tt>). For those you have to use
--   <a>withClientM</a>.
--   
--   <i>Note:</i> we <a>force</a> the result, so the likehood of
--   accidentally leaking a connection is smaller. Use with care.
runClientM :: NFData a => ClientM a -> ClientEnv -> IO (Either ServantError a)
performRequest :: Request -> ClientM Response
performWithStreamingRequest :: Request -> (StreamingResponse -> IO a) -> ClientM a

-- | The environment in which a request is run.
data ClientEnv
ClientEnv :: Manager -> BaseUrl -> Maybe (TVar CookieJar) -> ClientEnv
[manager] :: ClientEnv -> Manager
[baseUrl] :: ClientEnv -> BaseUrl
[cookieJar] :: ClientEnv -> Maybe (TVar CookieJar)

-- | <a>ClientEnv</a> smart constructor.
mkClientEnv :: Manager -> BaseUrl -> ClientEnv
clientResponseToResponse :: Response a -> GenResponse a
requestToClientRequest :: BaseUrl -> Request -> Request
catchConnectionError :: IO a -> IO (Either ServantError a)
instance Control.Monad.Error.Class.MonadError Servant.Client.Core.Internal.Request.ServantError Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Control.Monad.Reader.Class.MonadReader Servant.Client.Internal.HttpClient.ClientEnv Servant.Client.Internal.HttpClient.Streaming.ClientM
instance GHC.Generics.Generic (Servant.Client.Internal.HttpClient.Streaming.ClientM a)
instance Control.Monad.IO.Class.MonadIO Servant.Client.Internal.HttpClient.Streaming.ClientM
instance GHC.Base.Monad Servant.Client.Internal.HttpClient.Streaming.ClientM
instance GHC.Base.Applicative Servant.Client.Internal.HttpClient.Streaming.ClientM
instance GHC.Base.Functor Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Control.Monad.Base.MonadBase GHC.Types.IO Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Data.Functor.Alt.Alt Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Servant.Client.Core.Internal.RunClient.RunClient Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Servant.Client.Core.Internal.RunClient.RunStreamingClient Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Servant.Client.Core.Internal.Generic.ClientLike (Servant.Client.Internal.HttpClient.Streaming.ClientM a) (Servant.Client.Internal.HttpClient.Streaming.ClientM a)


-- | This module provides <a>client</a> which can automatically generate
--   querying functions for each endpoint just from the type representing
--   your API.
--   
--   This client supports streaming operations.
module Servant.Client.Streaming

-- | Generates a set of client functions for an API.
--   
--   Example:
--   
--   <pre>
--   type API = Capture "no" Int :&gt; Get '[JSON] Int
--          :&lt;|&gt; Get '[JSON] [Bool]
--   
--   api :: Proxy API
--   api = Proxy
--   
--   getInt :: Int -&gt; ClientM Int
--   getBools :: ClientM [Bool]
--   getInt :&lt;|&gt; getBools = client api
--   </pre>
client :: HasClient ClientM api => Proxy api -> Client ClientM api

-- | <tt>ClientM</tt> is the monad in which client functions run. Contains
--   the <a>Manager</a> and <a>BaseUrl</a> used for requests in the reader
--   environment.
data ClientM a
withClientM :: ClientM a -> ClientEnv -> (Either ServantError a -> IO b) -> IO b

-- | A <a>runClientM</a> variant for streaming client.
--   
--   It allows using this module's <a>ClientM</a> in a direct style. The
--   <a>NFData</a> constraint however prevents using this function with
--   genuine streaming response types (<tt>SourceT</tt>, <tt>Conduit</tt>,
--   pipes <a>Proxy</a> or <tt>Machine</tt>). For those you have to use
--   <a>withClientM</a>.
--   
--   <i>Note:</i> we <a>force</a> the result, so the likehood of
--   accidentally leaking a connection is smaller. Use with care.
runClientM :: NFData a => ClientM a -> ClientEnv -> IO (Either ServantError a)

-- | The environment in which a request is run.
data ClientEnv
ClientEnv :: Manager -> BaseUrl -> Maybe (TVar CookieJar) -> ClientEnv
[manager] :: ClientEnv -> Manager
[baseUrl] :: ClientEnv -> BaseUrl
[cookieJar] :: ClientEnv -> Maybe (TVar CookieJar)

-- | <a>ClientEnv</a> smart constructor.
mkClientEnv :: Manager -> BaseUrl -> ClientEnv

-- | Change the monad the client functions live in, by supplying a
--   conversion function (a natural transformation to be precise).
--   
--   For example, assuming you have some <tt>manager ::
--   <tt>Manager</tt></tt> and <tt>baseurl :: <a>BaseUrl</a></tt> around:
--   
--   <pre>
--   type API = Get '[JSON] Int :&lt;|&gt; Capture "n" Int :&gt; Post '[JSON] Int
--   api :: Proxy API
--   api = Proxy
--   getInt :: IO Int
--   postInt :: Int -&gt; IO Int
--   getInt :&lt;|&gt; postInt = hoistClient api (flip runClientM cenv) (client api)
--     where cenv = mkClientEnv manager baseurl
--   </pre>
hoistClient :: HasClient ClientM api => Proxy api -> (forall a. m a -> n a) -> Client m api -> Client n api
