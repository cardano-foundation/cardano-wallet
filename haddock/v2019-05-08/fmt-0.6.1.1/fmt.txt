-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A new formatting library
--   
--   A new formatting library that tries to be simple to understand while
--   still being powerful and providing more convenience features than
--   other libraries (like functions for pretty-printing maps and lists, or
--   a function for printing arbitrary datatypes using generics).
--   
--   A comparison with other libraries:
--   
--   <ul>
--   <li><tt>printf</tt> (from <tt>Text.Printf</tt>) takes a formatting
--   string and uses some type tricks to accept the rest of the arguments
--   polyvariadically. It's very concise, but there are some drawbacks – it
--   can't produce <tt>Text</tt> (you'd have to <tt>T.pack</tt> it every
--   time) and it doesn't warn you at compile-time if you pass wrong
--   arguments or not enough of them.</li>
--   <li><a>text-format</a> takes a formatting string with curly braces
--   denoting places where arguments would be substituted (the arguments
--   themselves are provided via a tuple). If you want to apply formatting
--   to some of the arguments, you have to use one of the provided
--   formatters. Like <tt>printf</tt>, it can fail at runtime, but at least
--   the formatters are first-class (and you can add new ones).</li>
--   <li><a>formatting</a> takes a formatting template consisting of pieces
--   of strings interleaved with formatters; this ensures that arguments
--   always match their placeholders. <tt>formatting</tt> provides lots of
--   formatters and generally seems to be the most popular formatting
--   library here. Unfortunately, at least in my experience writing new
--   formatters can be awkward and people sometimes have troubles
--   understanding how <tt>formatting</tt> works.</li>
--   <li><a>fmt</a> (i.e. this library) provides formatters that are
--   ordinary functions, and a bunch of operators for concatenating
--   formatted strings; those operators also do automatic conversion. There
--   are some convenience formatters which aren't present in
--   <tt>formatting</tt> (like ones for formatting maps, lists, converting
--   to base64, etc). Some find the operator syntax annoying, while others
--   like it.</li>
--   </ul>
@package fmt
@version 0.6.1.1

module Fmt.Internal.Core
class FromBuilder a

-- | Convert a <a>Builder</a> to something else.
fromBuilder :: FromBuilder a => Builder -> a

-- | Concatenate, then convert.
(+|) :: FromBuilder b => Builder -> Builder -> b
infixr 1 +|

-- | <a>build</a> and concatenate, then convert.
(|+) :: (Buildable a, FromBuilder b) => a -> Builder -> b
infixr 1 |+

-- | Concatenate, then convert.
(+||) :: FromBuilder b => Builder -> Builder -> b
infixr 1 +||

-- | <a>show</a> and concatenate, then convert.
(||+) :: (Show a, FromBuilder b) => a -> Builder -> b
infixr 1 ||+
(|++|) :: (Buildable a, FromBuilder b) => a -> Builder -> b
infixr 1 |++|
(||++||) :: (Show a, FromBuilder b) => a -> Builder -> b
infixr 1 ||++||
(||++|) :: (Buildable a, FromBuilder b) => a -> Builder -> b
infixr 1 ||++|
(|++||) :: (Show a, FromBuilder b) => a -> Builder -> b
infixr 1 |++||

-- | <a>fmt</a> converts things to <a>String</a>, <a>Text</a>,
--   <a>ByteString</a> or <a>Builder</a>.
--   
--   Most of the time you won't need it, as strings produced with
--   (<a>+|</a>) and (<a>|+</a>) can already be used as <a>String</a>,
--   <a>Text</a>, etc. However, combinators like <tt>listF</tt> can only
--   produce <a>Builder</a> (for better type inference), and you need to
--   use <a>fmt</a> on them.
--   
--   Also, <a>fmt</a> can do printing:
--   
--   <pre>
--   &gt;&gt;&gt; fmt "Hello world!\n"
--   Hello world!
--   </pre>
fmt :: FromBuilder b => Builder -> b

-- | Like <a>fmt</a>, but appends a newline.
fmtLn :: FromBuilder b => Builder -> b

-- | <a>pretty</a> shows a value using its <a>Buildable</a> instance.
pretty :: (Buildable a, FromBuilder b) => a -> b

-- | Like <a>pretty</a>, but appends a newline.
prettyLn :: (Buildable a, FromBuilder b) => a -> b
instance Fmt.Internal.Core.FromBuilder Data.Text.Internal.Builder.Builder
instance (a Data.Type.Equality.~ GHC.Types.Char) => Fmt.Internal.Core.FromBuilder [a]
instance Fmt.Internal.Core.FromBuilder Data.Text.Internal.Text
instance Fmt.Internal.Core.FromBuilder Data.Text.Internal.Lazy.Text
instance Fmt.Internal.Core.FromBuilder Data.ByteString.Internal.ByteString
instance Fmt.Internal.Core.FromBuilder Data.ByteString.Lazy.Internal.ByteString
instance Fmt.Internal.Core.FromBuilder Data.ByteString.Builder.Internal.Builder
instance (a Data.Type.Equality.~ ()) => Fmt.Internal.Core.FromBuilder (GHC.Types.IO a)

module Fmt.Internal.Formatters

-- | Indent a block of text.
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ "This is a list:\n" &lt;&gt; indentF 4 (blockListF [1,2,3])
--   This is a list:
--       - 1
--       - 2
--       - 3
--   </pre>
--   
--   The output will always end with a newline, even when the input
--   doesn't.
indentF :: Int -> Builder -> Builder

-- | Add a prefix to the first line, and indent all lines but the first
--   one.
--   
--   The output will always end with a newline, even when the input
--   doesn't.
indentF' :: Int -> Text -> Builder -> Builder

-- | Attach a name to anything:
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ nameF "clients" $ blockListF ["Alice", "Bob", "Zalgo"]
--   clients:
--     - Alice
--     - Bob
--     - Zalgo
--   </pre>
nameF :: Builder -> Builder -> Builder

-- | Put spaces between elements.
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ unwordsF ["hello", "world"]
--   hello world
--   </pre>
--   
--   Of course, it works on anything <a>Buildable</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ unwordsF [1, 2]
--   1 2
--   </pre>
unwordsF :: (Foldable f, Buildable a) => f a -> Builder

-- | Arrange elements on separate lines.
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ unlinesF ["hello", "world"]
--   hello
--   world
--   </pre>
unlinesF :: (Foldable f, Buildable a) => f a -> Builder

-- | A simple comma-separated list formatter.
--   
--   <pre>
--   &gt;&gt;&gt; listF ["hello", "world"]
--   "[hello, world]"
--   </pre>
--   
--   For multiline output, use <a>jsonListF</a>.
listF :: (Foldable f, Buildable a) => f a -> Builder

-- | A version of <a>listF</a> that lets you supply your own building
--   function for list elements.
--   
--   For instance, to format a list of lists you'd have to do this (since
--   there's no <a>Buildable</a> instance for lists):
--   
--   <pre>
--   &gt;&gt;&gt; listF' listF [[1,2,3],[4,5,6]]
--   "[[1, 2, 3], [4, 5, 6]]"
--   </pre>
listF' :: Foldable f => (a -> Builder) -> f a -> Builder

-- | A multiline formatter for lists.
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ blockListF [1,2,3]
--   - 1
--   - 2
--   - 3
--   </pre>
--   
--   Multi-line elements are indented correctly:
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ blockListF ["hello\nworld", "foo\nbar\nquix"]
--   - hello
--     world
--   - foo
--     bar
--     quix
--   </pre>
blockListF :: forall f a. (Foldable f, Buildable a) => f a -> Builder

-- | A version of <a>blockListF</a> that lets you supply your own building
--   function for list elements (instead of <a>build</a>) and choose the
--   bullet character (instead of <tt>"-"</tt>).
blockListF' :: forall f a. Foldable f => Text -> (a -> Builder) -> f a -> Builder

-- | A JSON-style formatter for lists.
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ jsonListF [1,2,3]
--   [
--     1
--   , 2
--   , 3
--   ]
--   </pre>
--   
--   Like <a>blockListF</a>, it handles multiline elements well:
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ jsonListF ["hello\nworld", "foo\nbar\nquix"]
--   [
--     hello
--     world
--   , foo
--     bar
--     quix
--   ]
--   </pre>
jsonListF :: forall f a. (Foldable f, Buildable a) => f a -> Builder

-- | A version of <a>jsonListF</a> that lets you supply your own building
--   function for list elements.
jsonListF' :: forall f a. Foldable f => (a -> Builder) -> f a -> Builder

-- | A simple JSON-like map formatter; works for Map, HashMap, etc, as well
--   as ordinary lists of pairs.
--   
--   <pre>
--   &gt;&gt;&gt; mapF [("a", 1), ("b", 4)]
--   "{a: 1, b: 4}"
--   </pre>
--   
--   For multiline output, use <a>jsonMapF</a>.
mapF :: (IsList t, Item t ~ (k, v), Buildable k, Buildable v) => t -> Builder

-- | A version of <a>mapF</a> that lets you supply your own building
--   function for keys and values.
mapF' :: (IsList t, Item t ~ (k, v)) => (k -> Builder) -> (v -> Builder) -> t -> Builder

-- | A YAML-like map formatter:
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ blockMapF [("Odds", blockListF [1,3]), ("Evens", blockListF [2,4])]
--   Odds:
--     - 1
--     - 3
--   Evens:
--     - 2
--     - 4
--   </pre>
blockMapF :: (IsList t, Item t ~ (k, v), Buildable k, Buildable v) => t -> Builder

-- | A version of <a>blockMapF</a> that lets you supply your own building
--   function for keys and values.
blockMapF' :: (IsList t, Item t ~ (k, v)) => (k -> Builder) -> (v -> Builder) -> t -> Builder

-- | A JSON-like map formatter (unlike <a>mapF</a>, always multiline):
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ jsonMapF [("Odds", jsonListF [1,3]), ("Evens", jsonListF [2,4])]
--   {
--     Odds:
--       [
--         1
--       , 3
--       ]
--   , Evens:
--       [
--         2
--       , 4
--       ]
--   }
--   </pre>
jsonMapF :: (IsList t, Item t ~ (k, v), Buildable k, Buildable v) => t -> Builder

-- | A version of <a>jsonMapF</a> that lets you supply your own building
--   function for keys and values.
jsonMapF' :: forall t k v. (IsList t, Item t ~ (k, v)) => (k -> Builder) -> (v -> Builder) -> t -> Builder

-- | Like <a>build</a> for <a>Maybe</a>, but displays <a>Nothing</a> as
--   <tt>&lt;Nothing&gt;</tt> instead of an empty string.
--   
--   <a>build</a>:
--   
--   <pre>
--   &gt;&gt;&gt; build (Nothing :: Maybe Int)
--   ""
--   
--   &gt;&gt;&gt; build (Just 1 :: Maybe Int)
--   "1"
--   </pre>
--   
--   <a>maybeF</a>:
--   
--   <pre>
--   &gt;&gt;&gt; maybeF (Nothing :: Maybe Int)
--   "&lt;Nothing&gt;"
--   
--   &gt;&gt;&gt; maybeF (Just 1 :: Maybe Int)
--   "1"
--   </pre>
maybeF :: Buildable a => Maybe a -> Builder

-- | Format an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; eitherF (Right 1 :: Either Bool Int)
--   "&lt;Right: 1&gt;"
--   </pre>
eitherF :: (Buildable a, Buildable b) => Either a b -> Builder

-- | Take the first N characters:
--   
--   <pre>
--   &gt;&gt;&gt; prefixF 3 "hello"
--   "hel"
--   </pre>
prefixF :: Buildable a => Int -> a -> Builder

-- | Take the last N characters:
--   
--   <pre>
--   &gt;&gt;&gt; suffixF 3 "hello"
--   "llo"
--   </pre>
suffixF :: Buildable a => Int -> a -> Builder

-- | <tt>padLeftF n c</tt> pads the string with character <tt>c</tt> from
--   the left side until it becomes <tt>n</tt> characters wide (and does
--   nothing if the string is already that long, or longer):
--   
--   <pre>
--   &gt;&gt;&gt; padLeftF 5 '0' 12
--   "00012"
--   
--   &gt;&gt;&gt; padLeftF 5 '0' 123456
--   "123456"
--   </pre>
padLeftF :: Buildable a => Int -> Char -> a -> Builder

-- | <tt>padRightF n c</tt> pads the string with character <tt>c</tt> from
--   the right side until it becomes <tt>n</tt> characters wide (and does
--   nothing if the string is already that long, or longer):
--   
--   <pre>
--   &gt;&gt;&gt; padRightF 5 ' ' "foo"
--   "foo  "
--   
--   &gt;&gt;&gt; padRightF 5 ' ' "foobar"
--   "foobar"
--   </pre>
padRightF :: Buildable a => Int -> Char -> a -> Builder

-- | <tt>padBothF n c</tt> pads the string with character <tt>c</tt> from
--   both sides until it becomes <tt>n</tt> characters wide (and does
--   nothing if the string is already that long, or longer):
--   
--   <pre>
--   &gt;&gt;&gt; padBothF 5 '=' "foo"
--   "=foo="
--   
--   &gt;&gt;&gt; padBothF 5 '=' "foobar"
--   "foobar"
--   </pre>
--   
--   When padding can't be distributed equally, the left side is preferred:
--   
--   <pre>
--   &gt;&gt;&gt; padBothF 8 '=' "foo"
--   "===foo=="
--   </pre>
padBothF :: Buildable a => Int -> Char -> a -> Builder

-- | Display something only if the condition is <a>True</a> (empty string
--   otherwise).
--   
--   Note that it can only take a <a>Builder</a> (because otherwise it
--   would be unusable with (<a>+|</a>)-formatted strings which can resolve
--   to any <a>FromBuilder</a>). You can use <a>build</a> to convert any
--   value to a <a>Builder</a>.
whenF :: Bool -> Builder -> Builder

-- | Display something only if the condition is <a>False</a> (empty string
--   otherwise).
unlessF :: Bool -> Builder -> Builder

module Fmt.Internal.Numeric

-- | Format a number as octal:
--   
--   <pre>
--   &gt;&gt;&gt; listF' octF [7,8,9,10]
--   "[7, 10, 11, 12]"
--   </pre>
octF :: Integral a => a -> Builder

-- | Format a number as binary:
--   
--   <pre>
--   &gt;&gt;&gt; listF' binF [7,8,9,10]
--   "[111, 1000, 1001, 1010]"
--   </pre>
binF :: Integral a => a -> Builder

-- | Format a number in arbitrary base (up to 36):
--   
--   <pre>
--   &gt;&gt;&gt; baseF 3 10000
--   "111201101"
--   
--   &gt;&gt;&gt; baseF 7 10000
--   "41104"
--   
--   &gt;&gt;&gt; baseF 36 10000
--   "7ps"
--   </pre>
baseF :: (HasCallStack, Integral a) => Int -> a -> Builder

-- | Format a floating-point number:
--   
--   <pre>
--   &gt;&gt;&gt; floatF 3.1415
--   "3.1415"
--   </pre>
--   
--   Numbers smaller than 1e-6 or bigger-or-equal to 1e21 will be displayed
--   using scientific notation:
--   
--   <pre>
--   &gt;&gt;&gt; listF' floatF [1e-6,9e-7]
--   "[0.000001, 9.0e-7]"
--   
--   &gt;&gt;&gt; listF' floatF [9e20,1e21]
--   "[900000000000000000000.0, 1.0e21]"
--   </pre>
floatF :: Real a => a -> Builder

-- | Format a floating-point number using scientific notation, with the
--   given amount of decimal places.
--   
--   <pre>
--   &gt;&gt;&gt; listF' (exptF 5) [pi,0.1,10]
--   "[3.14159e0, 1.00000e-1, 1.00000e1]"
--   </pre>
exptF :: Real a => Int -> a -> Builder

-- | Format a floating-point number without scientific notation:
--   
--   <pre>
--   &gt;&gt;&gt; listF' (fixedF 5) [pi,0.1,10]
--   "[3.14159, 0.10000, 10.00000]"
--   </pre>
fixedF :: Real a => Int -> a -> Builder

-- | Break digits in a number:
--   
--   <pre>
--   &gt;&gt;&gt; commaizeF 15830000
--   "15,830,000"
--   </pre>
commaizeF :: (Buildable a, Integral a) => a -> Builder

-- | Add an ordinal suffix to a number:
--   
--   <pre>
--   &gt;&gt;&gt; ordinalF 15
--   "15th"
--   
--   &gt;&gt;&gt; ordinalF 22
--   "22nd"
--   </pre>
ordinalF :: (Buildable a, Integral a) => a -> Builder
groupInt :: (Buildable a, Integral a) => Int -> Char -> a -> Builder
atBase :: Integral a => Int -> a -> String
showSigned' :: Real a => (a -> ShowS) -> a -> ShowS
intToDigit' :: Int -> Char


-- | Old-style formatting a la <tt>text-format</tt>.
module Fmt.Internal.Template

-- | An old-style formatting function taken from <tt>text-format</tt> (see
--   <a>Data.Text.Format</a>). Unlike <a>format</a> from
--   <a>Data.Text.Format</a>, it can produce <a>String</a> and strict
--   <a>Text</a> as well (and print to console too). Also it's
--   polyvariadic:
--   
--   <pre>
--   &gt;&gt;&gt; format "{} + {} = {}" 2 2 4
--   2 + 2 = 4
--   </pre>
--   
--   You can use arbitrary formatters:
--   
--   <pre>
--   &gt;&gt;&gt; format "0x{} + 0x{} = 0x{}" (hexF 130) (hexF 270) (hexF (130+270))
--   0x82 + 0x10e = 0x190
--   </pre>
format :: (HasCallStack, FormatType r) => Format -> r

-- | Like <a>format</a>, but adds a newline.
formatLn :: (HasCallStack, FormatType r) => Format -> r

-- | A format string. This is intentionally incompatible with other string
--   types, to make it difficult to construct a format string by
--   concatenating string fragments (a very common way to accidentally make
--   code vulnerable to malicious data).
--   
--   This type is an instance of <a>IsString</a>, so the easiest way to
--   construct a query is to enable the <tt>OverloadedStrings</tt> language
--   extension and then simply write the query in double quotes.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Fmt
--   
--   f :: Format
--   f = "hello {}"
--   </pre>
--   
--   The underlying type is <a>Text</a>, so literal Haskell strings that
--   contain Unicode characters will be correctly handled.
newtype Format
Format :: Text -> Format
[fromFormat] :: Format -> Text

-- | Render a format string and arguments to a <a>Builder</a>.
renderFormat :: Format -> [Builder] -> Builder
zipParams :: [Builder] -> [Builder] -> Builder
crack :: Format -> [Builder]

-- | Something like <a>PrintfType</a> in <a>Text.Printf</a>.
class FormatType r
format' :: FormatType r => Format -> [Builder] -> r
instance GHC.Show.Show Fmt.Internal.Template.Format
instance GHC.Classes.Ord Fmt.Internal.Template.Format
instance GHC.Classes.Eq Fmt.Internal.Template.Format
instance (Formatting.Buildable.Buildable a, Fmt.Internal.Template.FormatType r) => Fmt.Internal.Template.FormatType (a -> r)
instance Fmt.Internal.Core.FromBuilder r => Fmt.Internal.Template.FormatType r
instance GHC.Base.Semigroup Fmt.Internal.Template.Format
instance GHC.Base.Monoid Fmt.Internal.Template.Format
instance Data.String.IsString Fmt.Internal.Template.Format

module Fmt.Internal.Tuple
class TupleF a

-- | Format a tuple (of up to 8 elements):
--   
--   <pre>
--   &gt;&gt;&gt; tupleF (1,2,"hi")
--   "(1, 2, hi)"
--   </pre>
--   
--   If any of the elements takes several lines, an alternate format is
--   used:
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ tupleF ("test","foo\nbar","more test")
--   ( test
--   ,
--     foo
--     bar
--   ,
--     more test )
--   </pre>
--   
--   You can also use <a>tupleF</a> on lists to get tuple-like formatting.
tupleF :: TupleF a => a -> Builder
instance (Formatting.Buildable.Buildable a1, Formatting.Buildable.Buildable a2) => Fmt.Internal.Tuple.TupleF (a1, a2)
instance (Formatting.Buildable.Buildable a1, Formatting.Buildable.Buildable a2, Formatting.Buildable.Buildable a3) => Fmt.Internal.Tuple.TupleF (a1, a2, a3)
instance (Formatting.Buildable.Buildable a1, Formatting.Buildable.Buildable a2, Formatting.Buildable.Buildable a3, Formatting.Buildable.Buildable a4) => Fmt.Internal.Tuple.TupleF (a1, a2, a3, a4)
instance (Formatting.Buildable.Buildable a1, Formatting.Buildable.Buildable a2, Formatting.Buildable.Buildable a3, Formatting.Buildable.Buildable a4, Formatting.Buildable.Buildable a5) => Fmt.Internal.Tuple.TupleF (a1, a2, a3, a4, a5)
instance (Formatting.Buildable.Buildable a1, Formatting.Buildable.Buildable a2, Formatting.Buildable.Buildable a3, Formatting.Buildable.Buildable a4, Formatting.Buildable.Buildable a5, Formatting.Buildable.Buildable a6) => Fmt.Internal.Tuple.TupleF (a1, a2, a3, a4, a5, a6)
instance (Formatting.Buildable.Buildable a1, Formatting.Buildable.Buildable a2, Formatting.Buildable.Buildable a3, Formatting.Buildable.Buildable a4, Formatting.Buildable.Buildable a5, Formatting.Buildable.Buildable a6, Formatting.Buildable.Buildable a7) => Fmt.Internal.Tuple.TupleF (a1, a2, a3, a4, a5, a6, a7)
instance (Formatting.Buildable.Buildable a1, Formatting.Buildable.Buildable a2, Formatting.Buildable.Buildable a3, Formatting.Buildable.Buildable a4, Formatting.Buildable.Buildable a5, Formatting.Buildable.Buildable a6, Formatting.Buildable.Buildable a7, Formatting.Buildable.Buildable a8) => Fmt.Internal.Tuple.TupleF (a1, a2, a3, a4, a5, a6, a7, a8)
instance Formatting.Buildable.Buildable a => Fmt.Internal.Tuple.TupleF [a]
instance Fmt.Internal.Tuple.TupleF [Data.Text.Internal.Builder.Builder]

module Fmt.Internal.Generic

-- | Format an arbitrary value without requiring a <a>Buildable</a>
--   instance:
--   
--   <pre>
--   &gt;&gt;&gt; data Foo = Foo { x :: Bool, y :: [Int] } deriving Generic
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fmt (genericF (Foo True [1,2,3]))
--   Foo:
--     x: True
--     y: [1, 2, 3]
--   </pre>
--   
--   It works for non-record constructors too:
--   
--   <pre>
--   &gt;&gt;&gt; data Bar = Bar Bool [Int] deriving Generic
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fmtLn (genericF (Bar True [1,2,3]))
--   &lt;Bar: True, [1, 2, 3]&gt;
--   </pre>
--   
--   Any fields inside the type must either be <a>Buildable</a> or one of
--   the following types:
--   
--   <ul>
--   <li>a function</li>
--   <li>a tuple (up to 8-tuples)</li>
--   <li>list, <a>NonEmpty</a>, <a>Seq</a></li>
--   <li><a>Map</a>, <a>IntMap</a>, <a>Set</a>, <a>IntSet</a></li>
--   <li><a>Maybe</a>, <a>Either</a></li>
--   </ul>
--   
--   The exact format of <a>genericF</a> might change in future versions,
--   so don't rely on it. It's merely a convenience function.
genericF :: (Generic a, GBuildable (Rep a)) => a -> Builder
class GBuildable f
gbuild :: GBuildable f => f a -> Builder

-- | A more powerful <a>Buildable</a> used for <a>genericF</a>. Can build
--   functions, tuples, lists, maps, etc., as well as combinations thereof.
class Buildable' a
build' :: Buildable' a => a -> Builder
class GetFields f

-- | Get fields, together with their names if available
getFields :: GetFields f => f a -> [(String, Builder)]
instance (Fmt.Internal.Generic.GetFields a, GHC.Generics.Constructor c) => Fmt.Internal.Generic.GBuildable (GHC.Generics.M1 GHC.Generics.C c a)
instance (Fmt.Internal.Generic.GetFields a, Fmt.Internal.Generic.GetFields b) => Fmt.Internal.Generic.GetFields (a GHC.Generics.:*: b)
instance (Fmt.Internal.Generic.GBuildable a, GHC.Generics.Selector c) => Fmt.Internal.Generic.GetFields (GHC.Generics.M1 GHC.Generics.S c a)
instance Fmt.Internal.Generic.GBuildable a => Fmt.Internal.Generic.GetFields (GHC.Generics.M1 GHC.Generics.D c a)
instance Fmt.Internal.Generic.GBuildable a => Fmt.Internal.Generic.GetFields (GHC.Generics.M1 GHC.Generics.C c a)
instance Fmt.Internal.Generic.GetFields GHC.Generics.U1
instance Fmt.Internal.Generic.Buildable' c => Fmt.Internal.Generic.GBuildable (GHC.Generics.K1 i c)
instance Fmt.Internal.Generic.Buildable' ()
instance (Fmt.Internal.Generic.Buildable' a1, Fmt.Internal.Generic.Buildable' a2) => Fmt.Internal.Generic.Buildable' (a1, a2)
instance (Fmt.Internal.Generic.Buildable' a1, Fmt.Internal.Generic.Buildable' a2, Fmt.Internal.Generic.Buildable' a3) => Fmt.Internal.Generic.Buildable' (a1, a2, a3)
instance (Fmt.Internal.Generic.Buildable' a1, Fmt.Internal.Generic.Buildable' a2, Fmt.Internal.Generic.Buildable' a3, Fmt.Internal.Generic.Buildable' a4) => Fmt.Internal.Generic.Buildable' (a1, a2, a3, a4)
instance (Fmt.Internal.Generic.Buildable' a1, Fmt.Internal.Generic.Buildable' a2, Fmt.Internal.Generic.Buildable' a3, Fmt.Internal.Generic.Buildable' a4, Fmt.Internal.Generic.Buildable' a5) => Fmt.Internal.Generic.Buildable' (a1, a2, a3, a4, a5)
instance (Fmt.Internal.Generic.Buildable' a1, Fmt.Internal.Generic.Buildable' a2, Fmt.Internal.Generic.Buildable' a3, Fmt.Internal.Generic.Buildable' a4, Fmt.Internal.Generic.Buildable' a5, Fmt.Internal.Generic.Buildable' a6) => Fmt.Internal.Generic.Buildable' (a1, a2, a3, a4, a5, a6)
instance (Fmt.Internal.Generic.Buildable' a1, Fmt.Internal.Generic.Buildable' a2, Fmt.Internal.Generic.Buildable' a3, Fmt.Internal.Generic.Buildable' a4, Fmt.Internal.Generic.Buildable' a5, Fmt.Internal.Generic.Buildable' a6, Fmt.Internal.Generic.Buildable' a7) => Fmt.Internal.Generic.Buildable' (a1, a2, a3, a4, a5, a6, a7)
instance (Fmt.Internal.Generic.Buildable' a1, Fmt.Internal.Generic.Buildable' a2, Fmt.Internal.Generic.Buildable' a3, Fmt.Internal.Generic.Buildable' a4, Fmt.Internal.Generic.Buildable' a5, Fmt.Internal.Generic.Buildable' a6, Fmt.Internal.Generic.Buildable' a7, Fmt.Internal.Generic.Buildable' a8) => Fmt.Internal.Generic.Buildable' (a1, a2, a3, a4, a5, a6, a7, a8)
instance Fmt.Internal.Generic.Buildable' [GHC.Types.Char]
instance Fmt.Internal.Generic.Buildable' a => Fmt.Internal.Generic.Buildable' [a]
instance Fmt.Internal.Generic.Buildable' a => Fmt.Internal.Generic.Buildable' (GHC.Base.NonEmpty a)
instance Fmt.Internal.Generic.Buildable' a => Fmt.Internal.Generic.Buildable' (Data.Sequence.Internal.Seq a)
instance (Fmt.Internal.Generic.Buildable' k, Fmt.Internal.Generic.Buildable' v) => Fmt.Internal.Generic.Buildable' (Data.Map.Internal.Map k v)
instance Fmt.Internal.Generic.Buildable' v => Fmt.Internal.Generic.Buildable' (Data.Set.Internal.Set v)
instance Fmt.Internal.Generic.Buildable' v => Fmt.Internal.Generic.Buildable' (Data.IntMap.Internal.IntMap v)
instance Fmt.Internal.Generic.Buildable' Data.IntSet.Internal.IntSet
instance Fmt.Internal.Generic.Buildable' a => Fmt.Internal.Generic.Buildable' (GHC.Maybe.Maybe a)
instance (Fmt.Internal.Generic.Buildable' a, Fmt.Internal.Generic.Buildable' b) => Fmt.Internal.Generic.Buildable' (Data.Either.Either a b)
instance Fmt.Internal.Generic.Buildable' (a -> b)
instance Formatting.Buildable.Buildable a => Fmt.Internal.Generic.Buildable' a
instance (Fmt.Internal.Generic.GBuildable a, Fmt.Internal.Generic.GBuildable b) => Fmt.Internal.Generic.GBuildable (a GHC.Generics.:+: b)
instance Fmt.Internal.Generic.GBuildable a => Fmt.Internal.Generic.GBuildable (GHC.Generics.M1 GHC.Generics.D d a)


-- | A module providing access to internals (in case you really need them).
--   Can change at any time, though probably won't.
module Fmt.Internal
class FormatAsHex a

-- | Format a number or bytestring as hex:
--   
--   <pre>
--   &gt;&gt;&gt; hexF 3635
--   "e33"
--   
--   &gt;&gt;&gt; hexF ("\0\50\63\80" :: BS.ByteString)
--   "00323f50"
--   </pre>
hexF :: FormatAsHex a => a -> Builder
class FormatAsBase64 a

-- | Convert a bytestring to base64:
--   
--   <pre>
--   &gt;&gt;&gt; base64F ("\0\50\63\80" :: BS.ByteString)
--   "ADI/UA=="
--   </pre>
base64F :: FormatAsBase64 a => a -> Builder

-- | Convert a bytestring to base64url (a variant of base64 which omits
--   <tt>/</tt> and thus can be used in URLs):
--   
--   <pre>
--   &gt;&gt;&gt; base64UrlF ("\0\50\63\80" :: BS.ByteString)
--   "ADI_UA=="
--   </pre>
base64UrlF :: FormatAsBase64 a => a -> Builder
instance Fmt.Internal.FormatAsBase64 Data.ByteString.Internal.ByteString
instance Fmt.Internal.FormatAsBase64 Data.ByteString.Lazy.Internal.ByteString
instance Fmt.Internal.FormatAsHex Data.ByteString.Internal.ByteString
instance Fmt.Internal.FormatAsHex Data.ByteString.Lazy.Internal.ByteString
instance GHC.Real.Integral a => Fmt.Internal.FormatAsHex a


-- | Formatters for various time types. This module copies the structure of
--   <tt><a>Formatting.Time</a></tt> from the <tt><a>formatting</a></tt>
--   package.
--   
--   Most of the time you'll want to use one of these formatters (all of
--   the examples below use <tt>"2018-02-14 16:20:45.5 CST"</tt>):
--   
--   <ul>
--   <li><a>dateTimeF</a> – full date and time:<pre>&gt;&gt;&gt; dateTimeF
--   t "Wed Feb 14 16:20:45 CST 2018" </pre></li>
--   <li><a>hmF</a> – hours and minutes:<pre>&gt;&gt;&gt; hmF t "16:20"
--   </pre></li>
--   <li><a>hmsF</a> – hours, minutes and seconds:<pre>&gt;&gt;&gt; hmsF t
--   "16:20:45" </pre></li>
--   <li><a>dateDashF</a> – date in ISO 8601 format:<pre>&gt;&gt;&gt;
--   dateDashF t "2018-02-14" </pre></li>
--   <li><a>diffF</a> – either a time period or a point in time, in a
--   convenient for humans format:<pre>&gt;&gt;&gt; diffF False 130 -- time
--   period (130 seconds) "2 minutes" &gt;&gt;&gt; diffF True 130 -- point
--   in time (130 seconds in the future) "in 2 minutes" </pre></li>
--   </ul>
--   
--   Note that two formatters from <tt>Formatting.Time</tt> are called
--   differently here:
--   
--   <pre>
--   pico     -&gt; <a>picosecondF</a>
--   decimals -&gt; <a>subsecondF</a>
--   </pre>
module Fmt.Time

-- | Format time with an arbitrary formatting string. Other formatters in
--   this module are implemented using <a>timeF</a>.
timeF :: FormatTime a => Text -> a -> Builder

-- | Timezone offset on the format <tt>-HHMM</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; t
--   2018-02-14 16:20:45.5 CST
--   
--   &gt;&gt;&gt; tzF t
--   "-0600"
--   </pre>
tzF :: FormatTime a => a -> Builder

-- | Timezone name.
--   
--   <pre>
--   &gt;&gt;&gt; tzNameF t
--   "CST"
--   </pre>
tzNameF :: FormatTime a => a -> Builder

-- | As <a>dateTimeFmt</a> <tt>locale</tt> (e.g. <tt>%a %b %e %H:%M:%S %Z
--   %Y</tt>).
--   
--   <pre>
--   &gt;&gt;&gt; dateTimeF t
--   "Wed Feb 14 16:20:45 CST 2018"
--   </pre>
dateTimeF :: FormatTime a => a -> Builder

-- | Same as <tt>%H:%M</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; hmF t
--   "16:20"
--   </pre>
hmF :: FormatTime a => a -> Builder

-- | Same as <tt>%H:%M:%S</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; hmsF t
--   "16:20:45"
--   </pre>
hmsF :: FormatTime a => a -> Builder

-- | As <a>timeFmt</a> <tt>locale</tt> (e.g. <tt>%H:%M:%S</tt>).
--   
--   <pre>
--   &gt;&gt;&gt; hmsLF t
--   "16:20:45"
--   </pre>
hmsLF :: FormatTime a => a -> Builder

-- | As <a>time12Fmt</a> <tt>locale</tt> (e.g. <tt>%I:%M:%S %p</tt>).
--   
--   <pre>
--   &gt;&gt;&gt; hmsPLF t
--   "04:20:45 PM"
--   </pre>
hmsPLF :: FormatTime a => a -> Builder

-- | Day half from (<a>amPm</a> <tt>locale</tt>), converted to lowercase,
--   <tt>am</tt>, <tt>pm</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dayHalfF t
--   "pm"
--   </pre>
dayHalfF :: FormatTime a => a -> Builder

-- | Day half from (<a>amPm</a> <tt>locale</tt>), <tt>AM</tt>, <tt>PM</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dayHalfUF t
--   "PM"
--   </pre>
dayHalfUF :: FormatTime a => a -> Builder

-- | Hour, 24-hour, leading 0 as needed, <tt>00</tt> - <tt>23</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; hour24F t
--   "16"
--   
--   &gt;&gt;&gt; hour24F midnight
--   "00"
--   </pre>
hour24F :: FormatTime a => a -> Builder

-- | Hour, 12-hour, leading 0 as needed, <tt>01</tt> - <tt>12</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; hour12F t
--   "04"
--   
--   &gt;&gt;&gt; hour12F midnight
--   "12"
--   </pre>
hour12F :: FormatTime a => a -> Builder

-- | Hour, 24-hour, leading space as needed, <tt> 0</tt> - <tt>23</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; hour24SF t
--   "16"
--   
--   &gt;&gt;&gt; hour24SF midnight
--   " 0"
--   </pre>
hour24SF :: FormatTime a => a -> Builder

-- | Hour, 12-hour, leading space as needed, <tt> 1</tt> - <tt>12</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; hour12SF t
--   " 4"
--   
--   &gt;&gt;&gt; hour12SF midnight
--   "12"
--   </pre>
hour12SF :: FormatTime a => a -> Builder

-- | Minute, <tt>00</tt> - <tt>59</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; minuteF t
--   "20"
--   </pre>
minuteF :: FormatTime a => a -> Builder

-- | Second, without decimal part, <tt>00</tt> - <tt>60</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; secondF t
--   "45"
--   </pre>
secondF :: FormatTime a => a -> Builder

-- | Picosecond, including trailing zeros, <tt>000000000000</tt> -
--   <tt>999999999999</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; picosecondF t
--   "500000000000"
--   </pre>
picosecondF :: FormatTime a => a -> Builder

-- | Decimal point of the second. Up to 12 digits, without trailing zeros.
--   For a whole number of seconds, this produces an empty string.
--   
--   <pre>
--   &gt;&gt;&gt; subsecondF t
--   ".5"
--   </pre>
subsecondF :: FormatTime a => a -> Builder

-- | Number of whole seconds since the Unix epoch. For times before the
--   Unix epoch, this is a negative number. Note that in <tt>%s.%q</tt> and
--   <tt>%s%Q</tt> the decimals are positive, not negative. For example,
--   0.9 seconds before the Unix epoch is formatted as <tt>-1.1</tt> with
--   <tt>%s%Q</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; epochF t
--   "1518646845"
--   </pre>
epochF :: FormatTime a => a -> Builder

-- | Same as <tt>%m/%d/%y</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dateSlashF t
--   "02/14/18"
--   </pre>
dateSlashF :: FormatTime a => a -> Builder

-- | Same as <tt>%Y-%m-%d</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dateDashF t
--   "2018-02-14"
--   </pre>
dateDashF :: FormatTime a => a -> Builder

-- | As <a>dateFmt</a> <tt>locale</tt> (e.g. <tt>%m/%d/%y</tt>).
--   
--   <pre>
--   &gt;&gt;&gt; dateSlashLF t
--   "02/14/18"
--   </pre>
dateSlashLF :: FormatTime a => a -> Builder

-- | Year.
--   
--   <pre>
--   &gt;&gt;&gt; yearF t
--   "2018"
--   </pre>
yearF :: FormatTime a => a -> Builder

-- | Last two digits of year, <tt>00</tt> - <tt>99</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; yyF t
--   "18"
--   </pre>
yyF :: FormatTime a => a -> Builder

-- | Century (being the first two digits of the year), <tt>00</tt> -
--   <tt>99</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; centuryF t
--   "20"
--   </pre>
centuryF :: FormatTime a => a -> Builder

-- | Month name, long form (<a>fst</a> from <a>months</a> <tt>locale</tt>),
--   <tt>January</tt> - <tt>December</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; monthNameF t
--   "February"
--   </pre>
monthNameF :: FormatTime a => a -> Builder

-- | Month name, short form (<a>snd</a> from <a>months</a>
--   <tt>locale</tt>), <tt>Jan</tt> - <tt>Dec</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; monthNameShortF t
--   "Feb"
--   </pre>
monthNameShortF :: FormatTime a => a -> Builder

-- | Month of year, leading 0 as needed, <tt>01</tt> - <tt>12</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; monthF t
--   "02"
--   </pre>
monthF :: FormatTime a => a -> Builder

-- | Day of month, leading 0 as needed, <tt>01</tt> - <tt>31</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dayOfMonthF t
--   "14"
--   </pre>
dayOfMonthF :: FormatTime a => a -> Builder

-- | Day of month, <tt>1st</tt>, <tt>2nd</tt>, <tt>25th</tt>, etc.
--   
--   <pre>
--   &gt;&gt;&gt; dayOfMonthOrdF t
--   "14th"
--   </pre>
dayOfMonthOrdF :: FormatTime a => a -> Builder

-- | Day of month, leading space as needed, <tt> 1</tt> - <tt>31</tt>.
dayOfMonthSF :: FormatTime a => a -> Builder

-- | Day of year for Ordinal Date format, <tt>001</tt> - <tt>366</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dayF t
--   "045"
--   </pre>
dayF :: FormatTime a => a -> Builder

-- | Year for Week Date format e.g. <tt>2013</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; weekYearF t
--   "2018"
--   </pre>
weekYearF :: FormatTime a => a -> Builder

-- | Last two digits of year for Week Date format, <tt>00</tt> -
--   <tt>99</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; weekYYF t
--   "18"
--   </pre>
weekYYF :: FormatTime a => a -> Builder

-- | Century (first two digits of year) for Week Date format, <tt>00</tt> -
--   <tt>99</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; weekCenturyF t
--   "20"
--   </pre>
weekCenturyF :: FormatTime a => a -> Builder

-- | Week for Week Date format, <tt>01</tt> - <tt>53</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; weekF t
--   "07"
--   </pre>
weekF :: FormatTime a => a -> Builder

-- | Day for Week Date format, <tt>1</tt> - <tt>7</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dayOfWeekF t
--   "3"
--   </pre>
dayOfWeekF :: FormatTime a => a -> Builder

-- | Day of week, short form (<a>snd</a> from <a>wDays</a>
--   <tt>locale</tt>), <tt>Sun</tt> - <tt>Sat</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dayNameShortF t
--   "Wed"
--   </pre>
dayNameShortF :: FormatTime a => a -> Builder

-- | Day of week, long form (<a>fst</a> from <a>wDays</a> <tt>locale</tt>),
--   <tt>Sunday</tt> - <tt>Saturday</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dayNameF t
--   "Wednesday"
--   </pre>
dayNameF :: FormatTime a => a -> Builder

-- | Week number of year, where weeks start on Sunday (as
--   <tt>sundayStartWeek</tt>), <tt>00</tt> - <tt>53</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; weekFromZeroF t
--   "06"
--   </pre>
weekFromZeroF :: FormatTime a => a -> Builder

-- | Day of week number, <tt>0</tt> (= Sunday) - <tt>6</tt> (= Saturday).
--   
--   <pre>
--   &gt;&gt;&gt; dayOfWeekFromZeroF t
--   "3"
--   </pre>
dayOfWeekFromZeroF :: FormatTime a => a -> Builder

-- | Week number of year, where weeks start on Monday (as
--   <tt>mondayStartWeek</tt>), <tt>00</tt> - <tt>53</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; weekOfYearMonF t
--   "07"
--   </pre>
weekOfYearMonF :: FormatTime a => a -> Builder

-- | Display a time span as one time relative to another. Input is assumed
--   to be seconds. Typical inputs are <a>NominalDiffTime</a> and
--   <a>DiffTime</a>.
--   
--   <pre>
--   &gt;&gt;&gt; diffF False 100
--   "a minute"
--   
--   &gt;&gt;&gt; diffF True 100
--   "in a minute"
--   </pre>
diffF :: forall n. RealFrac n => Bool -> n -> Builder

-- | Display the absolute value time span in years.
--   
--   <pre>
--   &gt;&gt;&gt; epochF t    -- time passed since Jan 1, 1970
--   "1518646845"
--   
--   &gt;&gt;&gt; yearsF 3 1518646845
--   "48.156"
--   </pre>
yearsF :: RealFrac n => Int -> n -> Builder

-- | Display the absolute value time span in days.
--   
--   <pre>
--   &gt;&gt;&gt; daysF 3 1518646845
--   "17576.931"
--   </pre>
daysF :: RealFrac n => Int -> n -> Builder

-- | Display the absolute value time span in hours.
--   
--   <pre>
--   &gt;&gt;&gt; hoursF 3 3600
--   "1.000"
--   </pre>
hoursF :: RealFrac n => Int -> n -> Builder

-- | Display the absolute value time span in minutes.
--   
--   <pre>
--   &gt;&gt;&gt; minutesF 3 150
--   "2.500"
--   </pre>
minutesF :: RealFrac n => Int -> n -> Builder

-- | Display the absolute value time span in seconds.
--   
--   <pre>
--   &gt;&gt;&gt; secondsF 3 100
--   "100.000"
--   </pre>
secondsF :: RealFrac n => Int -> n -> Builder

module Fmt

-- | Concatenate, then convert.
(+|) :: FromBuilder b => Builder -> Builder -> b
infixr 1 +|

-- | <a>build</a> and concatenate, then convert.
(|+) :: (Buildable a, FromBuilder b) => a -> Builder -> b
infixr 1 |+

-- | Concatenate, then convert.
(+||) :: FromBuilder b => Builder -> Builder -> b
infixr 1 +||

-- | <a>show</a> and concatenate, then convert.
(||+) :: (Show a, FromBuilder b) => a -> Builder -> b
infixr 1 ||+
(|++|) :: (Buildable a, FromBuilder b) => a -> Builder -> b
infixr 1 |++|
(||++||) :: (Show a, FromBuilder b) => a -> Builder -> b
infixr 1 ||++||
(|++||) :: (Show a, FromBuilder b) => a -> Builder -> b
infixr 1 |++||
(||++|) :: (Buildable a, FromBuilder b) => a -> Builder -> b
infixr 1 ||++|

-- | An old-style formatting function taken from <tt>text-format</tt> (see
--   <a>Data.Text.Format</a>). Unlike <a>format</a> from
--   <a>Data.Text.Format</a>, it can produce <a>String</a> and strict
--   <a>Text</a> as well (and print to console too). Also it's
--   polyvariadic:
--   
--   <pre>
--   &gt;&gt;&gt; format "{} + {} = {}" 2 2 4
--   2 + 2 = 4
--   </pre>
--   
--   You can use arbitrary formatters:
--   
--   <pre>
--   &gt;&gt;&gt; format "0x{} + 0x{} = 0x{}" (hexF 130) (hexF 270) (hexF (130+270))
--   0x82 + 0x10e = 0x190
--   </pre>
format :: (HasCallStack, FormatType r) => Format -> r

-- | Like <a>format</a>, but adds a newline.
formatLn :: (HasCallStack, FormatType r) => Format -> r

-- | A format string. This is intentionally incompatible with other string
--   types, to make it difficult to construct a format string by
--   concatenating string fragments (a very common way to accidentally make
--   code vulnerable to malicious data).
--   
--   This type is an instance of <a>IsString</a>, so the easiest way to
--   construct a query is to enable the <tt>OverloadedStrings</tt> language
--   extension and then simply write the query in double quotes.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Fmt
--   
--   f :: Format
--   f = "hello {}"
--   </pre>
--   
--   The underlying type is <a>Text</a>, so literal Haskell strings that
--   contain Unicode characters will be correctly handled.
data Format

-- | <a>fmt</a> converts things to <a>String</a>, <a>Text</a>,
--   <a>ByteString</a> or <a>Builder</a>.
--   
--   Most of the time you won't need it, as strings produced with
--   (<a>+|</a>) and (<a>|+</a>) can already be used as <a>String</a>,
--   <a>Text</a>, etc. However, combinators like <tt>listF</tt> can only
--   produce <a>Builder</a> (for better type inference), and you need to
--   use <a>fmt</a> on them.
--   
--   Also, <a>fmt</a> can do printing:
--   
--   <pre>
--   &gt;&gt;&gt; fmt "Hello world!\n"
--   Hello world!
--   </pre>
fmt :: FromBuilder b => Builder -> b

-- | Like <a>fmt</a>, but appends a newline.
fmtLn :: FromBuilder b => Builder -> b

-- | <a>pretty</a> shows a value using its <a>Buildable</a> instance.
pretty :: (Buildable a, FromBuilder b) => a -> b

-- | Like <a>pretty</a>, but appends a newline.
prettyLn :: (Buildable a, FromBuilder b) => a -> b

-- | A <tt>Builder</tt> is an efficient way to build lazy <tt>Text</tt>
--   values. There are several functions for constructing builders, but
--   only one to inspect them: to extract any data, you have to turn them
--   into lazy <tt>Text</tt> values using <tt>toLazyText</tt>.
--   
--   Internally, a builder constructs a lazy <tt>Text</tt> by filling
--   arrays piece by piece. As each buffer is filled, it is 'popped' off,
--   to become a new chunk of the resulting lazy <tt>Text</tt>. All this is
--   hidden from the user of the <tt>Builder</tt>.
data Builder

-- | The class of types that can be rendered to a <a>Builder</a>.
class Buildable p
build :: Buildable p => p -> Builder

-- | Indent a block of text.
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ "This is a list:\n" &lt;&gt; indentF 4 (blockListF [1,2,3])
--   This is a list:
--       - 1
--       - 2
--       - 3
--   </pre>
--   
--   The output will always end with a newline, even when the input
--   doesn't.
indentF :: Int -> Builder -> Builder

-- | Add a prefix to the first line, and indent all lines but the first
--   one.
--   
--   The output will always end with a newline, even when the input
--   doesn't.
indentF' :: Int -> Text -> Builder -> Builder

-- | Attach a name to anything:
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ nameF "clients" $ blockListF ["Alice", "Bob", "Zalgo"]
--   clients:
--     - Alice
--     - Bob
--     - Zalgo
--   </pre>
nameF :: Builder -> Builder -> Builder

-- | Put spaces between elements.
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ unwordsF ["hello", "world"]
--   hello world
--   </pre>
--   
--   Of course, it works on anything <a>Buildable</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ unwordsF [1, 2]
--   1 2
--   </pre>
unwordsF :: (Foldable f, Buildable a) => f a -> Builder

-- | Arrange elements on separate lines.
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ unlinesF ["hello", "world"]
--   hello
--   world
--   </pre>
unlinesF :: (Foldable f, Buildable a) => f a -> Builder

-- | A simple comma-separated list formatter.
--   
--   <pre>
--   &gt;&gt;&gt; listF ["hello", "world"]
--   "[hello, world]"
--   </pre>
--   
--   For multiline output, use <a>jsonListF</a>.
listF :: (Foldable f, Buildable a) => f a -> Builder

-- | A version of <a>listF</a> that lets you supply your own building
--   function for list elements.
--   
--   For instance, to format a list of lists you'd have to do this (since
--   there's no <a>Buildable</a> instance for lists):
--   
--   <pre>
--   &gt;&gt;&gt; listF' listF [[1,2,3],[4,5,6]]
--   "[[1, 2, 3], [4, 5, 6]]"
--   </pre>
listF' :: Foldable f => (a -> Builder) -> f a -> Builder

-- | A multiline formatter for lists.
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ blockListF [1,2,3]
--   - 1
--   - 2
--   - 3
--   </pre>
--   
--   Multi-line elements are indented correctly:
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ blockListF ["hello\nworld", "foo\nbar\nquix"]
--   - hello
--     world
--   - foo
--     bar
--     quix
--   </pre>
blockListF :: forall f a. (Foldable f, Buildable a) => f a -> Builder

-- | A version of <a>blockListF</a> that lets you supply your own building
--   function for list elements (instead of <a>build</a>) and choose the
--   bullet character (instead of <tt>"-"</tt>).
blockListF' :: forall f a. Foldable f => Text -> (a -> Builder) -> f a -> Builder

-- | A JSON-style formatter for lists.
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ jsonListF [1,2,3]
--   [
--     1
--   , 2
--   , 3
--   ]
--   </pre>
--   
--   Like <a>blockListF</a>, it handles multiline elements well:
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ jsonListF ["hello\nworld", "foo\nbar\nquix"]
--   [
--     hello
--     world
--   , foo
--     bar
--     quix
--   ]
--   </pre>
jsonListF :: forall f a. (Foldable f, Buildable a) => f a -> Builder

-- | A version of <a>jsonListF</a> that lets you supply your own building
--   function for list elements.
jsonListF' :: forall f a. Foldable f => (a -> Builder) -> f a -> Builder

-- | A simple JSON-like map formatter; works for Map, HashMap, etc, as well
--   as ordinary lists of pairs.
--   
--   <pre>
--   &gt;&gt;&gt; mapF [("a", 1), ("b", 4)]
--   "{a: 1, b: 4}"
--   </pre>
--   
--   For multiline output, use <a>jsonMapF</a>.
mapF :: (IsList t, Item t ~ (k, v), Buildable k, Buildable v) => t -> Builder

-- | A version of <a>mapF</a> that lets you supply your own building
--   function for keys and values.
mapF' :: (IsList t, Item t ~ (k, v)) => (k -> Builder) -> (v -> Builder) -> t -> Builder

-- | A YAML-like map formatter:
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ blockMapF [("Odds", blockListF [1,3]), ("Evens", blockListF [2,4])]
--   Odds:
--     - 1
--     - 3
--   Evens:
--     - 2
--     - 4
--   </pre>
blockMapF :: (IsList t, Item t ~ (k, v), Buildable k, Buildable v) => t -> Builder

-- | A version of <a>blockMapF</a> that lets you supply your own building
--   function for keys and values.
blockMapF' :: (IsList t, Item t ~ (k, v)) => (k -> Builder) -> (v -> Builder) -> t -> Builder

-- | A JSON-like map formatter (unlike <a>mapF</a>, always multiline):
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ jsonMapF [("Odds", jsonListF [1,3]), ("Evens", jsonListF [2,4])]
--   {
--     Odds:
--       [
--         1
--       , 3
--       ]
--   , Evens:
--       [
--         2
--       , 4
--       ]
--   }
--   </pre>
jsonMapF :: (IsList t, Item t ~ (k, v), Buildable k, Buildable v) => t -> Builder

-- | A version of <a>jsonMapF</a> that lets you supply your own building
--   function for keys and values.
jsonMapF' :: forall t k v. (IsList t, Item t ~ (k, v)) => (k -> Builder) -> (v -> Builder) -> t -> Builder

-- | Format a tuple (of up to 8 elements):
--   
--   <pre>
--   &gt;&gt;&gt; tupleF (1,2,"hi")
--   "(1, 2, hi)"
--   </pre>
--   
--   If any of the elements takes several lines, an alternate format is
--   used:
--   
--   <pre>
--   &gt;&gt;&gt; fmt $ tupleF ("test","foo\nbar","more test")
--   ( test
--   ,
--     foo
--     bar
--   ,
--     more test )
--   </pre>
--   
--   You can also use <a>tupleF</a> on lists to get tuple-like formatting.
tupleF :: TupleF a => a -> Builder

-- | Like <a>build</a> for <a>Maybe</a>, but displays <a>Nothing</a> as
--   <tt>&lt;Nothing&gt;</tt> instead of an empty string.
--   
--   <a>build</a>:
--   
--   <pre>
--   &gt;&gt;&gt; build (Nothing :: Maybe Int)
--   ""
--   
--   &gt;&gt;&gt; build (Just 1 :: Maybe Int)
--   "1"
--   </pre>
--   
--   <a>maybeF</a>:
--   
--   <pre>
--   &gt;&gt;&gt; maybeF (Nothing :: Maybe Int)
--   "&lt;Nothing&gt;"
--   
--   &gt;&gt;&gt; maybeF (Just 1 :: Maybe Int)
--   "1"
--   </pre>
maybeF :: Buildable a => Maybe a -> Builder

-- | Format an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; eitherF (Right 1 :: Either Bool Int)
--   "&lt;Right: 1&gt;"
--   </pre>
eitherF :: (Buildable a, Buildable b) => Either a b -> Builder

-- | Take the first N characters:
--   
--   <pre>
--   &gt;&gt;&gt; prefixF 3 "hello"
--   "hel"
--   </pre>
prefixF :: Buildable a => Int -> a -> Builder

-- | Take the last N characters:
--   
--   <pre>
--   &gt;&gt;&gt; suffixF 3 "hello"
--   "llo"
--   </pre>
suffixF :: Buildable a => Int -> a -> Builder

-- | <tt>padLeftF n c</tt> pads the string with character <tt>c</tt> from
--   the left side until it becomes <tt>n</tt> characters wide (and does
--   nothing if the string is already that long, or longer):
--   
--   <pre>
--   &gt;&gt;&gt; padLeftF 5 '0' 12
--   "00012"
--   
--   &gt;&gt;&gt; padLeftF 5 '0' 123456
--   "123456"
--   </pre>
padLeftF :: Buildable a => Int -> Char -> a -> Builder

-- | <tt>padRightF n c</tt> pads the string with character <tt>c</tt> from
--   the right side until it becomes <tt>n</tt> characters wide (and does
--   nothing if the string is already that long, or longer):
--   
--   <pre>
--   &gt;&gt;&gt; padRightF 5 ' ' "foo"
--   "foo  "
--   
--   &gt;&gt;&gt; padRightF 5 ' ' "foobar"
--   "foobar"
--   </pre>
padRightF :: Buildable a => Int -> Char -> a -> Builder

-- | <tt>padBothF n c</tt> pads the string with character <tt>c</tt> from
--   both sides until it becomes <tt>n</tt> characters wide (and does
--   nothing if the string is already that long, or longer):
--   
--   <pre>
--   &gt;&gt;&gt; padBothF 5 '=' "foo"
--   "=foo="
--   
--   &gt;&gt;&gt; padBothF 5 '=' "foobar"
--   "foobar"
--   </pre>
--   
--   When padding can't be distributed equally, the left side is preferred:
--   
--   <pre>
--   &gt;&gt;&gt; padBothF 8 '=' "foo"
--   "===foo=="
--   </pre>
padBothF :: Buildable a => Int -> Char -> a -> Builder

-- | Format a number or bytestring as hex:
--   
--   <pre>
--   &gt;&gt;&gt; hexF 3635
--   "e33"
--   
--   &gt;&gt;&gt; hexF ("\0\50\63\80" :: BS.ByteString)
--   "00323f50"
--   </pre>
hexF :: FormatAsHex a => a -> Builder

-- | Convert a bytestring to base64:
--   
--   <pre>
--   &gt;&gt;&gt; base64F ("\0\50\63\80" :: BS.ByteString)
--   "ADI/UA=="
--   </pre>
base64F :: FormatAsBase64 a => a -> Builder

-- | Convert a bytestring to base64url (a variant of base64 which omits
--   <tt>/</tt> and thus can be used in URLs):
--   
--   <pre>
--   &gt;&gt;&gt; base64UrlF ("\0\50\63\80" :: BS.ByteString)
--   "ADI_UA=="
--   </pre>
base64UrlF :: FormatAsBase64 a => a -> Builder

-- | Add an ordinal suffix to a number:
--   
--   <pre>
--   &gt;&gt;&gt; ordinalF 15
--   "15th"
--   
--   &gt;&gt;&gt; ordinalF 22
--   "22nd"
--   </pre>
ordinalF :: (Buildable a, Integral a) => a -> Builder

-- | Break digits in a number:
--   
--   <pre>
--   &gt;&gt;&gt; commaizeF 15830000
--   "15,830,000"
--   </pre>
commaizeF :: (Buildable a, Integral a) => a -> Builder

-- | Format a number as octal:
--   
--   <pre>
--   &gt;&gt;&gt; listF' octF [7,8,9,10]
--   "[7, 10, 11, 12]"
--   </pre>
octF :: Integral a => a -> Builder

-- | Format a number as binary:
--   
--   <pre>
--   &gt;&gt;&gt; listF' binF [7,8,9,10]
--   "[111, 1000, 1001, 1010]"
--   </pre>
binF :: Integral a => a -> Builder

-- | Format a number in arbitrary base (up to 36):
--   
--   <pre>
--   &gt;&gt;&gt; baseF 3 10000
--   "111201101"
--   
--   &gt;&gt;&gt; baseF 7 10000
--   "41104"
--   
--   &gt;&gt;&gt; baseF 36 10000
--   "7ps"
--   </pre>
baseF :: (HasCallStack, Integral a) => Int -> a -> Builder

-- | Format a floating-point number:
--   
--   <pre>
--   &gt;&gt;&gt; floatF 3.1415
--   "3.1415"
--   </pre>
--   
--   Numbers smaller than 1e-6 or bigger-or-equal to 1e21 will be displayed
--   using scientific notation:
--   
--   <pre>
--   &gt;&gt;&gt; listF' floatF [1e-6,9e-7]
--   "[0.000001, 9.0e-7]"
--   
--   &gt;&gt;&gt; listF' floatF [9e20,1e21]
--   "[900000000000000000000.0, 1.0e21]"
--   </pre>
floatF :: Real a => a -> Builder

-- | Format a floating-point number using scientific notation, with the
--   given amount of decimal places.
--   
--   <pre>
--   &gt;&gt;&gt; listF' (exptF 5) [pi,0.1,10]
--   "[3.14159e0, 1.00000e-1, 1.00000e1]"
--   </pre>
exptF :: Real a => Int -> a -> Builder

-- | Format a floating-point number without scientific notation:
--   
--   <pre>
--   &gt;&gt;&gt; listF' (fixedF 5) [pi,0.1,10]
--   "[3.14159, 0.10000, 10.00000]"
--   </pre>
fixedF :: Real a => Int -> a -> Builder

-- | Display something only if the condition is <a>True</a> (empty string
--   otherwise).
--   
--   Note that it can only take a <a>Builder</a> (because otherwise it
--   would be unusable with (<a>+|</a>)-formatted strings which can resolve
--   to any <a>FromBuilder</a>). You can use <a>build</a> to convert any
--   value to a <a>Builder</a>.
whenF :: Bool -> Builder -> Builder

-- | Display something only if the condition is <a>False</a> (empty string
--   otherwise).
unlessF :: Bool -> Builder -> Builder

-- | Format an arbitrary value without requiring a <a>Buildable</a>
--   instance:
--   
--   <pre>
--   &gt;&gt;&gt; data Foo = Foo { x :: Bool, y :: [Int] } deriving Generic
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fmt (genericF (Foo True [1,2,3]))
--   Foo:
--     x: True
--     y: [1, 2, 3]
--   </pre>
--   
--   It works for non-record constructors too:
--   
--   <pre>
--   &gt;&gt;&gt; data Bar = Bar Bool [Int] deriving Generic
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fmtLn (genericF (Bar True [1,2,3]))
--   &lt;Bar: True, [1, 2, 3]&gt;
--   </pre>
--   
--   Any fields inside the type must either be <a>Buildable</a> or one of
--   the following types:
--   
--   <ul>
--   <li>a function</li>
--   <li>a tuple (up to 8-tuples)</li>
--   <li>list, <a>NonEmpty</a>, <a>Seq</a></li>
--   <li><a>Map</a>, <a>IntMap</a>, <a>Set</a>, <a>IntSet</a></li>
--   <li><a>Maybe</a>, <a>Either</a></li>
--   </ul>
--   
--   The exact format of <a>genericF</a> might change in future versions,
--   so don't rely on it. It's merely a convenience function.
genericF :: (Generic a, GBuildable (Rep a)) => a -> Builder
