-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A family of combinators for defining webservices APIs and serving them
--   
--   A family of combinators for defining webservices APIs and serving them
--   
--   You can learn about the basics in the <a>tutorial</a>.
--   
--   <a>Here</a> is a runnable example, with comments, that defines a dummy
--   API and implements a webserver that serves this API, using this
--   package.
--   
--   <a>CHANGELOG</a>
@package servant-server
@version 0.15

module Servant.Server.Internal.Context

-- | <a>Context</a>s are used to pass values to combinators. (They are
--   <b>not</b> meant to be used to pass parameters to your handlers, i.e.
--   they should not replace any custom <a>ReaderT</a>-monad-stack that
--   you're using with <tt>hoistServer</tt>.) If you don't use combinators
--   that require any context entries, you can just use <a>serve</a> as
--   always.
--   
--   If you are using combinators that require a non-empty <a>Context</a>
--   you have to use <a>serveWithContext</a> and pass it a <a>Context</a>
--   that contains all the values your combinators need. A <a>Context</a>
--   is essentially a heterogenous list and accessing the elements is being
--   done by type (see <a>getContextEntry</a>). The parameter of the type
--   <a>Context</a> is a type-level list reflecting the types of the
--   contained context entries. To create a <a>Context</a> with entries,
--   use the operator <tt>(<a>:.</a>)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; :type True :. () :. EmptyContext
--   True :. () :. EmptyContext :: Context '[Bool, ()]
--   </pre>
data Context contextTypes
[EmptyContext] :: Context '[]
[:.] :: x -> Context xs -> Context (x : xs)
infixr 5 :.

-- | This class is used to access context entries in <a>Context</a>s.
--   <a>getContextEntry</a> returns the first value where the type matches:
--   
--   <pre>
--   &gt;&gt;&gt; getContextEntry (True :. False :. EmptyContext) :: Bool
--   True
--   </pre>
--   
--   If the <a>Context</a> does not contain an entry of the requested type,
--   you'll get an error:
--   
--   <pre>
--   &gt;&gt;&gt; getContextEntry (True :. False :. EmptyContext) :: String
--   ...
--   ...No instance for (HasContextEntry '[] [Char])
--   ...
--   </pre>
class HasContextEntry (context :: [*]) (val :: *)
getContextEntry :: HasContextEntry context val => Context context -> val

-- | Normally context entries are accessed by their types. In case you need
--   to have multiple values of the same type in your <a>Context</a> and
--   need to access them, we provide <a>NamedContext</a>. You can think of
--   it as sub-namespaces for <a>Context</a>s.
data NamedContext (name :: Symbol) (subContext :: [*])
NamedContext :: Context subContext -> NamedContext

-- | <a>descendIntoNamedContext</a> allows you to access
--   <a>NamedContext</a>s. Usually you won't have to use it yourself but
--   instead use a combinator like <a>WithNamedContext</a>.
--   
--   This is how <a>descendIntoNamedContext</a> works:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XFlexibleContexts
--   
--   &gt;&gt;&gt; let subContext = True :. EmptyContext
--   
--   &gt;&gt;&gt; :type subContext
--   subContext :: Context '[Bool]
--   
--   &gt;&gt;&gt; let parentContext = False :. (NamedContext subContext :: NamedContext "subContext" '[Bool]) :. EmptyContext
--   
--   &gt;&gt;&gt; :type parentContext
--   parentContext :: Context '[Bool, NamedContext "subContext" '[Bool]]
--   
--   &gt;&gt;&gt; descendIntoNamedContext (Proxy :: Proxy "subContext") parentContext :: Context '[Bool]
--   True :. EmptyContext
--   </pre>
descendIntoNamedContext :: forall context name subContext. HasContextEntry context (NamedContext name subContext) => Proxy (name :: Symbol) -> Context context -> Context subContext
instance Servant.Server.Internal.Context.HasContextEntry xs val => Servant.Server.Internal.Context.HasContextEntry (notIt : xs) val
instance Servant.Server.Internal.Context.HasContextEntry (val : xs) val
instance GHC.Show.Show (Servant.Server.Internal.Context.Context '[])
instance (GHC.Show.Show a, GHC.Show.Show (Servant.Server.Internal.Context.Context as)) => GHC.Show.Show (Servant.Server.Internal.Context.Context (a : as))
instance GHC.Classes.Eq (Servant.Server.Internal.Context.Context '[])
instance (GHC.Classes.Eq a, GHC.Classes.Eq (Servant.Server.Internal.Context.Context as)) => GHC.Classes.Eq (Servant.Server.Internal.Context.Context (a : as))

module Servant.Server.Internal.ServantErr
data ServantErr
ServantErr :: Int -> String -> ByteString -> [Header] -> ServantErr
[errHTTPCode] :: ServantErr -> Int
[errReasonPhrase] :: ServantErr -> String
[errBody] :: ServantErr -> ByteString
[errHeaders] :: ServantErr -> [Header]
responseServantErr :: ServantErr -> Response

-- | <a>err300</a> Multiple Choices
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err300 { errBody = "I can't choose." }
--   </pre>
err300 :: ServantErr

-- | <a>err301</a> Moved Permanently
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err301
--   </pre>
err301 :: ServantErr

-- | <a>err302</a> Found
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err302
--   </pre>
err302 :: ServantErr

-- | <a>err303</a> See Other
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err303
--   </pre>
err303 :: ServantErr

-- | <a>err304</a> Not Modified
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err304
--   </pre>
err304 :: ServantErr

-- | <a>err305</a> Use Proxy
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err305
--   </pre>
err305 :: ServantErr

-- | <a>err307</a> Temporary Redirect
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err307
--   </pre>
err307 :: ServantErr

-- | <a>err400</a> Bad Request
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err400 { errBody = "Your request makes no sense to me." }
--   </pre>
err400 :: ServantErr

-- | <a>err401</a> Unauthorized
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err401 { errBody = "Your credentials are invalid." }
--   </pre>
err401 :: ServantErr

-- | <a>err402</a> Payment Required
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err402 { errBody = "You have 0 credits. Please give me $$$." }
--   </pre>
err402 :: ServantErr

-- | <a>err403</a> Forbidden
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err403 { errBody = "Please login first." }
--   </pre>
err403 :: ServantErr

-- | <a>err404</a> Not Found
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err404 { errBody = "(╯°□°）╯︵ ┻━┻)." }
--   </pre>
err404 :: ServantErr

-- | <a>err405</a> Method Not Allowed
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err405 { errBody = "Your account privileges does not allow for this.  Please pay $$$." }
--   </pre>
err405 :: ServantErr

-- | <a>err406</a> Not Acceptable
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err406
--   </pre>
err406 :: ServantErr

-- | <a>err407</a> Proxy Authentication Required
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err407
--   </pre>
err407 :: ServantErr

-- | <a>err409</a> Conflict
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err409 { errBody = "Transaction conflicts with 59879cb56c7c159231eeacdd503d755f7e835f74" }
--   </pre>
err409 :: ServantErr

-- | <a>err410</a> Gone
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err410 { errBody = "I know it was here at some point, but.. I blame bad luck." }
--   </pre>
err410 :: ServantErr

-- | <a>err411</a> Length Required
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err411
--   </pre>
err411 :: ServantErr

-- | <a>err412</a> Precondition Failed
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err412 { errBody = "Precondition fail: x &lt; 42 &amp;&amp; y &gt; 57" }
--   </pre>
err412 :: ServantErr

-- | <a>err413</a> Request Entity Too Large
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err413 { errBody = "Request exceeded 64k." }
--   </pre>
err413 :: ServantErr

-- | <a>err414</a> Request-URI Too Large
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err414 { errBody = "Maximum length is 64." }
--   </pre>
err414 :: ServantErr

-- | <a>err415</a> Unsupported Media Type
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err415 { errBody = "Supported media types:  gif, png" }
--   </pre>
err415 :: ServantErr

-- | <a>err416</a> Request range not satisfiable
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err416 { errBody = "Valid range is [0, 424242]." }
--   </pre>
err416 :: ServantErr

-- | <a>err417</a> Expectation Failed
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err417 { errBody = "I found a quux in the request.  This isn't going to work." }
--   </pre>
err417 :: ServantErr

-- | <a>err418</a> Expectation Failed
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err418 { errBody = "Apologies, this is not a webserver but a teapot." }
--   </pre>
err418 :: ServantErr

-- | <a>err422</a> Unprocessable Entity
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err422 { errBody = "I understood your request, but can't process it." }
--   </pre>
err422 :: ServantErr

-- | <a>err500</a> Internal Server Error
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err500 { errBody = "Exception in module A.B.C:55.  Have a great day!" }
--   </pre>
err500 :: ServantErr

-- | <a>err501</a> Not Implemented
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err501 { errBody = "/v1/foo is not supported with quux in the request." }
--   </pre>
err501 :: ServantErr

-- | <a>err502</a> Bad Gateway
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err502 { errBody = "Tried gateway foo, bar, and baz.  None responded." }
--   </pre>
err502 :: ServantErr

-- | <a>err503</a> Service Unavailable
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err503 { errBody = "We're rewriting in PHP." }
--   </pre>
err503 :: ServantErr

-- | <a>err504</a> Gateway Time-out
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err504 { errBody = "Backend foobar did not respond in 5 seconds." }
--   </pre>
err504 :: ServantErr

-- | <a>err505</a> HTTP Version not supported
--   
--   Example usage:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err505 { errBody = "I support HTTP/4.0 only." }
--   </pre>
err505 :: ServantErr
instance GHC.Read.Read Servant.Server.Internal.ServantErr.ServantErr
instance GHC.Classes.Eq Servant.Server.Internal.ServantErr.ServantErr
instance GHC.Show.Show Servant.Server.Internal.ServantErr.ServantErr
instance GHC.Exception.Type.Exception Servant.Server.Internal.ServantErr.ServantErr

module Servant.Server.Internal.Handler
newtype Handler a
Handler :: ExceptT ServantErr IO a -> Handler a
[runHandler'] :: Handler a -> ExceptT ServantErr IO a
runHandler :: Handler a -> IO (Either ServantErr a)
instance Control.Monad.Catch.MonadMask Servant.Server.Internal.Handler.Handler
instance Control.Monad.Catch.MonadCatch Servant.Server.Internal.Handler.Handler
instance Control.Monad.Catch.MonadThrow Servant.Server.Internal.Handler.Handler
instance Control.Monad.Error.Class.MonadError Servant.Server.Internal.ServantErr.ServantErr Servant.Server.Internal.Handler.Handler
instance GHC.Generics.Generic (Servant.Server.Internal.Handler.Handler a)
instance Control.Monad.IO.Class.MonadIO Servant.Server.Internal.Handler.Handler
instance GHC.Base.Monad Servant.Server.Internal.Handler.Handler
instance GHC.Base.Applicative Servant.Server.Internal.Handler.Handler
instance GHC.Base.Functor Servant.Server.Internal.Handler.Handler
instance Control.Monad.Base.MonadBase GHC.Types.IO Servant.Server.Internal.Handler.Handler
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO Servant.Server.Internal.Handler.Handler

module Servant.Server.Internal.RoutingApplication
type RoutingApplication = Request " the request, the field 'pathInfo' may be modified by url routing" -> (RouteResult Response -> IO ResponseReceived) -> IO ResponseReceived

-- | The result of matching against a path in the route tree.
data RouteResult a

-- | Keep trying other paths. The <tt>ServantErr</tt> should only be 404,
--   405 or 406.
Fail :: ServantErr -> RouteResult a

-- | Don't try other paths.
FailFatal :: !ServantErr -> RouteResult a
Route :: !a -> RouteResult a
newtype RouteResultT m a
RouteResultT :: m (RouteResult a) -> RouteResultT m a
[runRouteResultT] :: RouteResultT m a -> m (RouteResult a)
toApplication :: RoutingApplication -> Application

-- | A <a>Delayed</a> is a representation of a handler with scheduled
--   delayed checks that can trigger errors.
--   
--   Why would we want to delay checks?
--   
--   There are two reasons:
--   
--   <ol>
--   <li>In a straight-forward implementation, the order in which we
--   perform checks will determine the error we generate. This is because
--   once an error occurs, we would abort and not perform any subsequent
--   checks, but rather return the current error.</li>
--   </ol>
--   
--   This is not a necessity: we could continue doing other checks, and
--   choose the preferred error. However, that would in general mean more
--   checking, which leads us to the other reason.
--   
--   <ol>
--   <li>We really want to avoid doing certain checks too early. For
--   example, captures involve parsing, and are much more costly than
--   static route matches. In particular, if several paths contain the
--   "same" capture, we'd like as much as possible to avoid trying the same
--   parse many times. Also tricky is the request body. Again, this
--   involves parsing, but also, WAI makes obtaining the request body a
--   side-effecting operation. We could/can work around this by manually
--   caching the request body, but we'd rather keep the number of times we
--   actually try to decode the request body to an absolute minimum.</li>
--   </ol>
--   
--   We prefer to have the following relative priorities of error codes:
--   
--   <pre>
--   404
--   405 (bad method)
--   401 (unauthorized)
--   415 (unsupported media type)
--   406 (not acceptable)
--   400 (bad request)
--   </pre>
--   
--   Therefore, while routing, we delay most checks so that they will
--   ultimately occur in the right order.
--   
--   A <a>Delayed</a> contains many delayed blocks of tests, and the actual
--   handler:
--   
--   <ol>
--   <li>Delayed captures. These can actually cause 404, and while they're
--   costly, they should be done first among the delayed checks (at least
--   as long as we do not decouple the check order from the error
--   reporting, see above). Delayed captures can provide inputs to the
--   actual handler.</li>
--   <li>Method check(s). This can cause a 405. On success, it does not
--   provide an input for the handler. Method checks are comparatively
--   cheap.</li>
--   <li>Authentication checks. This can cause 401.</li>
--   <li>Accept and content type header checks. These checks can cause 415
--   and 406 errors.</li>
--   <li>Query parameter checks. They require parsing and can cause 400 if
--   the parsing fails. Query parameter checks provide inputs to the
--   handler</li>
--   <li>Header Checks. They also require parsing and can cause 400 if
--   parsing fails.</li>
--   <li>Body check. The request body check can cause 400.</li>
--   </ol>
data Delayed env c
[Delayed] :: {capturesD :: env -> DelayedIO captures, methodD :: DelayedIO (), authD :: DelayedIO auth, acceptD :: DelayedIO (), contentD :: DelayedIO contentType, paramsD :: DelayedIO params, headersD :: DelayedIO headers, bodyD :: contentType -> DelayedIO body, serverD :: captures -> params -> headers -> auth -> body -> Request -> RouteResult c} -> Delayed env c

-- | Computations used in a <a>Delayed</a> can depend on the incoming
--   <a>Request</a>, may perform 'IO, and result in a 'RouteResult, meaning
--   they can either suceed, fail (with the possibility to recover), or
--   fail fatally.
newtype DelayedIO a
DelayedIO :: ReaderT Request (ResourceT (RouteResultT IO)) a -> DelayedIO a
[runDelayedIO'] :: DelayedIO a -> ReaderT Request (ResourceT (RouteResultT IO)) a
liftRouteResult :: RouteResult a -> DelayedIO a
runDelayedIO :: DelayedIO a -> Request -> ResourceT IO (RouteResult a)

-- | A <a>Delayed</a> without any stored checks.
emptyDelayed :: RouteResult a -> Delayed env a

-- | Fail with the option to recover.
delayedFail :: ServantErr -> DelayedIO a

-- | Fail fatally, i.e., without any option to recover.
delayedFailFatal :: ServantErr -> DelayedIO a

-- | Gain access to the incoming request.
withRequest :: (Request -> DelayedIO a) -> DelayedIO a

-- | Add a capture to the end of the capture block.
addCapture :: Delayed env (a -> b) -> (captured -> DelayedIO a) -> Delayed (captured, env) b

-- | Add a parameter check to the end of the params block
addParameterCheck :: Delayed env (a -> b) -> DelayedIO a -> Delayed env b

-- | Add a parameter check to the end of the params block
addHeaderCheck :: Delayed env (a -> b) -> DelayedIO a -> Delayed env b

-- | Add a method check to the end of the method block.
addMethodCheck :: Delayed env a -> DelayedIO () -> Delayed env a

-- | Add an auth check to the end of the auth block.
addAuthCheck :: Delayed env (a -> b) -> DelayedIO a -> Delayed env b

-- | Add a content type and body checks around parameter checks.
--   
--   We'll report failed content type check (415), before trying to parse
--   query parameters (400). Which, in turn, happens before request body
--   parsing.
addBodyCheck :: Delayed env (a -> b) -> DelayedIO c -> (c -> DelayedIO a) -> Delayed env b

-- | Add an accept header check before handling parameters. In principle,
--   we'd like to take a bad body (400) response take precedence over a
--   failed accept check (406). BUT to allow streaming the body, we cannot
--   run the body check and then still backtrack. We therefore do the
--   accept check before the body check, when we can still backtrack. There
--   are other solutions to this, but they'd be more complicated (such as
--   delaying the body check further so that it can still be run in a
--   situation where we'd otherwise report 406).
addAcceptCheck :: Delayed env a -> DelayedIO () -> Delayed env a

-- | Many combinators extract information that is passed to the handler
--   without the possibility of failure. In such a case,
--   <a>passToServer</a> can be used.
passToServer :: Delayed env (a -> b) -> (Request -> a) -> Delayed env b

-- | Run a delayed server. Performs all scheduled operations in order, and
--   passes the results from the capture and body blocks on to the actual
--   handler.
--   
--   This should only be called once per request; otherwise the guarantees
--   about effect and HTTP error ordering break down.
runDelayed :: Delayed env a -> env -> Request -> ResourceT IO (RouteResult a)

-- | Runs a delayed server and the resulting action. Takes a continuation
--   that lets us send a response. Also takes a continuation for how to
--   turn the result of the delayed server into a response.
runAction :: Delayed env (Handler a) -> env -> Request -> (RouteResult Response -> IO r) -> (a -> RouteResult Response) -> IO r
instance Control.Monad.Trans.Resource.Internal.MonadResource Servant.Server.Internal.RoutingApplication.DelayedIO
instance Control.Monad.Catch.MonadThrow Servant.Server.Internal.RoutingApplication.DelayedIO
instance Control.Monad.Reader.Class.MonadReader Network.Wai.Internal.Request Servant.Server.Internal.RoutingApplication.DelayedIO
instance Control.Monad.IO.Class.MonadIO Servant.Server.Internal.RoutingApplication.DelayedIO
instance GHC.Base.Monad Servant.Server.Internal.RoutingApplication.DelayedIO
instance GHC.Base.Applicative Servant.Server.Internal.RoutingApplication.DelayedIO
instance GHC.Base.Functor Servant.Server.Internal.RoutingApplication.DelayedIO
instance GHC.Base.Functor m => GHC.Base.Functor (Servant.Server.Internal.RoutingApplication.RouteResultT m)
instance GHC.Base.Functor Servant.Server.Internal.RoutingApplication.RouteResult
instance GHC.Read.Read a => GHC.Read.Read (Servant.Server.Internal.RoutingApplication.RouteResult a)
instance GHC.Show.Show a => GHC.Show.Show (Servant.Server.Internal.RoutingApplication.RouteResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Servant.Server.Internal.RoutingApplication.RouteResult a)
instance GHC.Base.Functor (Servant.Server.Internal.RoutingApplication.Delayed env)
instance Control.Monad.Base.MonadBase GHC.Types.IO Servant.Server.Internal.RoutingApplication.DelayedIO
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO Servant.Server.Internal.RoutingApplication.DelayedIO
instance Control.Monad.Trans.Class.MonadTrans Servant.Server.Internal.RoutingApplication.RouteResultT
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Servant.Server.Internal.RoutingApplication.RouteResultT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Servant.Server.Internal.RoutingApplication.RouteResultT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Servant.Server.Internal.RoutingApplication.RouteResultT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Servant.Server.Internal.RoutingApplication.RouteResultT m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Servant.Server.Internal.RoutingApplication.RouteResultT m)
instance Control.Monad.Trans.Control.MonadTransControl Servant.Server.Internal.RoutingApplication.RouteResultT
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Servant.Server.Internal.RoutingApplication.RouteResultT m)
instance GHC.Base.Applicative Servant.Server.Internal.RoutingApplication.RouteResult
instance GHC.Base.Monad Servant.Server.Internal.RoutingApplication.RouteResult

module Servant.Server.Internal.Router
type Router env = Router' env RoutingApplication

-- | Internal representation of a router.
--   
--   The first argument describes an environment type that is expected as
--   extra input by the routers at the leaves. The environment is filled
--   while running the router, with path components that can be used to
--   process captures.
data Router' env a

-- | the map contains routers for subpaths (first path component used for
--   lookup and removed afterwards), the list contains handlers for the
--   empty path, to be tried in order
StaticRouter :: Map Text (Router' env a) -> [env -> a] -> Router' env a

-- | first path component is passed to the child router in its environment
--   and removed afterwards
CaptureRouter :: Router' (Text, env) a -> Router' env a

-- | all path components are passed to the child router in its environment
--   and are removed afterwards
CaptureAllRouter :: Router' ([Text], env) a -> Router' env a

-- | to be used for routes we do not know anything about
RawRouter :: (env -> a) -> Router' env a

-- | left-biased choice between two routers
Choice :: Router' env a -> Router' env a -> Router' env a

-- | Smart constructor for a single static path component.
pathRouter :: Text -> Router' env a -> Router' env a

-- | Smart constructor for a leaf, i.e., a router that expects the empty
--   path.
leafRouter :: (env -> a) -> Router' env a

-- | Smart constructor for the choice between routers. We currently
--   optimize the following cases:
--   
--   <ul>
--   <li>Two static routers can be joined by joining their maps and
--   concatenating their leaf-lists.</li>
--   <li>Two dynamic routers can be joined by joining their codomains.</li>
--   <li>Choice nodes can be reordered.</li>
--   </ul>
choice :: Router' env a -> Router' env a -> Router' env a

-- | Datatype used for representing and debugging the structure of a
--   router. Abstracts from the handlers at the leaves.
--   
--   Two <a>Router</a>s can be structurally compared by computing their
--   <a>RouterStructure</a> using <a>routerStructure</a> and then testing
--   for equality, see <a>sameStructure</a>.
data RouterStructure
StaticRouterStructure :: Map Text RouterStructure -> Int -> RouterStructure
CaptureRouterStructure :: RouterStructure -> RouterStructure
RawRouterStructure :: RouterStructure
ChoiceStructure :: RouterStructure -> RouterStructure -> RouterStructure

-- | Compute the structure of a router.
--   
--   Assumes that the request or text being passed in <tt>WithRequest</tt>
--   or <a>CaptureRouter</a> does not affect the structure of the
--   underlying tree.
routerStructure :: Router' env a -> RouterStructure

-- | Compare the structure of two routers.
sameStructure :: Router' env a -> Router' env b -> Bool

-- | Provide a textual representation of the structure of a router.
routerLayout :: Router' env a -> Text

-- | Apply a transformation to the response of a <a>Router</a>.
tweakResponse :: (RouteResult Response -> RouteResult Response) -> Router env -> Router env

-- | Interpret a router as an application.
runRouter :: Router () -> RoutingApplication
runRouterEnv :: Router env -> env -> RoutingApplication

-- | Try a list of routing applications in order. We stop as soon as one
--   fails fatally or succeeds. If all fail normally, we pick the "best"
--   error.
runChoice :: [env -> RoutingApplication] -> env -> RoutingApplication
worseHTTPCode :: Int -> Int -> Bool
instance GHC.Show.Show Servant.Server.Internal.Router.RouterStructure
instance GHC.Classes.Eq Servant.Server.Internal.Router.RouterStructure
instance GHC.Base.Functor (Servant.Server.Internal.Router.Router' env)

module Servant.Server.Internal.BasicAuth

-- | servant-server's current implementation of basic authentication is not
--   immune to certian kinds of timing attacks. Decoding payloads does not
--   take a fixed amount of time.
--   
--   The result of authentication/authorization
data BasicAuthResult usr
Unauthorized :: BasicAuthResult usr
BadPassword :: BasicAuthResult usr
NoSuchUser :: BasicAuthResult usr
Authorized :: usr -> BasicAuthResult usr

-- | Datatype wrapping a function used to check authentication.
newtype BasicAuthCheck usr
BasicAuthCheck :: (BasicAuthData -> IO (BasicAuthResult usr)) -> BasicAuthCheck usr
[unBasicAuthCheck] :: BasicAuthCheck usr -> BasicAuthData -> IO (BasicAuthResult usr)

-- | Internal method to make a basic-auth challenge
mkBAChallengerHdr :: ByteString -> Header

-- | Find and decode an <tt>Authorization</tt> header from the request as
--   Basic Auth
decodeBAHdr :: Request -> Maybe BasicAuthData

-- | Run and check basic authentication, returning the appropriate http
--   error per the spec.
runBasicAuth :: Request -> ByteString -> BasicAuthCheck usr -> DelayedIO usr
instance GHC.Base.Functor Servant.Server.Internal.BasicAuth.BasicAuthCheck
instance GHC.Generics.Generic (Servant.Server.Internal.BasicAuth.BasicAuthCheck usr)
instance GHC.Base.Functor Servant.Server.Internal.BasicAuth.BasicAuthResult
instance GHC.Generics.Generic (Servant.Server.Internal.BasicAuth.BasicAuthResult usr)
instance GHC.Read.Read usr => GHC.Read.Read (Servant.Server.Internal.BasicAuth.BasicAuthResult usr)
instance GHC.Show.Show usr => GHC.Show.Show (Servant.Server.Internal.BasicAuth.BasicAuthResult usr)
instance GHC.Classes.Eq usr => GHC.Classes.Eq (Servant.Server.Internal.BasicAuth.BasicAuthResult usr)

module Servant.Server.Internal
type HasServerArrowTypeError a b =  'Text "No instance HasServer (a -> b)." :$$:  'Text "Maybe you have used '->' instead of ':>' between " :$$:  'ShowType a :$$:  'Text "and" :$$:  'ShowType b
type HasServerArrowKindError arr =  'Text "Expected something of kind Symbol or *, got: k -> l on the LHS of ':>'." :$$:  'Text "Maybe you haven't applied enough arguments to" :$$:  'ShowType arr

-- | Singleton type representing a server that serves an empty API.
data EmptyServer
EmptyServer :: EmptyServer
type Server api = ServerT api Handler
class HasServer api context where {
    type family ServerT api (m :: * -> *) :: *;
}
route :: HasServer api context => Proxy api -> Context context -> Delayed env (Server api) -> Router env
hoistServerWithContext :: HasServer api context => Proxy api -> Proxy context -> (forall x. m x -> n x) -> ServerT api m -> ServerT api n
allowedMethodHead :: Method -> Request -> Bool
allowedMethod :: Method -> Request -> Bool
methodCheck :: Method -> Request -> DelayedIO ()
acceptCheck :: AllMime list => Proxy list -> ByteString -> DelayedIO ()
methodRouter :: AllCTRender ctypes a => (b -> ([(HeaderName, ByteString)], a)) -> Method -> Proxy ctypes -> Status -> Delayed env (Handler b) -> Router env
streamRouter :: forall ctype a c chunk env framing. (MimeRender ctype chunk, FramingRender framing, ToSourceIO chunk a) => (c -> ([(HeaderName, ByteString)], a)) -> Method -> Status -> Proxy framing -> Proxy ctype -> Delayed env (Handler c) -> Router env

-- | Server for <a>EmptyAPI</a>
emptyServer :: ServerT EmptyAPI m
ct_wildcard :: ByteString
instance GHC.Enum.Enum Servant.Server.Internal.EmptyServer
instance GHC.Enum.Bounded Servant.Server.Internal.EmptyServer
instance GHC.Show.Show Servant.Server.Internal.EmptyServer
instance GHC.Classes.Eq Servant.Server.Internal.EmptyServer
instance (TypeError ...) => Servant.Server.Internal.HasServer (a -> b) context
instance forall k l (arr :: k -> l) api (context :: [*]). (TypeError ...) => Servant.Server.Internal.HasServer (arr Servant.API.Sub.:> api) context
instance Servant.Server.Internal.HasServer Servant.API.Empty.EmptyAPI context
instance (Servant.Server.Internal.HasServer a context, Servant.Server.Internal.HasServer b context) => Servant.Server.Internal.HasServer (a Servant.API.Alternative.:<|> b) context
instance (GHC.TypeLits.KnownSymbol capture, Web.Internal.HttpApiData.FromHttpApiData a, Servant.Server.Internal.HasServer api context) => Servant.Server.Internal.HasServer (Servant.API.Capture.Capture' mods capture a Servant.API.Sub.:> api) context
instance (GHC.TypeLits.KnownSymbol capture, Web.Internal.HttpApiData.FromHttpApiData a, Servant.Server.Internal.HasServer api context) => Servant.Server.Internal.HasServer (Servant.API.Capture.CaptureAll capture a Servant.API.Sub.:> api) context
instance forall k1 (ctypes :: [*]) a (method :: k1) (status :: GHC.Types.Nat) (context :: [*]). (Servant.API.ContentTypes.AllCTRender ctypes a, Servant.API.Verbs.ReflectMethod method, GHC.TypeNats.KnownNat status) => Servant.Server.Internal.HasServer (Servant.API.Verbs.Verb method status ctypes a) context
instance forall k1 (ctypes :: [*]) a (method :: k1) (status :: GHC.Types.Nat) (h :: [*]) (context :: [*]). (Servant.API.ContentTypes.AllCTRender ctypes a, Servant.API.Verbs.ReflectMethod method, GHC.TypeNats.KnownNat status, Servant.API.ResponseHeaders.GetHeaders (Servant.API.ResponseHeaders.Headers h a)) => Servant.Server.Internal.HasServer (Servant.API.Verbs.Verb method status ctypes (Servant.API.ResponseHeaders.Headers h a)) context
instance forall k1 ctype chunk (method :: k1) (status :: GHC.Types.Nat) framing a (context :: [*]). (Servant.API.ContentTypes.MimeRender ctype chunk, Servant.API.Verbs.ReflectMethod method, GHC.TypeNats.KnownNat status, Servant.API.Stream.FramingRender framing, Servant.API.Stream.ToSourceIO chunk a) => Servant.Server.Internal.HasServer (Servant.API.Stream.Stream method status framing ctype a) context
instance forall k1 ctype chunk (method :: k1) (status :: GHC.Types.Nat) framing a (h :: [*]) (context :: [*]). (Servant.API.ContentTypes.MimeRender ctype chunk, Servant.API.Verbs.ReflectMethod method, GHC.TypeNats.KnownNat status, Servant.API.Stream.FramingRender framing, Servant.API.Stream.ToSourceIO chunk a, Servant.API.ResponseHeaders.GetHeaders (Servant.API.ResponseHeaders.Headers h a)) => Servant.Server.Internal.HasServer (Servant.API.Stream.Stream method status framing ctype (Servant.API.ResponseHeaders.Headers h a)) context
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.FromHttpApiData a, Servant.Server.Internal.HasServer api context, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired mods), Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldLenient mods)) => Servant.Server.Internal.HasServer (Servant.API.Header.Header' mods sym a Servant.API.Sub.:> api) context
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.FromHttpApiData a, Servant.Server.Internal.HasServer api context, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired mods), Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldLenient mods)) => Servant.Server.Internal.HasServer (Servant.API.QueryParam.QueryParam' mods sym a Servant.API.Sub.:> api) context
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.FromHttpApiData a, Servant.Server.Internal.HasServer api context) => Servant.Server.Internal.HasServer (Servant.API.QueryParam.QueryParams sym a Servant.API.Sub.:> api) context
instance (GHC.TypeLits.KnownSymbol sym, Servant.Server.Internal.HasServer api context) => Servant.Server.Internal.HasServer (Servant.API.QueryParam.QueryFlag sym Servant.API.Sub.:> api) context
instance Servant.Server.Internal.HasServer Servant.API.Raw.Raw context
instance (Servant.API.ContentTypes.AllCTUnrender list a, Servant.Server.Internal.HasServer api context, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldLenient mods)) => Servant.Server.Internal.HasServer (Servant.API.ReqBody.ReqBody' mods list a Servant.API.Sub.:> api) context
instance (Servant.API.Stream.FramingUnrender framing, Servant.API.Stream.FromSourceIO chunk a, Servant.API.ContentTypes.MimeUnrender ctype chunk, Servant.Server.Internal.HasServer api context) => Servant.Server.Internal.HasServer (Servant.API.Stream.StreamBody' mods framing ctype a Servant.API.Sub.:> api) context
instance (GHC.TypeLits.KnownSymbol path, Servant.Server.Internal.HasServer api context) => Servant.Server.Internal.HasServer (path Servant.API.Sub.:> api) context
instance Servant.Server.Internal.HasServer api context => Servant.Server.Internal.HasServer (Servant.API.RemoteHost.RemoteHost Servant.API.Sub.:> api) context
instance Servant.Server.Internal.HasServer api context => Servant.Server.Internal.HasServer (Servant.API.IsSecure.IsSecure Servant.API.Sub.:> api) context
instance Servant.Server.Internal.HasServer api context => Servant.Server.Internal.HasServer (Data.Vault.Lazy.Vault Servant.API.Sub.:> api) context
instance Servant.Server.Internal.HasServer api context => Servant.Server.Internal.HasServer (Network.HTTP.Types.Version.HttpVersion Servant.API.Sub.:> api) context
instance Servant.Server.Internal.HasServer api ctx => Servant.Server.Internal.HasServer (Servant.API.Description.Summary desc Servant.API.Sub.:> api) ctx
instance Servant.Server.Internal.HasServer api ctx => Servant.Server.Internal.HasServer (Servant.API.Description.Description desc Servant.API.Sub.:> api) ctx
instance (GHC.TypeLits.KnownSymbol realm, Servant.Server.Internal.HasServer api context, Servant.Server.Internal.Context.HasContextEntry context (Servant.Server.Internal.BasicAuth.BasicAuthCheck usr)) => Servant.Server.Internal.HasServer (Servant.API.BasicAuth.BasicAuth realm usr Servant.API.Sub.:> api) context
instance (Servant.Server.Internal.Context.HasContextEntry context (Servant.Server.Internal.Context.NamedContext name subContext), Servant.Server.Internal.HasServer subApi subContext) => Servant.Server.Internal.HasServer (Servant.API.WithNamedContext.WithNamedContext name subContext subApi) context


-- | This module lets you implement <a>Server</a>s for defined APIs. You'll
--   most likely just need <a>serve</a>.
module Servant.Server

-- | <a>serve</a> allows you to implement an API and produce a wai
--   <a>Application</a>.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; Get '[JSON] [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody Book :&gt; Post '[JSON] Book -- POST /books
--   
--   server :: Server MyApi
--   server = listAllBooks :&lt;|&gt; postBook
--     where listAllBooks = ...
--           postBook book = ...
--   
--   myApi :: Proxy MyApi
--   myApi = Proxy
--   
--   app :: Application
--   app = serve myApi server
--   
--   main :: IO ()
--   main = Network.Wai.Handler.Warp.run 8080 app
--   </pre>
serve :: HasServer api '[] => Proxy api -> Server api -> Application
serveWithContext :: HasServer api context => Proxy api -> Context context -> Server api -> Application
toApplication :: RoutingApplication -> Application
class HasServer api context where {
    type family ServerT api (m :: * -> *) :: *;
}
route :: HasServer api context => Proxy api -> Context context -> Delayed env (Server api) -> Router env
hoistServerWithContext :: HasServer api context => Proxy api -> Proxy context -> (forall x. m x -> n x) -> ServerT api m -> ServerT api n
type Server api = ServerT api Handler

-- | Singleton type representing a server that serves an empty API.
data EmptyServer

-- | Server for <a>EmptyAPI</a>
emptyServer :: ServerT EmptyAPI m
newtype Handler a
Handler :: ExceptT ServantErr IO a -> Handler a
[runHandler'] :: Handler a -> ExceptT ServantErr IO a
runHandler :: Handler a -> IO (Either ServantErr a)

-- | The function <a>layout</a> produces a textual description of the
--   internal router layout for debugging purposes. Note that the router
--   layout is determined just by the API, not by the handlers.
--   
--   Example:
--   
--   For the following API
--   
--   <pre>
--   type API =
--          "a" :&gt; "d" :&gt; Get '[JSON] NoContent
--     :&lt;|&gt; "b" :&gt; Capture "x" Int :&gt; Get '[JSON] Bool
--     :&lt;|&gt; "c" :&gt; Put '[JSON] Bool
--     :&lt;|&gt; "a" :&gt; "e" :&gt; Get '[JSON] Int
--     :&lt;|&gt; "b" :&gt; Capture "x" Int :&gt; Put '[JSON] Bool
--     :&lt;|&gt; Raw
--   </pre>
--   
--   we get the following output:
--   
--   <pre>
--   /
--   ├─ a/
--   │  ├─ d/
--   │  │  └─•
--   │  └─ e/
--   │     └─•
--   ├─ b/
--   │  └─ &lt;capture&gt;/
--   │     ├─•
--   │     ┆
--   │     └─•
--   ├─ c/
--   │  └─•
--   ┆
--   └─ &lt;raw&gt;
--   </pre>
--   
--   Explanation of symbols:
--   
--   <ul>
--   <li><i><tt>├</tt></i> Normal lines reflect static branching via a
--   table.</li>
--   <li><i><tt>a/</tt></i> Nodes reflect static path components.</li>
--   <li><i><tt>─•</tt></i> Leaves reflect endpoints.</li>
--   <li><i><tt>&lt;capture&gt;/</tt></i> This is a delayed capture of a
--   path component.</li>
--   <li><i><tt>&lt;raw&gt;</tt></i> This is a part of the API we do not
--   know anything about.</li>
--   <li><i><tt>┆</tt></i> Dashed lines suggest a dynamic choice between
--   the part above and below. If there is a success for fatal failure in
--   the first part, that one takes precedence. If both parts fail, the
--   "better" error code will be returned.</li>
--   </ul>
layout :: HasServer api '[] => Proxy api -> Text

-- | Variant of <a>layout</a> that takes an additional <a>Context</a>.
layoutWithContext :: HasServer api context => Proxy api -> Context context -> Text

-- | Hoist server implementation.
--   
--   Sometimes our cherished <a>Handler</a> monad isn't quite the type
--   you'd like for your handlers. Maybe you want to thread some
--   configuration in a <tt>Reader</tt> monad. Or have your types ensure
--   that your handlers don't do any IO. Use <a>hoistServer</a> (a
--   successor of now deprecated <tt>enter</tt>).
--   
--   With <a>hoistServer</a>, you can provide a function, to convert any
--   number of endpoints from one type constructor to another. For example
--   
--   <i>Note:</i> <a>Server</a> <tt>Raw</tt> can also be entered. It will
--   be retagged.
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.Reader
--   
--   &gt;&gt;&gt; type ReaderAPI = "ep1" :&gt; Get '[JSON] Int :&lt;|&gt; "ep2" :&gt; Get '[JSON] String :&lt;|&gt; Raw :&lt;|&gt; EmptyAPI
--   
--   &gt;&gt;&gt; let readerApi = Proxy :: Proxy ReaderAPI
--   
--   &gt;&gt;&gt; let readerServer = return 1797 :&lt;|&gt; ask :&lt;|&gt; Tagged (error "raw server") :&lt;|&gt; emptyServer :: ServerT ReaderAPI (Reader String)
--   
--   &gt;&gt;&gt; let nt x = return (runReader x "hi")
--   
--   &gt;&gt;&gt; let mainServer = hoistServer readerApi nt readerServer :: Server ReaderAPI
--   </pre>
hoistServer :: HasServer api '[] => Proxy api -> (forall x. m x -> n x) -> ServerT api m -> ServerT api n

-- | Apply a transformation to the response of a <a>Router</a>.
tweakResponse :: (RouteResult Response -> RouteResult Response) -> Router env -> Router env

-- | <a>Context</a>s are used to pass values to combinators. (They are
--   <b>not</b> meant to be used to pass parameters to your handlers, i.e.
--   they should not replace any custom <a>ReaderT</a>-monad-stack that
--   you're using with <tt>hoistServer</tt>.) If you don't use combinators
--   that require any context entries, you can just use <a>serve</a> as
--   always.
--   
--   If you are using combinators that require a non-empty <a>Context</a>
--   you have to use <a>serveWithContext</a> and pass it a <a>Context</a>
--   that contains all the values your combinators need. A <a>Context</a>
--   is essentially a heterogenous list and accessing the elements is being
--   done by type (see <a>getContextEntry</a>). The parameter of the type
--   <a>Context</a> is a type-level list reflecting the types of the
--   contained context entries. To create a <a>Context</a> with entries,
--   use the operator <tt>(<a>:.</a>)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; :type True :. () :. EmptyContext
--   True :. () :. EmptyContext :: Context '[Bool, ()]
--   </pre>
data Context contextTypes
[EmptyContext] :: Context '[]
[:.] :: x -> Context xs -> Context (x : xs)
infixr 5 :.

-- | This class is used to access context entries in <a>Context</a>s.
--   <a>getContextEntry</a> returns the first value where the type matches:
--   
--   <pre>
--   &gt;&gt;&gt; getContextEntry (True :. False :. EmptyContext) :: Bool
--   True
--   </pre>
--   
--   If the <a>Context</a> does not contain an entry of the requested type,
--   you'll get an error:
--   
--   <pre>
--   &gt;&gt;&gt; getContextEntry (True :. False :. EmptyContext) :: String
--   ...
--   ...No instance for (HasContextEntry '[] [Char])
--   ...
--   </pre>
class HasContextEntry (context :: [*]) (val :: *)
getContextEntry :: HasContextEntry context val => Context context -> val

-- | Normally context entries are accessed by their types. In case you need
--   to have multiple values of the same type in your <a>Context</a> and
--   need to access them, we provide <a>NamedContext</a>. You can think of
--   it as sub-namespaces for <a>Context</a>s.
data NamedContext (name :: Symbol) (subContext :: [*])
NamedContext :: Context subContext -> NamedContext

-- | <a>descendIntoNamedContext</a> allows you to access
--   <a>NamedContext</a>s. Usually you won't have to use it yourself but
--   instead use a combinator like <a>WithNamedContext</a>.
--   
--   This is how <a>descendIntoNamedContext</a> works:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XFlexibleContexts
--   
--   &gt;&gt;&gt; let subContext = True :. EmptyContext
--   
--   &gt;&gt;&gt; :type subContext
--   subContext :: Context '[Bool]
--   
--   &gt;&gt;&gt; let parentContext = False :. (NamedContext subContext :: NamedContext "subContext" '[Bool]) :. EmptyContext
--   
--   &gt;&gt;&gt; :type parentContext
--   parentContext :: Context '[Bool, NamedContext "subContext" '[Bool]]
--   
--   &gt;&gt;&gt; descendIntoNamedContext (Proxy :: Proxy "subContext") parentContext :: Context '[Bool]
--   True :. EmptyContext
--   </pre>
descendIntoNamedContext :: forall context name subContext. HasContextEntry context (NamedContext name subContext) => Proxy (name :: Symbol) -> Context context -> Context subContext

-- | Datatype wrapping a function used to check authentication.
newtype BasicAuthCheck usr
BasicAuthCheck :: (BasicAuthData -> IO (BasicAuthResult usr)) -> BasicAuthCheck usr
[unBasicAuthCheck] :: BasicAuthCheck usr -> BasicAuthData -> IO (BasicAuthResult usr)

-- | servant-server's current implementation of basic authentication is not
--   immune to certian kinds of timing attacks. Decoding payloads does not
--   take a fixed amount of time.
--   
--   The result of authentication/authorization
data BasicAuthResult usr
Unauthorized :: BasicAuthResult usr
BadPassword :: BasicAuthResult usr
NoSuchUser :: BasicAuthResult usr
Authorized :: usr -> BasicAuthResult usr
data ServantErr
ServantErr :: Int -> String -> ByteString -> [Header] -> ServantErr
[errHTTPCode] :: ServantErr -> Int
[errReasonPhrase] :: ServantErr -> String
[errBody] :: ServantErr -> ByteString
[errHeaders] :: ServantErr -> [Header]

-- | <a>err300</a> Multiple Choices
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err300 { errBody = "I can't choose." }
--   </pre>
err300 :: ServantErr

-- | <a>err301</a> Moved Permanently
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err301
--   </pre>
err301 :: ServantErr

-- | <a>err302</a> Found
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err302
--   </pre>
err302 :: ServantErr

-- | <a>err303</a> See Other
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err303
--   </pre>
err303 :: ServantErr

-- | <a>err304</a> Not Modified
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err304
--   </pre>
err304 :: ServantErr

-- | <a>err305</a> Use Proxy
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err305
--   </pre>
err305 :: ServantErr

-- | <a>err307</a> Temporary Redirect
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err307
--   </pre>
err307 :: ServantErr

-- | <a>err400</a> Bad Request
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err400 { errBody = "Your request makes no sense to me." }
--   </pre>
err400 :: ServantErr

-- | <a>err401</a> Unauthorized
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err401 { errBody = "Your credentials are invalid." }
--   </pre>
err401 :: ServantErr

-- | <a>err402</a> Payment Required
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err402 { errBody = "You have 0 credits. Please give me $$$." }
--   </pre>
err402 :: ServantErr

-- | <a>err403</a> Forbidden
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err403 { errBody = "Please login first." }
--   </pre>
err403 :: ServantErr

-- | <a>err404</a> Not Found
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err404 { errBody = "(╯°□°）╯︵ ┻━┻)." }
--   </pre>
err404 :: ServantErr

-- | <a>err405</a> Method Not Allowed
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err405 { errBody = "Your account privileges does not allow for this.  Please pay $$$." }
--   </pre>
err405 :: ServantErr

-- | <a>err406</a> Not Acceptable
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err406
--   </pre>
err406 :: ServantErr

-- | <a>err407</a> Proxy Authentication Required
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err407
--   </pre>
err407 :: ServantErr

-- | <a>err409</a> Conflict
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err409 { errBody = "Transaction conflicts with 59879cb56c7c159231eeacdd503d755f7e835f74" }
--   </pre>
err409 :: ServantErr

-- | <a>err410</a> Gone
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err410 { errBody = "I know it was here at some point, but.. I blame bad luck." }
--   </pre>
err410 :: ServantErr

-- | <a>err411</a> Length Required
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError err411
--   </pre>
err411 :: ServantErr

-- | <a>err412</a> Precondition Failed
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err412 { errBody = "Precondition fail: x &lt; 42 &amp;&amp; y &gt; 57" }
--   </pre>
err412 :: ServantErr

-- | <a>err413</a> Request Entity Too Large
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err413 { errBody = "Request exceeded 64k." }
--   </pre>
err413 :: ServantErr

-- | <a>err414</a> Request-URI Too Large
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err414 { errBody = "Maximum length is 64." }
--   </pre>
err414 :: ServantErr

-- | <a>err415</a> Unsupported Media Type
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err415 { errBody = "Supported media types:  gif, png" }
--   </pre>
err415 :: ServantErr

-- | <a>err416</a> Request range not satisfiable
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err416 { errBody = "Valid range is [0, 424242]." }
--   </pre>
err416 :: ServantErr

-- | <a>err417</a> Expectation Failed
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err417 { errBody = "I found a quux in the request.  This isn't going to work." }
--   </pre>
err417 :: ServantErr

-- | <a>err418</a> Expectation Failed
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err418 { errBody = "Apologies, this is not a webserver but a teapot." }
--   </pre>
err418 :: ServantErr

-- | <a>err422</a> Unprocessable Entity
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err422 { errBody = "I understood your request, but can't process it." }
--   </pre>
err422 :: ServantErr

-- | <a>err500</a> Internal Server Error
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err500 { errBody = "Exception in module A.B.C:55.  Have a great day!" }
--   </pre>
err500 :: ServantErr

-- | <a>err501</a> Not Implemented
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err501 { errBody = "/v1/foo is not supported with quux in the request." }
--   </pre>
err501 :: ServantErr

-- | <a>err502</a> Bad Gateway
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err502 { errBody = "Tried gateway foo, bar, and baz.  None responded." }
--   </pre>
err502 :: ServantErr

-- | <a>err503</a> Service Unavailable
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err503 { errBody = "We're rewriting in PHP." }
--   </pre>
err503 :: ServantErr

-- | <a>err504</a> Gateway Time-out
--   
--   Example:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err504 { errBody = "Backend foobar did not respond in 5 seconds." }
--   </pre>
err504 :: ServantErr

-- | <a>err505</a> HTTP Version not supported
--   
--   Example usage:
--   
--   <pre>
--   failingHandler :: Handler ()
--   failingHandler = throwError $ err505 { errBody = "I support HTTP/4.0 only." }
--   </pre>
err505 :: ServantErr

-- | The WAI application.
--   
--   Note that, since WAI 3.0, this type is structured in continuation
--   passing style to allow for proper safe resource handling. This was
--   handled in the past via other means (e.g., <tt>ResourceT</tt>). As a
--   demonstration:
--   
--   <pre>
--   app :: Application
--   app req respond = bracket_
--       (putStrLn "Allocating scarce resource")
--       (putStrLn "Cleaning up")
--       (respond $ responseLBS status200 [] "Hello World")
--   </pre>
type Application = Request -> Response -> IO ResponseReceived -> IO ResponseReceived

-- | A <tt><a>Tagged</a> s b</tt> value is a value <tt>b</tt> with an
--   attached phantom type <tt>s</tt>. This can be used in place of the
--   more traditional but less safe idiom of passing in an undefined value
--   with the type, because unlike an <tt>(s -&gt; b)</tt>, a
--   <tt><a>Tagged</a> s b</tt> can't try to use the argument <tt>s</tt> as
--   a real value.
--   
--   Moreover, you don't have to rely on the compiler to inline away the
--   extra argument, because the newtype is "free"
--   
--   <a>Tagged</a> has kind <tt>k -&gt; * -&gt; *</tt> if the compiler
--   supports <tt>PolyKinds</tt>, therefore there is an extra <tt>k</tt>
--   showing in the instance haddocks that may cause confusion.
newtype Tagged (s :: k) b :: forall k. () => k -> Type -> Type
Tagged :: b -> Tagged b
[unTagged] :: Tagged b -> b


module Servant.Server.Generic

-- | A type that specifies that an API record contains a server
--   implementation.
data AsServerT (m :: * -> *)
type AsServer = AsServerT Handler

-- | Transform record of routes into a WAI <a>Application</a>.
genericServe :: forall routes. (HasServer (ToServantApi routes) '[], GenericServant routes AsServer, Server (ToServantApi routes) ~ ToServant routes AsServer) => routes AsServer -> Application

-- | Transform a record of routes with custom monad into a WAI
--   <a>Application</a>, by providing a transformation to bring each
--   handler back in the <a>Handler</a> monad.
genericServeT :: forall (routes :: * -> *) (m :: * -> *). (GenericServant routes (AsServerT m), GenericServant routes AsApi, HasServer (ToServantApi routes) '[], ServerT (ToServantApi routes) m ~ ToServant routes (AsServerT m)) => (forall a. m a -> Handler a) -> routes (AsServerT m) -> Application

-- | Transform a record of routes with custom monad into a WAI
--   <a>Application</a>, while using the given <a>Context</a> to serve the
--   application (contexts are typically used by auth-related combinators
--   in servant, e.g to hold auth checks) and the given transformation to
--   map all the handlers back to the <a>Handler</a> monad.
genericServeTWithContext :: forall (routes :: * -> *) (m :: * -> *) (ctx :: [*]). (GenericServant routes (AsServerT m), GenericServant routes AsApi, HasServer (ToServantApi routes) ctx, ServerT (ToServantApi routes) m ~ ToServant routes (AsServerT m)) => (forall a. m a -> Handler a) -> routes (AsServerT m) -> Context ctx -> Application

-- | Transform record of endpoints into a <a>Server</a>.
genericServer :: GenericServant routes AsServer => routes AsServer -> ToServant routes AsServer
genericServerT :: GenericServant routes (AsServerT m) => routes (AsServerT m) -> ToServant routes (AsServerT m)
instance Servant.API.Generic.GenericMode (Servant.Server.Generic.AsServerT m)


-- | This module defines server-side handlers that lets you serve static
--   files.
--   
--   The most common needs for a web application are covered by
--   <a>serveDirectoryWebApp</a>, but the other variants allow you to use
--   different <a>StaticSettings</a> and <a>serveDirectoryWith</a> even
--   allows you to specify arbitrary <a>StaticSettings</a> to be used for
--   serving static files.
module Servant.Server.StaticFiles

-- | Serve anything under the specified directory as a <a>Raw</a> endpoint.
--   
--   <pre>
--   type MyApi = "static" :&gt; Raw
--   
--   server :: Server MyApi
--   server = serveDirectoryWebApp "/var/www"
--   </pre>
--   
--   would capture any request to <tt>/static/&lt;something&gt;</tt> and
--   look for <tt>&lt;something&gt;</tt> under <tt>/var/www</tt>.
--   
--   It will do its best to guess the MIME type for that file, based on the
--   extension, and send an appropriate <i>Content-Type</i> header if
--   possible.
--   
--   If your goal is to serve HTML, CSS and Javascript files that use the
--   rest of the API as a webapp backend, you will most likely not want the
--   static files to be hidden behind a <i>/static/</i> prefix. In that
--   case, remember to put the <a>serveDirectoryWebApp</a> handler in the
--   last position, because <i>servant</i> will try to match the handlers
--   in order.
--   
--   Corresponds to the <a>defaultWebAppSettings</a> <a>StaticSettings</a>
--   value.
serveDirectoryWebApp :: FilePath -> ServerT Raw m

-- | Same as <a>serveDirectoryWebApp</a>, but uses
--   <a>webAppSettingsWithLookup</a>.
serveDirectoryWebAppLookup :: ETagLookup -> FilePath -> ServerT Raw m

-- | Same as <a>serveDirectoryWebApp</a>, but uses
--   <a>defaultFileServerSettings</a>.
serveDirectoryFileServer :: FilePath -> ServerT Raw m

-- | Uses <a>embeddedSettings</a>.
serveDirectoryEmbedded :: [(FilePath, ByteString)] -> ServerT Raw m

-- | Alias for <a>staticApp</a>. Lets you serve a directory with arbitrary
--   <a>StaticSettings</a>. Useful when you want particular settings not
--   covered by the four other variants. This is the most flexible method.
serveDirectoryWith :: StaticSettings -> ServerT Raw m

-- | Same as <a>serveDirectoryFileServer</a>. It used to be the only file
--   serving function in servant pre-0.10 and will be kept around for a few
--   versions, but is deprecated.

-- | <i>Deprecated: Use serveDirectoryFileServer instead</i>
serveDirectory :: FilePath -> ServerT Raw m

module Servant

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt>'undefined :: a'</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k) :: forall k. () => k -> Type
Proxy :: Proxy

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

module Servant.Server.Experimental.Auth

-- | Specify the type of data returned after we've authenticated a request.
--   quite often this is some <tt>User</tt> datatype.
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
type family AuthServerData a :: *

-- | Handlers for AuthProtected resources
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
newtype AuthHandler r usr
AuthHandler :: (r -> Handler usr) -> AuthHandler r usr
[unAuthHandler] :: AuthHandler r usr -> r -> Handler usr

-- | NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
mkAuthHandler :: (r -> Handler usr) -> AuthHandler r usr
instance GHC.Generics.Generic (Servant.Server.Experimental.Auth.AuthHandler r usr)
instance forall k api (context :: [*]) (tag :: k). (Servant.Server.Internal.HasServer api context, Servant.Server.Internal.Context.HasContextEntry context (Servant.Server.Experimental.Auth.AuthHandler Network.Wai.Internal.Request (Servant.Server.Experimental.Auth.AuthServerData (Servant.API.Experimental.Auth.AuthProtect tag)))) => Servant.Server.Internal.HasServer (Servant.API.Experimental.Auth.AuthProtect tag Servant.API.Sub.:> api) context


-- | <i>Deprecated: Use Servant.Server.StaticFiles.</i>
module Servant.Utils.StaticFiles
