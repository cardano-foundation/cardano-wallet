-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Testing Framework for Haskell
--   
--   This package exposes internal types and functions that can be used to
--   extend Hspec's functionality.
@package hspec-core
@version 2.6.1


module Test.Hspec.Core.Util

-- | <tt>pluralize count singular</tt> pluralizes the given
--   <tt>singular</tt> word unless given <tt>count</tt> is 1.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; pluralize 0 "example"
--   "0 examples"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pluralize 1 "example"
--   "1 example"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; pluralize 2 "example"
--   "2 examples"
--   </pre>
pluralize :: Int -> String -> String

-- | Strip leading and trailing whitespace
strip :: String -> String

-- | ensure that lines are not longer than given <tt>n</tt>, insert line
--   breaks at word boundaries
lineBreaksAt :: Int -> String -> [String]

-- | A <a>Path</a> describes the location of a spec item within a spec
--   tree.
--   
--   It consists of a list of group descriptions and a requirement
--   description.
type Path = ([String], String)

-- | Join a <a>Path</a> with slashes. The result will have a leading and a
--   trailing slash.
joinPath :: Path -> String

-- | Try to create a proper English sentence from a path by applying some
--   heuristics.
formatRequirement :: Path -> String

-- | A predicate that can be used to filter a spec tree.
filterPredicate :: String -> Path -> Bool

-- | <tt>safeTry</tt> evaluates given action and returns its result. If an
--   exception occurs, the exception is returned instead. Unlike <a>try</a>
--   it is agnostic to asynchronous exceptions.
safeTry :: IO a -> IO (Either SomeException a)

-- | The function <a>formatException</a> converts an exception to a string.
--   
--   This is different from <a>show</a>. The type of the exception is
--   included, e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; formatException (toException DivideByZero)
--   "ArithException (divide by zero)"
--   </pre>
--   
--   For <a>IOException</a>s the <a>IOErrorType</a> is included, as well.
formatException :: SomeException -> String


module Test.Hspec.Core.Hooks

-- | Run a custom action before every spec item.
before :: IO a -> SpecWith a -> Spec

-- | Run a custom action before every spec item.
before_ :: IO () -> SpecWith a -> SpecWith a

-- | Run a custom action before every spec item.
beforeWith :: (b -> IO a) -> SpecWith a -> SpecWith b

-- | Run a custom action before the first spec item.
beforeAll :: IO a -> SpecWith a -> Spec

-- | Run a custom action before the first spec item.
beforeAll_ :: IO () -> SpecWith a -> SpecWith a

-- | Run a custom action after every spec item.
after :: ActionWith a -> SpecWith a -> SpecWith a

-- | Run a custom action after every spec item.
after_ :: IO () -> SpecWith a -> SpecWith a

-- | Run a custom action after the last spec item.
afterAll :: ActionWith a -> SpecWith a -> SpecWith a

-- | Run a custom action after the last spec item.
afterAll_ :: IO () -> SpecWith a -> SpecWith a

-- | Run a custom action before and/or after every spec item.
around :: (ActionWith a -> IO ()) -> SpecWith a -> Spec

-- | Run a custom action before and/or after every spec item.
around_ :: (IO () -> IO ()) -> SpecWith a -> SpecWith a

-- | Run a custom action before and/or after every spec item.
aroundWith :: (ActionWith a -> ActionWith b) -> SpecWith a -> SpecWith b


-- | This module provides access to Hspec's internals. It is less stable
--   than other parts of the API. For most users <tt>Test.Hspec</tt> is
--   more suitable!
module Test.Hspec.Core.Spec

-- | The <tt>it</tt> function creates a spec item.
--   
--   A spec item consists of:
--   
--   <ul>
--   <li>a textual description of a desired behavior</li>
--   <li>an example for that behavior</li>
--   </ul>
--   
--   <pre>
--   describe "absolute" $ do
--     it "returns a positive number when given a negative number" $
--       absolute (-1) == 1
--   </pre>
it :: (HasCallStack, Example a) => String -> a -> SpecWith (Arg a)

-- | <tt>specify</tt> is an alias for <a>it</a>.
specify :: (HasCallStack, Example a) => String -> a -> SpecWith (Arg a)

-- | The <tt>describe</tt> function combines a list of specs into a larger
--   spec.
describe :: HasCallStack => String -> SpecWith a -> SpecWith a

-- | <tt>context</tt> is an alias for <a>describe</a>.
context :: HasCallStack => String -> SpecWith a -> SpecWith a

-- | <a>pending</a> can be used to mark a spec item as pending.
--   
--   If you want to textually specify a behavior but do not have an example
--   yet, use this:
--   
--   <pre>
--   describe "fancyFormatter" $ do
--     it "can format text in a way that everyone likes" $
--       pending
--   </pre>
pending :: HasCallStack => Expectation

-- | <a>pendingWith</a> is similar to <a>pending</a>, but it takes an
--   additional string argument that can be used to specify the reason for
--   why the spec item is pending.
pendingWith :: HasCallStack => String -> Expectation

-- | Changing <a>it</a> to <a>xit</a> marks the corresponding spec item as
--   pending.
--   
--   This can be used to temporarily disable a spec item.
xit :: (HasCallStack, Example a) => String -> a -> SpecWith (Arg a)

-- | <tt>xspecify</tt> is an alias for <a>xit</a>.
xspecify :: (HasCallStack, Example a) => String -> a -> SpecWith (Arg a)

-- | Changing <a>describe</a> to <a>xdescribe</a> marks all spec items of
--   the corresponding subtree as pending.
--   
--   This can be used to temporarily disable spec items.
xdescribe :: HasCallStack => String -> SpecWith a -> SpecWith a

-- | <tt>xcontext</tt> is an alias for <a>xdescribe</a>.
xcontext :: HasCallStack => String -> SpecWith a -> SpecWith a

-- | <a>focus</a> focuses all spec items of the given spec.
--   
--   Applying <a>focus</a> to a spec with focused spec items has no effect.
focus :: SpecWith a -> SpecWith a

-- | <tt>fit</tt> is an alias for <tt>fmap focus . it</tt>
fit :: (HasCallStack, Example a) => String -> a -> SpecWith (Arg a)

-- | <tt>fspecify</tt> is an alias for <a>fit</a>.
fspecify :: (HasCallStack, Example a) => String -> a -> SpecWith (Arg a)

-- | <tt>fdescribe</tt> is an alias for <tt>fmap focus . describe</tt>
fdescribe :: HasCallStack => String -> SpecWith a -> SpecWith a

-- | <tt>fcontext</tt> is an alias for <a>fdescribe</a>.
fcontext :: HasCallStack => String -> SpecWith a -> SpecWith a

-- | <a>parallel</a> marks all spec items of the given spec to be safe for
--   parallel evaluation.
parallel :: SpecWith a -> SpecWith a

-- | <a>sequential</a> marks all spec items of the given spec to be
--   evaluated sequentially.
sequential :: SpecWith a -> SpecWith a
type Spec = SpecWith ()
type SpecWith a = SpecM a ()

-- | A writer monad for <a>SpecTree</a> forests
newtype SpecM a r
SpecM :: WriterT [SpecTree a] IO r -> SpecM a r

-- | Convert a <a>Spec</a> to a forest of <a>SpecTree</a>s.
runSpecM :: SpecWith a -> IO [SpecTree a]

-- | Create a <a>Spec</a> from a forest of <a>SpecTree</a>s.
fromSpecList :: [SpecTree a] -> SpecWith a

-- | Run an IO action while constructing the spec tree.
--   
--   <a>SpecM</a> is a monad to construct a spec tree, without executing
--   any spec items. <tt>runIO</tt> allows you to run IO actions during
--   this construction phase. The IO action is always run when the spec
--   tree is constructed (e.g. even when <tt>--dry-run</tt> is specified).
--   If you do not need the result of the IO action to construct the spec
--   tree, <a>beforeAll</a> may be more suitable for your use case.
runIO :: IO r -> SpecM a r
mapSpecItem :: (ActionWith a -> ActionWith b) -> (Item a -> Item b) -> SpecWith a -> SpecWith b
mapSpecItem_ :: (Item a -> Item a) -> SpecWith a -> SpecWith a
modifyParams :: (Params -> Params) -> SpecWith a -> SpecWith a

-- | A type class for examples
class Example e where {
    type family Arg e;
    type Arg e = ();
}
evaluateExample :: Example e => e -> Params -> (ActionWith (Arg e) -> IO ()) -> ProgressCallback -> IO Result
data Params
Params :: Args -> Int -> Params
[paramsQuickCheckArgs] :: Params -> Args
[paramsSmallCheckDepth] :: Params -> Int
defaultParams :: Params

-- | An <a>IO</a> action that expects an argument of type <tt>a</tt>
type ActionWith a = a -> IO ()
type Progress = (Int, Int)
type ProgressCallback = Progress -> IO ()

-- | The result of running an example
data Result
Result :: String -> ResultStatus -> Result
[resultInfo] :: Result -> String
[resultStatus] :: Result -> ResultStatus
data ResultStatus
Success :: ResultStatus
Pending :: Maybe Location -> Maybe String -> ResultStatus
Failure :: Maybe Location -> FailureReason -> ResultStatus

-- | <tt>Location</tt> is used to represent source locations.
data Location
Location :: FilePath -> Int -> Int -> Location
[locationFile] :: Location -> FilePath
[locationLine] :: Location -> Int
[locationColumn] :: Location -> Int
data FailureReason
NoReason :: FailureReason
Reason :: String -> FailureReason
ExpectedButGot :: Maybe String -> String -> String -> FailureReason
Error :: Maybe String -> SomeException -> FailureReason
safeEvaluateExample :: Example e => e -> Params -> (ActionWith (Arg e) -> IO ()) -> ProgressCallback -> IO Result

-- | A tree is used to represent a spec internally. The tree is parametrize
--   over the type of cleanup actions and the type of the actual spec
--   items.
type SpecTree a = Tree (ActionWith a) (Item a)

-- | Internal tree data structure
data Tree c a
Node :: String -> [Tree c a] -> Tree c a
NodeWithCleanup :: c -> [Tree c a] -> Tree c a
Leaf :: a -> Tree c a

-- | <tt>Item</tt> is used to represent spec items internally. A spec item
--   consists of:
--   
--   <ul>
--   <li>a textual description of a desired behavior</li>
--   <li>an example for that behavior</li>
--   <li>additional meta information</li>
--   </ul>
--   
--   Everything that is an instance of the <a>Example</a> type class can be
--   used as an example, including QuickCheck properties, Hspec
--   expectations and HUnit assertions.
data Item a
Item :: String -> Maybe Location -> Maybe Bool -> Bool -> (Params -> (ActionWith a -> IO ()) -> ProgressCallback -> IO Result) -> Item a

-- | Textual description of behavior
[itemRequirement] :: Item a -> String

-- | Source location of the spec item
[itemLocation] :: Item a -> Maybe Location

-- | A flag that indicates whether it is safe to evaluate this spec item in
--   parallel with other spec items
[itemIsParallelizable] :: Item a -> Maybe Bool

-- | A flag that indicates whether this spec item is focused.
[itemIsFocused] :: Item a -> Bool

-- | Example for behavior
[itemExample] :: Item a -> Params -> (ActionWith a -> IO ()) -> ProgressCallback -> IO Result

-- | The <tt>specGroup</tt> function combines a list of specs into a larger
--   spec.
specGroup :: HasCallStack => String -> [SpecTree a] -> SpecTree a

-- | The <tt>specItem</tt> function creates a spec item.
specItem :: (HasCallStack, Example a) => String -> a -> SpecTree (Arg a)
bimapTree :: (a -> b) -> (c -> d) -> Tree a c -> Tree b d
location :: HasCallStack => Maybe Location


module Test.Hspec.Core.QuickCheck

-- | Use modified <a>Args</a> for given spec.
modifyArgs :: (Args -> Args) -> SpecWith a -> SpecWith a

-- | Use a modified <a>maxSuccess</a> for given spec.
modifyMaxSuccess :: (Int -> Int) -> SpecWith a -> SpecWith a

-- | Use a modified <a>maxDiscardRatio</a> for given spec.
modifyMaxDiscardRatio :: (Int -> Int) -> SpecWith a -> SpecWith a

-- | Use a modified <a>maxSize</a> for given spec.
modifyMaxSize :: (Int -> Int) -> SpecWith a -> SpecWith a

-- | Use a modified <a>maxShrinks</a> for given spec.
modifyMaxShrinks :: (Int -> Int) -> SpecWith a -> SpecWith a


-- | This module contains formatters that can be used with
--   <a>hspecWith</a>.
module Test.Hspec.Core.Formatters
silent :: Formatter
specdoc :: Formatter
progress :: Formatter
failed_examples :: Formatter
data Formatter
Formatter :: FormatM () -> ([String] -> String -> FormatM ()) -> FormatM () -> (Path -> Progress -> FormatM ()) -> (Path -> String -> FormatM ()) -> (Path -> String -> FailureReason -> FormatM ()) -> (Path -> String -> Maybe String -> FormatM ()) -> FormatM () -> FormatM () -> Formatter
[headerFormatter] :: Formatter -> FormatM ()

-- | evaluated before each test group
[exampleGroupStarted] :: Formatter -> [String] -> String -> FormatM ()
[exampleGroupDone] :: Formatter -> FormatM ()

-- | used to notify the progress of the currently evaluated example
--   
--   <i>Note</i>: This is only called when interactive/color mode.
[exampleProgress] :: Formatter -> Path -> Progress -> FormatM ()

-- | evaluated after each successful example
[exampleSucceeded] :: Formatter -> Path -> String -> FormatM ()

-- | evaluated after each failed example
[exampleFailed] :: Formatter -> Path -> String -> FailureReason -> FormatM ()

-- | evaluated after each pending example
[examplePending] :: Formatter -> Path -> String -> Maybe String -> FormatM ()

-- | evaluated after a test run
[failedFormatter] :: Formatter -> FormatM ()

-- | evaluated after <tt>failuresFormatter</tt>
[footerFormatter] :: Formatter -> FormatM ()
data FailureReason
NoReason :: FailureReason
Reason :: String -> FailureReason
ExpectedButGot :: Maybe String -> String -> String -> FailureReason
Error :: Maybe String -> SomeException -> FailureReason
type FormatM = Free FormatF

-- | Get the number of successful examples encountered so far.
getSuccessCount :: FormatM Int

-- | Get the number of pending examples encountered so far.
getPendingCount :: FormatM Int

-- | Get the number of failed examples encountered so far.
getFailCount :: FormatM Int

-- | Get the total number of examples encountered so far.
getTotalCount :: FormatM Int
data FailureRecord
FailureRecord :: Maybe Location -> Path -> FailureReason -> FailureRecord
[failureRecordLocation] :: FailureRecord -> Maybe Location
[failureRecordPath] :: FailureRecord -> Path
[failureRecordMessage] :: FailureRecord -> FailureReason

-- | Get the list of accumulated failure messages.
getFailMessages :: FormatM [FailureRecord]

-- | The random seed that is used for QuickCheck.
usedSeed :: FormatM Integer
newtype Seconds
Seconds :: Double -> Seconds

-- | Get the used CPU time since the test run has been started.
getCPUTime :: FormatM (Maybe Seconds)

-- | Get the passed real time since the test run has been started.
getRealTime :: FormatM Seconds

-- | Append some output to the report.
write :: String -> FormatM ()

-- | The same as <a>write</a>, but adds a newline character.
writeLine :: String -> FormatM ()
writeTransient :: String -> FormatM ()

-- | Set output color to cyan, run given action, and finally restore the
--   default color.
withInfoColor :: FormatM a -> FormatM a

-- | Set output color to green, run given action, and finally restore the
--   default color.
withSuccessColor :: FormatM a -> FormatM a

-- | Set output color to yellow, run given action, and finally restore the
--   default color.
withPendingColor :: FormatM a -> FormatM a

-- | Set output color to red, run given action, and finally restore the
--   default color.
withFailColor :: FormatM a -> FormatM a

-- | Return <a>True</a> if the user requested colorized diffs, <a>False</a>
--   otherwise.
useDiff :: FormatM Bool

-- | Output given chunk in red.
extraChunk :: String -> FormatM ()

-- | Output given chunk in green.
missingChunk :: String -> FormatM ()

-- | The function <a>formatException</a> converts an exception to a string.
--   
--   This is different from <a>show</a>. The type of the exception is
--   included, e.g.:
--   
--   <pre>
--   &gt;&gt;&gt; formatException (toException DivideByZero)
--   "ArithException (divide by zero)"
--   </pre>
--   
--   For <a>IOException</a>s the <a>IOErrorType</a> is included, as well.
formatException :: SomeException -> String


module Test.Hspec.Core.Runner

-- | Run a given spec and write a report to <a>stdout</a>. Exit with
--   <a>exitFailure</a> if at least one spec item fails.
--   
--   <i>Note</i>: <a>hspec</a> handles command-line options and reads
--   config files. This is not always desired. Use <a>runSpec</a> if you
--   need more control over these aspects.
hspec :: Spec -> IO ()

-- | <a>runSpec</a> is the most basic primitive to run a spec. <a>hspec</a>
--   is defined in terms of <tt>runSpec</tt>:
--   
--   <pre>
--   hspec spec =
--         <a>getArgs</a>
--     &gt;&gt;= <a>readConfig</a> <a>defaultConfig</a>
--     &gt;&gt;= <a>withArgs</a> [] . runSpec spec
--     &gt;&gt;= <a>evaluateSummary</a>
--   </pre>
runSpec :: Spec -> Config -> IO Summary
data Config
Config :: Bool -> Bool -> Bool -> Bool -> Maybe FilePath -> Bool -> Bool -> Maybe (Path -> Bool) -> Maybe (Path -> Bool) -> Maybe Integer -> Maybe Int -> Maybe Int -> Maybe Int -> Int -> ColorMode -> Bool -> Maybe Formatter -> Bool -> Either Handle FilePath -> Maybe Int -> Config
[configIgnoreConfigFile] :: Config -> Bool
[configDryRun] :: Config -> Bool
[configPrintCpuTime] :: Config -> Bool
[configFastFail] :: Config -> Bool
[configFailureReport] :: Config -> Maybe FilePath
[configRerun] :: Config -> Bool
[configRerunAllOnSuccess] :: Config -> Bool

-- | A predicate that is used to filter the spec before it is run. Only
--   examples that satisfy the predicate are run.
[configFilterPredicate] :: Config -> Maybe (Path -> Bool)
[configSkipPredicate] :: Config -> Maybe (Path -> Bool)
[configQuickCheckSeed] :: Config -> Maybe Integer
[configQuickCheckMaxSuccess] :: Config -> Maybe Int
[configQuickCheckMaxDiscardRatio] :: Config -> Maybe Int
[configQuickCheckMaxSize] :: Config -> Maybe Int
[configSmallCheckDepth] :: Config -> Int
[configColorMode] :: Config -> ColorMode
[configDiff] :: Config -> Bool
[configFormatter] :: Config -> Maybe Formatter
[configHtmlOutput] :: Config -> Bool
[configOutputFile] :: Config -> Either Handle FilePath
[configConcurrentJobs] :: Config -> Maybe Int
data ColorMode
ColorAuto :: ColorMode
ColorNever :: ColorMode
ColorAlways :: ColorMode

-- | A <a>Path</a> describes the location of a spec item within a spec
--   tree.
--   
--   It consists of a list of group descriptions and a requirement
--   description.
type Path = ([String], String)
defaultConfig :: Config

-- | Add a filter predicate to config. If there is already a filter
--   predicate, then combine them with <a>||</a>.
configAddFilter :: (Path -> Bool) -> Config -> Config

-- | <a>readConfig</a> parses config options from several sources and
--   constructs a <a>Config</a> value. It takes options from:
--   
--   <ol>
--   <li><tt>~/.hspec</tt> (a config file in the user's home
--   directory)</li>
--   <li><tt>.hspec</tt> (a config file in the current working
--   directory)</li>
--   <li>the environment variable <tt>HSPEC_OPTIONS</tt></li>
--   <li>the provided list of command-line options (the second argument to
--   <tt>readConfig</tt>)</li>
--   </ol>
--   
--   (precedence from low to high)
--   
--   When parsing fails then <tt>readConfig</tt> writes an error message to
--   <a>stderr</a> and exits with <a>exitFailure</a>.
--   
--   When <tt>--help</tt> is provided as a command-line option then
--   <tt>readConfig</tt> writes a help message to <a>stdout</a> and exits
--   with <a>exitSuccess</a>.
--   
--   A common way to use <tt>readConfig</tt> is:
--   
--   <pre>
--   <a>getArgs</a> &gt;&gt;= readConfig <a>defaultConfig</a>
--   </pre>
readConfig :: Config -> [String] -> IO Config

-- | Summary of a test run.
data Summary
Summary :: Int -> Int -> Summary
[summaryExamples] :: Summary -> Int
[summaryFailures] :: Summary -> Int

-- | <a>True</a> if the given <a>Summary</a> indicates that there were no
--   failures, <a>False</a> otherwise.
isSuccess :: Summary -> Bool

-- | Exit with <a>exitFailure</a> if the given <a>Summary</a> indicates
--   that there was at least one failure.
evaluateSummary :: Summary -> IO ()

-- | Run given spec with custom options. This is similar to <a>hspec</a>,
--   but more flexible.
hspecWith :: Config -> Spec -> IO ()

-- | Run given spec and returns a summary of the test run.
--   
--   <i>Note</i>: <a>hspecResult</a> does not exit with <a>exitFailure</a>
--   on failing spec items. If you need this, you have to check the
--   <a>Summary</a> yourself and act accordingly.
hspecResult :: Spec -> IO Summary

-- | Run given spec with custom options and returns a summary of the test
--   run.
--   
--   <i>Note</i>: <a>hspecWithResult</a> does not exit with
--   <a>exitFailure</a> on failing spec items. If you need this, you have
--   to check the <a>Summary</a> yourself and act accordingly.
hspecWithResult :: Config -> Spec -> IO Summary
instance GHC.Show.Show Test.Hspec.Core.Runner.Summary
instance GHC.Classes.Eq Test.Hspec.Core.Runner.Summary
instance GHC.Base.Monoid Test.Hspec.Core.Runner.Summary
instance GHC.Base.Semigroup Test.Hspec.Core.Runner.Summary
