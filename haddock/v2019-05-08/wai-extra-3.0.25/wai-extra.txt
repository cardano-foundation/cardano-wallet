-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Provides some basic WAI handlers and middleware.
--   
--   Provides basic WAI handler and middleware functionality:
--   
--   <ul>
--   <li>WAI Testing Framework</li>
--   </ul>
--   
--   Hspec testing facilities and helpers for WAI.
--   
--   <ul>
--   <li>Event Source/Event Stream</li>
--   </ul>
--   
--   Send server events to the client. Compatible with the JavaScript
--   EventSource API.
--   
--   <ul>
--   <li>Accept Override</li>
--   </ul>
--   
--   Override the Accept header in a request. Special handling for the
--   _accept query parameter (which is used throughout WAI override the
--   Accept header).
--   
--   <ul>
--   <li>Add Headers</li>
--   </ul>
--   
--   WAI Middleware for adding arbitrary headers to an HTTP request.
--   
--   <ul>
--   <li>Clean Path</li>
--   </ul>
--   
--   Clean a request path to a canonical form.
--   
--   <ul>
--   <li>GZip Compression</li>
--   </ul>
--   
--   Negotiate HTTP payload gzip compression.
--   
--   <ul>
--   <li>HTTP Basic Authentication</li>
--   </ul>
--   
--   WAI Basic Authentication Middleware which uses Authorization header.
--   
--   <ul>
--   <li>JSONP</li>
--   </ul>
--   
--   "JSON with Padding" middleware. Automatic wrapping of JSON responses
--   to convert into JSONP.
--   
--   <ul>
--   <li>Method Override / Post</li>
--   </ul>
--   
--   Allows overriding of the HTTP request method via the _method query
--   string parameter.
--   
--   <ul>
--   <li>Request Logging</li>
--   </ul>
--   
--   Request logging middleware for development and production environments
--   
--   <ul>
--   <li>Request Rewrite</li>
--   </ul>
--   
--   Rewrite request path info based on a custom conversion rules.
--   
--   <ul>
--   <li>Stream Files</li>
--   </ul>
--   
--   Convert ResponseFile type responses into ResponseStream type.
--   
--   <ul>
--   <li>Virtual Host</li>
--   </ul>
--   
--   Redirect incoming requests to a new host based on custom rules.
--   
--   API docs and the README are available at
--   <a>http://www.stackage.org/package/wai-extra</a>.
@package wai-extra
@version 3.0.25


-- | Internal module, usually you don't need to use it.
module Network.Wai.EventSource.EventStream

-- | Type representing a communication over an event stream. This can be an
--   actual event, a comment, a modification to the retry timer, or a
--   special "close" event indicating the server should close the
--   connection.
data ServerEvent
ServerEvent :: Maybe Builder -> Maybe Builder -> [Builder] -> ServerEvent
[eventName] :: ServerEvent -> Maybe Builder
[eventId] :: ServerEvent -> Maybe Builder
[eventData] :: ServerEvent -> [Builder]
CommentEvent :: Builder -> ServerEvent
[eventComment] :: ServerEvent -> Builder
RetryEvent :: Int -> ServerEvent
[eventRetry] :: ServerEvent -> Int
CloseEvent :: ServerEvent

-- | Converts a <a>ServerEvent</a> to its wire representation as specified
--   by the <tt>text/event-stream</tt> content type.
eventToBuilder :: ServerEvent -> Maybe Builder


-- | A WAI adapter to the HTML5 Server-Sent Events API.
--   
--   If running through a proxy like Nginx you might need to add the
--   headers:
--   
--   <pre>
--   [ ("X-Accel-Buffering", "no"), ("Cache-Control", "no-cache")]
--   </pre>
module Network.Wai.EventSource

-- | Type representing a communication over an event stream. This can be an
--   actual event, a comment, a modification to the retry timer, or a
--   special "close" event indicating the server should close the
--   connection.
data ServerEvent
ServerEvent :: Maybe Builder -> Maybe Builder -> [Builder] -> ServerEvent
[eventName] :: ServerEvent -> Maybe Builder
[eventId] :: ServerEvent -> Maybe Builder
[eventData] :: ServerEvent -> [Builder]
CommentEvent :: Builder -> ServerEvent
[eventComment] :: ServerEvent -> Builder
RetryEvent :: Int -> ServerEvent
[eventRetry] :: ServerEvent -> Int
CloseEvent :: ServerEvent

-- | Make a new WAI EventSource application reading events from the given
--   channel.
eventSourceAppChan :: Chan ServerEvent -> Application

-- | Make a new WAI EventSource application reading events from the given
--   IO action.
eventSourceAppIO :: IO ServerEvent -> Application


-- | Backend for Common Gateway Interface. Almost all users should use the
--   <a>run</a> function.
module Network.Wai.Handler.CGI

-- | Run an application using CGI.
run :: Application -> IO ()

-- | Some web servers provide an optimization for sending files via a
--   sendfile system call via a special header. To use this feature,
--   provide that header name here.
runSendfile :: ByteString -> Application -> IO ()

-- | A generic CGI helper, which allows other backends (FastCGI and SCGI)
--   to use the same code as CGI. Most users will not need this function,
--   and can stick with <a>run</a> or <a>runSendfile</a>.
runGeneric :: [(String, String)] -> (Int -> IO (IO ByteString)) -> (ByteString -> IO ()) -> Maybe ByteString -> Application -> IO ()
requestBodyFunc :: (Int -> IO (Maybe ByteString)) -> Int -> IO (IO ByteString)

module Network.Wai.Handler.SCGI
run :: Application -> IO ()
runSendfile :: ByteString -> Application -> IO ()


-- | Some helpers for dealing with WAI <a>Header</a>s.
module Network.Wai.Header

-- | More useful for a response. A Wai Request already has a
--   requestBodyLength
contentLength :: [(HeaderName, ByteString)] -> Maybe Integer

module Network.Wai.Middleware.AcceptOverride
acceptOverride :: Middleware


-- | Since 3.0.3
module Network.Wai.Middleware.AddHeaders

-- | Prepend a list of headers without any checks
--   
--   Since 3.0.3
addHeaders :: [(ByteString, ByteString)] -> Middleware


-- | Automatically produce responses to HEAD requests based on the
--   underlying applications GET response.
module Network.Wai.Middleware.Autohead
autohead :: Middleware

module Network.Wai.Middleware.CleanPath
cleanPath :: ([Text] -> Either ByteString [Text]) -> ByteString -> ([Text] -> Application) -> Application


-- | Automatic gzip compression of responses.
module Network.Wai.Middleware.Gzip

-- | Use gzip to compress the body of the response.
--   
--   Analyzes the "Accept-Encoding" header from the client to determine if
--   gzip is supported.
--   
--   File responses will be compressed according to the <a>GzipFiles</a>
--   setting.
gzip :: GzipSettings -> Middleware
data GzipSettings
gzipFiles :: GzipSettings -> GzipFiles

-- | Gzip behavior for files.
data GzipFiles

-- | Do not compress file responses.
GzipIgnore :: GzipFiles

-- | Compress files. Note that this may counteract zero-copy response
--   optimizations on some platforms.
GzipCompress :: GzipFiles

-- | Compress files, caching them in some directory.
GzipCacheFolder :: FilePath -> GzipFiles

-- | If we use compression then try to use the filename with ".gz" appended
--   to it, if the file is missing then try next action
GzipPreCompressed :: GzipFiles -> GzipFiles
gzipCheckMime :: GzipSettings -> ByteString -> Bool

-- | The default value for this type.
def :: Default a => a

-- | MIME types that will be compressed by default: <tt>text/</tt>
--   <tt>*</tt>, <tt>application/json</tt>,
--   <tt>application/javascript</tt>, <tt>application/ecmascript</tt>,
--   <tt>image/x-icon</tt>.
defaultCheckMime :: ByteString -> Bool
instance GHC.Read.Read Network.Wai.Middleware.Gzip.GzipFiles
instance GHC.Classes.Eq Network.Wai.Middleware.Gzip.GzipFiles
instance GHC.Show.Show Network.Wai.Middleware.Gzip.GzipFiles
instance Data.Default.Class.Default Network.Wai.Middleware.Gzip.GzipSettings


-- | Implements HTTP Basic Authentication.
--   
--   This module may add digest authentication in the future.
module Network.Wai.Middleware.HttpAuth

-- | Perform basic authentication.
--   
--   <pre>
--   basicAuth (\u p -&gt; return $ u == "michael" &amp;&amp; p == "mypass") "My Realm"
--   </pre>
basicAuth :: CheckCreds -> AuthSettings -> Middleware

-- | Like <a>basicAuth</a>, but also passes a request to the authentication
--   function.
basicAuth' :: (Request -> CheckCreds) -> AuthSettings -> Middleware

-- | Check if a given username and password is valid.
type CheckCreds = ByteString -> ByteString -> IO Bool

-- | Basic authentication settings. This value is an instance of
--   <tt>IsString</tt>, so the recommended approach to create a value is to
--   provide a string literal (which will be the realm) and then overriding
--   individual fields.
--   
--   <pre>
--   "My Realm" { authIsProtected = someFunc } :: AuthSettings
--   </pre>
data AuthSettings

authRealm :: AuthSettings -> ByteString

-- | Takes the realm and returns an appropriate 401 response when
--   authentication is not provided.
authOnNoAuth :: AuthSettings -> ByteString -> Application

-- | Determine if access to the requested resource is restricted.
--   
--   Default: always returns <tt>True</tt>.
authIsProtected :: AuthSettings -> Request -> IO Bool

-- | Extract basic authentication data from usually <b>Authorization</b>
--   header value. Returns username and password
extractBasicAuth :: ByteString -> Maybe (ByteString, ByteString)

-- | Extract bearer authentication data from <b>Authorization</b> header
--   value. Returns bearer token
extractBearerAuth :: ByteString -> Maybe ByteString
instance Data.String.IsString Network.Wai.Middleware.HttpAuth.AuthSettings


-- | Automatic wrapping of JSON responses to convert into JSONP.
module Network.Wai.Middleware.Jsonp

-- | Wrap json responses in a jsonp callback.
--   
--   Basically, if the user requested a "text/javascript" and supplied a
--   "callback" GET parameter, ask the application for an
--   "application/json" response, then convert that into a JSONP response,
--   having a content type of "text/javascript" and calling the specified
--   callback function.
jsonp :: Middleware


-- | Only allow local connections.
module Network.Wai.Middleware.Local

-- | This middleware rejects non-local connections with a specific
--   response. It is useful when supporting web-based local applications,
--   which would typically want to reject external connections.
local :: Response -> Middleware

module Network.Wai.Middleware.MethodOverride

-- | Overriding of HTTP request method via <tt>_method</tt> query string
--   parameter.
--   
--   This middleware only applies when the initial request method is POST.
--   Allows submitting of normal HTML forms, without worries of semantic
--   mismatches with the HTTP spec.
methodOverride :: Middleware


-- | Changes the request-method via first post-parameter _method.
module Network.Wai.Middleware.MethodOverridePost

-- | Allows overriding of the HTTP request method via the _method post
--   string parameter.
--   
--   <ul>
--   <li>Looks for the Content-Type requestHeader.</li>
--   <li>If the header is set to application/x-www-form-urlencoded and the
--   first POST parameter is _method then it changes the request-method to
--   the value of that parameter.</li>
--   <li>This middleware only applies when the initial request method is
--   POST.</li>
--   </ul>
methodOverridePost :: Middleware

module Network.Wai.Middleware.Rewrite

-- | A tuple of the path sections as [<a>Text</a>] and query parameters as
--   <a>Query</a>. This makes writing type signatures for the conversion
--   function far more pleasant.
--   
--   Note that this uses <a>Query</a> not <a>QueryText</a> to more
--   accurately reflect the paramaters that can be supplied in URLs. It may
--   be safe to treat parameters as text; use the <a>queryToQueryText</a>
--   and <a>queryTextToQuery</a> functions to interconvert.
type PathsAndQueries = ([Text], Query)

-- | Rewrite based on your own conversion function for paths and queries.
--   This function is to be supplied by users of this library, and operates
--   in <a>IO</a>.
rewriteWithQueries :: (PathsAndQueries -> RequestHeaders -> IO PathsAndQueries) -> Middleware

-- | Rewrite based on pure conversion function for paths and queries. This
--   function is to be supplied by users of this library.
rewritePureWithQueries :: (PathsAndQueries -> RequestHeaders -> PathsAndQueries) -> Middleware

-- | Rewrite root requests (/) to a specified path
--   
--   Note that <i>index.html</i> in example below should already be a valid
--   route.
--   
--   <pre>
--   rewriteRoot "index.html" :: Middleware
--   </pre>
rewriteRoot :: Text -> Middleware

-- | Rewrite based on your own conversion function for paths only, to be
--   supplied by users of this library (with the conversion operating in
--   <a>IO</a>).
--   
--   For new code, use <a>rewriteWithQueries</a> instead.

-- | <i>Warning: This modifies the <a>rawPathInfo</a> field of a
--   <a>Request</a>. This is not recommended behaviour; it is however how
--   this function has worked in the past. Use <a>rewriteWithQueries</a>
--   instead</i>
rewrite :: ([Text] -> RequestHeaders -> IO [Text]) -> Middleware

-- | Rewrite based on pure conversion function for paths only, to be
--   supplied by users of this library.
--   
--   For new code, use <a>rewritePureWithQueries</a> instead.

-- | <i>Warning: This modifies the <a>rawPathInfo</a> field of a
--   <a>Request</a>. This is not recommended behaviour; it is however how
--   this function has worked in the past. Use
--   <a>rewritePureWithQueries</a> instead</i>
rewritePure :: ([Text] -> RequestHeaders -> [Text]) -> Middleware

-- | Modify a <a>Request</a> using the supplied function in <a>IO</a>. This
--   is suitable for the reverse proxy example.
rewriteRequest :: (PathsAndQueries -> RequestHeaders -> IO PathsAndQueries) -> Request -> IO Request

-- | Modify a <a>Request</a> using the pure supplied function. This is
--   suitable for the reverse proxy example.
rewriteRequestPure :: (PathsAndQueries -> RequestHeaders -> PathsAndQueries) -> Request -> Request


-- | Since 3.0.9
module Network.Wai.Middleware.Routed

-- | Apply a middleware based on a test of pathInfo
--   
--   example:
--   
--   <pre>
--   let corsify = routedMiddleWare ("static" `elem`) addCorsHeaders
--   </pre>
--   
--   Since 3.0.9
routedMiddleware :: ([Text] -> Bool) -> Middleware -> Middleware

-- | Only apply the middleware to certain hosts
--   
--   Since 3.0.9
hostedMiddleware :: ByteString -> Middleware -> Middleware


-- | Since 3.0.4
module Network.Wai.Middleware.StreamFile

-- | Convert ResponseFile type responses into ResponseStream type
--   
--   Checks the response type, and if it's a ResponseFile, converts it into
--   a ResponseStream. Other response types are passed through unchanged.
--   
--   Converted responses get a Content-Length header.
--   
--   Streaming a file will bypass a sendfile system call, and may be useful
--   to work around systems without working sendfile implementations.
--   
--   Since 3.0.4
streamFile :: Middleware

module Network.Wai.Middleware.StripHeaders
stripHeader :: ByteString -> Response -> Response
stripHeaders :: [ByteString] -> Response -> Response

-- | If the request satisifes the provided predicate, strip headers
--   matching the provided header name.
--   
--   Since 3.0.8
stripHeaderIf :: ByteString -> (Request -> Bool) -> Middleware

-- | If the request satisifes the provided predicate, strip all headers
--   whose header name is in the list of provided header names.
--   
--   Since 3.0.8
stripHeadersIf :: [ByteString] -> (Request -> Bool) -> Middleware


-- | Timeout requests
module Network.Wai.Middleware.Timeout

-- | Time out the request after the given number of seconds
--   
--   Timeouts respond with <tt><a>status503</a></tt>. See
--   <tt><a>timeoutStatus</a></tt> or <tt><a>timeoutAs</a></tt> to
--   customize the behavior of the timed-out case.
--   
--   <pre>
--   since 3.0.24.0
--   </pre>
timeout :: Int -> Middleware

-- | Time out with the given <tt><a>Status</a></tt>
--   
--   <pre>
--   since 3.0.24.0
--   </pre>
timeoutStatus :: Status -> Int -> Middleware

-- | Time out with the given <tt><a>Response</a></tt>
--   
--   <pre>
--   since 3.0.24.0
--   </pre>
timeoutAs :: Response -> Int -> Middleware

module Network.Wai.Middleware.Vhost
vhost :: [(Request -> Bool, Application)] -> Application -> Application
redirectWWW :: Text -> Application -> Application
redirectTo :: ByteString -> Response
redirectToLogged :: (Text -> IO ()) -> ByteString -> IO Response


-- | Some helpers for parsing data out of a raw WAI <a>Request</a>.
module Network.Wai.Parse

-- | Parse the HTTP accept string to determine supported content types.
parseHttpAccept :: ByteString -> [ByteString]

-- | Parse the body of an HTTP request. See parseRequestBodyEx for details.
--   Note: This function does not limit the memory it allocates. When
--   dealing with untrusted data (as is usually the case when receiving
--   input from the internet), it is recommended to use the
--   <a>parseRequestBodyEx</a> function instead.
parseRequestBody :: BackEnd y -> Request -> IO ([Param], [File y])

-- | The mimetype of the http body. Depending on whether just parameters or
--   parameters and files are passed, one or the other mimetype should be
--   used.
data RequestBodyType

-- | application/x-www-form-urlencoded (parameters only)
UrlEncoded :: RequestBodyType

-- | multipart/form-data (parameters and files)
Multipart :: ByteString -> RequestBodyType

-- | Get the mimetype of the body of an http request.
getRequestBodyType :: Request -> Maybe RequestBodyType
sinkRequestBody :: BackEnd y -> RequestBodyType -> IO ByteString -> IO ([Param], [File y])

sinkRequestBodyEx :: ParseRequestBodyOptions -> BackEnd y -> RequestBodyType -> IO ByteString -> IO ([Param], [File y])

-- | A file uploading backend. Takes the parameter name, file name, and a
--   stream of data.
type BackEnd a = ByteString " parameter name" -> FileInfo () -> IO ByteString -> IO a

-- | Store uploaded files in memory
lbsBackEnd :: Monad m => ignored1 -> ignored2 -> m ByteString -> m ByteString

-- | Save uploaded files on disk as temporary files
--   
--   Note: starting with version 2.0, removal of temp files is registered
--   with the provided <tt>InternalState</tt>. It is the responsibility of
--   the caller to ensure that this <tt>InternalState</tt> gets cleaned up.
tempFileBackEnd :: InternalState -> ignored1 -> ignored2 -> IO ByteString -> IO FilePath

-- | Same as <a>tempFileBackEnd</a>, but use configurable temp folders and
--   patterns.
tempFileBackEndOpts :: IO FilePath -> String -> InternalState -> ignored1 -> ignored2 -> IO ByteString -> IO FilePath

-- | Post parameter name and value.
type Param = (ByteString, ByteString)

-- | Post parameter name and associated file information.
type File y = (ByteString, FileInfo y)

-- | Information on an uploaded file.
data FileInfo c
FileInfo :: ByteString -> ByteString -> c -> FileInfo c
[fileName] :: FileInfo c -> ByteString
[fileContentType] :: FileInfo c -> ByteString
[fileContent] :: FileInfo c -> c

-- | Parse a content type value, turning a single <tt>ByteString</tt> into
--   the actual content type and a list of pairs of attributes.
parseContentType :: ByteString -> (ByteString, [(ByteString, ByteString)])

-- | A data structure that describes the behavior of the parseRequestBodyEx
--   function.
data ParseRequestBodyOptions

-- | A reasonable default set of parsing options. Maximum key/filename
--   length: 32 bytes; maximum files: 10; filesize unlimited; maximum size
--   for parameters: 64kbytes; maximum number of header lines: 32 bytes
--   (applies only to headers of a mime/multipart message); maximum header
--   line length: Apache's default for that is 8190 bytes
--   (http:/<i>httpd.apache.org</i>docs<i>2.2</i>mod/core.html#limitrequestline)
--   so we're using that here as well.
defaultParseRequestBodyOptions :: ParseRequestBodyOptions

-- | Do not impose any memory limits.
noLimitParseRequestBodyOptions :: ParseRequestBodyOptions

-- | Parse the body of an HTTP request, limit resource usage. The HTTP body
--   can contain both parameters and files. This function will return a
--   list of key,value pairs for all parameters, and a list of key,a pairs
--   for filenames. The a depends on the used backend that is responsible
--   for storing the received files.
parseRequestBodyEx :: ParseRequestBodyOptions -> BackEnd y -> Request -> IO ([Param], [File y])

-- | Set the maximum length of a filename.
setMaxRequestKeyLength :: Int -> ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Do not limit the length of filenames.
clearMaxRequestKeyLength :: ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Set the maximum number of files per request.
setMaxRequestNumFiles :: Int -> ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Do not limit the maximum number of files per request.
clearMaxRequestNumFiles :: ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Set the maximum filesize per file (in bytes).
setMaxRequestFileSize :: Int64 -> ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Do not limit the maximum filesize per file.
clearMaxRequestFileSize :: ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Set the maximum size of all files per request.
setMaxRequestFilesSize :: Int64 -> ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Do not limit the maximum size of all files per request.
clearMaxRequestFilesSize :: ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Set the maximum size of the sum of all parameters.
setMaxRequestParmsSize :: Int -> ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Do not limit the maximum size of the sum of all parameters.
clearMaxRequestParmsSize :: ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Set the maximum header lines per mime/multipart entry.
setMaxHeaderLines :: Int -> ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Do not limit the maximum header lines per mime/multipart entry.
clearMaxHeaderLines :: ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Set the maximum header line length per mime/multipart entry.
setMaxHeaderLineLength :: Int -> ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Do not limit the maximum header lines per mime/multipart entry.
clearMaxHeaderLineLength :: ParseRequestBodyOptions -> ParseRequestBodyOptions
instance GHC.Show.Show Network.Wai.Parse.Bound
instance GHC.Classes.Eq Network.Wai.Parse.Bound
instance GHC.Show.Show c => GHC.Show.Show (Network.Wai.Parse.FileInfo c)
instance GHC.Classes.Eq c => GHC.Classes.Eq (Network.Wai.Parse.FileInfo c)

module Network.Wai.Middleware.RequestLogger

-- | Production request logger middleware.
--   
--   This uses the <a>Apache</a> logging format, and takes IP addresses for
--   clients from the socket (see <a>IPAddrSource</a> for more
--   information). It logs to <a>stdout</a>.
logStdout :: Middleware

-- | Development request logger middleware.
--   
--   This uses the <a>Detailed</a> <a>True</a> logging format and logs to
--   <a>stdout</a>.
logStdoutDev :: Middleware
mkRequestLogger :: RequestLoggerSettings -> IO Middleware

-- | <tt>RequestLoggerSettings</tt> is an instance of Default. See
--   <a>Data.Default</a> for more information.
--   
--   <tt>outputFormat</tt>, <tt>autoFlush</tt>, and <tt>destination</tt>
--   are record fields for the record type <tt>RequestLoggerSettings</tt>,
--   so they can be used to modify settings values using record syntax.
data RequestLoggerSettings

-- | Default value: <tt>Detailed</tt> <tt>True</tt>.
outputFormat :: RequestLoggerSettings -> OutputFormat

-- | Only applies when using the <tt>Handle</tt> constructor for
--   <tt>destination</tt>.
--   
--   Default value: <tt>True</tt>.
autoFlush :: RequestLoggerSettings -> Bool

-- | Default: <tt>Handle</tt> <tt>stdout</tt>.
destination :: RequestLoggerSettings -> Destination
data OutputFormat
Apache :: IPAddrSource -> OutputFormat

-- | use colors?
Detailed :: Bool -> OutputFormat
CustomOutputFormat :: OutputFormatter -> OutputFormat
CustomOutputFormatWithDetails :: OutputFormatterWithDetails -> OutputFormat
type OutputFormatter = ZonedDate -> Request -> Status -> Maybe Integer -> LogStr
type OutputFormatterWithDetails = ZonedDate -> Request -> Status -> Maybe Integer -> NominalDiffTime -> [ByteString] -> Builder -> LogStr
data Destination
Handle :: Handle -> Destination
Logger :: LoggerSet -> Destination
Callback :: Callback -> Destination
type Callback = LogStr -> IO ()

-- | Source from which the IP source address of the client is obtained.
data IPAddrSource

-- | From the peer address of the HTTP connection.
FromSocket :: IPAddrSource

-- | From X-Real-IP: or X-Forwarded-For: in the HTTP header.
FromHeader :: IPAddrSource

-- | From the peer address if header is not found.
FromFallback :: IPAddrSource
instance Data.Default.Class.Default Network.Wai.Middleware.RequestLogger.RequestLoggerSettings

module Network.Wai.Middleware.RequestLogger.JSON
formatAsJSON :: OutputFormatterWithDetails


-- | Some helpers for interrogating a WAI <a>Request</a>.
module Network.Wai.Request

-- | Does this request appear to have been made over an SSL connection?
--   
--   This function first checks <tt><a>isSecure</a></tt>, but also checks
--   for headers that may indicate a secure connection even in the presence
--   of reverse proxies.
--   
--   Note: these headers can be easily spoofed, so decisions which require
--   a true SSL connection (i.e. sending sensitive information) should only
--   use <tt><a>isSecure</a></tt>. This is not always the case though: for
--   example, deciding to force a non-SSL request to SSL by redirect. One
--   can safely choose not to redirect when the request <i>appears</i>
--   secure, even if it's actually not.
appearsSecure :: Request -> Bool

-- | Guess the "application root" based on the given request.
--   
--   The application root is the basis for forming URLs pointing at the
--   current application. For more information and relevant caveats, please
--   see <a>Network.Wai.Middleware.Approot</a>.
guessApproot :: Request -> ByteString

-- | see <a>requestSizeCheck</a>
data RequestSizeException
RequestSizeException :: Word64 -> RequestSizeException

-- | Check request body size to avoid server crash when request is too
--   large.
--   
--   This function first checks <tt><a>requestBodyLength</a></tt>, if
--   content-length is known but larger than limit, or it's unknown but we
--   have received too many chunks, a <a>RequestSizeException</a> are
--   thrown when user use <tt><a>requestBody</a></tt> to extract request
--   body inside IO.
requestSizeCheck :: Word64 -> Request -> IO Request
instance GHC.Classes.Ord Network.Wai.Request.RequestSizeException
instance GHC.Classes.Eq Network.Wai.Request.RequestSizeException
instance GHC.Exception.Type.Exception Network.Wai.Request.RequestSizeException
instance GHC.Show.Show Network.Wai.Request.RequestSizeException


-- | Redirect non-SSL requests to https
--   
--   Since 3.0.7
module Network.Wai.Middleware.ForceSSL

-- | For requests that don't appear secure, redirect to https
--   
--   Since 3.0.7
forceSSL :: Middleware


module Network.Wai.Middleware.ForceDomain

-- | Force a domain by redirecting. The <tt>checkDomain</tt> function takes
--   the current domain and checks whether it is correct. It should return
--   <a>Nothing</a> if the domain is correct, or `Just "domain.com"` if it
--   is incorrect.
forceDomain :: (ByteString -> Maybe ByteString) -> Middleware


-- | Middleware for establishing the root of the application.
--   
--   Many application need the ability to create URLs referring back to the
--   application itself. For example: generate RSS feeds or sitemaps,
--   giving users copy-paste links, or sending emails. In many cases, the
--   approot can be determined correctly from the request headers. However,
--   some things can prevent this, especially reverse proxies. This module
--   provides multiple ways of configuring approot discovery, and functions
--   for applications to get that approot.
--   
--   Approots are structured such that they can be prepended to a string
--   such as <tt><i>foo</i>bar?baz=bin</tt>. For example, if your
--   application is hosted on example.com using HTTPS, the approot would be
--   <tt><a>https://example.com</a></tt>. Note the lack of a trailing
--   slash.
module Network.Wai.Middleware.Approot

-- | The most generic version of the middleware, allowing you to provide a
--   function to get the approot for each request. For many use cases, one
--   of the helper functions provided by this module will give the
--   necessary functionality more conveniently.
--   
--   Since 3.0.7
approotMiddleware :: (Request -> IO ByteString) -> Middleware

-- | Same as <tt><a>envFallbackNamed</a> <a>APPROOT</a></tt>.
--   
--   The environment variable <tt>APPROOT</tt> is used by Keter, School of
--   Haskell, and yesod-devel.
--   
--   Since 3.0.7
envFallback :: IO Middleware

-- | Produce a middleware that takes the approot from the given environment
--   variable, falling back to the behavior of <a>fromRequest</a> if the
--   variable is not set.
--   
--   Since 3.0.7
envFallbackNamed :: String -> IO Middleware

-- | Hard-code the given value as the approot.
--   
--   Since 3.0.7
hardcoded :: ByteString -> Middleware

-- | Get the approot by analyzing the request. This is not a full-proof
--   approach, but in many common cases will work. Situations that can
--   break this are:
--   
--   <ul>
--   <li>Requests which spoof headers and imply the connection is over
--   HTTPS</li>
--   <li>Reverse proxies that change ports in surprising ways</li>
--   <li>Invalid Host headers</li>
--   <li>Reverse proxies which modify the path info</li>
--   </ul>
--   
--   Normally trusting headers in this way is insecure, however in the case
--   of approot, the worst that can happen is that the client will get an
--   incorrect URL. If you are relying on the approot for some
--   security-sensitive purpose, it is highly recommended to use
--   <tt>hardcoded</tt>, which cannot be spoofed.
--   
--   Since 3.0.7
fromRequest :: Middleware

-- | Get the approot set by the middleware. If the middleware is not in
--   use, then this function will return an exception. For a total version
--   of the function, see <a>getApprootMay</a>.
--   
--   Since 3.0.7
getApproot :: Request -> ByteString

-- | A total version of <a>getApproot</a>, which returns <a>Nothing</a> if
--   the middleware is not in use.
--   
--   Since 3.0.7
getApprootMay :: Request -> Maybe ByteString
instance GHC.Show.Show Network.Wai.Middleware.Approot.ApprootMiddlewareNotSetup
instance GHC.Exception.Type.Exception Network.Wai.Middleware.Approot.ApprootMiddlewareNotSetup

module Network.Wai.Test.Internal
type Session = ReaderT Application (StateT ClientState IO)

-- | Since 3.0.6
type ClientCookies = Map ByteString SetCookie
data ClientState
ClientState :: ClientCookies -> ClientState
[clientCookies] :: ClientState -> ClientCookies

-- | Since 3.0.20.0
initState :: ClientState

-- | Like <tt>runSession</tt>, but if allows you to hand in cookies and get
--   the updated cookies back. One use case for this is writing tests that
--   address the application under test alternatingly through rest api and
--   through db handle.
--   
--   Since 3.0.20.0
runSessionWith :: ClientState -> Session a -> Application -> IO (a, ClientState)

module Network.Wai.Test
type Session = ReaderT Application (StateT ClientState IO)

-- | See also: <a>runSessionWith</a>.
runSession :: Session a -> Application -> IO a

-- | Since 3.0.6
type ClientCookies = Map ByteString SetCookie

-- | Since 3.0.6
getClientCookies :: Session ClientCookies

-- | Since 3.0.6
modifyClientCookies :: (ClientCookies -> ClientCookies) -> Session ()

-- | Since 3.0.6
setClientCookie :: SetCookie -> Session ()

-- | Since 3.0.6
deleteClientCookie :: ByteString -> Session ()
request :: Request -> Session SResponse
srequest :: SRequest -> Session SResponse
data SRequest
SRequest :: Request -> ByteString -> SRequest
[simpleRequest] :: SRequest -> Request
[simpleRequestBody] :: SRequest -> ByteString
data SResponse
SResponse :: Status -> ResponseHeaders -> ByteString -> SResponse
[simpleStatus] :: SResponse -> Status
[simpleHeaders] :: SResponse -> ResponseHeaders
[simpleBody] :: SResponse -> ByteString

-- | A default, blank request.
--   
--   Since 2.0.0
defaultRequest :: Request

-- | Set whole path (request path + query string).
setPath :: Request -> ByteString -> Request
setRawPathInfo :: Request -> ByteString -> Request
assertStatus :: Int -> SResponse -> Session ()
assertContentType :: ByteString -> SResponse -> Session ()
assertBody :: ByteString -> SResponse -> Session ()
assertBodyContains :: ByteString -> SResponse -> Session ()
assertHeader :: CI ByteString -> ByteString -> SResponse -> Session ()
assertNoHeader :: CI ByteString -> SResponse -> Session ()

-- | Since 3.0.6
assertClientCookieExists :: String -> ByteString -> Session ()

-- | Since 3.0.6
assertNoClientCookieExists :: String -> ByteString -> Session ()

-- | Since 3.0.6
assertClientCookieValue :: String -> ByteString -> ByteString -> Session ()
data WaiTestFailure
WaiTestFailure :: String -> WaiTestFailure
instance GHC.Classes.Eq Network.Wai.Test.WaiTestFailure
instance GHC.Show.Show Network.Wai.Test.WaiTestFailure
instance GHC.Classes.Eq Network.Wai.Test.SResponse
instance GHC.Show.Show Network.Wai.Test.SResponse
instance GHC.Exception.Type.Exception Network.Wai.Test.WaiTestFailure


-- | This module gives you a way to mount applications under sub-URIs. For
--   example:
--   
--   <pre>
--   bugsApp, helpdeskApp, apiV1, apiV2, mainApp :: Application
--   
--   myApp :: Application
--   myApp = mapUrls $
--         mount "bugs"     bugsApp
--     &lt;|&gt; mount "helpdesk" helpdeskApp
--     &lt;|&gt; mount "api"
--             (   mount "v1" apiV1
--             &lt;|&gt; mount "v2" apiV2
--             )
--     &lt;|&gt; mountRoot mainApp
--   </pre>
module Network.Wai.UrlMap
data UrlMap' a
type UrlMap = UrlMap' Application

-- | Mount an application under a given path. The ToApplication typeclass
--   gives you the option to pass either an <a>Application</a> or an
--   <a>UrlMap</a> as the second argument.
mount' :: ToApplication a => Path -> a -> UrlMap

-- | A convenience function like mount', but for mounting things under a
--   single path segment.
mount :: ToApplication a => Text -> a -> UrlMap

-- | Mount something at the root. Use this for the last application in the
--   block, to avoid 500 errors from none of the applications matching.
mountRoot :: ToApplication a => a -> UrlMap
mapUrls :: UrlMap -> Application
instance Network.Wai.UrlMap.ToApplication Network.Wai.Application
instance Network.Wai.UrlMap.ToApplication Network.Wai.UrlMap.UrlMap
instance GHC.Base.Functor Network.Wai.UrlMap.UrlMap'
instance GHC.Base.Applicative Network.Wai.UrlMap.UrlMap'
instance GHC.Base.Alternative Network.Wai.UrlMap.UrlMap'
